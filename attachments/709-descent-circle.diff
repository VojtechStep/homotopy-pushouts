diff --git a/flake.lock b/flake.lock
index 9584bfe814..b65861621d 100644
--- a/flake.lock
+++ b/flake.lock
@@ -103,11 +103,11 @@
         ]
       },
       "locked": {
-        "lastModified": 1689783639,
-        "narHash": "sha256-k6ExUOrKdlqfdhbdRLHYay0tAqSLcteQj/78qQ+l7kI=",
+        "lastModified": 1690590452,
+        "narHash": "sha256-d7jaMDFjlVoomGYjdxECpe+7xcLzQiF6LVLJSHj6q20=",
         "owner": "catppuccin",
         "repo": "mdBook",
-        "rev": "7616df4bfc8f63e44e4a9f6fc1849c975fd0fc03",
+        "rev": "b6a45ab31ac1f91d82b5302ab4f030bb0a751877",
         "type": "github"
       },
       "original": {
diff --git a/src/elementary-number-theory.lagda.md b/src/elementary-number-theory.lagda.md
index 95ee6bb674..2226b9389c 100644
--- a/src/elementary-number-theory.lagda.md
+++ b/src/elementary-number-theory.lagda.md
@@ -113,6 +113,7 @@ open import elementary-number-theory.twin-prime-conjecture public
 open import elementary-number-theory.type-arithmetic-natural-numbers public
 open import elementary-number-theory.unit-elements-standard-finite-types public
 open import elementary-number-theory.unit-similarity-standard-finite-types public
+open import elementary-number-theory.universal-property-integers public
 open import elementary-number-theory.universal-property-natural-numbers public
 open import elementary-number-theory.upper-bounds-natural-numbers public
 open import elementary-number-theory.well-ordering-principle-natural-numbers public
diff --git a/src/elementary-number-theory/universal-property-integers.lagda.md b/src/elementary-number-theory/universal-property-integers.lagda.md
new file mode 100644
index 0000000000..c175953cab
--- /dev/null
+++ b/src/elementary-number-theory/universal-property-integers.lagda.md
@@ -0,0 +1,239 @@
+# The universal property of the integers
+
+```agda
+module elementary-number-theory.universal-property-integers where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import elementary-number-theory.integers
+open import elementary-number-theory.natural-numbers
+
+open import foundation.cartesian-product-types
+open import foundation.contractible-types
+open import foundation.coproduct-types
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.fundamental-theorem-of-identity-types
+open import foundation.homotopies
+open import foundation.identity-types
+open import foundation.propositions
+open import foundation.structure-identity-principle
+open import foundation.unit-type
+open import foundation.universe-levels
+```
+
+</details>
+
+## Idea
+
+The universal property of [the integers](elementary-number-theory.integers.md)
+states that given any type `X` equipped with a point `x : X` and an
+[automorphism](foundation.automorphisms.md) `e : X ‚âÉ X`, there is a
+[unique](foundation.contractible-types.md) structure preserving map from `‚Ñ§` to
+`X`.
+
+```agda
+abstract
+  elim-‚Ñ§ :
+    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
+    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+    ( k : ‚Ñ§) ‚Üí P k
+  elim-‚Ñ§ P p0 pS (inl zero-‚Ñï) =
+    map-inv-is-equiv (is-equiv-map-equiv (pS neg-one-‚Ñ§)) p0
+  elim-‚Ñ§ P p0 pS (inl (succ-‚Ñï x)) =
+    map-inv-is-equiv
+      ( is-equiv-map-equiv (pS (inl (succ-‚Ñï x))))
+      ( elim-‚Ñ§ P p0 pS (inl x))
+  elim-‚Ñ§ P p0 pS (inr (inl star)) = p0
+  elim-‚Ñ§ P p0 pS (inr (inr zero-‚Ñï)) = map-equiv (pS zero-‚Ñ§) p0
+  elim-‚Ñ§ P p0 pS (inr (inr (succ-‚Ñï x))) =
+    map-equiv
+      ( pS (inr (inr x)))
+      ( elim-‚Ñ§ P p0 pS (inr (inr x)))
+
+  compute-zero-elim-‚Ñ§ :
+    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
+    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+    Id (elim-‚Ñ§ P p0 pS zero-‚Ñ§) p0
+  compute-zero-elim-‚Ñ§ P p0 pS = refl
+
+  compute-succ-elim-‚Ñ§ :
+    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
+    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) (k : ‚Ñ§) ‚Üí
+    Id (elim-‚Ñ§ P p0 pS (succ-‚Ñ§ k)) (map-equiv (pS k) (elim-‚Ñ§ P p0 pS k))
+  compute-succ-elim-‚Ñ§ P p0 pS (inl zero-‚Ñï) =
+    inv
+      ( is-section-map-inv-is-equiv
+        ( is-equiv-map-equiv (pS (inl zero-‚Ñï)))
+        ( elim-‚Ñ§ P p0 pS (succ-‚Ñ§ (inl zero-‚Ñï))))
+  compute-succ-elim-‚Ñ§ P p0 pS (inl (succ-‚Ñï x)) =
+    inv
+      ( is-section-map-inv-is-equiv
+        ( is-equiv-map-equiv (pS (inl (succ-‚Ñï x))))
+        ( elim-‚Ñ§ P p0 pS (succ-‚Ñ§ (inl (succ-‚Ñï x)))))
+  compute-succ-elim-‚Ñ§ P p0 pS (inr (inl star)) = refl
+  compute-succ-elim-‚Ñ§ P p0 pS (inr (inr x)) = refl
+
+ELIM-‚Ñ§ :
+  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
+  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí UU l1
+ELIM-‚Ñ§ P p0 pS =
+  Œ£ ( (k : ‚Ñ§) ‚Üí P k)
+    ( Œª f ‚Üí
+      ( ( Id (f zero-‚Ñ§) p0) √ó
+        ( (k : ‚Ñ§) ‚Üí Id (f (succ-‚Ñ§ k)) ((map-equiv (pS k)) (f k)))))
+
+Elim-‚Ñ§ :
+  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
+  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí ELIM-‚Ñ§ P p0 pS
+pr1 (Elim-‚Ñ§ P p0 pS) = elim-‚Ñ§ P p0 pS
+pr1 (pr2 (Elim-‚Ñ§ P p0 pS)) = compute-zero-elim-‚Ñ§ P p0 pS
+pr2 (pr2 (Elim-‚Ñ§ P p0 pS)) = compute-succ-elim-‚Ñ§ P p0 pS
+
+equiv-comparison-map-Eq-ELIM-‚Ñ§ :
+  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
+  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+  ( s t : ELIM-‚Ñ§ P p0 pS) (k : ‚Ñ§) ‚Üí
+  Id ((pr1 s) k) ((pr1 t) k) ‚âÉ Id ((pr1 s) (succ-‚Ñ§ k)) ((pr1 t) (succ-‚Ñ§ k))
+equiv-comparison-map-Eq-ELIM-‚Ñ§ P p0 pS s t k =
+  ( ( equiv-concat (pr2 (pr2 s) k) (pr1 t (succ-‚Ñ§ k))) ‚àòe
+    ( equiv-concat' (map-equiv (pS k) (pr1 s k)) (inv (pr2 (pr2 t) k)))) ‚àòe
+  ( equiv-ap (pS k) (pr1 s k) (pr1 t k))
+
+zero-Eq-ELIM-‚Ñ§ :
+  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
+  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+  ( s t : ELIM-‚Ñ§ P p0 pS) (H : (pr1 s) ~ (pr1 t)) ‚Üí UU l1
+zero-Eq-ELIM-‚Ñ§ P p0 pS s t H =
+  Id (H zero-‚Ñ§) ((pr1 (pr2 s)) ‚àô (inv (pr1 (pr2 t))))
+
+succ-Eq-ELIM-‚Ñ§ :
+  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
+  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+  ( s t : ELIM-‚Ñ§ P p0 pS) (H : (pr1 s) ~ (pr1 t)) ‚Üí UU l1
+succ-Eq-ELIM-‚Ñ§ P p0 pS s t H =
+  ( k : ‚Ñ§) ‚Üí
+  Id
+    ( H (succ-‚Ñ§ k))
+    ( map-equiv (equiv-comparison-map-Eq-ELIM-‚Ñ§ P p0 pS s t k) (H k))
+
+Eq-ELIM-‚Ñ§ :
+  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
+  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+  ( s t : ELIM-‚Ñ§ P p0 pS) ‚Üí UU l1
+Eq-ELIM-‚Ñ§ P p0 pS s t =
+  ELIM-‚Ñ§
+    ( Œª k ‚Üí Id (pr1 s k) (pr1 t k))
+    ( (pr1 (pr2 s)) ‚àô (inv (pr1 (pr2 t))))
+    ( equiv-comparison-map-Eq-ELIM-‚Ñ§ P p0 pS s t)
+
+reflexive-Eq-ELIM-‚Ñ§ :
+  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
+  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+  ( s : ELIM-‚Ñ§ P p0 pS) ‚Üí Eq-ELIM-‚Ñ§ P p0 pS s s
+pr1 (reflexive-Eq-ELIM-‚Ñ§ P p0 pS (f , p , H)) = refl-htpy
+pr1 (pr2 (reflexive-Eq-ELIM-‚Ñ§ P p0 pS (f , p , H))) = inv (right-inv p)
+pr2 (pr2 (reflexive-Eq-ELIM-‚Ñ§ P p0 pS (f , p , H))) = inv ‚àò (right-inv ‚àò H)
+
+Eq-ELIM-‚Ñ§-eq :
+  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1) ‚Üí
+  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+  ( s t : ELIM-‚Ñ§ P p0 pS) ‚Üí Id s t ‚Üí Eq-ELIM-‚Ñ§ P p0 pS s t
+Eq-ELIM-‚Ñ§-eq P p0 pS s .s refl = reflexive-Eq-ELIM-‚Ñ§ P p0 pS s
+
+abstract
+  is-contr-total-Eq-ELIM-‚Ñ§ :
+    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1) ‚Üí
+    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+    ( s : ELIM-‚Ñ§ P p0 pS) ‚Üí is-contr (Œ£ (ELIM-‚Ñ§ P p0 pS) (Eq-ELIM-‚Ñ§ P p0 pS s))
+  is-contr-total-Eq-ELIM-‚Ñ§ P p0 pS s =
+    is-contr-total-Eq-structure
+      ( Œª f t H ‚Üí
+        ( zero-Eq-ELIM-‚Ñ§ P p0 pS s (pair f t) H) √ó
+        ( succ-Eq-ELIM-‚Ñ§ P p0 pS s (pair f t) H))
+      ( is-contr-total-htpy (pr1 s))
+      ( pair (pr1 s) refl-htpy)
+      ( is-contr-total-Eq-structure
+        ( Œª p K
+          ( q : zero-Eq-ELIM-‚Ñ§ P p0 pS s
+            ( pair (pr1 s) (pair p K))
+            ( refl-htpy)) ‚Üí
+          succ-Eq-ELIM-‚Ñ§ P p0 pS s
+            ( pair (pr1 s) (pair p K))
+            ( refl-htpy))
+        ( is-contr-is-equiv'
+          ( Œ£ (Id (pr1 s zero-‚Ñ§) p0) (Œª Œ± ‚Üí Id Œ± (pr1 (pr2 s))))
+          ( tot (Œª Œ± ‚Üí con-inv refl Œ± (pr1 (pr2 s))))
+          ( is-equiv-tot-is-fiberwise-equiv
+            ( Œª Œ± ‚Üí is-equiv-con-inv refl Œ± (pr1 (pr2 s))))
+          ( is-contr-total-path' (pr1 (pr2 s))))
+        ( pair (pr1 (pr2 s)) (inv (right-inv (pr1 (pr2 s)))))
+        ( is-contr-is-equiv'
+          ( Œ£ ( ( k : ‚Ñ§) ‚Üí Id (pr1 s (succ-‚Ñ§ k)) (pr1 (pS k) (pr1 s k)))
+              ( Œª Œ≤ ‚Üí Œ≤ ~ (pr2 (pr2 s))))
+          ( tot (Œª Œ≤ ‚Üí con-inv-htpy refl-htpy Œ≤ (pr2 (pr2 s))))
+          ( is-equiv-tot-is-fiberwise-equiv
+            ( Œª Œ≤ ‚Üí is-equiv-con-inv-htpy refl-htpy Œ≤ (pr2 (pr2 s))))
+          ( is-contr-total-htpy' (pr2 (pr2 s)))))
+
+abstract
+  is-equiv-Eq-ELIM-‚Ñ§-eq :
+    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1) ‚Üí
+    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+    ( s t : ELIM-‚Ñ§ P p0 pS) ‚Üí is-equiv (Eq-ELIM-‚Ñ§-eq P p0 pS s t)
+  is-equiv-Eq-ELIM-‚Ñ§-eq P p0 pS s =
+    fundamental-theorem-id
+      ( is-contr-total-Eq-ELIM-‚Ñ§ P p0 pS s)
+      ( Eq-ELIM-‚Ñ§-eq P p0 pS s)
+
+eq-Eq-ELIM-‚Ñ§ :
+  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1) ‚Üí
+  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+  ( s t : ELIM-‚Ñ§ P p0 pS) ‚Üí Eq-ELIM-‚Ñ§ P p0 pS s t ‚Üí Id s t
+eq-Eq-ELIM-‚Ñ§ P p0 pS s t = map-inv-is-equiv (is-equiv-Eq-ELIM-‚Ñ§-eq P p0 pS s t)
+
+abstract
+  is-prop-ELIM-‚Ñ§ :
+    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1) ‚Üí
+    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+    is-prop (ELIM-‚Ñ§ P p0 pS)
+  is-prop-ELIM-‚Ñ§ P p0 pS =
+    is-prop-all-elements-equal
+      ( Œª s t ‚Üí eq-Eq-ELIM-‚Ñ§ P p0 pS s t
+        ( Elim-‚Ñ§
+          ( Œª k ‚Üí Id (pr1 s k) (pr1 t k))
+          ( (pr1 (pr2 s)) ‚àô (inv (pr1 (pr2 t))))
+          ( equiv-comparison-map-Eq-ELIM-‚Ñ§ P p0 pS s t)))
+```
+
+### The dependent universal property of the integers
+
+```agda
+abstract
+  is-contr-ELIM-‚Ñ§ :
+    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1) ‚Üí
+    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
+    is-contr (ELIM-‚Ñ§ P p0 pS)
+  is-contr-ELIM-‚Ñ§ P p0 pS =
+    is-proof-irrelevant-is-prop (is-prop-ELIM-‚Ñ§ P p0 pS) (Elim-‚Ñ§ P p0 pS)
+```
+
+### The universal property of the integers
+
+The non-dependent universal property of the integers is a special case of the
+dependent universal property applied to constant type families.
+
+```agda
+ELIM-‚Ñ§' :
+  { l1 : Level} {X : UU l1} (x : X) (e : X ‚âÉ X) ‚Üí UU l1
+ELIM-‚Ñ§' {X = X} x e = ELIM-‚Ñ§ (Œª k ‚Üí X) x (Œª k ‚Üí e)
+
+abstract
+  universal-property-‚Ñ§ :
+    { l1 : Level} {X : UU l1} (x : X) (e : X ‚âÉ X) ‚Üí is-contr (ELIM-‚Ñ§' x e)
+  universal-property-‚Ñ§ {X = X} x e = is-contr-ELIM-‚Ñ§ (Œª k ‚Üí X) x (Œª k ‚Üí e)
+```
diff --git a/src/foundation/equivalences.lagda.md b/src/foundation/equivalences.lagda.md
index ae1f1e6ca5..4991d3c347 100644
--- a/src/foundation/equivalences.lagda.md
+++ b/src/foundation/equivalences.lagda.md
@@ -337,6 +337,60 @@ module _
   pr2 emb-map-equiv = is-emb-map-equiv
 ```
 
+### The 3-for-2 property of being an equivalence
+
+#### If the right factor is an equivalence, then the left factor being an equivalence is equivalent to the composite being one
+
+```agda
+module _
+  { l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {C : UU l3}
+  where
+
+  equiv-is-equiv-left-factor-htpy :
+    { f : A ‚Üí B} (e : B ‚âÉ C) (h : A ‚Üí C) (H : h ~ (map-equiv e ‚àò f)) ‚Üí
+    is-equiv f ‚âÉ is-equiv h
+  equiv-is-equiv-left-factor-htpy {f} e h H =
+    equiv-prop
+      ( is-property-is-equiv f)
+      ( is-property-is-equiv h)
+      ( Œª is-equiv-f ‚Üí
+        is-equiv-comp-htpy h (map-equiv e) f H is-equiv-f
+          ( is-equiv-map-equiv e))
+      ( is-equiv-right-factor-htpy h (map-equiv e) f H (is-equiv-map-equiv e))
+
+  equiv-is-equiv-left-factor :
+    { f : A ‚Üí B} (e : B ‚âÉ C) ‚Üí
+    is-equiv f ‚âÉ is-equiv (map-equiv e ‚àò f)
+  equiv-is-equiv-left-factor {f} e =
+    equiv-is-equiv-left-factor-htpy e (map-equiv e ‚àò f) refl-htpy
+```
+
+#### If the left factor is an equivalence, then the right factor being an equivalence is equivalent to the composite being one
+
+```agda
+module _
+  { l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {C : UU l3}
+  where
+
+  equiv-is-equiv-right-factor-htpy :
+    ( e : A ‚âÉ B) {f : B ‚Üí C} (h : A ‚Üí C) (H : h ~ (f ‚àò map-equiv e)) ‚Üí
+    is-equiv f ‚âÉ is-equiv h
+  equiv-is-equiv-right-factor-htpy e {f} h H =
+    equiv-prop
+      ( is-property-is-equiv f)
+      ( is-property-is-equiv h)
+      ( is-equiv-comp-htpy h f (map-equiv e) H (is-equiv-map-equiv e))
+      ( Œª is-equiv-h ‚Üí
+        is-equiv-left-factor-htpy h f (map-equiv e) H is-equiv-h
+          ( is-equiv-map-equiv e))
+
+  equiv-is-equiv-right-factor :
+    ( e : A ‚âÉ B) {f : B ‚Üí C} ‚Üí
+    is-equiv f ‚âÉ is-equiv (f ‚àò map-equiv e)
+  equiv-is-equiv-right-factor e {f} =
+    equiv-is-equiv-right-factor-htpy e (f ‚àò map-equiv e) refl-htpy
+```
+
 ### Homotopy induction for homotopies between equivalences
 
 ```agda
diff --git a/src/synthetic-homotopy-theory.lagda.md b/src/synthetic-homotopy-theory.lagda.md
index f570c1b178..58d0c18a4e 100644
--- a/src/synthetic-homotopy-theory.lagda.md
+++ b/src/synthetic-homotopy-theory.lagda.md
@@ -20,6 +20,11 @@ open import synthetic-homotopy-theory.dependent-cocones-under-spans public
 open import synthetic-homotopy-theory.dependent-pullback-property-pushouts public
 open import synthetic-homotopy-theory.dependent-universal-property-pushouts public
 open import synthetic-homotopy-theory.descent-circle public
+open import synthetic-homotopy-theory.descent-circle-constant-families public
+open import synthetic-homotopy-theory.descent-circle-dependent-pair-types public
+open import synthetic-homotopy-theory.descent-circle-equivalence-types public
+open import synthetic-homotopy-theory.descent-circle-function-types public
+open import synthetic-homotopy-theory.descent-circle-subtypes public
 open import synthetic-homotopy-theory.double-loop-spaces public
 open import synthetic-homotopy-theory.free-loops public
 open import synthetic-homotopy-theory.functoriality-loop-spaces public
@@ -40,6 +45,7 @@ open import synthetic-homotopy-theory.prespectra public
 open import synthetic-homotopy-theory.pullback-property-pushouts public
 open import synthetic-homotopy-theory.pushouts public
 open import synthetic-homotopy-theory.pushouts-of-pointed-types public
+open import synthetic-homotopy-theory.sections-descent-circle public
 open import synthetic-homotopy-theory.smash-products-of-pointed-types public
 open import synthetic-homotopy-theory.spectra public
 open import synthetic-homotopy-theory.spheres public
diff --git a/src/synthetic-homotopy-theory/descent-circle-constant-families.lagda.md b/src/synthetic-homotopy-theory/descent-circle-constant-families.lagda.md
new file mode 100644
index 0000000000..3e6384785c
--- /dev/null
+++ b/src/synthetic-homotopy-theory/descent-circle-constant-families.lagda.md
@@ -0,0 +1,73 @@
+# Descent data for constant type families over the circle
+
+```agda
+module synthetic-homotopy-theory.descent-circle-constant-families where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.constant-type-families
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.identity-types
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.descent-circle
+open import synthetic-homotopy-theory.free-loops
+```
+
+</details>
+
+## Idea
+
+[Descent data for the circle](synthetic-homotopy-theory.descent-circle.md) for a
+[constant type family](foundation.constant-type-families.md) is simply the type
+it evaluates to, together with the identity.
+
+## Definitions
+
+### Descent data for constant type families over the circle
+
+```agda
+module _
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( X : UU l2)
+  where
+
+  descent-data-circle-constant-type : descent-data-circle l2
+  pr1 descent-data-circle-constant-type = X
+  pr2 descent-data-circle-constant-type = id-equiv
+
+  family-descent-data-circle-constant-type : S ‚Üí UU l2
+  family-descent-data-circle-constant-type x = X
+```
+
+## Properties
+
+### Characterization of descent data for constant type families over the circle
+
+```agda
+module _
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( X : UU l2)
+  where
+
+  eq-descent-data-circle-constant-type :
+    Eq-descent-data-circle
+      ( descent-data-circle-constant-type l X)
+      ( ev-descent-data-circle l
+        ( family-descent-data-circle-constant-type l X))
+  pr1 eq-descent-data-circle-constant-type = id-equiv
+  pr2 eq-descent-data-circle-constant-type x =
+    inv (tr-constant-type-family (loop-free-loop l) x)
+
+  family-with-descent-data-constant-type :
+    family-with-descent-data-circle l l2
+  pr1 family-with-descent-data-constant-type =
+    family-descent-data-circle-constant-type l X
+  pr1 (pr2 family-with-descent-data-constant-type) =
+    descent-data-circle-constant-type l X
+  pr2 (pr2 family-with-descent-data-constant-type) =
+    eq-descent-data-circle-constant-type
+```
diff --git a/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
new file mode 100644
index 0000000000..e0cc330f78
--- /dev/null
+++ b/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
@@ -0,0 +1,115 @@
+# Descent data for families of dependent pair types over the circle
+
+```agda
+module synthetic-homotopy-theory.descent-circle-dependent-pair-types where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.dependent-pair-types
+open import foundation.equality-dependent-pair-types
+open import foundation.equivalences
+open import foundation.functoriality-dependent-pair-types
+open import foundation.identity-types
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.descent-circle
+open import synthetic-homotopy-theory.free-loops
+```
+
+</details>
+
+## Idea
+
+Given a family `A : ùïä¬π ‚Üí U` over the
+[circle](synthetic-homotopy-theory.circle.md) and a family
+`B : (t : ùïä¬π) ‚Üí (A t) ‚Üí U` over `A`, the
+[descent data](synthetic-homotopy-theory.descent-circle.md) for the family of
+[dependent pair types](foundation.dependent-pair-types.md) `Œª t ‚Üí Œ£ (A t) (B t)`
+is `(Œ£ X R, map-Œ£ e k)`, where `(X, e)` is descent data for `A` and `(R, k)` is
+dependent descent data for `B`.
+
+## Definitions
+
+### Descent data for families of dependent pair types over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-dependent-descent-data-circle l A l3)
+  where
+
+  descent-data-circle-dependent-pair-type : descent-data-circle (l2 ‚äî l3)
+  pr1 descent-data-circle-dependent-pair-type =
+    Œ£ ( type-family-with-descent-data-circle A)
+      ( type-family-with-dependent-descent-data-circle A B)
+  pr2 descent-data-circle-dependent-pair-type =
+    equiv-Œ£
+      ( type-family-with-dependent-descent-data-circle A B)
+      ( aut-family-with-descent-data-circle A)
+      ( pseudo-aut-family-with-dependent-descent-data-circle A B)
+
+  family-descent-data-circle-dependent-pair-type : S ‚Üí UU (l2 ‚äî l3)
+  family-descent-data-circle-dependent-pair-type x =
+    Œ£ ( family-family-with-descent-data-circle A x)
+      ( family-family-with-dependent-descent-data-circle A B x)
+```
+
+## Properties
+
+### Characterization of descent data for families of dependent pair types over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-dependent-descent-data-circle l A l3)
+  where
+
+  eq-descent-data-circle-dependent-pair-type :
+    Eq-descent-data-circle
+      ( descent-data-circle-dependent-pair-type l A B)
+      ( ev-descent-data-circle l
+        ( family-descent-data-circle-dependent-pair-type l A B))
+  pr1 eq-descent-data-circle-dependent-pair-type =
+    equiv-Œ£
+      ( family-family-with-dependent-descent-data-circle A B (base-free-loop l))
+      ( equiv-family-with-descent-data-circle A)
+      ( equiv-family-with-dependent-descent-data-circle A B)
+  pr2 eq-descent-data-circle-dependent-pair-type u =
+    inv
+      ( tr-Œ£
+          ( family-family-with-dependent-descent-data-circle A B)
+          ( loop-free-loop l)
+          ( map-Œ£
+            ( family-family-with-dependent-descent-data-circle A B
+              ( base-free-loop l))
+            ( map-equiv-family-with-descent-data-circle A)
+            ( map-equiv-family-with-dependent-descent-data-circle A B)
+            ( u)) ‚àô
+        eq-pair-Œ£
+          ( inv (coherence-square-family-with-descent-data-circle A (pr1 u)))
+          ( inv
+            ( coherence-square-family-with-dependent-descent-data-circle A B
+              ( pr1 u)
+              ( pr2 u) ‚àô
+              tr-eq-pair-Œ£
+                ( ind-Œ£ (family-family-with-dependent-descent-data-circle A B))
+                ( loop-free-loop l)
+                ( inv
+                  ( coherence-square-family-with-descent-data-circle A (pr1 u)))
+                ( map-equiv-family-with-dependent-descent-data-circle A B
+                  ( pr1 u)
+                  ( pr2 u)))))
+
+  family-with-descent-data-circle-dependent-pair-type :
+    family-with-descent-data-circle l (l2 ‚äî l3)
+  pr1 family-with-descent-data-circle-dependent-pair-type =
+    family-descent-data-circle-dependent-pair-type l A B
+  pr1 (pr2 family-with-descent-data-circle-dependent-pair-type) =
+    descent-data-circle-dependent-pair-type l A B
+  pr2 (pr2 family-with-descent-data-circle-dependent-pair-type) =
+    eq-descent-data-circle-dependent-pair-type
+```
diff --git a/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
new file mode 100644
index 0000000000..50f406815d
--- /dev/null
+++ b/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
@@ -0,0 +1,174 @@
+# Descent data for families of equivalence types over the circle
+
+```agda
+module synthetic-homotopy-theory.descent-circle-equivalence-types where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.contractible-types
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.functoriality-dependent-pair-types
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.descent-circle
+open import synthetic-homotopy-theory.descent-circle-dependent-pair-types
+open import synthetic-homotopy-theory.descent-circle-function-types
+open import synthetic-homotopy-theory.descent-circle-subtypes
+open import synthetic-homotopy-theory.free-loops
+open import synthetic-homotopy-theory.sections-descent-circle
+open import synthetic-homotopy-theory.universal-property-circle
+```
+
+</details>
+
+## Idea
+
+Given two families `A, B : ùïä¬π ‚Üí U` over the
+[circle](synthetic-homotopy-theory.circle.md), to show that they are
+[equivalent](foundation.equivalences.md) is the same as showing that their
+[descent data](synthetic-homotopy-theory.descent-circle.md) is equivalent.
+
+## Definitions
+
+### Dependent descent data for being an equivalence of families over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
+  family-dependent-descent-data-circle-is-equiv :
+    ( t : S) ‚Üí family-descent-data-circle-function-type l A B t ‚Üí
+    UU (l2 ‚äî l3)
+  family-dependent-descent-data-circle-is-equiv t = is-equiv
+
+  dependent-descent-data-circle-is-equiv :
+    dependent-descent-data-circle
+      ( descent-data-circle-function-type l A B)
+      ( l2 ‚äî l3)
+  pr1 dependent-descent-data-circle-is-equiv = is-equiv
+  pr2 dependent-descent-data-circle-is-equiv f =
+    equiv-is-equiv-left-factor
+      ( aut-family-with-descent-data-circle B) ‚àòe
+    ( equiv-is-equiv-right-factor
+      ( inv-equiv (aut-family-with-descent-data-circle A)))
+```
+
+## Properties
+
+### Characterization of dependent descent data for being an equivalence of families over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
+  eq-dependent-descent-data-circle-is-equiv :
+    Eq-dependent-descent-data-circle
+      ( descent-data-circle-function-type l A B)
+      ( dependent-descent-data-circle-is-equiv l A B)
+      ( ev-dependent-descent-data-circle l
+        ( family-with-descent-data-circle-function-type l A B)
+        ( family-dependent-descent-data-circle-is-equiv l A B))
+  pr1 eq-dependent-descent-data-circle-is-equiv f =
+    equiv-is-equiv-left-factor
+      ( equiv-family-with-descent-data-circle B) ‚àòe
+    ( equiv-is-equiv-right-factor
+      ( inv-equiv (equiv-family-with-descent-data-circle A)))
+  pr2 eq-dependent-descent-data-circle-is-equiv f p =
+    center (is-property-is-equiv _ _ _)
+
+  family-with-dependent-descent-data-circle-is-equiv :
+    family-with-dependent-descent-data-circle l
+      ( family-with-descent-data-circle-function-type l A B)
+      ( l2 ‚äî l3)
+  pr1 family-with-dependent-descent-data-circle-is-equiv =
+    family-dependent-descent-data-circle-is-equiv l A B
+  pr1 (pr2 family-with-dependent-descent-data-circle-is-equiv) =
+    dependent-descent-data-circle-is-equiv l A B
+  pr2 (pr2 family-with-dependent-descent-data-circle-is-equiv) =
+    eq-dependent-descent-data-circle-is-equiv
+```
+
+### Characterization of descent data for families of equivalence types over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
+  family-with-descent-data-circle-equivalence-type :
+    family-with-descent-data-circle l (l2 ‚äî l3)
+  family-with-descent-data-circle-equivalence-type =
+    family-with-descent-data-circle-dependent-pair-type l
+      ( family-with-descent-data-circle-function-type l A B)
+      ( family-with-dependent-descent-data-circle-is-equiv l A B)
+```
+
+### A family of equivalences between families over the circle is given by an equivalence of the corresponding descent data
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
+  equiv-section-descent-data-circle-equiv-Eq-descent-data-circle :
+    dependent-universal-property-circle (l2 ‚äî l3) l ‚Üí
+    ( ( t : S) ‚Üí
+      ( family-family-with-descent-data-circle A t) ‚âÉ
+      ( family-family-with-descent-data-circle B t)) ‚âÉ
+    ( Eq-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( descent-data-family-with-descent-data-circle B))
+  equiv-section-descent-data-circle-equiv-Eq-descent-data-circle dup-circle =
+    equivalence-reasoning
+    ( ( t : S) ‚Üí
+        family-family-with-descent-data-circle A t ‚âÉ
+        family-family-with-descent-data-circle B t)
+    ‚âÉ Œ£ ( fixpoint-descent-data-circle
+          ( descent-data-circle-function-type l A B))
+        ( Œª x ‚Üí is-equiv (pr1 x))
+      by
+        equiv-section-descent-data-circle-subtype-fixpoint-in-subtype l
+          ( family-with-descent-data-circle-function-type l A B)
+          ( family-with-dependent-descent-data-circle-is-equiv l A B)
+          ( Œª t f ‚Üí is-property-is-equiv f)
+          ( dup-circle)
+    ‚âÉ Œ£ ( hom-descent-data-circle
+          ( descent-data-family-with-descent-data-circle A)
+          ( descent-data-family-with-descent-data-circle B))
+        ( Œª h ‚Üí
+          is-equiv
+            ( map-hom-descent-data-circle
+              ( descent-data-family-with-descent-data-circle A)
+              ( descent-data-family-with-descent-data-circle B)
+              ( h)))
+      by
+        equiv-Œ£-equiv-base
+          ( Œª h ‚Üí
+            is-equiv
+              ( map-hom-descent-data-circle
+                ( descent-data-family-with-descent-data-circle A)
+                ( descent-data-family-with-descent-data-circle B)
+                ( h)))
+          ( equiv-fixpoint-descent-data-circle-function-type-hom l A B)
+    ‚âÉ Eq-descent-data-circle
+        ( descent-data-family-with-descent-data-circle A)
+        ( descent-data-family-with-descent-data-circle B)
+      by
+        inv-equiv
+          ( equiv-Eq-descent-data-circle-hom-is-equiv
+            ( descent-data-family-with-descent-data-circle A)
+            ( descent-data-family-with-descent-data-circle B))
+```
diff --git a/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
new file mode 100644
index 0000000000..15f9bbe907
--- /dev/null
+++ b/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
@@ -0,0 +1,170 @@
+# Descent data for families of function types over the circle
+
+```agda
+module synthetic-homotopy-theory.descent-circle-function-types where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.commuting-squares-of-maps
+open import foundation.commuting-triangles-of-maps
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.function-extensionality
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.functoriality-function-types
+open import foundation.homotopies
+open import foundation.identity-types
+open import foundation.transport
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.descent-circle
+open import synthetic-homotopy-theory.free-loops
+open import synthetic-homotopy-theory.sections-descent-circle
+open import synthetic-homotopy-theory.universal-property-circle
+```
+
+</details>
+
+## Idea
+
+Given two families `A, B : ùïä¬π ‚Üí U` over the
+[circle](synthetic-homotopy-theory.circle.md), the
+[descent data](synthetic-homotopy-theory.descent-circle.md) for the family of
+function types `Œª t ‚Üí (A t ‚Üí B t)` is `(X ‚Üí Y, Œª h ‚Üí f ‚àò h ‚àò e‚Åª¬π)`, where
+`(X, e)` is descent data for `A` and `(Y, f)` is descent data for `B`.
+
+This correspondence allows us to characterize sections of this family as
+homomorphisms from `(X, e)` to `(Y, f)`.
+
+## Definitions
+
+### Descent data for families of function types over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
+  family-descent-data-circle-function-type : S ‚Üí UU (l2 ‚äî l3)
+  family-descent-data-circle-function-type x =
+    family-family-with-descent-data-circle A x ‚Üí
+    family-family-with-descent-data-circle B x
+
+  descent-data-circle-function-type : descent-data-circle (l2 ‚äî l3)
+  pr1 descent-data-circle-function-type =
+    type-family-with-descent-data-circle A ‚Üí
+    type-family-with-descent-data-circle B
+  pr2 descent-data-circle-function-type =
+    ( equiv-postcomp
+      ( type-family-with-descent-data-circle A)
+      ( aut-family-with-descent-data-circle B)) ‚àòe
+    ( equiv-precomp
+      ( inv-equiv (aut-family-with-descent-data-circle A))
+      ( type-family-with-descent-data-circle B))
+```
+
+## Properties
+
+### Characterization of descent data for families of function types over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
+  eq-descent-data-circle-function-type :
+    Eq-descent-data-circle
+      ( descent-data-circle-function-type l A B)
+      ( ev-descent-data-circle
+        ( l)
+        ( family-descent-data-circle-function-type l A B))
+  pr1 eq-descent-data-circle-function-type =
+    ( equiv-postcomp
+      ( family-family-with-descent-data-circle A (base-free-loop l))
+      ( equiv-family-with-descent-data-circle B)) ‚àòe
+    ( equiv-precomp
+      ( inv-equiv (equiv-family-with-descent-data-circle A))
+      ( type-family-with-descent-data-circle B))
+  pr2 eq-descent-data-circle-function-type h =
+    ( eq-htpy
+      ( htpy-comp-horizontal
+        ( h ¬∑l
+          inv-htpy
+            ( coherence-square-inv-all
+              ( equiv-family-with-descent-data-circle A)
+              ( aut-family-with-descent-data-circle A)
+              ( equiv-tr
+                ( family-family-with-descent-data-circle A)
+                ( loop-free-loop l))
+              ( equiv-family-with-descent-data-circle A)
+              ( coherence-square-family-with-descent-data-circle A)))
+        ( coherence-square-family-with-descent-data-circle B))) ‚àô
+    ( inv
+      ( ( tr-function-type
+          ( family-family-with-descent-data-circle A)
+          ( family-family-with-descent-data-circle B) (loop-free-loop l))
+        ( map-Eq-descent-data-circle
+          ( descent-data-circle-function-type l A B)
+          ( ev-descent-data-circle
+            ( l)
+            ( family-descent-data-circle-function-type l A B))
+          ( eq-descent-data-circle-function-type)
+          ( h))))
+
+  family-with-descent-data-circle-function-type :
+    family-with-descent-data-circle l (l2 ‚äî l3)
+  pr1 family-with-descent-data-circle-function-type =
+    family-descent-data-circle-function-type l A B
+  pr1 (pr2 family-with-descent-data-circle-function-type) =
+    descent-data-circle-function-type l A B
+  pr2 (pr2 family-with-descent-data-circle-function-type) =
+    eq-descent-data-circle-function-type
+```
+
+### Maps between families over the circle are equivalent to homomorphisms between the families' descent data
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
+  equiv-fixpoint-descent-data-circle-function-type-hom :
+    fixpoint-descent-data-circle (descent-data-circle-function-type l A B) ‚âÉ
+    hom-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( descent-data-family-with-descent-data-circle B)
+  equiv-fixpoint-descent-data-circle-function-type-hom =
+    equiv-tot
+      ( Œª h ‚Üí
+        ( equiv-inv-htpy
+          ( map-aut-family-with-descent-data-circle B ‚àò h)
+          ( h ‚àò map-aut-family-with-descent-data-circle A)) ‚àòe
+        ( ( inv-equiv
+            ( equiv-coherence-triangle-maps-inv-top
+              ( map-aut-family-with-descent-data-circle B ‚àò h)
+              ( h)
+              ( aut-family-with-descent-data-circle A))) ‚àòe
+          ( equiv-funext)))
+
+  equiv-ev-descent-data-circle-function-type-hom :
+    dependent-universal-property-circle (l2 ‚äî l3) l ‚Üí
+    ( (x : S) ‚Üí family-descent-data-circle-function-type l A B x) ‚âÉ
+    hom-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( descent-data-family-with-descent-data-circle B)
+  equiv-ev-descent-data-circle-function-type-hom dup-circle =
+    equiv-fixpoint-descent-data-circle-function-type-hom ‚àòe
+    ( equiv-ev-fixpoint-descent-data-circle
+      ( l)
+      ( family-with-descent-data-circle-function-type l A B)
+      ( dup-circle))
+```
diff --git a/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md b/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md
new file mode 100644
index 0000000000..9e596982b2
--- /dev/null
+++ b/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md
@@ -0,0 +1,139 @@
+# Subtypes of descent data for the circle
+
+```agda
+module synthetic-homotopy-theory.descent-circle-subtypes where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.cartesian-product-types
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.functoriality-dependent-pair-types
+open import foundation.identity-types
+open import foundation.propositions
+open import foundation.subtypes
+open import foundation.type-arithmetic-cartesian-product-types
+open import foundation.type-arithmetic-dependent-pair-types
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.descent-circle
+open import synthetic-homotopy-theory.descent-circle-dependent-pair-types
+open import synthetic-homotopy-theory.free-loops
+open import synthetic-homotopy-theory.sections-descent-circle
+open import synthetic-homotopy-theory.universal-property-circle
+```
+
+</details>
+
+## Idea
+
+Given a family `A : ùïä¬π ‚Üí U` over the
+[circle](synthetic-homotopy-theory.circle.md) and a family
+`B : (t : ùïä¬π) ‚Üí (A t) ‚Üí U` over `A` with corresponding
+[descent data](synthetic-homotopy-theory.descent-circle.md) `(X, e)` and
+dependent descent data `(R, k)`, where `R` is a
+[subtype](foundation-core.subtypes.md) of `X`, we get that dependent functions
+of type `(t : ùïä¬π) ‚Üí Œ£ (A t) (B t)` are exactly the
+[fixpoints](synthetic-homotopy-theory.sections-descent-circle.md) of `e` which
+belong to `R`.
+
+## Properties
+
+### Characterization of sections of families of subtypes
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-dependent-descent-data-circle l A l3)
+  ( is-subtype-B :
+    ( t : S) ‚Üí
+    is-subtype (family-family-with-dependent-descent-data-circle A B t))
+  where
+
+  subtype-descent-data-circle-subtype :
+    subtype l3 (type-family-with-descent-data-circle A)
+  pr1 (subtype-descent-data-circle-subtype x) =
+    type-family-with-dependent-descent-data-circle A B x
+  pr2 (subtype-descent-data-circle-subtype x) =
+    is-prop-equiv
+      ( equiv-family-with-dependent-descent-data-circle A B x)
+      ( is-subtype-B
+        ( base-free-loop l)
+        ( map-equiv-family-with-descent-data-circle A x))
+
+  equiv-fixpoint-descent-data-circle-subtype-fixpoint-in-subtype :
+    fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle
+        ( family-with-descent-data-circle-dependent-pair-type l A B)) ‚âÉ
+    ( Œ£ ( fixpoint-descent-data-circle
+          ( descent-data-family-with-descent-data-circle A))
+        ( Œª x ‚Üí is-in-subtype subtype-descent-data-circle-subtype (pr1 x)))
+  equiv-fixpoint-descent-data-circle-subtype-fixpoint-in-subtype =
+    equivalence-reasoning
+    fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle
+        ( family-with-descent-data-circle-dependent-pair-type l A B))
+    ‚âÉ Œ£ ( type-family-with-descent-data-circle A)
+        ( Œª x ‚Üí
+          Œ£ ( type-family-with-dependent-descent-data-circle A B x)
+            ( Œª r ‚Üí
+              map-Œ£
+                ( type-family-with-dependent-descent-data-circle A B)
+                ( map-aut-family-with-descent-data-circle A)
+                ( map-pseudo-aut-family-with-dependent-descent-data-circle A B)
+                ( x , r) Ôºù
+              ( x , r)))
+      by
+        associative-Œ£
+          ( type-family-with-descent-data-circle A)
+          ( type-family-with-dependent-descent-data-circle A B)
+          ( Œª u ‚Üí
+            map-Œ£
+              ( type-family-with-dependent-descent-data-circle A B)
+              ( map-aut-family-with-descent-data-circle A)
+              ( map-pseudo-aut-family-with-dependent-descent-data-circle A B)
+              ( u) Ôºù
+            u)
+    ‚âÉ Œ£ ( type-family-with-descent-data-circle A)
+        ( Œª x ‚Üí
+          ( is-in-subtype subtype-descent-data-circle-subtype x) √ó
+          ( map-aut-family-with-descent-data-circle A x Ôºù x))
+      by
+        equiv-tot
+          ( Œª x ‚Üí
+            equiv-tot
+              ( Œª r ‚Üí
+                extensionality-type-subtype'
+                  ( subtype-descent-data-circle-subtype)
+                  ( _)
+                  ( x , r)))
+    ‚âÉ Œ£ ( type-family-with-descent-data-circle A)
+        ( Œª x ‚Üí
+          ( map-aut-family-with-descent-data-circle A x Ôºù x) √ó
+          ( is-in-subtype subtype-descent-data-circle-subtype x))
+      by equiv-tot (Œª _ ‚Üí commutative-prod)
+    ‚âÉ Œ£ ( fixpoint-descent-data-circle
+          ( descent-data-family-with-descent-data-circle A))
+        ( Œª x ‚Üí is-in-subtype subtype-descent-data-circle-subtype (pr1 x))
+      by
+        inv-associative-Œ£
+          ( type-family-with-descent-data-circle A)
+          ( Œª x ‚Üí map-aut-family-with-descent-data-circle A x Ôºù x)
+          ( Œª x ‚Üí is-in-subtype subtype-descent-data-circle-subtype (pr1 x))
+
+  equiv-section-descent-data-circle-subtype-fixpoint-in-subtype :
+    dependent-universal-property-circle (l2 ‚äî l3) l ‚Üí
+    ( (x : S) ‚Üí family-descent-data-circle-dependent-pair-type l A B x) ‚âÉ
+    ( Œ£ ( fixpoint-descent-data-circle
+          ( descent-data-family-with-descent-data-circle A))
+        ( Œª x ‚Üí is-in-subtype subtype-descent-data-circle-subtype (pr1 x)))
+  equiv-section-descent-data-circle-subtype-fixpoint-in-subtype dup-circle =
+    equiv-fixpoint-descent-data-circle-subtype-fixpoint-in-subtype ‚àòe
+    ( equiv-ev-fixpoint-descent-data-circle
+      ( l)
+      ( family-with-descent-data-circle-dependent-pair-type l A B)
+      ( dup-circle))
+```
diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index 1efe950f82..050124368f 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -7,28 +7,26 @@ module synthetic-homotopy-theory.descent-circle where
 <details><summary>Imports</summary>
 
 ```agda
-open import foundation.action-on-identifications-dependent-functions
-open import foundation.action-on-identifications-functions
 open import foundation.automorphisms
 open import foundation.commuting-squares-of-maps
 open import foundation.commuting-triangles-of-maps
 open import foundation.contractible-maps
 open import foundation.contractible-types
-open import foundation.dependent-identifications
 open import foundation.dependent-pair-types
+open import foundation.equality-dependent-function-types
+open import foundation.equality-dependent-pair-types
 open import foundation.equivalence-extensionality
 open import foundation.equivalences
 open import foundation.fibers-of-maps
 open import foundation.function-extensionality
 open import foundation.function-types
 open import foundation.functoriality-dependent-pair-types
-open import foundation.functoriality-function-types
 open import foundation.fundamental-theorem-of-identity-types
 open import foundation.homotopies
 open import foundation.identity-types
-open import foundation.path-algebra
 open import foundation.structure-identity-principle
 open import foundation.transport
+open import foundation.type-arithmetic-dependent-pair-types
 open import foundation.univalence
 open import foundation.universe-levels
 
@@ -46,6 +44,14 @@ The descent property uniquely characterizes type families over the circle.
 
 ### Descent data for the circle
 
+By the
+[universal property of the circle](synthetic-homotopy-theory.universal-property-circle.md)
+and [univalence](foundation.univalence.md), a type family `A : ùïä¬π ‚Üí U` over the
+[circle](synthetic-homotopy-theory.circle.md) is equivalent to a type `X : U`
+equipped with an [automorphism](foundation.automorphisms.md) `e : X ‚âÉ X`, in a
+way made precise in further sections of this file. The pair `(X, e)` is called
+**descent data** for the circle.
+
 ```agda
 descent-data-circle :
   ( l1 : Level) ‚Üí UU (lsuc l1)
@@ -60,53 +66,512 @@ module _
 
   aut-descent-data-circle : Aut type-descent-data-circle
   aut-descent-data-circle = pr2 P
-```
 
-### Fixpoints of the descent data
-
-```agda
-fixpoint-descent-data-circle :
-  { l1 l2 : Level} {X : UU l1} (l : free-loop X)
-  ( P : descent-data-circle l2) ‚Üí UU l2
-fixpoint-descent-data-circle l P =
-  Œ£ ( type-descent-data-circle P)
-    ( Œª p ‚Üí (map-equiv (aut-descent-data-circle P) p) Ôºù p)
+  map-descent-data-circle : type-descent-data-circle ‚Üí type-descent-data-circle
+  map-descent-data-circle = map-equiv aut-descent-data-circle
 ```
 
 ### Homomorphisms between descent data for the circle
 
+A homomorphism `h` between `(X, e)` and `(Y, f)` is a map from `X` to `Y` such
+that the obvious square [commutes](foundation.commuting-squares-of-maps.md).
+
+```text
+      h
+  X -----> Y
+  |        |
+ e|        |f
+  v        v
+  X -----> Y
+      h
+```
+
 ```agda
 hom-descent-data-circle :
-  { l1 l2 l3 : Level} {X : UU l1} (l : free-loop X)
-  ( P : descent-data-circle l2) (Q : descent-data-circle l3) ‚Üí
-  UU (l2 ‚äî l3)
-hom-descent-data-circle _ P Q =
+  { l1 l2 : Level}
+  ( P : descent-data-circle l1) (Q : descent-data-circle l2) ‚Üí
+  UU (l1 ‚äî l2)
+hom-descent-data-circle P Q =
   Œ£ ( (type-descent-data-circle P) ‚Üí (type-descent-data-circle Q))
     ( Œª h ‚Üí
       coherence-square-maps
         ( h)
-        ( map-equiv (aut-descent-data-circle P))
-        ( map-equiv (aut-descent-data-circle Q))
+        ( map-descent-data-circle P)
+        ( map-descent-data-circle Q)
         ( h))
+
+module _
+  { l1 l2 : Level} (P : descent-data-circle l1) (Q : descent-data-circle l2)
+  ( h : hom-descent-data-circle P Q)
+  where
+
+  map-hom-descent-data-circle :
+    type-descent-data-circle P ‚Üí type-descent-data-circle Q
+  map-hom-descent-data-circle = pr1 h
+
+  coherence-hom-descent-data-circle :
+    coherence-square-maps
+      ( map-hom-descent-data-circle)
+      ( map-descent-data-circle P)
+      ( map-descent-data-circle Q)
+      ( map-hom-descent-data-circle)
+  coherence-hom-descent-data-circle = pr2 h
 ```
 
-## Properties
+### Canonical descent data for a family over the circle
 
-### Characterization of the identity type of descent data for the circle
+A type family over the circle gives rise to its canonical descent data, obtained
+by evaluation at `base` and [transporting](foundation-core.transport.md) along
+`loop`.
+
+```agda
+ev-descent-data-circle :
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S) ‚Üí
+  ( S ‚Üí UU l2) ‚Üí descent-data-circle l2
+pr1 (ev-descent-data-circle l A) = A (base-free-loop l)
+pr2 (ev-descent-data-circle l A) = equiv-tr A (loop-free-loop l)
+```
+
+### The identity type of descent data for the circle
+
+An [equivalence](foundation.equivalences.md) between `(X, e)` and `(Y, f)` is an
+equivalence between `X` and `Y` which commutes with the automorphisms.
 
 ```agda
 Eq-descent-data-circle :
-  { l1 : Level} ‚Üí descent-data-circle l1 ‚Üí descent-data-circle l1 ‚Üí
-  UU l1
+  { l1 l2 : Level} ‚Üí descent-data-circle l1 ‚Üí descent-data-circle l2 ‚Üí
+  UU (l1 ‚äî l2)
 Eq-descent-data-circle P Q =
-  Œ£ ( (type-descent-data-circle P) ‚âÉ (type-descent-data-circle Q))
+  Œ£ ( type-descent-data-circle P ‚âÉ type-descent-data-circle Q)
     ( Œª h ‚Üí
       coherence-square-maps
         ( map-equiv h)
-        ( map-equiv (aut-descent-data-circle P))
-        ( map-equiv (aut-descent-data-circle Q))
+        ( map-descent-data-circle P)
+        ( map-descent-data-circle Q)
         ( map-equiv h))
 
+module _
+  { l1 l2 : Level} (P : descent-data-circle l1) (Q : descent-data-circle l2)
+  ( Œ±H : Eq-descent-data-circle P Q)
+  where
+
+  equiv-Eq-descent-data-circle :
+    type-descent-data-circle P ‚âÉ type-descent-data-circle Q
+  equiv-Eq-descent-data-circle = pr1 Œ±H
+
+  map-Eq-descent-data-circle :
+    type-descent-data-circle P ‚Üí type-descent-data-circle Q
+  map-Eq-descent-data-circle = map-equiv equiv-Eq-descent-data-circle
+
+  coherence-square-Eq-descent-data-circle :
+    coherence-square-maps
+      ( map-Eq-descent-data-circle)
+      ( map-descent-data-circle P)
+      ( map-descent-data-circle Q)
+      ( map-Eq-descent-data-circle)
+  coherence-square-Eq-descent-data-circle = pr2 Œ±H
+```
+
+### A family over the circle equipped with corresponding descent data
+
+A family for descent data `(X, e)` is a family over the circle, along with a
+proof that `(X, e)` is equivalent to the canonical descent data of the family.
+
+Descent data for a family `A : ùïä¬π ‚Üí U` is descent data with a proof that it's
+equivalent to the canonical descent data of `A`.
+
+A family with descent data is a family `A : ùïä¬π ‚Üí U` over the circle, equipped
+with descent data `(X, e)`, and a proof of their equivalence. This can be
+described as a diagram
+
+```text
+      Œ±
+  X -----> A base
+  |         |
+ e|         | tr A loop
+  v         v
+  X -----> A base
+      Œ±
+```
+
+Ideally, every section characterizing descent data of a particular type family
+should include a term of type `family-with-descent-data-circle`, whose type
+family is the one being described.
+
+Note on naming: a `-for-` in a name indicates that the particular term contains
+a proof that it's somehow equivalent to the structure it's "for".
+
+```agda
+module _
+  { l1 : Level} {S : UU l1} (l : free-loop S)
+  where
+
+  family-for-descent-data-circle :
+    { l2 : Level} ‚Üí descent-data-circle l2 ‚Üí UU (l1 ‚äî lsuc l2)
+  family-for-descent-data-circle {l2} P =
+    Œ£ ( S ‚Üí UU l2)
+      ( Œª A ‚Üí
+        Eq-descent-data-circle
+          ( P)
+          ( ev-descent-data-circle l A))
+
+  descent-data-circle-for-family :
+    { l2 : Level} ‚Üí (S ‚Üí UU l2) ‚Üí UU (lsuc l2)
+  descent-data-circle-for-family {l2} A =
+    Œ£ ( descent-data-circle l2)
+      ( Œª P ‚Üí
+        Eq-descent-data-circle
+          ( P)
+          ( ev-descent-data-circle l A))
+
+  family-with-descent-data-circle :
+    ( l2 : Level) ‚Üí UU (l1 ‚äî lsuc l2)
+  family-with-descent-data-circle l2 =
+    Œ£ ( S ‚Üí UU l2) descent-data-circle-for-family
+
+module _
+  { l1 l2 : Level} {S : UU l1} {l : free-loop S}
+  ( A : family-with-descent-data-circle l l2)
+  where
+
+  family-family-with-descent-data-circle : S ‚Üí UU l2
+  family-family-with-descent-data-circle = pr1 A
+
+  descent-data-for-family-with-descent-data-circle :
+    descent-data-circle-for-family l
+      family-family-with-descent-data-circle
+  descent-data-for-family-with-descent-data-circle = pr2 A
+
+  descent-data-family-with-descent-data-circle : descent-data-circle l2
+  descent-data-family-with-descent-data-circle =
+    pr1 descent-data-for-family-with-descent-data-circle
+
+  type-family-with-descent-data-circle : UU l2
+  type-family-with-descent-data-circle =
+    type-descent-data-circle descent-data-family-with-descent-data-circle
+
+  aut-family-with-descent-data-circle : Aut type-family-with-descent-data-circle
+  aut-family-with-descent-data-circle =
+    aut-descent-data-circle descent-data-family-with-descent-data-circle
+
+  map-aut-family-with-descent-data-circle :
+    type-family-with-descent-data-circle ‚Üí type-family-with-descent-data-circle
+  map-aut-family-with-descent-data-circle =
+    map-descent-data-circle descent-data-family-with-descent-data-circle
+
+  eq-family-with-descent-data-circle :
+    Eq-descent-data-circle
+      ( descent-data-family-with-descent-data-circle)
+      ( ev-descent-data-circle l family-family-with-descent-data-circle)
+  eq-family-with-descent-data-circle =
+    pr2 descent-data-for-family-with-descent-data-circle
+
+  equiv-family-with-descent-data-circle :
+    type-family-with-descent-data-circle ‚âÉ
+    family-family-with-descent-data-circle (base-free-loop l)
+  equiv-family-with-descent-data-circle =
+    equiv-Eq-descent-data-circle
+      ( descent-data-family-with-descent-data-circle)
+      ( ev-descent-data-circle l family-family-with-descent-data-circle)
+      ( eq-family-with-descent-data-circle)
+
+  map-equiv-family-with-descent-data-circle :
+    type-family-with-descent-data-circle ‚Üí
+    family-family-with-descent-data-circle (base-free-loop l)
+  map-equiv-family-with-descent-data-circle =
+    map-equiv equiv-family-with-descent-data-circle
+
+  coherence-square-family-with-descent-data-circle :
+    coherence-square-maps
+      ( map-equiv-family-with-descent-data-circle)
+      ( map-aut-family-with-descent-data-circle)
+      ( tr family-family-with-descent-data-circle (loop-free-loop l))
+      ( map-equiv-family-with-descent-data-circle)
+  coherence-square-family-with-descent-data-circle =
+    coherence-square-Eq-descent-data-circle
+      ( descent-data-family-with-descent-data-circle)
+      ( ev-descent-data-circle l family-family-with-descent-data-circle)
+      ( eq-family-with-descent-data-circle)
+
+  family-for-family-with-descent-data-circle :
+    family-for-descent-data-circle l
+      descent-data-family-with-descent-data-circle
+  pr1 family-for-family-with-descent-data-circle =
+    family-family-with-descent-data-circle
+  pr2 family-for-family-with-descent-data-circle =
+    eq-family-with-descent-data-circle
+```
+
+### Dependent descent data for the circle
+
+The equivalence extends to the dependent case, where given a type family `A`
+over the circle with descent data `(X, e)`, a type family
+`B : (t : ùïä¬π) ‚Üí A t ‚Üí U` is equivalent to a type family `R : X ‚Üí U` equipped
+with a family of equivalences `k : (x : X) ‚Üí R(x) ‚âÉ R(e(x))`. The pair `(R, k)`
+is called **dependent descent data** for the circle over `A`. Intuitively, this
+states that the types over points of `X` belonging to the same connected
+component in the total space `Œ£ ùïä¬π A` are equivalent.
+
+```agda
+dependent-descent-data-circle :
+  { l1 : Level} ‚Üí descent-data-circle l1 ‚Üí
+  ( l2 : Level) ‚Üí UU (l1 ‚äî lsuc l2)
+dependent-descent-data-circle P l2 =
+  Œ£ ( type-descent-data-circle P ‚Üí UU l2)
+    ( Œª R ‚Üí equiv-fam R (R ‚àò (map-descent-data-circle P)))
+
+module _
+  { l1 l2 : Level} (P : descent-data-circle l1)
+  ( Q : dependent-descent-data-circle P l2)
+  where
+
+  type-dependent-descent-data-circle : type-descent-data-circle P ‚Üí UU l2
+  type-dependent-descent-data-circle = pr1 Q
+
+  pseudo-aut-dependent-descent-data-circle :
+    equiv-fam
+      ( type-dependent-descent-data-circle)
+      ( type-dependent-descent-data-circle ‚àò (map-descent-data-circle P))
+  pseudo-aut-dependent-descent-data-circle = pr2 Q
+
+  map-dependent-descent-data-circle :
+    ( x : type-descent-data-circle P) ‚Üí
+    ( type-dependent-descent-data-circle x) ‚Üí
+    ( type-dependent-descent-data-circle (map-descent-data-circle P x))
+  map-dependent-descent-data-circle x =
+    map-equiv (pseudo-aut-dependent-descent-data-circle x)
+```
+
+### Canonical dependent descent data for a family over a family over the circle
+
+```agda
+ev-dependent-descent-data-circle :
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S) ‚Üí
+  ( A : family-with-descent-data-circle l l2) ‚Üí
+  ( (x : S) ‚Üí (family-family-with-descent-data-circle A x) ‚Üí UU l3) ‚Üí
+  dependent-descent-data-circle
+    ( descent-data-family-with-descent-data-circle A)
+    ( l3)
+pr1 (ev-dependent-descent-data-circle l A B) x =
+  B (base-free-loop l) (map-equiv-family-with-descent-data-circle A x)
+pr2 (ev-dependent-descent-data-circle l A B) x =
+  equiv-tr
+    ( ind-Œ£ B)
+    ( eq-pair-Œ£
+      ( loop-free-loop l)
+      ( inv (coherence-square-family-with-descent-data-circle A x)))
+```
+
+### The identity type of dependent descent data for the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} (P : descent-data-circle l1)
+  where
+
+  Eq-dependent-descent-data-circle :
+    dependent-descent-data-circle P l2 ‚Üí dependent-descent-data-circle P l3 ‚Üí
+    UU (l1 ‚äî l2 ‚äî l3)
+  Eq-dependent-descent-data-circle Q T =
+    Œ£ ( equiv-fam
+        ( type-dependent-descent-data-circle P Q)
+        ( type-dependent-descent-data-circle P T))
+      ( Œª H ‚Üí
+        ( x : type-descent-data-circle P) ‚Üí
+        coherence-square-maps
+          ( map-equiv (H x))
+          ( map-dependent-descent-data-circle P Q x)
+          ( map-dependent-descent-data-circle P T x)
+          ( map-equiv (H (map-descent-data-circle P x))))
+
+module _
+  { l1 l2 l3 : Level} (P : descent-data-circle l1)
+  ( Q : dependent-descent-data-circle P l2)
+  ( T : dependent-descent-data-circle P l3)
+  ( Œ±H : Eq-dependent-descent-data-circle P Q T)
+  where
+
+  equiv-Eq-dependent-descent-data-circle :
+    equiv-fam
+      ( type-dependent-descent-data-circle P Q)
+      ( type-dependent-descent-data-circle P T)
+  equiv-Eq-dependent-descent-data-circle = pr1 Œ±H
+
+  map-Eq-dependent-descent-data-circle :
+    ( x : type-descent-data-circle P) ‚Üí
+    ( type-dependent-descent-data-circle P Q x) ‚Üí
+    ( type-dependent-descent-data-circle P T x)
+  map-Eq-dependent-descent-data-circle x =
+    map-equiv (equiv-Eq-dependent-descent-data-circle x)
+
+  coherence-square-Eq-dependent-descent-data-circle :
+    ( x : type-descent-data-circle P) ‚Üí
+    coherence-square-maps
+      ( map-Eq-dependent-descent-data-circle x)
+      ( map-dependent-descent-data-circle P Q x)
+      ( map-dependent-descent-data-circle P T x)
+      ( map-Eq-dependent-descent-data-circle
+        ( map-descent-data-circle P x))
+  coherence-square-Eq-dependent-descent-data-circle = pr2 Œ±H
+```
+
+### A dependent family over the circle with corresponding dependent descent data
+
+```agda
+module _
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  where
+
+  family-for-dependent-descent-data-circle :
+    { l3 : Level} ‚Üí
+    dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( l3) ‚Üí
+    UU (l1 ‚äî l2 ‚äî lsuc l3)
+  family-for-dependent-descent-data-circle {l3} Q =
+    Œ£ ( (x : S) ‚Üí (family-family-with-descent-data-circle A x) ‚Üí UU l3)
+      ( Œª B ‚Üí
+        Eq-dependent-descent-data-circle
+          ( descent-data-family-with-descent-data-circle A)
+          ( Q)
+          ( ev-dependent-descent-data-circle l A B))
+
+  dependent-descent-data-circle-for-family :
+    { l3 : Level} ‚Üí
+    ( (x : S) ‚Üí (family-family-with-descent-data-circle A x) ‚Üí UU l3) ‚Üí
+    UU (l2 ‚äî lsuc l3)
+  dependent-descent-data-circle-for-family {l3} B =
+    Œ£ ( dependent-descent-data-circle
+        ( descent-data-family-with-descent-data-circle A)
+        ( l3))
+      ( Œª Q ‚Üí
+        Eq-dependent-descent-data-circle
+          ( descent-data-family-with-descent-data-circle A)
+          ( Q)
+          ( ev-dependent-descent-data-circle l A B))
+
+  family-with-dependent-descent-data-circle :
+    ( l3 : Level) ‚Üí UU (l1 ‚äî l2 ‚äî lsuc l3)
+  family-with-dependent-descent-data-circle l3 =
+    Œ£ ( (x : S) ‚Üí (family-family-with-descent-data-circle A x) ‚Üí UU l3)
+      dependent-descent-data-circle-for-family
+
+module _
+  { l1 l2 l3 : Level} {S : UU l1} {l : free-loop S}
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-dependent-descent-data-circle l A l3)
+  where
+
+  family-family-with-dependent-descent-data-circle :
+    ( x : S) ‚Üí (family-family-with-descent-data-circle A x) ‚Üí UU l3
+  family-family-with-dependent-descent-data-circle = pr1 B
+
+  dependent-descent-data-for-family-with-dependent-descent-data-circle :
+    dependent-descent-data-circle-for-family l A
+      family-family-with-dependent-descent-data-circle
+  dependent-descent-data-for-family-with-dependent-descent-data-circle = pr2 B
+
+  dependent-descent-data-family-with-dependent-descent-data-circle :
+    dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( l3)
+  dependent-descent-data-family-with-dependent-descent-data-circle =
+    pr1 dependent-descent-data-for-family-with-dependent-descent-data-circle
+
+  type-family-with-dependent-descent-data-circle :
+    type-family-with-descent-data-circle A ‚Üí UU l3
+  type-family-with-dependent-descent-data-circle =
+    type-dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( dependent-descent-data-family-with-dependent-descent-data-circle)
+
+  pseudo-aut-family-with-dependent-descent-data-circle :
+    equiv-fam
+    ( type-family-with-dependent-descent-data-circle)
+    ( type-family-with-dependent-descent-data-circle ‚àò
+      ( map-aut-family-with-descent-data-circle A))
+  pseudo-aut-family-with-dependent-descent-data-circle =
+    pseudo-aut-dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( dependent-descent-data-family-with-dependent-descent-data-circle)
+
+  map-pseudo-aut-family-with-dependent-descent-data-circle :
+    ( x : type-family-with-descent-data-circle A) ‚Üí
+    ( type-family-with-dependent-descent-data-circle x) ‚Üí
+    ( type-family-with-dependent-descent-data-circle
+      ( map-aut-family-with-descent-data-circle A x))
+  map-pseudo-aut-family-with-dependent-descent-data-circle =
+    map-dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( dependent-descent-data-family-with-dependent-descent-data-circle)
+
+  eq-family-with-dependent-descent-data-circle :
+    Eq-dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( dependent-descent-data-family-with-dependent-descent-data-circle)
+      ( ev-dependent-descent-data-circle l A
+        ( family-family-with-dependent-descent-data-circle))
+  eq-family-with-dependent-descent-data-circle =
+    pr2 dependent-descent-data-for-family-with-dependent-descent-data-circle
+
+  equiv-family-with-dependent-descent-data-circle :
+    ( x : type-family-with-descent-data-circle A) ‚Üí
+    ( type-family-with-dependent-descent-data-circle x) ‚âÉ
+    ( family-family-with-dependent-descent-data-circle
+      ( base-free-loop l)
+      ( map-equiv-family-with-descent-data-circle A x))
+  equiv-family-with-dependent-descent-data-circle =
+    equiv-Eq-dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( dependent-descent-data-family-with-dependent-descent-data-circle)
+      ( ev-dependent-descent-data-circle l A
+        ( family-family-with-dependent-descent-data-circle))
+      ( eq-family-with-dependent-descent-data-circle)
+
+  map-equiv-family-with-dependent-descent-data-circle :
+    ( x : type-family-with-descent-data-circle A) ‚Üí
+    ( type-family-with-dependent-descent-data-circle x) ‚Üí
+    ( family-family-with-dependent-descent-data-circle
+      ( base-free-loop l)
+      ( map-equiv-family-with-descent-data-circle A x))
+  map-equiv-family-with-dependent-descent-data-circle x =
+    map-equiv (equiv-family-with-dependent-descent-data-circle x)
+
+  coherence-square-family-with-dependent-descent-data-circle :
+    ( x : type-family-with-descent-data-circle A) ‚Üí
+    coherence-square-maps
+      ( map-equiv-family-with-dependent-descent-data-circle x)
+      ( map-pseudo-aut-family-with-dependent-descent-data-circle x)
+      ( tr
+        ( ind-Œ£ (family-family-with-dependent-descent-data-circle))
+        ( eq-pair-Œ£
+          ( loop-free-loop l)
+          ( inv (coherence-square-family-with-descent-data-circle A x))))
+      ( map-equiv-family-with-dependent-descent-data-circle
+        ( map-aut-family-with-descent-data-circle A x))
+  coherence-square-family-with-dependent-descent-data-circle =
+    coherence-square-Eq-dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( dependent-descent-data-family-with-dependent-descent-data-circle)
+      ( ev-dependent-descent-data-circle l A
+        ( family-family-with-dependent-descent-data-circle))
+      ( eq-family-with-dependent-descent-data-circle)
+
+  family-for-family-with-dependent-descent-data-circle :
+    family-for-dependent-descent-data-circle l A
+      dependent-descent-data-family-with-dependent-descent-data-circle
+  pr1 family-for-family-with-dependent-descent-data-circle =
+    family-family-with-dependent-descent-data-circle
+  pr2 family-for-family-with-dependent-descent-data-circle =
+    eq-family-with-dependent-descent-data-circle
+```
+
+## Properties
+
+### Characterization of the identity type of descent data for the circle
+
+```agda
 refl-Eq-descent-data-circle :
   { l1 : Level} (P : descent-data-circle l1) ‚Üí
   Eq-descent-data-circle P P
@@ -125,7 +590,7 @@ is-contr-total-Eq-descent-data-circle P =
     ( Œª Y f h ‚Üí
       coherence-square-maps
         ( map-equiv h)
-        ( map-equiv (aut-descent-data-circle P))
+        ( map-descent-data-circle P)
         ( map-equiv f)
         ( map-equiv h))
     ( is-contr-total-equiv (type-descent-data-circle P))
@@ -147,7 +612,29 @@ eq-Eq-descent-data-circle P Q =
   map-inv-is-equiv (is-equiv-Eq-eq-descent-data-circle P Q)
 ```
 
-### Uniqueness of descent data characterizing a particular type family over the circle
+### Alternative definition of equality of descent data as homomorphisms which are equivalences
+
+```agda
+module _
+  { l1 l2 : Level}
+  ( P : descent-data-circle l1)
+  ( Q : descent-data-circle l2)
+  where
+
+  Eq-descent-data-circle' : UU (l1 ‚äî l2)
+  Eq-descent-data-circle' =
+    Œ£ ( hom-descent-data-circle P Q)
+      ( Œª h ‚Üí is-equiv (map-hom-descent-data-circle P Q h))
+
+  equiv-Eq-descent-data-circle-hom-is-equiv :
+    Eq-descent-data-circle P Q ‚âÉ Eq-descent-data-circle'
+  equiv-Eq-descent-data-circle-hom-is-equiv = equiv-right-swap-Œ£
+```
+
+### Uniqueness of descent data characterizing a type family over the circle
+
+Given a type `X` and an automorphism `e : X ‚âÉ X`, there is a unique type family
+`ùìì(X, e) : ùïä¬π ‚Üí U` for which `(X, e)` is descent data.
 
 ```agda
 comparison-descent-data-circle :
@@ -160,30 +647,26 @@ is-equiv-comparison-descent-data-circle l1 =
   is-equiv-tot-is-fiberwise-equiv (Œª Y ‚Üí univalence Y Y)
 
 module _
-  { l1 l2 : Level} {X : UU l1} (l : free-loop X)
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
   where
 
-  ev-descent-data-circle : (X ‚Üí UU l2) ‚Üí descent-data-circle l2
-  pr1 (ev-descent-data-circle P) = P (base-free-loop l)
-  pr2 (ev-descent-data-circle P) = equiv-tr P (loop-free-loop l)
-
   triangle-comparison-descent-data-circle :
     coherence-triangle-maps
-      ( ev-descent-data-circle)
+      ( ev-descent-data-circle l)
       ( comparison-descent-data-circle l2)
       ( ev-free-loop l (UU l2))
-  triangle-comparison-descent-data-circle P =
+  triangle-comparison-descent-data-circle A =
     eq-Eq-descent-data-circle
-      ( ev-descent-data-circle P)
-      ( comparison-descent-data-circle l2 (ev-free-loop l (UU l2) P))
+      ( ev-descent-data-circle l A)
+      ( comparison-descent-data-circle l2 (ev-free-loop l (UU l2) A))
       ( id-equiv , (htpy-eq (inv (compute-equiv-eq-ap (loop-free-loop l)))))
 
   is-equiv-ev-descent-data-circle-universal-property-circle :
     ( up-circle : universal-property-circle (lsuc l2) l) ‚Üí
-    is-equiv ev-descent-data-circle
+    is-equiv (ev-descent-data-circle l)
   is-equiv-ev-descent-data-circle-universal-property-circle up-circle =
     is-equiv-comp-htpy
-      ( ev-descent-data-circle)
+      ( ev-descent-data-circle l)
       ( comparison-descent-data-circle l2)
       ( ev-free-loop l (UU l2))
       ( triangle-comparison-descent-data-circle)
@@ -191,22 +674,19 @@ module _
       ( is-equiv-comparison-descent-data-circle l2)
 
 unique-family-property-circle :
-  { l1 : Level} (l2 : Level) {X : UU l1} (l : free-loop X) ‚Üí
+  { l1 : Level} (l2 : Level) {S : UU l1} (l : free-loop S) ‚Üí
   UU (l1 ‚äî lsuc l2)
-unique-family-property-circle l2 {X} l =
-  ( Q : descent-data-circle l2) ‚Üí
-    is-contr
-    ( Œ£ (X ‚Üí UU l2)
-        (Œª P ‚Üí Eq-descent-data-circle Q (ev-descent-data-circle l P)))
+unique-family-property-circle l2 {S} l =
+  ( Q : descent-data-circle l2) ‚Üí is-contr (family-for-descent-data-circle l Q)
 
 module _
-  { l1 l2 : Level} {X : UU l1} (l : free-loop X)
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( up-circle : universal-property-circle (lsuc l2) l)
   where
 
   unique-family-property-universal-property-circle :
-    universal-property-circle (lsuc l2) l ‚Üí
     unique-family-property-circle l2 l
-  unique-family-property-universal-property-circle up-circle Q =
+  unique-family-property-universal-property-circle Q =
     is-contr-is-equiv'
       ( fib (ev-descent-data-circle l) Q)
       ( tot
@@ -225,256 +705,103 @@ module _
           ( l)
           ( up-circle))
         ( Q))
-```
 
-### Characterization of sections of type families over the circle
+  family-for-descent-data-circle-descent-data :
+    ( P : descent-data-circle l2) ‚Üí
+    family-for-descent-data-circle l P
+  family-for-descent-data-circle-descent-data P =
+    center (unique-family-property-universal-property-circle P)
+
+  family-with-descent-data-circle-descent-data :
+    ( P : descent-data-circle l2) ‚Üí
+    ( family-with-descent-data-circle l l2)
+  pr1 (family-with-descent-data-circle-descent-data P) =
+    pr1 (family-for-descent-data-circle-descent-data P)
+  pr1 (pr2 (family-with-descent-data-circle-descent-data P)) = P
+  pr2 (pr2 (family-with-descent-data-circle-descent-data P)) =
+    pr2 (family-for-descent-data-circle-descent-data P)
+```
 
-Sections of type families over the circle are exactly the fixpoints of the
-automorphism from the characteristic descent data.
+### Characterization of the identity type of dependent descent data for the circle
 
 ```agda
 module _
-  { l1 l2 : Level} {X : UU l1} (l : free-loop X)
-  ( Q : X ‚Üí UU l2) (P : descent-data-circle l2)
-  ( Œ±H : Eq-descent-data-circle P (ev-descent-data-circle l Q))
+  { l1 l2 : Level} (P : descent-data-circle l1)
   where
 
-  private
-    Œ± : type-descent-data-circle P ‚âÉ Q (base-free-loop l)
-    Œ± = pr1 Œ±H
-
-  map-compute-dependent-identification-loop-circle :
-    ( x y : type-descent-data-circle P) ‚Üí
-    map-equiv (aut-descent-data-circle P) x Ôºù y ‚Üí
-    dependent-identification Q
-      ( loop-free-loop l)
-      ( map-equiv Œ± x)
-      ( map-equiv Œ± y)
-  map-compute-dependent-identification-loop-circle x y q =
-    inv (pr2 Œ±H x) ‚àô (ap (map-equiv Œ±) q)
-
-  is-equiv-map-compute-dependent-identification-loop-circle :
-    ( x y : type-descent-data-circle P) ‚Üí
-    is-equiv (map-compute-dependent-identification-loop-circle x y)
-  is-equiv-map-compute-dependent-identification-loop-circle x y =
+  refl-Eq-dependent-descent-data-circle :
+    ( Q : dependent-descent-data-circle P l2) ‚Üí
+    Eq-dependent-descent-data-circle P Q Q
+  pr1 (refl-Eq-dependent-descent-data-circle Q) =
+    id-equiv-fam (type-dependent-descent-data-circle P Q)
+  pr2 (refl-Eq-dependent-descent-data-circle Q) x = refl-htpy
+
+  Eq-eq-dependent-descent-data-circle :
+    ( Q T : dependent-descent-data-circle P l2) ‚Üí
+    Q Ôºù T ‚Üí Eq-dependent-descent-data-circle P Q T
+  Eq-eq-dependent-descent-data-circle Q .Q refl =
+    refl-Eq-dependent-descent-data-circle Q
+
+  is-contr-total-Eq-dependent-descent-data-circle :
+    ( Q : dependent-descent-data-circle P l2) ‚Üí
+    is-contr
+      ( Œ£ ( dependent-descent-data-circle P l2)
+          ( Eq-dependent-descent-data-circle P Q))
+  is-contr-total-Eq-dependent-descent-data-circle Q =
+    is-contr-total-Eq-structure
+      ( Œª R K H ‚Üí
+        ( x : type-descent-data-circle P) ‚Üí
+        coherence-square-maps
+          ( map-equiv (H x))
+          ( map-dependent-descent-data-circle P Q x)
+          ( map-equiv (K x))
+          ( map-equiv (H (map-descent-data-circle P x))))
+      ( is-contr-total-equiv-fam (type-dependent-descent-data-circle P Q))
+      ( type-dependent-descent-data-circle P Q ,
+        id-equiv-fam (type-dependent-descent-data-circle P Q))
+      ( is-contr-total-Eq-Œ†
+        ( Œª x K ‚Üí
+          ( map-dependent-descent-data-circle P Q x) ~
+          ( map-equiv K))
+        ( Œª x ‚Üí
+          is-contr-total-htpy-equiv
+            ( pseudo-aut-dependent-descent-data-circle P Q x)))
+
+  is-equiv-Eq-eq-dependent-descent-data-circle :
+    ( Q T : dependent-descent-data-circle P l2) ‚Üí
+    is-equiv (Eq-eq-dependent-descent-data-circle Q T)
+  is-equiv-Eq-eq-dependent-descent-data-circle Q =
     fundamental-theorem-id
-      ( is-contr-equiv'
-        ( fib (map-equiv Œ±) (tr Q (loop-free-loop l) (map-equiv Œ± x)))
-        ( equiv-fib _ _)
-        ( is-contr-map-is-equiv
-          ( is-equiv-map-equiv Œ±)
-          ( tr Q (loop-free-loop l) (map-equiv Œ± x))))
-      ( map-compute-dependent-identification-loop-circle x)
-      ( y)
-
-  compute-dependent-identification-loop-circle :
-    ( x y : type-descent-data-circle P) ‚Üí
-    ( map-equiv (aut-descent-data-circle P) x Ôºù y) ‚âÉ
-    ( dependent-identification Q
-      ( loop-free-loop l)
-      ( map-equiv Œ± x)
-      ( map-equiv Œ± y))
-  pr1 (compute-dependent-identification-loop-circle x y) =
-    map-compute-dependent-identification-loop-circle x y
-  pr2 (compute-dependent-identification-loop-circle x y) =
-    is-equiv-map-compute-dependent-identification-loop-circle x y
+      ( is-contr-total-Eq-dependent-descent-data-circle Q)
+      ( Eq-eq-dependent-descent-data-circle Q)
+
+  eq-Eq-dependent-descent-data-circle :
+    ( Q T : dependent-descent-data-circle P l2) ‚Üí
+    Eq-dependent-descent-data-circle P Q T ‚Üí Q Ôºù T
+  eq-Eq-dependent-descent-data-circle Q T =
+    map-inv-is-equiv (is-equiv-Eq-eq-dependent-descent-data-circle Q T)
 ```
 
-```agda
-module _
-  { l1 l2 : Level} {X : UU l1} (l : free-loop X)
-  ( Q : X ‚Üí UU l2) (P : descent-data-circle l2)
-  ( Œ±H : Eq-descent-data-circle P (ev-descent-data-circle l Q))
-  where
+### Uniqueness of dependent descent data characterizing a type family over a family over the circle
 
-  private
-    Œ± : type-descent-data-circle P ‚âÉ Q (base-free-loop l)
-    Œ± = pr1 Œ±H
-
-  ev-fixpoint-descent-data-circle :
-    ( (x : X) ‚Üí Q x) ‚Üí fixpoint-descent-data-circle l P
-  pr1 (ev-fixpoint-descent-data-circle s) =
-    map-inv-equiv
-      ( Œ±)
-      ( s (base-free-loop l))
-  pr2 (ev-fixpoint-descent-data-circle s) =
-    map-inv-is-equiv
-      ( is-equiv-map-compute-dependent-identification-loop-circle
-        ( l)
-        ( Q)
-        ( P)
-        ( Œ±H)
-        ( map-inv-equiv Œ± (s (base-free-loop l)))
-        ( map-inv-equiv Œ± (s (base-free-loop l))))
-      ( ( ap
-          ( tr Q (loop-free-loop l))
-          ( is-section-map-inv-equiv Œ± (s (base-free-loop l)))) ‚àô
-        ( ( apd s (loop-free-loop l)) ‚àô
-          ( inv (is-section-map-inv-equiv Œ± (s (base-free-loop l))))))
-
-  equiv-fixpoint-descent-data-circle-free-dependent-loop :
-    fixpoint-descent-data-circle l P ‚âÉ free-dependent-loop l Q
-  equiv-fixpoint-descent-data-circle-free-dependent-loop =
-    equiv-Œ£
-      ( Œª x ‚Üí dependent-identification Q (loop-free-loop l) x x)
-      ( Œ±)
-      ( Œª x ‚Üí
-        compute-dependent-identification-loop-circle l Q P Œ±H x x)
-
-  comparison-fixpoint-descent-data-circle :
-    fixpoint-descent-data-circle l P ‚Üí free-dependent-loop l Q
-  comparison-fixpoint-descent-data-circle =
-    map-equiv equiv-fixpoint-descent-data-circle-free-dependent-loop
-
-  triangle-comparison-fixpoint-descent-data-circle :
-    coherence-triangle-maps
-      ( ev-free-loop-Œ† l Q)
-      ( comparison-fixpoint-descent-data-circle)
-      ( ev-fixpoint-descent-data-circle)
-  triangle-comparison-fixpoint-descent-data-circle s =
-    eq-Eq-free-dependent-loop l Q
-      ( ev-free-loop-Œ† l Q s)
-      ( ( comparison-fixpoint-descent-data-circle ‚àò
-          ev-fixpoint-descent-data-circle)
-        ( s))
-      ( inv is-section-inv-Œ± ,
-        inv
-        ( ( horizontal-concat-Id¬≤
-            ( refl {x = ap (tr Q (loop-free-loop l)) (inv is-section-inv-Œ±)})
-            ( is-section-map-inv-is-equiv
-              ( is-equiv-map-compute-dependent-identification-loop-circle
-                ( l)
-                ( Q)
-                ( P)
-                ( Œ±H)
-                ( map-inv-equiv Œ± (s (base-free-loop l)))
-                ( pr1 (ev-fixpoint-descent-data-circle s)))
-              ( _))) ‚àô
-          ( ( inv (assoc (ap _ (inv is-section-inv-Œ±)) _ _)) ‚àô
-            ( horizontal-concat-Id¬≤
-              ( inv
-                ( ap-concat-eq (tr Q (loop-free-loop l))
-                  ( inv is-section-inv-Œ±)
-                  ( is-section-inv-Œ±)
-                  ( refl)
-                  ( inv (left-inv is-section-inv-Œ±))))
-              ( refl)))))
-    where
-    is-section-inv-Œ± :
-      eq-value (map-equiv Œ± ‚àò map-inv-equiv Œ±) id (s (base-free-loop l))
-    is-section-inv-Œ± = is-section-map-inv-equiv Œ± (s (base-free-loop l))
-
-  is-equiv-comparison-fixpoint-descent-data-circle :
-    is-equiv comparison-fixpoint-descent-data-circle
-  is-equiv-comparison-fixpoint-descent-data-circle =
-    is-equiv-map-equiv equiv-fixpoint-descent-data-circle-free-dependent-loop
-
-  is-equiv-ev-fixpoint-descent-data-circle :
-    ( dependent-universal-property-circle l2 l) ‚Üí
-    is-equiv ev-fixpoint-descent-data-circle
-  is-equiv-ev-fixpoint-descent-data-circle dup-circle =
-    is-equiv-right-factor-htpy
-      ( ev-free-loop-Œ† l Q)
-      ( comparison-fixpoint-descent-data-circle)
-      ( ev-fixpoint-descent-data-circle)
-      ( triangle-comparison-fixpoint-descent-data-circle)
-      ( is-equiv-comparison-fixpoint-descent-data-circle)
-      ( dup-circle Q)
-
-  equiv-ev-fixpoint-descent-data-circle :
-    ( dependent-universal-property-circle l2 l) ‚Üí
-    ( (x : X) ‚Üí Q x) ‚âÉ (fixpoint-descent-data-circle l P)
-  pr1 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
-    ev-fixpoint-descent-data-circle
-  pr2 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
-    is-equiv-ev-fixpoint-descent-data-circle dup-circle
-
-  compute-ev-fixpoint-descent-data-circle :
-    coherence-square-maps
-      ( ev-fixpoint-descent-data-circle)
-      ( ev-point (base-free-loop l) {Q})
-      ( pr1)
-      ( map-inv-equiv Œ±)
-  compute-ev-fixpoint-descent-data-circle = refl-htpy
-```
-
-### Characterization of families of maps over the circle
+Given a type family `A : ùïä¬π ‚Üí U` with corresponding descent data `(X, e)`, and a
+type family `R : X ‚Üí U` over `X` invariant under `e` as witnessed by `k`, there
+is a unique family `B : (t : ùïä¬π) ‚Üí A t ‚Üí U` for which `(R, k)` is dependent
+descent data over `A`.
 
-Families of maps over the circle are maps commuting with the respective
-automorphisms.
+This is so far a conjecture which remains to be shown.
 
 ```agda
 module _
-  { l1 l2 l3 : Level} {X : UU l1} (l : free-loop X)
-  ( A : X ‚Üí UU l2) (P : descent-data-circle l2)
-  ( Œ±H : Eq-descent-data-circle P (ev-descent-data-circle l A))
-  ( B : X ‚Üí UU l3) (Q : descent-data-circle l3)
-  ( Œ≤K : Eq-descent-data-circle Q (ev-descent-data-circle l B))
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
   where
 
-  private
-    Y : UU l2
-    Y = type-descent-data-circle P
-    e : Aut Y
-    e = aut-descent-data-circle P
-    Z : UU l3
-    Z = type-descent-data-circle Q
-    f : Aut Z
-    f = aut-descent-data-circle Q
-
-    Œ± : Y ‚âÉ A (base-free-loop l)
-    Œ± = pr1 Œ±H
-    Œ≤ : Z ‚âÉ B (base-free-loop l)
-    Œ≤ = pr1 Œ≤K
-
-  descent-data-circle-function-type : descent-data-circle (l2 ‚äî l3)
-  pr1 descent-data-circle-function-type =
-    Y ‚Üí Z
-  pr2 descent-data-circle-function-type =
-    (equiv-postcomp Y f) ‚àòe (equiv-precomp (inv-equiv e) Z)
-
-  eq-descent-data-circle-function-type :
-    Eq-descent-data-circle
-      ( descent-data-circle-function-type)
-      ( ev-descent-data-circle l (Œª s ‚Üí (A s ‚Üí B s)))
-  pr1 eq-descent-data-circle-function-type =
-    (equiv-postcomp (A (base-free-loop l)) Œ≤) ‚àòe (equiv-precomp (inv-equiv Œ±) Z)
-  pr2 eq-descent-data-circle-function-type h =
-    ( eq-htpy
-      ( htpy-comp-horizontal
-        ( h ¬∑l
-          inv-htpy
-            ( coherence-square-inv-all
-              ( Œ±)
-              ( e)
-              ( equiv-tr A (loop-free-loop l))
-              ( Œ±)
-              ( pr2 Œ±H)))
-        ( pr2 Œ≤K))) ‚àô
-    ( inv
-      ( ( tr-function-type A B (loop-free-loop l))
-        ( map-equiv (pr1 eq-descent-data-circle-function-type) h)))
-
-  equiv-fixpoint-descent-data-circle-function-type-hom :
-    fixpoint-descent-data-circle l descent-data-circle-function-type ‚âÉ
-    hom-descent-data-circle l P Q
-  equiv-fixpoint-descent-data-circle-function-type-hom =
-    equiv-tot
-      (Œª h ‚Üí
-        ( equiv-inv-htpy (((map-equiv f) ‚àò h)) (h ‚àò (map-equiv e))) ‚àòe
-        ( ( inv-equiv
-            ( equiv-coherence-triangle-maps-inv-top ((map-equiv f) ‚àò h) h e)) ‚àòe
-          ( equiv-funext)))
-
-  equiv-ev-descent-data-circle-function-type-hom :
-    dependent-universal-property-circle (l2 ‚äî l3) l ‚Üí
-    ((s : X) ‚Üí A s ‚Üí B s) ‚âÉ (hom-descent-data-circle l P Q)
-  equiv-ev-descent-data-circle-function-type-hom dup-circle =
-    equiv-fixpoint-descent-data-circle-function-type-hom ‚àòe
-    ( equiv-ev-fixpoint-descent-data-circle
-      ( l)
-      ( Œª s ‚Üí A s ‚Üí B s)
-      ( descent-data-circle-function-type)
-      ( eq-descent-data-circle-function-type)
-      ( dup-circle))
+  unique-dependent-family-property-circle : UU (l1 ‚äî l2 ‚äî lsuc l3)
+  unique-dependent-family-property-circle =
+    ( Q :
+      dependent-descent-data-circle
+        ( descent-data-family-with-descent-data-circle A)
+        ( l3)) ‚Üí
+    is-contr (family-for-dependent-descent-data-circle l A Q)
 ```
diff --git a/src/synthetic-homotopy-theory/sections-descent-circle.lagda.md b/src/synthetic-homotopy-theory/sections-descent-circle.lagda.md
new file mode 100644
index 0000000000..af2782990c
--- /dev/null
+++ b/src/synthetic-homotopy-theory/sections-descent-circle.lagda.md
@@ -0,0 +1,263 @@
+# Sections of families over the circle
+
+```agda
+module synthetic-homotopy-theory.sections-descent-circle where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.action-on-identifications-dependent-functions
+open import foundation.action-on-identifications-functions
+open import foundation.commuting-squares-of-maps
+open import foundation.commuting-triangles-of-maps
+open import foundation.contractible-maps
+open import foundation.contractible-types
+open import foundation.dependent-identifications
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.fibers-of-maps
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.fundamental-theorem-of-identity-types
+open import foundation.homotopies
+open import foundation.identity-types
+open import foundation.path-algebra
+open import foundation.transport
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.descent-circle
+open import synthetic-homotopy-theory.free-loops
+open import synthetic-homotopy-theory.universal-property-circle
+```
+
+</details>
+
+## Idea
+
+Sections of type families over the [circle](synthetic-homotopy-theory.circle.md)
+are exactly the fixpoints of the [automorphism](foundation.automorphisms.md)
+from the corresponding
+[descent data](synthetic-homotopy-theory.descent-circle.md).
+
+## Definitions
+
+### Fixpoints of descent data
+
+A fixpoint of `(X, e)` is a fixpoint of `e`.
+
+```agda
+fixpoint-descent-data-circle :
+  { l1 : Level}
+  ( P : descent-data-circle l1) ‚Üí UU l1
+fixpoint-descent-data-circle P =
+  Œ£ ( type-descent-data-circle P)
+    ( Œª x ‚Üí (map-descent-data-circle P x) Ôºù x)
+```
+
+## Properties
+
+### Characterization of sections of type families over the circle
+
+```agda
+module _
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  where
+
+  map-compute-dependent-identification-loop-circle :
+    ( x y : type-family-with-descent-data-circle A) ‚Üí
+    map-aut-family-with-descent-data-circle A x Ôºù y ‚Üí
+    dependent-identification (family-family-with-descent-data-circle A)
+      ( loop-free-loop l)
+      ( map-equiv-family-with-descent-data-circle A x)
+      ( map-equiv-family-with-descent-data-circle A y)
+  map-compute-dependent-identification-loop-circle x y q =
+    inv (coherence-square-family-with-descent-data-circle A x) ‚àô
+    ( ap (map-equiv-family-with-descent-data-circle A) q)
+
+  is-equiv-map-compute-dependent-identification-loop-circle :
+    ( x y : type-family-with-descent-data-circle A) ‚Üí
+    is-equiv (map-compute-dependent-identification-loop-circle x y)
+  is-equiv-map-compute-dependent-identification-loop-circle x y =
+    fundamental-theorem-id
+      ( is-contr-equiv'
+        ( fib
+          ( map-equiv-family-with-descent-data-circle A)
+          ( tr
+            ( family-family-with-descent-data-circle A)
+            ( loop-free-loop l)
+            ( map-equiv-family-with-descent-data-circle A x)))
+        ( equiv-fib _ _)
+        ( is-contr-map-is-equiv
+          ( is-equiv-map-equiv (equiv-family-with-descent-data-circle A))
+          ( tr
+            ( family-family-with-descent-data-circle A)
+            ( loop-free-loop l)
+            ( map-equiv-family-with-descent-data-circle A x))))
+      ( map-compute-dependent-identification-loop-circle x)
+      ( y)
+
+  compute-dependent-identification-loop-circle :
+    ( x y : type-family-with-descent-data-circle A) ‚Üí
+    ( map-aut-family-with-descent-data-circle A x Ôºù y) ‚âÉ
+    ( dependent-identification
+      ( family-family-with-descent-data-circle A)
+      ( loop-free-loop l)
+      ( map-equiv-family-with-descent-data-circle A x)
+      ( map-equiv-family-with-descent-data-circle A y))
+  pr1 (compute-dependent-identification-loop-circle x y) =
+    map-compute-dependent-identification-loop-circle x y
+  pr2 (compute-dependent-identification-loop-circle x y) =
+    is-equiv-map-compute-dependent-identification-loop-circle x y
+```
+
+```agda
+module _
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  where
+
+  ev-fixpoint-descent-data-circle :
+    ( (x : S) ‚Üí family-family-with-descent-data-circle A x) ‚Üí
+    ( fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A))
+  pr1 (ev-fixpoint-descent-data-circle s) =
+    map-inv-equiv
+      ( equiv-family-with-descent-data-circle A)
+      ( s (base-free-loop l))
+  pr2 (ev-fixpoint-descent-data-circle s) =
+    map-inv-equiv
+      ( compute-dependent-identification-loop-circle
+        ( l)
+        ( A)
+        ( map-inv-equiv
+          ( equiv-family-with-descent-data-circle A)
+          ( s (base-free-loop l)))
+        ( map-inv-equiv
+          ( equiv-family-with-descent-data-circle A)
+          ( s (base-free-loop l))))
+      ( ( ap
+          ( tr (family-family-with-descent-data-circle A) (loop-free-loop l))
+          ( is-section-map-inv-equiv
+            ( equiv-family-with-descent-data-circle A)
+            ( s (base-free-loop l)))) ‚àô
+        ( ( apd s (loop-free-loop l)) ‚àô
+          ( inv
+            ( is-section-map-inv-equiv
+              ( equiv-family-with-descent-data-circle A)
+              ( s (base-free-loop l))))))
+
+  equiv-fixpoint-descent-data-circle-free-dependent-loop :
+    ( fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)) ‚âÉ
+    ( free-dependent-loop l (family-family-with-descent-data-circle A))
+  equiv-fixpoint-descent-data-circle-free-dependent-loop =
+    equiv-Œ£
+      ( Œª x ‚Üí
+        dependent-identification
+          ( family-family-with-descent-data-circle A)
+          ( loop-free-loop l)
+          ( x)
+          ( x))
+      ( equiv-family-with-descent-data-circle A)
+      ( Œª x ‚Üí
+        compute-dependent-identification-loop-circle l A x x)
+
+  comparison-fixpoint-descent-data-circle :
+    ( fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)) ‚Üí
+    ( free-dependent-loop l (family-family-with-descent-data-circle A))
+  comparison-fixpoint-descent-data-circle =
+    map-equiv equiv-fixpoint-descent-data-circle-free-dependent-loop
+
+  triangle-comparison-fixpoint-descent-data-circle :
+    coherence-triangle-maps
+      ( ev-free-loop-Œ† l (family-family-with-descent-data-circle A))
+      ( comparison-fixpoint-descent-data-circle)
+      ( ev-fixpoint-descent-data-circle)
+  triangle-comparison-fixpoint-descent-data-circle s =
+    eq-Eq-free-dependent-loop l
+      ( family-family-with-descent-data-circle A)
+      ( ev-free-loop-Œ† l (family-family-with-descent-data-circle A) s)
+      ( ( comparison-fixpoint-descent-data-circle ‚àò
+          ev-fixpoint-descent-data-circle)
+        ( s))
+      ( inv is-section-inv-Œ± ,
+        inv
+        ( ( horizontal-concat-Id¬≤
+            ( refl
+              { x =
+                ap
+                  ( tr
+                    ( family-family-with-descent-data-circle A)
+                    ( loop-free-loop l))
+                  ( inv is-section-inv-Œ±)})
+            ( is-section-map-inv-is-equiv
+              ( is-equiv-map-compute-dependent-identification-loop-circle
+                ( l)
+                ( A)
+                ( map-inv-equiv
+                  ( equiv-family-with-descent-data-circle A)
+                  ( s (base-free-loop l)))
+                ( pr1 (ev-fixpoint-descent-data-circle s)))
+              ( _))) ‚àô
+          ( ( inv (assoc (ap _ (inv is-section-inv-Œ±)) _ _)) ‚àô
+            ( horizontal-concat-Id¬≤
+              ( inv
+                ( ap-concat-eq
+                  ( tr
+                    ( family-family-with-descent-data-circle A)
+                    ( loop-free-loop l))
+                  ( inv is-section-inv-Œ±)
+                  ( is-section-inv-Œ±)
+                  ( refl)
+                  ( inv (left-inv is-section-inv-Œ±))))
+              ( refl)))))
+    where
+    is-section-inv-Œ± :
+      eq-value
+        ( map-equiv-family-with-descent-data-circle A ‚àò
+          map-inv-equiv (equiv-family-with-descent-data-circle A))
+        ( id)
+        ( s (base-free-loop l))
+    is-section-inv-Œ± =
+      is-section-map-inv-equiv
+        ( equiv-family-with-descent-data-circle A)
+        ( s (base-free-loop l))
+
+  is-equiv-comparison-fixpoint-descent-data-circle :
+    is-equiv comparison-fixpoint-descent-data-circle
+  is-equiv-comparison-fixpoint-descent-data-circle =
+    is-equiv-map-equiv equiv-fixpoint-descent-data-circle-free-dependent-loop
+
+  is-equiv-ev-fixpoint-descent-data-circle :
+    ( dependent-universal-property-circle l2 l) ‚Üí
+    is-equiv ev-fixpoint-descent-data-circle
+  is-equiv-ev-fixpoint-descent-data-circle dup-circle =
+    is-equiv-right-factor-htpy
+      ( ev-free-loop-Œ† l (family-family-with-descent-data-circle A))
+      ( comparison-fixpoint-descent-data-circle)
+      ( ev-fixpoint-descent-data-circle)
+      ( triangle-comparison-fixpoint-descent-data-circle)
+      ( is-equiv-comparison-fixpoint-descent-data-circle)
+      ( dup-circle (family-family-with-descent-data-circle A))
+
+  equiv-ev-fixpoint-descent-data-circle :
+    ( dependent-universal-property-circle l2 l) ‚Üí
+    ( (x : S) ‚Üí (family-family-with-descent-data-circle A) x) ‚âÉ
+    ( fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A))
+  pr1 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
+    ev-fixpoint-descent-data-circle
+  pr2 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
+    is-equiv-ev-fixpoint-descent-data-circle dup-circle
+
+  compute-ev-fixpoint-descent-data-circle :
+    coherence-square-maps
+      ( ev-fixpoint-descent-data-circle)
+      ( ev-point (base-free-loop l))
+      ( pr1)
+      ( map-inv-equiv (equiv-family-with-descent-data-circle A))
+  compute-ev-fixpoint-descent-data-circle = refl-htpy
+```
diff --git a/src/synthetic-homotopy-theory/universal-cover-circle.lagda.md b/src/synthetic-homotopy-theory/universal-cover-circle.lagda.md
index 5802758f3c..719258c5f5 100644
--- a/src/synthetic-homotopy-theory/universal-cover-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/universal-cover-circle.lagda.md
@@ -8,13 +8,13 @@ module synthetic-homotopy-theory.universal-cover-circle where
 
 ```agda
 open import elementary-number-theory.integers
-open import elementary-number-theory.natural-numbers
+open import elementary-number-theory.universal-property-integers
 
 open import foundation.action-on-identifications-dependent-functions
 open import foundation.action-on-identifications-functions
 open import foundation.cartesian-product-types
+open import foundation.commuting-squares-of-maps
 open import foundation.contractible-types
-open import foundation.coproduct-types
 open import foundation.dependent-identifications
 open import foundation.dependent-pair-types
 open import foundation.equality-dependent-pair-types
@@ -26,10 +26,8 @@ open import foundation.functoriality-dependent-pair-types
 open import foundation.fundamental-theorem-of-identity-types
 open import foundation.homotopies
 open import foundation.identity-types
-open import foundation.propositions
 open import foundation.raising-universe-levels
 open import foundation.sets
-open import foundation.structure-identity-principle
 open import foundation.transport
 open import foundation.truncated-types
 open import foundation.truncation-levels
@@ -49,22 +47,16 @@ circle with respect to any universe level, then it satisfies the induction
 principle with respect to the zeroth universe level.
 
 ```agda
-naturality-tr-fiberwise-transformation :
-  { l1 l2 l3 : Level} {X : UU l1} {P : X ‚Üí UU l2} {Q : X ‚Üí UU l3}
-  ( f : (x : X) ‚Üí P x ‚Üí Q x) {x y : X} (Œ± : Id x y) (p : P x) ‚Üí
-  Id (tr Q Œ± (f x p)) (f y (tr P Œ± p))
-naturality-tr-fiberwise-transformation f refl p = refl
-
 functor-free-dependent-loop :
   { l1 l2 l3 : Level} {X : UU l1} (l : free-loop X)
   { P : X ‚Üí UU l2} {Q : X ‚Üí UU l3} (f : (x : X) ‚Üí P x ‚Üí Q x) ‚Üí
   free-dependent-loop l P ‚Üí free-dependent-loop l Q
 functor-free-dependent-loop l {P} {Q} f =
   map-Œ£
-    ( Œª q‚ÇÄ ‚Üí Id (tr Q (loop-free-loop l) q‚ÇÄ) q‚ÇÄ)
+    ( Œª q ‚Üí dependent-identification Q (loop-free-loop l) q q)
     ( f (base-free-loop l))
-    ( Œª p‚ÇÄ Œ± ‚Üí
-      ( naturality-tr-fiberwise-transformation f (loop-free-loop l) p‚ÇÄ) ‚àô
+    ( Œª p Œ± ‚Üí
+      inv (preserves-tr f (loop-free-loop l) p) ‚àô
       ( ap (f (base-free-loop l)) Œ±))
 
 coherence-square-functor-free-dependent-loop :
@@ -72,7 +64,7 @@ coherence-square-functor-free-dependent-loop :
   ( f : (x : X) ‚Üí P x ‚Üí Q x) {x y : X} (Œ± : Id x y)
   ( h : (x : X) ‚Üí P x) ‚Üí
   Id
-    ( ( naturality-tr-fiberwise-transformation f Œ± (h x)) ‚àô
+    ( inv ( preserves-tr f Œ± (h x)) ‚àô
       ( ap (f y) (apd h Œ±)))
     ( apd (map-Œ† f h) Œ±)
 coherence-square-functor-free-dependent-loop f refl h = refl
@@ -106,12 +98,12 @@ abstract
       ( Œª p‚ÇÄ ‚Üí
         is-equiv-comp
           ( concat
-            ( naturality-tr-fiberwise-transformation f l p‚ÇÄ)
+            ( inv (preserves-tr f l p‚ÇÄ))
             ( f x p‚ÇÄ))
           ( ap (f x))
           ( is-emb-is-equiv (is-equiv-f x) (tr P l p‚ÇÄ) p‚ÇÄ)
           ( is-equiv-concat
-            ( naturality-tr-fiberwise-transformation f l p‚ÇÄ)
+            ( inv (preserves-tr f l p‚ÇÄ))
             ( f x p‚ÇÄ)))
 
 abstract
@@ -143,45 +135,45 @@ abstract
 ### The fundamental cover
 
 ```agda
-abstract
-  Fundamental-cover-circle :
-    { l1 : Level} {X : UU l1} (l : free-loop X) ‚Üí
-    ( {l2 : Level} ‚Üí dependent-universal-property-circle l2 l) ‚Üí
-    Œ£ ( X ‚Üí UU lzero)
-      ( Œª P ‚Üí
-        Eq-descent-data-circle
-        ( pair ‚Ñ§ equiv-succ-‚Ñ§)
-        ( ev-descent-data-circle l P))
-  Fundamental-cover-circle {l1} l dup-circle =
-    center
-      ( unique-family-property-universal-property-circle l
-        ( universal-property-dependent-universal-property-circle l
-          ( dup-circle))
-        ( pair ‚Ñ§ equiv-succ-‚Ñ§))
-
-  fundamental-cover-circle :
-    { l1 : Level} {X : UU l1} (l : free-loop X) ‚Üí
-    ({k : Level} ‚Üí dependent-universal-property-circle k l) ‚Üí
-    X ‚Üí UU lzero
-  fundamental-cover-circle l dup-circle =
-    pr1 (Fundamental-cover-circle l dup-circle)
-
-  compute-fiber-fundamental-cover-circle :
-    { l1 : Level} {X : UU l1} (l : free-loop X) ‚Üí
-    ( dup-circle : {l2 : Level} ‚Üí dependent-universal-property-circle l2 l) ‚Üí
-    ‚Ñ§ ‚âÉ fundamental-cover-circle l dup-circle (base-free-loop l)
-  compute-fiber-fundamental-cover-circle l dup-circle =
-    pr1 ( pr2 ( Fundamental-cover-circle l dup-circle))
-
-  compute-tr-fundamental-cover-circle :
-    { l1 : Level} {X : UU l1} (l : free-loop X) ‚Üí
-    ( dup-circle : {l2 : Level} ‚Üí dependent-universal-property-circle l2 l) ‚Üí
-    ( ( map-equiv (compute-fiber-fundamental-cover-circle l dup-circle)) ‚àò
-      ( succ-‚Ñ§)) ~
-    ( ( tr (fundamental-cover-circle l dup-circle) (loop-free-loop l)) ‚àò
-      ( map-equiv (compute-fiber-fundamental-cover-circle l dup-circle)))
-  compute-tr-fundamental-cover-circle l dup-circle =
-    pr2 ( pr2 ( Fundamental-cover-circle l dup-circle))
+module _
+  { l1 : Level} {S : UU l1} (l : free-loop S)
+  where
+
+  descent-data-Fundamental-cover-circle :
+    descent-data-circle lzero
+  pr1 descent-data-Fundamental-cover-circle = ‚Ñ§
+  pr2 descent-data-Fundamental-cover-circle = equiv-succ-‚Ñ§
+
+  module _
+    ( dup-circle : {l2 : Level} ‚Üí dependent-universal-property-circle l2 l)
+    where
+
+    abstract
+
+      Fundamental-cover-circle : family-with-descent-data-circle l lzero
+      Fundamental-cover-circle =
+        family-with-descent-data-circle-descent-data l
+          ( universal-property-dependent-universal-property-circle l dup-circle)
+          ( descent-data-Fundamental-cover-circle)
+
+      fundamental-cover-circle : S ‚Üí UU lzero
+      fundamental-cover-circle =
+        family-family-with-descent-data-circle Fundamental-cover-circle
+
+      compute-fiber-fundamental-cover-circle :
+        ‚Ñ§ ‚âÉ fundamental-cover-circle (base-free-loop l)
+      compute-fiber-fundamental-cover-circle =
+        equiv-family-with-descent-data-circle Fundamental-cover-circle
+
+      compute-tr-fundamental-cover-circle :
+        coherence-square-maps
+          ( map-equiv compute-fiber-fundamental-cover-circle)
+          ( succ-‚Ñ§)
+          ( tr fundamental-cover-circle (loop-free-loop l))
+          ( map-equiv compute-fiber-fundamental-cover-circle)
+      compute-tr-fundamental-cover-circle =
+        coherence-square-family-with-descent-data-circle
+          Fundamental-cover-circle
 ```
 
 ### The fundamental cover of the circle is a family of sets
@@ -514,207 +506,6 @@ pr2 (is-contr-total-fundamental-cover-circle-data l dup-circle h p) =
   contraction-total-fundamental-cover-circle-data l dup-circle h p
 ```
 
-### Section 12.4 The dependent universal property of ‚Ñ§
-
-```agda
-abstract
-  elim-‚Ñ§ :
-    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
-    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-    ( k : ‚Ñ§) ‚Üí P k
-  elim-‚Ñ§ P p0 pS (inl zero-‚Ñï) =
-    map-inv-is-equiv (is-equiv-map-equiv (pS neg-one-‚Ñ§)) p0
-  elim-‚Ñ§ P p0 pS (inl (succ-‚Ñï x)) =
-    map-inv-is-equiv
-      ( is-equiv-map-equiv (pS (inl (succ-‚Ñï x))))
-      ( elim-‚Ñ§ P p0 pS (inl x))
-  elim-‚Ñ§ P p0 pS (inr (inl star)) = p0
-  elim-‚Ñ§ P p0 pS (inr (inr zero-‚Ñï)) = map-equiv (pS zero-‚Ñ§) p0
-  elim-‚Ñ§ P p0 pS (inr (inr (succ-‚Ñï x))) =
-    map-equiv
-      ( pS (inr (inr x)))
-      ( elim-‚Ñ§ P p0 pS (inr (inr x)))
-
-  compute-zero-elim-‚Ñ§ :
-    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
-    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-    Id (elim-‚Ñ§ P p0 pS zero-‚Ñ§) p0
-  compute-zero-elim-‚Ñ§ P p0 pS = refl
-
-  compute-succ-elim-‚Ñ§ :
-    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
-    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) (k : ‚Ñ§) ‚Üí
-    Id (elim-‚Ñ§ P p0 pS (succ-‚Ñ§ k)) (map-equiv (pS k) (elim-‚Ñ§ P p0 pS k))
-  compute-succ-elim-‚Ñ§ P p0 pS (inl zero-‚Ñï) =
-    inv
-      ( is-section-map-inv-is-equiv
-        ( is-equiv-map-equiv (pS (inl zero-‚Ñï)))
-        ( elim-‚Ñ§ P p0 pS (succ-‚Ñ§ (inl zero-‚Ñï))))
-  compute-succ-elim-‚Ñ§ P p0 pS (inl (succ-‚Ñï x)) =
-    inv
-      ( is-section-map-inv-is-equiv
-        ( is-equiv-map-equiv (pS (inl (succ-‚Ñï x))))
-        ( elim-‚Ñ§ P p0 pS (succ-‚Ñ§ (inl (succ-‚Ñï x)))))
-  compute-succ-elim-‚Ñ§ P p0 pS (inr (inl star)) = refl
-  compute-succ-elim-‚Ñ§ P p0 pS (inr (inr x)) = refl
-
-ELIM-‚Ñ§ :
-  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
-  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí UU l1
-ELIM-‚Ñ§ P p0 pS =
-  Œ£ ( (k : ‚Ñ§) ‚Üí P k)
-    ( Œª f ‚Üí
-      ( ( Id (f zero-‚Ñ§) p0) √ó
-        ( (k : ‚Ñ§) ‚Üí Id (f (succ-‚Ñ§ k)) ((map-equiv (pS k)) (f k)))))
-
-Elim-‚Ñ§ :
-  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
-  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí ELIM-‚Ñ§ P p0 pS
-pr1 (Elim-‚Ñ§ P p0 pS) = elim-‚Ñ§ P p0 pS
-pr1 (pr2 (Elim-‚Ñ§ P p0 pS)) = compute-zero-elim-‚Ñ§ P p0 pS
-pr2 (pr2 (Elim-‚Ñ§ P p0 pS)) = compute-succ-elim-‚Ñ§ P p0 pS
-
-equiv-comparison-map-Eq-ELIM-‚Ñ§ :
-  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
-  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-  ( s t : ELIM-‚Ñ§ P p0 pS) (k : ‚Ñ§) ‚Üí
-  Id ((pr1 s) k) ((pr1 t) k) ‚âÉ Id ((pr1 s) (succ-‚Ñ§ k)) ((pr1 t) (succ-‚Ñ§ k))
-equiv-comparison-map-Eq-ELIM-‚Ñ§ P p0 pS s t k =
-  ( ( equiv-concat (pr2 (pr2 s) k) (pr1 t (succ-‚Ñ§ k))) ‚àòe
-    ( equiv-concat' (map-equiv (pS k) (pr1 s k)) (inv (pr2 (pr2 t) k)))) ‚àòe
-  ( equiv-ap (pS k) (pr1 s k) (pr1 t k))
-
-zero-Eq-ELIM-‚Ñ§ :
-  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
-  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-  ( s t : ELIM-‚Ñ§ P p0 pS) (H : (pr1 s) ~ (pr1 t)) ‚Üí UU l1
-zero-Eq-ELIM-‚Ñ§ P p0 pS s t H =
-  Id (H zero-‚Ñ§) ((pr1 (pr2 s)) ‚àô (inv (pr1 (pr2 t))))
-
-succ-Eq-ELIM-‚Ñ§ :
-  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
-  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-  ( s t : ELIM-‚Ñ§ P p0 pS) (H : (pr1 s) ~ (pr1 t)) ‚Üí UU l1
-succ-Eq-ELIM-‚Ñ§ P p0 pS s t H =
-  ( k : ‚Ñ§) ‚Üí
-  Id
-    ( H (succ-‚Ñ§ k))
-    ( map-equiv (equiv-comparison-map-Eq-ELIM-‚Ñ§ P p0 pS s t k) (H k))
-
-Eq-ELIM-‚Ñ§ :
-  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
-  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-  ( s t : ELIM-‚Ñ§ P p0 pS) ‚Üí UU l1
-Eq-ELIM-‚Ñ§ P p0 pS s t =
-  ELIM-‚Ñ§
-    ( Œª k ‚Üí Id (pr1 s k) (pr1 t k))
-    ( (pr1 (pr2 s)) ‚àô (inv (pr1 (pr2 t))))
-    ( equiv-comparison-map-Eq-ELIM-‚Ñ§ P p0 pS s t)
-
-reflexive-Eq-ELIM-‚Ñ§ :
-  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1)
-  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-  ( s : ELIM-‚Ñ§ P p0 pS) ‚Üí Eq-ELIM-‚Ñ§ P p0 pS s s
-pr1 (reflexive-Eq-ELIM-‚Ñ§ P p0 pS (f , p , H)) = refl-htpy
-pr1 (pr2 (reflexive-Eq-ELIM-‚Ñ§ P p0 pS (f , p , H))) = inv (right-inv p)
-pr2 (pr2 (reflexive-Eq-ELIM-‚Ñ§ P p0 pS (f , p , H))) = inv ‚àò (right-inv ‚àò H)
-
-Eq-ELIM-‚Ñ§-eq :
-  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1) ‚Üí
-  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-  ( s t : ELIM-‚Ñ§ P p0 pS) ‚Üí Id s t ‚Üí Eq-ELIM-‚Ñ§ P p0 pS s t
-Eq-ELIM-‚Ñ§-eq P p0 pS s .s refl = reflexive-Eq-ELIM-‚Ñ§ P p0 pS s
-
-abstract
-  is-contr-total-Eq-ELIM-‚Ñ§ :
-    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1) ‚Üí
-    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-    ( s : ELIM-‚Ñ§ P p0 pS) ‚Üí is-contr (Œ£ (ELIM-‚Ñ§ P p0 pS) (Eq-ELIM-‚Ñ§ P p0 pS s))
-  is-contr-total-Eq-ELIM-‚Ñ§ P p0 pS s =
-    is-contr-total-Eq-structure
-      ( Œª f t H ‚Üí
-        ( zero-Eq-ELIM-‚Ñ§ P p0 pS s (pair f t) H) √ó
-        ( succ-Eq-ELIM-‚Ñ§ P p0 pS s (pair f t) H))
-      ( is-contr-total-htpy (pr1 s))
-      ( pair (pr1 s) refl-htpy)
-      ( is-contr-total-Eq-structure
-        ( Œª p K
-          ( q : zero-Eq-ELIM-‚Ñ§ P p0 pS s
-            ( pair (pr1 s) (pair p K))
-            ( refl-htpy)) ‚Üí
-          succ-Eq-ELIM-‚Ñ§ P p0 pS s
-            ( pair (pr1 s) (pair p K))
-            ( refl-htpy))
-        ( is-contr-is-equiv'
-          ( Œ£ (Id (pr1 s zero-‚Ñ§) p0) (Œª Œ± ‚Üí Id Œ± (pr1 (pr2 s))))
-          ( tot (Œª Œ± ‚Üí con-inv refl Œ± (pr1 (pr2 s))))
-          ( is-equiv-tot-is-fiberwise-equiv
-            ( Œª Œ± ‚Üí is-equiv-con-inv refl Œ± (pr1 (pr2 s))))
-          ( is-contr-total-path' (pr1 (pr2 s))))
-        ( pair (pr1 (pr2 s)) (inv (right-inv (pr1 (pr2 s)))))
-        ( is-contr-is-equiv'
-          ( Œ£ ( ( k : ‚Ñ§) ‚Üí Id (pr1 s (succ-‚Ñ§ k)) (pr1 (pS k) (pr1 s k)))
-              ( Œª Œ≤ ‚Üí Œ≤ ~ (pr2 (pr2 s))))
-          ( tot (Œª Œ≤ ‚Üí con-inv-htpy refl-htpy Œ≤ (pr2 (pr2 s))))
-          ( is-equiv-tot-is-fiberwise-equiv
-            ( Œª Œ≤ ‚Üí is-equiv-con-inv-htpy refl-htpy Œ≤ (pr2 (pr2 s))))
-          ( is-contr-total-htpy' (pr2 (pr2 s)))))
-
-abstract
-  is-equiv-Eq-ELIM-‚Ñ§-eq :
-    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1) ‚Üí
-    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-    ( s t : ELIM-‚Ñ§ P p0 pS) ‚Üí is-equiv (Eq-ELIM-‚Ñ§-eq P p0 pS s t)
-  is-equiv-Eq-ELIM-‚Ñ§-eq P p0 pS s =
-    fundamental-theorem-id
-      ( is-contr-total-Eq-ELIM-‚Ñ§ P p0 pS s)
-      ( Eq-ELIM-‚Ñ§-eq P p0 pS s)
-
-eq-Eq-ELIM-‚Ñ§ :
-  { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1) ‚Üí
-  ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-  ( s t : ELIM-‚Ñ§ P p0 pS) ‚Üí Eq-ELIM-‚Ñ§ P p0 pS s t ‚Üí Id s t
-eq-Eq-ELIM-‚Ñ§ P p0 pS s t = map-inv-is-equiv (is-equiv-Eq-ELIM-‚Ñ§-eq P p0 pS s t)
-
-abstract
-  is-prop-ELIM-‚Ñ§ :
-    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1) ‚Üí
-    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-    is-prop (ELIM-‚Ñ§ P p0 pS)
-  is-prop-ELIM-‚Ñ§ P p0 pS =
-    is-prop-all-elements-equal
-      ( Œª s t ‚Üí eq-Eq-ELIM-‚Ñ§ P p0 pS s t
-        ( Elim-‚Ñ§
-          ( Œª k ‚Üí Id (pr1 s k) (pr1 t k))
-          ( (pr1 (pr2 s)) ‚àô (inv (pr1 (pr2 t))))
-          ( equiv-comparison-map-Eq-ELIM-‚Ñ§ P p0 pS s t)))
-```
-
-We finally arrive at the dependent universal property of ‚Ñ§
-
-```agda
-abstract
-  is-contr-ELIM-‚Ñ§ :
-    { l1 : Level} (P : ‚Ñ§ ‚Üí UU l1) ‚Üí
-    ( p0 : P zero-‚Ñ§) (pS : (k : ‚Ñ§) ‚Üí (P k) ‚âÉ (P (succ-‚Ñ§ k))) ‚Üí
-    is-contr (ELIM-‚Ñ§ P p0 pS)
-  is-contr-ELIM-‚Ñ§ P p0 pS =
-    is-proof-irrelevant-is-prop (is-prop-ELIM-‚Ñ§ P p0 pS) (Elim-‚Ñ§ P p0 pS)
-```
-
-The universal property of ‚Ñ§ is now just a special case
-
-```agda
-ELIM-‚Ñ§' :
-  { l1 : Level} {X : UU l1} (x : X) (e : X ‚âÉ X) ‚Üí UU l1
-ELIM-‚Ñ§' {X = X} x e = ELIM-‚Ñ§ (Œª k ‚Üí X) x (Œª k ‚Üí e)
-
-abstract
-  universal-property-‚Ñ§ :
-    { l1 : Level} {X : UU l1} (x : X) (e : X ‚âÉ X) ‚Üí is-contr (ELIM-‚Ñ§' x e)
-  universal-property-‚Ñ§ {X = X} x e = is-contr-ELIM-‚Ñ§ (Œª k ‚Üí X) x (Œª k ‚Üí e)
-```
-
 ### Section 12.5 The identity type of the circle
 
 ```agda
diff --git a/src/synthetic-homotopy-theory/universal-property-circle.lagda.md b/src/synthetic-homotopy-theory/universal-property-circle.lagda.md
index 002fc6ebb1..eaeaf94f8f 100644
--- a/src/synthetic-homotopy-theory/universal-property-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/universal-property-circle.lagda.md
@@ -263,5 +263,5 @@ abstract
   is-connected-circle' l dup-circle P is-prop-P p =
     map-inv-is-equiv
       ( dup-circle P)
-      ( pair p (center (is-prop-P _ (tr P (pr2 l) p) p)))
+      ( pair p (center (is-prop-P _ (tr P (loop-free-loop l) p) p)))
 ```
