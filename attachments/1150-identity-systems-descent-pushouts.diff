diff --git a/references.bib b/references.bib
index c2d2c7db82..aced02fe79 100644
--- a/references.bib
+++ b/references.bib
@@ -263,6 +263,22 @@ @article{KECA17
   eprintclass = {cs}
 }
 
+@inproceedings{KvR19,
+  title       =  {{Path Spaces of Higher Inductive Types in Homotopy Type Theory}},
+  booktitle   =  {Proceedings of the 34th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
+  author      =  {Kraus, Nicolai and von Raumer, Jakob},
+  year        =  {2019},
+  publisher   =  {IEEE Press},
+  abstract    =  {The study of equality types is central to homotopy type theory. Characterizing these types is often tricky, and various strategies, such as the encode-decode method, have been developed. We prove a theorem about equality types of coequalizers and pushouts, reminiscent of an induction principle and without any restrictions on the truncation levels. This result makes it possible to reason directly about certain equality types and to streamline existing proofs by eliminating the necessity of auxiliary constructions. To demonstrate this, we give a very short argument for the calculation of the fundamental group of the circle (Licata and Shulman [1]), and for the fact that pushouts preserve embeddings. Further, our development suggests a higher version of the Seifert-van Kampen theorem, and the set-truncation operator maps it to the standard Seifert-van Kampen theorem (due to Favonia and Shulman [2]). We provide a formalization of the main technical results in the proof assistant Lean.},
+  articleno   =  {7},
+  numpages    =  {13},
+  location    =  {Vancouver, Canada},
+  series      =  {LICS '19},
+  eprint      =  {1901.06022},
+  eprinttype  =  {arxiv},
+  eprintclass =  {cs, math},
+}
+
 @book{May12,
   title      = {More {{Concise Algebraic Topology}}: {{Localization}}, {{Completion}}, and {{Model Categories}}},
   shorttitle = {More {{Concise Algebraic Topology}}},
diff --git a/src/foundation/universal-property-identity-types.lagda.md b/src/foundation/universal-property-identity-types.lagda.md
index 4cb8ffc3df..678401d075 100644
--- a/src/foundation/universal-property-identity-types.lagda.md
+++ b/src/foundation/universal-property-identity-types.lagda.md
@@ -21,15 +21,17 @@ open import foundation.preunivalence
 open import foundation.univalence
 open import foundation.universe-levels
 
+open import foundation-core.contractible-maps
 open import foundation-core.contractible-types
+open import foundation-core.families-of-equivalences
 open import foundation-core.fibers-of-maps
 open import foundation-core.function-types
 open import foundation-core.functoriality-dependent-pair-types
+open import foundation-core.homotopies
 open import foundation-core.injective-maps
 open import foundation-core.propositional-maps
 open import foundation-core.propositions
 open import foundation-core.torsorial-type-families
-open import foundation-core.type-theoretic-principle-of-choice
 ```
 
 </details>
@@ -86,6 +88,29 @@ is-equiv-ev-refl' :
 is-equiv-ev-refl' a = is-equiv-map-equiv (equiv-ev-refl' a)
 ```
 
+### The type of fiberwise maps from `Id a` to a torsorial type family `B` is equivalent to the type of fiberwise equivalences
+
+Note that the type of fiberwise equivalences is a
+[subtype](foundation-core.subtypes.md) of the type of fiberwise maps. By the
+[fundamental theorem of identity types](foundation.fundamental-theorem-of-identity-types.md),
+it is a [full subtype](foundation.full-subtypes.md), hence it is equivalent to
+the whole type of fiberwise maps.
+
+```agda
+module _
+  {l1 l2 : Level} {A : UU l1} (a : A) {B : A ‚Üí UU l2}
+  (is-torsorial-B : is-torsorial B)
+  where
+
+  equiv-fam-map-fam-equiv-is-torsorial :
+    ((x : A) ‚Üí (a Ôºù x) ‚âÉ B x) ‚âÉ ((x : A) ‚Üí (a Ôºù x) ‚Üí B x)
+  equiv-fam-map-fam-equiv-is-torsorial =
+    ( equiv-inclusion-is-full-subtype
+      ( Œª h ‚Üí Œ†-Prop A (Œª a ‚Üí is-equiv-Prop (h a)))
+      ( fundamental-theorem-id is-torsorial-B)) ‚àòe
+    ( equiv-fiberwise-equiv-fam-equiv _ _)
+```
+
 ### `Id : A ‚Üí (A ‚Üí ùí∞)` is an embedding
 
 We first show that [the preunivalence axiom](foundation.preunivalence.md)
@@ -138,10 +163,7 @@ module _
           ( equiv-tot
             ( Œª x ‚Üí
               ( equiv-ev-refl x) ‚àòe
-              ( equiv-inclusion-is-full-subtype
-                ( Œ†-Prop A ‚àò (is-equiv-Prop ‚àò_))
-                ( fundamental-theorem-id (is-torsorial-Id a))) ‚àòe
-              ( distributive-Œ†-Œ£))))
+              ( equiv-fam-map-fam-equiv-is-torsorial x (is-torsorial-Id a)))))
         ( emb-tot
           ( Œª x ‚Üí
             comp-emb
@@ -211,6 +233,44 @@ module _
       ( is-proof-irrelevant-total-family-of-equivalences-Id)
 ```
 
+### The type of point-preserving fiberwise equivalences between `Id x` and a pointed torsorial type family is contractible
+
+**Proof:** Since `ev-refl` is an equivalence, it follows that its fibers are
+contractible. Explicitly, given a point `b : B a`, the type of maps
+`h : (x : A) ‚Üí (a = x) ‚Üí B x` such that `h a refl = b` is contractible. But the
+type of fiberwise maps is equivalent to the type of fiberwise equivalences.
+
+```agda
+module _
+  {l1 l2 : Level} {A : UU l1} {a : A} {B : A ‚Üí UU l2} (b : B a)
+  (is-torsorial-B : is-torsorial B)
+  where
+
+  abstract
+    is-torsorial-pointed-fam-equiv-is-torsorial :
+      is-torsorial
+        ( Œª (e : (x : A) ‚Üí (a Ôºù x) ‚âÉ B x) ‚Üí
+          map-equiv (e a) refl Ôºù b)
+    is-torsorial-pointed-fam-equiv-is-torsorial =
+      is-contr-equiv'
+        ( fiber (ev-refl a {B = Œª x _ ‚Üí B x}) b)
+        ( equiv-Œ£ _
+          ( inv-equiv
+            ( equiv-fam-map-fam-equiv-is-torsorial a is-torsorial-B))
+          ( Œª h ‚Üí
+            equiv-inv-concat
+              ( inv
+                ( ap
+                  ( ev-refl a)
+                  ( is-section-map-inv-equiv
+                    ( equiv-fam-map-fam-equiv-is-torsorial a is-torsorial-B)
+                    ( h))))
+              ( b)))
+        ( is-contr-map-is-equiv
+          ( is-equiv-ev-refl a)
+          ( b))
+```
+
 ## See also
 
 - In
diff --git a/src/synthetic-homotopy-theory.lagda.md b/src/synthetic-homotopy-theory.lagda.md
index 4717610eb4..6a4d8548fa 100644
--- a/src/synthetic-homotopy-theory.lagda.md
+++ b/src/synthetic-homotopy-theory.lagda.md
@@ -12,7 +12,6 @@ module synthetic-homotopy-theory where
 open import synthetic-homotopy-theory.0-acyclic-maps public
 open import synthetic-homotopy-theory.0-acyclic-types public
 open import synthetic-homotopy-theory.1-acyclic-types public
-open import synthetic-homotopy-theory.26-id-pushout public
 open import synthetic-homotopy-theory.acyclic-maps public
 open import synthetic-homotopy-theory.acyclic-types public
 open import synthetic-homotopy-theory.category-of-connected-set-bundles-circle public
@@ -73,6 +72,7 @@ open import synthetic-homotopy-theory.functoriality-sequential-colimits public
 open import synthetic-homotopy-theory.functoriality-suspensions public
 open import synthetic-homotopy-theory.groups-of-loops-in-1-types public
 open import synthetic-homotopy-theory.hatchers-acyclic-type public
+open import synthetic-homotopy-theory.identity-systems-descent-data-pushouts public
 open import synthetic-homotopy-theory.induction-principle-pushouts public
 open import synthetic-homotopy-theory.infinite-complex-projective-space public
 open import synthetic-homotopy-theory.infinite-cyclic-types public
diff --git a/src/synthetic-homotopy-theory/26-id-pushout.lagda.md b/src/synthetic-homotopy-theory/26-id-pushout.lagda.md
deleted file mode 100644
index 121f52e29a..0000000000
--- a/src/synthetic-homotopy-theory/26-id-pushout.lagda.md
+++ /dev/null
@@ -1,490 +0,0 @@
-# Formalization of the Symmetry book - 26 id pushout
-
-```agda
-module synthetic-homotopy-theory.26-id-pushout where
-```
-
-<details><summary>Imports</summary>
-
-```agda
-open import foundation.action-on-identifications-dependent-functions
-open import foundation.cartesian-product-types
-open import foundation.commuting-squares-of-maps
-open import foundation.dependent-pair-types
-open import foundation.dependent-universal-property-equivalences
-open import foundation.equality-dependent-function-types
-open import foundation.equivalences
-open import foundation.function-extensionality
-open import foundation.function-types
-open import foundation.functoriality-dependent-function-types
-open import foundation.functoriality-dependent-pair-types
-open import foundation.fundamental-theorem-of-identity-types
-open import foundation.homotopies
-open import foundation.homotopy-induction
-open import foundation.identity-types
-open import foundation.precomposition-dependent-functions
-open import foundation.span-diagrams
-open import foundation.structure-identity-principle
-open import foundation.torsorial-type-families
-open import foundation.transport-along-identifications
-open import foundation.universal-property-identity-types
-open import foundation.universe-levels
-open import foundation.whiskering-homotopies-composition
-
-open import synthetic-homotopy-theory.cocones-under-spans
-open import synthetic-homotopy-theory.dependent-cocones-under-spans
-open import synthetic-homotopy-theory.dependent-universal-property-pushouts
-open import synthetic-homotopy-theory.descent-data-pushouts
-open import synthetic-homotopy-theory.descent-property-pushouts
-open import synthetic-homotopy-theory.equivalences-descent-data-pushouts
-open import synthetic-homotopy-theory.universal-property-pushouts
-```
-
-</details>
-
-## Section 19.1 Characterizing families of maps over pushouts
-
-```agda
-module hom-Fam-pushout
-  { l1 l2 l3 l4 l5 : Level}
-  { S : UU l1}
-  { A : UU l2}
-  { B : UU l3}
-  { f : S ‚Üí A}
-  { g : S ‚Üí B}
-  ( P : descent-data-pushout (make-span-diagram f g) l4)
-  ( Q : descent-data-pushout (make-span-diagram f g) l5)
-  where
-
-  private
-    PA = pr1 P
-    PB = pr1 (pr2 P)
-    PS = pr2 (pr2 P)
-    QA = pr1 Q
-    QB = pr1 (pr2 Q)
-    QS = pr2 (pr2 Q)
-```
-
-### Definition 19.1.1
-
-```agda
-  hom-Fam-pushout :
-    UU (l1 ‚äî l2 ‚äî l3 ‚äî l4 ‚äî l5)
-  hom-Fam-pushout =
-    Œ£ ( (x : A) ‚Üí (PA x) ‚Üí (QA x)) (Œª hA ‚Üí
-      Œ£ ( (y : B) ‚Üí (PB y) ‚Üí (QB y)) (Œª hB ‚Üí
-        ( s : S) ‚Üí
-          ( (hB (g s)) ‚àò (map-equiv (PS s))) ~
-          ( (map-equiv (QS s)) ‚àò (hA (f s)))))
-```
-
-### Remark 19.1.2 We characterize the identity type of `hom-Fam-pushout`
-
-```agda
-  htpy-hom-Fam-pushout :
-    ( h k : hom-Fam-pushout) ‚Üí UU (l1 ‚äî l2 ‚äî l3 ‚äî l4 ‚äî l5)
-  htpy-hom-Fam-pushout h k =
-    Œ£ ( (x : A) ‚Üí (pr1 h x) ~ (pr1 k x)) (Œª HA ‚Üí
-      Œ£ ( (y : B) ‚Üí (pr1 (pr2 h) y) ~ (pr1 (pr2 k) y)) (Œª HB ‚Üí
-        ( s : S) ‚Üí
-        ( ((HB (g s)) ¬∑r (map-equiv (PS s))) ‚àôh (pr2 (pr2 k) s)) ~
-        ( (pr2 (pr2 h) s) ‚àôh ((map-equiv (QS s)) ¬∑l (HA (f s))))))
-
-  reflexive-htpy-hom-Fam-pushout :
-    ( h : hom-Fam-pushout) ‚Üí htpy-hom-Fam-pushout h h
-  reflexive-htpy-hom-Fam-pushout h =
-    pair
-      ( Œª x ‚Üí refl-htpy)
-      ( pair
-        ( Œª y ‚Üí refl-htpy)
-        ( Œª s ‚Üí inv-htpy-right-unit-htpy))
-
-  htpy-hom-Fam-pushout-eq :
-    ( h k : hom-Fam-pushout) ‚Üí Id h k ‚Üí htpy-hom-Fam-pushout h k
-  htpy-hom-Fam-pushout-eq h .h refl =
-    reflexive-htpy-hom-Fam-pushout h
-
-  is-torsorial-htpy-hom-Fam-pushout :
-    ( h : hom-Fam-pushout) ‚Üí is-torsorial (htpy-hom-Fam-pushout h)
-  is-torsorial-htpy-hom-Fam-pushout h =
-    is-torsorial-Eq-structure
-      ( is-torsorial-Eq-Œ†
-        ( Œª x ‚Üí is-torsorial-htpy (pr1 h x)))
-      ( pair (pr1 h) (Œª x ‚Üí refl-htpy))
-      ( is-torsorial-Eq-structure
-        ( is-torsorial-Eq-Œ†
-          ( Œª y ‚Üí is-torsorial-htpy (pr1 (pr2 h) y)))
-        ( pair (pr1 (pr2 h)) (Œª y ‚Üí refl-htpy))
-        ( is-torsorial-Eq-Œ†
-          ( Œª s ‚Üí is-torsorial-htpy'
-            ((pr2 (pr2 h) s) ‚àôh ((map-equiv (QS s)) ¬∑l refl-htpy)))))
-
-  is-equiv-htpy-hom-Fam-pushout-eq :
-    ( h k : hom-Fam-pushout) ‚Üí is-equiv (htpy-hom-Fam-pushout-eq h k)
-  is-equiv-htpy-hom-Fam-pushout-eq h =
-    fundamental-theorem-id
-      ( is-torsorial-htpy-hom-Fam-pushout h)
-      ( htpy-hom-Fam-pushout-eq h)
-
-  eq-htpy-hom-Fam-pushout :
-    ( h k : hom-Fam-pushout) ‚Üí htpy-hom-Fam-pushout h k ‚Üí Id h k
-  eq-htpy-hom-Fam-pushout h k =
-    map-inv-is-equiv (is-equiv-htpy-hom-Fam-pushout-eq h k)
-
-open hom-Fam-pushout public
-```
-
-### Definition 19.1.3
-
-Given a cocone structure on `X` and a family of maps indexed by `X`, we obtain a
-morphism of descent data.
-
-```agda
-Naturality-fam-maps :
-  { l1 l2 l3 : Level} {A : UU l1} {B : A ‚Üí UU l2} {C : A ‚Üí UU l3}
-  ( f : (a : A) ‚Üí B a ‚Üí C a) {x x' : A} (p : Id x x') ‚Üí UU (l2 ‚äî l3)
-Naturality-fam-maps {B = B} {C} f {x} {x'} p =
-  (y : B x) ‚Üí Id (f x' (tr B p y)) (tr C p (f x y))
-
-naturality-fam-maps :
-  { l1 l2 l3 : Level} {A : UU l1} {B : A ‚Üí UU l2} {C : A ‚Üí UU l3}
-  ( f : (a : A) ‚Üí B a ‚Üí C a) {x x' : A} (p : Id x x') ‚Üí
-  Naturality-fam-maps f p
-naturality-fam-maps f refl y = refl
-
-hom-Fam-pushout-map :
-  { l1 l2 l3 l4 l5 l6 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  { f : S ‚Üí A} {g : S ‚Üí B} (c : cocone f g X) ‚Üí
-  ( P : X ‚Üí UU l5) (Q : X ‚Üí UU l6) ‚Üí ((x : X) ‚Üí P x ‚Üí Q x) ‚Üí
-  hom-Fam-pushout
-    ( descent-data-family-cocone-span-diagram c P)
-    ( descent-data-family-cocone-span-diagram c Q)
-hom-Fam-pushout-map {f = f} {g} c P Q h =
-  pair
-    ( precomp-Œ† (pr1 c) (Œª x ‚Üí P x ‚Üí Q x) h)
-    ( pair
-      ( precomp-Œ† (pr1 (pr2 c)) (Œª x ‚Üí P x ‚Üí Q x) h)
-      ( Œª s ‚Üí naturality-fam-maps h (pr2 (pr2 c) s)))
-```
-
-### Theorem 19.1.4 The function `hom-Fam-pushout-map` is an equivalence
-
-```agda
-square-path-over-fam-maps :
-  { l1 l2 l3 : Level} {A : UU l1} {B : A ‚Üí UU l2} {C : A ‚Üí UU l3}
-  { x x' : A} (p : Id x x') (f : B x ‚Üí C x) (f' : B x' ‚Üí C x') ‚Üí
-  Id (tr (Œª a ‚Üí B a ‚Üí C a) p f) f' ‚Üí
-  ( y : B x) ‚Üí Id (f' (tr B p y)) (tr C p (f y))
-square-path-over-fam-maps refl f f' = htpy-eq ‚àò inv
-
-hom-Fam-pushout-dependent-cocone :
-  { l1 l2 l3 l4 l5 l6 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  { f : S ‚Üí A} {g : S ‚Üí B} (c : cocone f g X) ‚Üí
-  ( P : X ‚Üí UU l5) (Q : X ‚Üí UU l6) ‚Üí
-  dependent-cocone f g c (Œª x ‚Üí P x ‚Üí Q x) ‚Üí
-  hom-Fam-pushout
-    ( descent-data-family-cocone-span-diagram c P)
-    ( descent-data-family-cocone-span-diagram c Q)
-hom-Fam-pushout-dependent-cocone {f = f} {g} c P Q =
-  tot (Œª hA ‚Üí tot (Œª hB ‚Üí
-    map-Œ† (Œª s ‚Üí
-      square-path-over-fam-maps (pr2 (pr2 c) s) (hA (f s)) (hB (g s)))))
-
-is-equiv-square-path-over-fam-maps :
-  { l1 l2 l3 : Level} {A : UU l1} {B : A ‚Üí UU l2} {C : A ‚Üí UU l3}
-  { x x' : A} (p : Id x x') (f : B x ‚Üí C x) (f' : B x' ‚Üí C x') ‚Üí
-  is-equiv (square-path-over-fam-maps p f f')
-is-equiv-square-path-over-fam-maps refl f f' =
-  is-equiv-comp htpy-eq inv (is-equiv-inv f f') (funext f' f)
-
-is-equiv-hom-Fam-pushout-dependent-cocone :
-  { l1 l2 l3 l4 l5 l6 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  { f : S ‚Üí A} {g : S ‚Üí B} (c : cocone f g X) ‚Üí
-  ( P : X ‚Üí UU l5) (Q : X ‚Üí UU l6) ‚Üí
-  is-equiv (hom-Fam-pushout-dependent-cocone c P Q)
-is-equiv-hom-Fam-pushout-dependent-cocone {f = f} {g} c P Q =
-  is-equiv-tot-is-fiberwise-equiv (Œª hA ‚Üí
-    is-equiv-tot-is-fiberwise-equiv (Œª hB ‚Üí
-      is-equiv-map-Œ†-is-fiberwise-equiv
-        ( Œª s ‚Üí is-equiv-square-path-over-fam-maps
-          ( pr2 (pr2 c) s)
-          ( hA (f s))
-          ( hB (g s)))))
-
-coherence-naturality-fam-maps :
-  { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2}
-  (P : B ‚Üí UU l3) (Q : B ‚Üí UU l4) ‚Üí
-  { f f' : A ‚Üí B} (H : f ~ f') (h : (b : B) ‚Üí P b ‚Üí Q b) (a : A) ‚Üí
-  Id
-    ( square-path-over-fam-maps (H a) (h (f a)) (h (f' a)) (apd h (H a)))
-    ( naturality-fam-maps h (H a))
-coherence-naturality-fam-maps {A = A} {B} P Q {f} {f'} H =
-  ind-htpy f
-    ( Œª f' H ‚Üí
-      ( h : (b : B) ‚Üí P b ‚Üí Q b) (a : A) ‚Üí
-      Id
-        ( square-path-over-fam-maps (H a) (h (f a)) (h (f' a)) (apd h (H a)))
-        ( naturality-fam-maps h (H a)))
-    ( Œª h a ‚Üí refl)
-    ( H)
-
-triangle-hom-Fam-pushout-dependent-cocone :
-  { l1 l2 l3 l4 l5 l6 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  { f : S ‚Üí A} {g : S ‚Üí B} (c : cocone f g X) ‚Üí
-  ( P : X ‚Üí UU l5) (Q : X ‚Üí UU l6) ‚Üí
-  ( hom-Fam-pushout-map c P Q) ~
-  ( ( hom-Fam-pushout-dependent-cocone c P Q) ‚àò
-    ( dependent-cocone-map f g c (Œª x ‚Üí P x ‚Üí Q x)))
-triangle-hom-Fam-pushout-dependent-cocone {f = f} {g} c P Q h =
-  eq-htpy-hom-Fam-pushout
-    ( descent-data-family-cocone-span-diagram c P)
-    ( descent-data-family-cocone-span-diagram c Q)
-    ( hom-Fam-pushout-map c P Q h)
-    ( hom-Fam-pushout-dependent-cocone c P Q
-      ( dependent-cocone-map f g c (Œª x ‚Üí P x ‚Üí Q x) h))
-    ( pair
-      ( Œª a ‚Üí refl-htpy)
-      ( pair
-        ( Œª b ‚Üí refl-htpy)
-        ( Œª s ‚Üí
-          ( htpy-eq
-            ( coherence-naturality-fam-maps P Q (pr2 (pr2 c)) h s)) ‚àôh
-          ( inv-htpy-right-unit-htpy))))
-
-is-equiv-hom-Fam-pushout-map :
-  { l1 l2 l3 l4 l5 l6 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  { f : S ‚Üí A} {g : S ‚Üí B} (c : cocone f g X) ‚Üí
-  ( up-X : universal-property-pushout f g c)
-  ( P : X ‚Üí UU l5) (Q : X ‚Üí UU l6) ‚Üí
-  is-equiv (hom-Fam-pushout-map c P Q)
-is-equiv-hom-Fam-pushout-map {l5 = l5} {l6} {f = f} {g} c up-X P Q =
-  is-equiv-left-map-triangle
-    ( hom-Fam-pushout-map c P Q)
-    ( hom-Fam-pushout-dependent-cocone c P Q)
-    ( dependent-cocone-map f g c (Œª x ‚Üí P x ‚Üí Q x))
-    ( triangle-hom-Fam-pushout-dependent-cocone c P Q)
-    ( dependent-universal-property-universal-property-pushout
-      f g c up-X (Œª x ‚Üí P x ‚Üí Q x))
-    ( is-equiv-hom-Fam-pushout-dependent-cocone c P Q)
-
-equiv-hom-Fam-pushout-map :
-  { l1 l2 l3 l4 l5 l6 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  { f : S ‚Üí A} {g : S ‚Üí B} (c : cocone f g X) ‚Üí
-  ( up-X : universal-property-pushout f g c)
-  ( P : X ‚Üí UU l5) (Q : X ‚Üí UU l6) ‚Üí
-  ( (x : X) ‚Üí P x ‚Üí Q x) ‚âÉ
-  hom-Fam-pushout
-    ( descent-data-family-cocone-span-diagram c P)
-    ( descent-data-family-cocone-span-diagram c Q)
-equiv-hom-Fam-pushout-map c up-X P Q =
-  pair
-    ( hom-Fam-pushout-map c P Q)
-    ( is-equiv-hom-Fam-pushout-map c up-X P Q)
-```
-
-### Definition 19.2.1 Universal families over spans
-
-```agda
-ev-point-hom-Fam-pushout :
-  { l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
-  { f : S ‚Üí A} {g : S ‚Üí B}
-  ( P : descent-data-pushout (make-span-diagram f g) l4)
-  ( Q : descent-data-pushout (make-span-diagram f g) l5)
-  {a : A} ‚Üí (pr1 P a) ‚Üí (hom-Fam-pushout P Q) ‚Üí pr1 Q a
-ev-point-hom-Fam-pushout P Q {a} p h = pr1 h a p
-
-is-universal-Fam-pushout :
-  { l1 l2 l3 l4 : Level} (l : Level) {S : UU l1} {A : UU l2} {B : UU l3}
-  { f : S ‚Üí A} {g : S ‚Üí B}
-  ( P : descent-data-pushout (make-span-diagram f g) l4) (a : A) (p : pr1 P a) ‚Üí
-  UU (l1 ‚äî l2 ‚äî l3 ‚äî l4 ‚äî lsuc l)
-is-universal-Fam-pushout l {f = f} {g} P a p =
-  ( Q : descent-data-pushout (make-span-diagram f g) l) ‚Üí
-  is-equiv (ev-point-hom-Fam-pushout P Q p)
-```
-
-### Lemma 19.2.2 The descent data of the identity type is a universal family
-
-```agda
-triangle-is-universal-id-Fam-pushout' :
-  { l l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  { f : S ‚Üí A} {g : S ‚Üí B} (c : cocone f g X)
-  (a : A) ( Q : (x : X) ‚Üí UU l) ‚Üí
-  ( ev-refl (pr1 c a) {B = Œª x p ‚Üí Q x}) ~
-  ( ( ev-point-hom-Fam-pushout
-      ( descent-data-family-cocone-span-diagram c (Id (pr1 c a)))
-      ( descent-data-family-cocone-span-diagram c Q)
-      ( refl)) ‚àò
-    ( hom-Fam-pushout-map c (Id (pr1 c a)) Q))
-triangle-is-universal-id-Fam-pushout' c a Q = refl-htpy
-
-is-universal-id-Fam-pushout' :
-  { l l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  { f : S ‚Üí A} {g : S ‚Üí B} (c : cocone f g X)
-  ( up-X : universal-property-pushout f g c) (a : A) ‚Üí
-  ( Q : (x : X) ‚Üí UU l) ‚Üí
-  is-equiv
-    ( ev-point-hom-Fam-pushout
-      ( descent-data-family-cocone-span-diagram c (Id (pr1 c a)))
-      ( descent-data-family-cocone-span-diagram c Q)
-      ( refl))
-is-universal-id-Fam-pushout' c up-X a Q =
-  is-equiv-right-map-triangle
-    ( ev-refl (pr1 c a) {B = Œª x p ‚Üí Q x})
-    ( ev-point-hom-Fam-pushout
-      ( descent-data-family-cocone-span-diagram c (Id (pr1 c a)))
-      ( descent-data-family-cocone-span-diagram c Q)
-      ( refl))
-    ( hom-Fam-pushout-map c (Id (pr1 c a)) Q)
-    ( triangle-is-universal-id-Fam-pushout' c a Q)
-    ( is-equiv-ev-refl (pr1 c a))
-    ( is-equiv-hom-Fam-pushout-map c up-X (Id (pr1 c a)) Q)
-
-is-universal-id-Fam-pushout :
-  { l1 l2 l3 l4 l : Level}
-  { S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  { f : S ‚Üí A} {g : S ‚Üí B} (c : cocone f g X)
-  ( up-X : universal-property-pushout f g c) (a : A) ‚Üí
-  is-universal-Fam-pushout l
-    ( descent-data-family-cocone-span-diagram c (Id (pr1 c a)))
-    ( a)
-    ( refl)
-is-universal-id-Fam-pushout {S = S} {A} {B} {X} {f} {g} c up-X a Q =
-  map-inv-is-equiv
-    ( is-equiv-precomp-Œ†-is-equiv
-      ( is-equiv-descent-data-family-cocone-span-diagram up-X)
-      ( Œª (Q : descent-data-pushout (make-span-diagram f g) _) ‚Üí
-        is-equiv
-          ( ev-point-hom-Fam-pushout
-            ( descent-data-family-cocone-span-diagram c (Id (pr1 c a)))
-            ( Q)
-            ( refl))))
-    ( is-universal-id-Fam-pushout' c up-X a)
-    ( Q)
-```
-
-We construct the identity morphism and composition, and we show that morphisms
-equipped with two-sided inverses are equivalences.
-
-```agda
-id-hom-Fam-pushout :
-  { l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
-  { f : S ‚Üí A} {g : S ‚Üí B} ‚Üí
-  ( P : descent-data-pushout (make-span-diagram f g) l4) ‚Üí hom-Fam-pushout P P
-id-hom-Fam-pushout P =
-  pair
-    ( Œª a ‚Üí id)
-    ( pair
-      ( Œª b ‚Üí id)
-      ( Œª s ‚Üí refl-htpy))
-
-comp-hom-Fam-pushout :
-  { l1 l2 l3 l4 l5 l6 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
-  { f : S ‚Üí A} {g : S ‚Üí B} ‚Üí
-  ( P : descent-data-pushout (make-span-diagram f g) l4)
-  ( Q : descent-data-pushout (make-span-diagram f g) l5)
-  ( R : descent-data-pushout (make-span-diagram f g) l6) ‚Üí
-  hom-Fam-pushout Q R ‚Üí hom-Fam-pushout P Q ‚Üí hom-Fam-pushout P R
-comp-hom-Fam-pushout {f = f} {g} P Q R k h =
-  pair
-    ( Œª a ‚Üí (pr1 k a) ‚àò (pr1 h a))
-    ( pair
-      ( Œª b ‚Üí (pr1 (pr2 k) b) ‚àò (pr1 (pr2 h) b))
-      ( Œª s ‚Üí
-        pasting-horizontal-coherence-square-maps
-          ( pr1 h (f s))
-          ( pr1 k (f s))
-          ( map-equiv (pr2 (pr2 P) s))
-          ( map-equiv (pr2 (pr2 Q) s))
-          ( map-equiv (pr2 (pr2 R) s))
-          ( pr1 (pr2 h) (g s))
-          ( pr1 (pr2 k) (g s))
-          ( pr2 (pr2 h) s)
-          ( pr2 (pr2 k) s)))
-
-is-invertible-hom-Fam-pushout :
-  { l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
-  { f : S ‚Üí A} {g : S ‚Üí B} ‚Üí
-  ( P : descent-data-pushout (make-span-diagram f g) l4)
-  ( Q : descent-data-pushout (make-span-diagram f g) l5)
-  ( h : hom-Fam-pushout P Q) ‚Üí
-  UU (l1 ‚äî l2 ‚äî l3 ‚äî l4 ‚äî l5)
-is-invertible-hom-Fam-pushout P Q h =
-  Œ£ ( hom-Fam-pushout Q P) (Œª k ‚Üí
-    ( htpy-hom-Fam-pushout Q Q
-      ( comp-hom-Fam-pushout Q P Q h k)
-      ( id-hom-Fam-pushout Q)) √ó
-    ( htpy-hom-Fam-pushout P P
-      ( comp-hom-Fam-pushout P Q P k h)
-      ( id-hom-Fam-pushout P)))
-
-is-equiv-hom-Fam-pushout :
-  { l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
-  { f : S ‚Üí A} {g : S ‚Üí B}
-  ( P : descent-data-pushout (make-span-diagram f g) l4)
-  ( Q : descent-data-pushout (make-span-diagram f g) l5) ‚Üí
-  hom-Fam-pushout P Q ‚Üí UU (l2 ‚äî l3 ‚äî l4 ‚äî l5)
-is-equiv-hom-Fam-pushout {A = A} {B} {f} {g} P Q h =
-  ((a : A) ‚Üí is-equiv (pr1 h a)) √ó ((b : B) ‚Üí is-equiv (pr1 (pr2 h) b))
-
-is-equiv-is-invertible-hom-Fam-pushout :
-  { l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
-  { f : S ‚Üí A} {g : S ‚Üí B} ‚Üí
-  ( P : descent-data-pushout (make-span-diagram f g) l4)
-  ( Q : descent-data-pushout (make-span-diagram f g) l5)
-  (h : hom-Fam-pushout P Q) ‚Üí
-  is-invertible-hom-Fam-pushout P Q h ‚Üí is-equiv-hom-Fam-pushout P Q h
-is-equiv-is-invertible-hom-Fam-pushout P Q h has-inv-h =
-  pair
-    ( Œª a ‚Üí
-      is-equiv-is-invertible
-        ( pr1 (pr1 has-inv-h) a)
-        ( pr1 (pr1 (pr2 has-inv-h)) a)
-        ( pr1 (pr2 (pr2 has-inv-h)) a))
-    ( Œª b ‚Üí
-      is-equiv-is-invertible
-        ( pr1 (pr2 (pr1 has-inv-h)) b)
-        ( pr1 (pr2 (pr1 (pr2 has-inv-h))) b)
-        ( pr1 (pr2 (pr2 (pr2 has-inv-h))) b))
-
-equiv-is-equiv-hom-Fam-pushout :
-  { l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
-  { f : S ‚Üí A} {g : S ‚Üí B}
-  ( P : descent-data-pushout (make-span-diagram f g) l4)
-  ( Q : descent-data-pushout (make-span-diagram f g) l5) ‚Üí
-  ( h : hom-Fam-pushout P Q) ‚Üí
-  is-equiv-hom-Fam-pushout P Q h ‚Üí equiv-descent-data-pushout P Q
-equiv-is-equiv-hom-Fam-pushout P Q h is-equiv-h =
-  pair
-    ( Œª a ‚Üí pair (pr1 h a) (pr1 is-equiv-h a))
-    ( pair
-      ( Œª b ‚Üí pair (pr1 (pr2 h) b) (pr2 is-equiv-h b))
-      ( pr2 (pr2 h)))
-```
-
-### Theorem 19.1.3 Characterization of identity types of pushouts
-
-```agda
-{-
-hom-identity-is-universal-Fam-pushout :
-  { l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l5}
-  { f : S ‚Üí A} {g : S ‚Üí B} (c : cocone f g X) ‚Üí
-  ( up-X : universal-property-pushout f g c) ‚Üí
-  ( P : Fam-pushout l4 f g) (a : A) (p : pr1 P a) ‚Üí
-  is-universal-Fam-pushout l5 P a p ‚Üí
-  Œ£ ( hom-Fam-pushout P (desc-fam c (Id (pr1 c a))))
-    ( Œª h ‚Üí Id (pr1 h a p) refl)
-hom-identity-is-universal-Fam-pushout {f = f} {g} c up-X P a p is-univ-P =
-  {!!}
-
-is-identity-is-universal-Fam-pushout :
-  { l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l5}
-  { f : S ‚Üí A} {g : S ‚Üí B} (c : cocone f g X) ‚Üí
-  ( up-X : universal-property-pushout f g c) ‚Üí
-  ( P : Fam-pushout l4 f g) (a : A) (p : pr1 P a) ‚Üí
-  is-universal-Fam-pushout l5 P a p ‚Üí
-  Œ£ ( equiv-Fam-pushout P (desc-fam c (Id (pr1 c a))))
-    ( Œª e ‚Üí Id (map-equiv (pr1 e a) p) refl)
-is-identity-is-universal-Fam-pushout {f = f} {g} c up-X a P p‚ÇÄ is-eq-P = {!!}
--}
-```
diff --git a/src/synthetic-homotopy-theory/cocones-under-spans.lagda.md b/src/synthetic-homotopy-theory/cocones-under-spans.lagda.md
index d18ceee431..b3ac5c1716 100644
--- a/src/synthetic-homotopy-theory/cocones-under-spans.lagda.md
+++ b/src/synthetic-homotopy-theory/cocones-under-spans.lagda.md
@@ -41,7 +41,7 @@ A **cocone under a [span](foundation.spans.md)** `A <-f- S -g-> B` with codomain
         g
     S -----> B
     |        |
-  f |        |j
+  f |        | j
     ‚à®        ‚à®
     A -----> X
         i
@@ -331,7 +331,7 @@ A variation on the above:
         i
     A -----> X
     |        |
-  f |        |g
+  f |        | g
     ‚à®   j    ‚à®
     B -----> Y
     |        |
diff --git a/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
index e9bd8ae099..22394d4c95 100644
--- a/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
@@ -251,20 +251,22 @@ module _
   (f : S ‚Üí A) (g : S ‚Üí B) (c : cocone f g X)
   where
 
-  universal-property-dependent-universal-property-pushout :
-    dependent-universal-property-pushout f g c ‚Üí
-    universal-property-pushout f g c
-  universal-property-dependent-universal-property-pushout dup-c {l} =
-    universal-property-pushout-pullback-property-pushout f g c
-      ( pullback-property-dependent-pullback-property-pushout f g c
-        ( dependent-pullback-property-dependent-universal-property-pushout f g c
-          ( dup-c)))
-
-  dependent-universal-property-universal-property-pushout :
-    universal-property-pushout f g c ‚Üí
-    dependent-universal-property-pushout f g c
-  dependent-universal-property-universal-property-pushout up-c =
-    dependent-universal-property-dependent-pullback-property-pushout f g c
-      ( dependent-pullback-property-pullback-property-pushout f g c
-        ( pullback-property-pushout-universal-property-pushout f g c up-c))
+  abstract
+    universal-property-dependent-universal-property-pushout :
+      dependent-universal-property-pushout f g c ‚Üí
+      universal-property-pushout f g c
+    universal-property-dependent-universal-property-pushout dup-c {l} =
+      universal-property-pushout-pullback-property-pushout f g c
+        ( pullback-property-dependent-pullback-property-pushout f g c
+          ( dependent-pullback-property-dependent-universal-property-pushout f g
+            ( c)
+            ( dup-c)))
+
+    dependent-universal-property-universal-property-pushout :
+      universal-property-pushout f g c ‚Üí
+      dependent-universal-property-pushout f g c
+    dependent-universal-property-universal-property-pushout up-c =
+      dependent-universal-property-dependent-pullback-property-pushout f g c
+        ( dependent-pullback-property-pullback-property-pushout f g c
+          ( pullback-property-pushout-universal-property-pushout f g c up-c))
 ```
diff --git a/src/synthetic-homotopy-theory/families-descent-data-pushouts.lagda.md b/src/synthetic-homotopy-theory/families-descent-data-pushouts.lagda.md
index 573147d1a5..0a68a9200c 100644
--- a/src/synthetic-homotopy-theory/families-descent-data-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/families-descent-data-pushouts.lagda.md
@@ -111,6 +111,18 @@ module _
       ( descent-data-family-with-descent-data-pushout)
   equiv-descent-data-family-with-descent-data-pushout = pr2 (pr2 P)
 
+  inv-equiv-descent-data-family-with-descent-data-pushout :
+    equiv-descent-data-pushout
+      ( descent-data-family-with-descent-data-pushout)
+      ( descent-data-family-cocone-span-diagram c
+        ( family-cocone-family-with-descent-data-pushout))
+  inv-equiv-descent-data-family-with-descent-data-pushout =
+    inv-equiv-descent-data-pushout
+      ( descent-data-family-cocone-span-diagram c
+        ( family-cocone-family-with-descent-data-pushout))
+      ( descent-data-family-with-descent-data-pushout)
+      ( equiv-descent-data-family-with-descent-data-pushout)
+
   left-equiv-family-with-descent-data-pushout :
     (a : domain-span-diagram ùíÆ) ‚Üí
     family-cocone-family-with-descent-data-pushout
diff --git a/src/synthetic-homotopy-theory/flattening-lemma-coequalizers.lagda.md b/src/synthetic-homotopy-theory/flattening-lemma-coequalizers.lagda.md
index 96888b334f..d7951a5d85 100644
--- a/src/synthetic-homotopy-theory/flattening-lemma-coequalizers.lagda.md
+++ b/src/synthetic-homotopy-theory/flattening-lemma-coequalizers.lagda.md
@@ -101,7 +101,7 @@ module _
 
   flattening-lemma-coequalizer-statement : UUœâ
   flattening-lemma-coequalizer-statement =
-    dependent-universal-property-coequalizer a e ‚Üí
+    universal-property-coequalizer a e ‚Üí
     universal-property-coequalizer
       ( double-arrow-flattening-lemma-coequalizer)
       ( cofork-flattening-lemma-coequalizer)
@@ -133,7 +133,7 @@ module _
 
   abstract
     flattening-lemma-coequalizer : flattening-lemma-coequalizer-statement a P e
-    flattening-lemma-coequalizer dup-coequalizer =
+    flattening-lemma-coequalizer up-e =
       universal-property-coequalizer-universal-property-pushout
         ( double-arrow-flattening-lemma-coequalizer a P e)
         ( cofork-flattening-lemma-coequalizer a P e)
@@ -205,8 +205,6 @@ module _
             ( vertical-map-span-cocone-cofork a)
             ( horizontal-map-span-cocone-cofork a)
             ( cocone-codiagonal-cofork a e)
-            ( dependent-universal-property-pushout-dependent-universal-property-coequalizer
-              ( a)
-              ( e)
-              ( dup-coequalizer))))
+            ( universal-property-pushout-universal-property-coequalizer a e
+              ( up-e))))
 ```
diff --git a/src/synthetic-homotopy-theory/flattening-lemma-pushouts.lagda.md b/src/synthetic-homotopy-theory/flattening-lemma-pushouts.lagda.md
index 39b71b5028..a5842aaa89 100644
--- a/src/synthetic-homotopy-theory/flattening-lemma-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/flattening-lemma-pushouts.lagda.md
@@ -46,7 +46,7 @@ given a pushout square
       g
   S -----> B
   |        |
- f|        |j
+ f|        | j
   ‚à®      ‚åú ‚à®
   A -----> X
       i
@@ -127,7 +127,7 @@ module _
 
   flattening-lemma-pushout-statement : UUœâ
   flattening-lemma-pushout-statement =
-    dependent-universal-property-pushout f g c ‚Üí
+    universal-property-pushout f g c ‚Üí
     universal-property-pushout
       ( vertical-map-span-flattening-pushout)
       ( horizontal-map-span-flattening-pushout)
@@ -233,7 +233,7 @@ module _
 
   flattening-lemma-descent-data-pushout-statement : UUœâ
   flattening-lemma-descent-data-pushout-statement =
-    dependent-universal-property-pushout f g c ‚Üí
+    universal-property-pushout f g c ‚Üí
     universal-property-pushout
       ( vertical-map-span-flattening-descent-data-pushout P)
       ( horizontal-map-span-flattening-descent-data-pushout P)
@@ -305,25 +305,28 @@ module _
               ( Y)
               ( coherence-square-cocone f g c)
               ( h)))))
-
-  flattening-lemma-pushout :
-    flattening-lemma-pushout-statement P f g c
-  flattening-lemma-pushout dup-pushout Y =
-    is-equiv-left-factor
-      ( cocone-map-flattening-pushout Y)
-      ( ind-Œ£)
-      ( is-equiv-right-factor
-        ( map-equiv equiv-ev-pair¬≥)
-        ( cocone-map-flattening-pushout Y ‚àò ind-Œ£)
-        ( is-equiv-map-equiv equiv-ev-pair¬≥)
-        ( is-equiv-top-map-triangle
-          ( dependent-cocone-map f g c (Œª x ‚Üí P x ‚Üí Y))
-          ( map-equiv (comparison-dependent-cocone-ind-Œ£-cocone Y))
-          ( map-equiv equiv-ev-pair¬≥ ‚àò cocone-map-flattening-pushout Y ‚àò ind-Œ£)
-          ( triangle-comparison-dependent-cocone-ind-Œ£-cocone Y)
-          ( is-equiv-map-equiv (comparison-dependent-cocone-ind-Œ£-cocone Y))
-          ( dup-pushout (Œª x ‚Üí P x ‚Üí Y))))
-      ( is-equiv-ind-Œ£)
+  abstract
+    flattening-lemma-pushout :
+      flattening-lemma-pushout-statement P f g c
+    flattening-lemma-pushout up-c Y =
+      is-equiv-left-factor
+        ( cocone-map-flattening-pushout Y)
+        ( ind-Œ£)
+        ( is-equiv-right-factor
+          ( map-equiv equiv-ev-pair¬≥)
+          ( cocone-map-flattening-pushout Y ‚àò ind-Œ£)
+          ( is-equiv-map-equiv equiv-ev-pair¬≥)
+          ( is-equiv-top-map-triangle
+            ( dependent-cocone-map f g c (Œª x ‚Üí P x ‚Üí Y))
+            ( map-equiv (comparison-dependent-cocone-ind-Œ£-cocone Y))
+            ( ( map-equiv equiv-ev-pair¬≥) ‚àò
+              ( cocone-map-flattening-pushout Y) ‚àò
+              ( ind-Œ£))
+            ( triangle-comparison-dependent-cocone-ind-Œ£-cocone Y)
+            ( is-equiv-map-equiv (comparison-dependent-cocone-ind-Œ£-cocone Y))
+            ( dependent-universal-property-universal-property-pushout _ _ _ up-c
+              ( Œª x ‚Üí P x ‚Üí Y))))
+        ( is-equiv-ind-Œ£)
 ```
 
 ### Proof of the descent data statement of the flattening lemma
@@ -401,40 +404,41 @@ module _
             ( refl)
             ( inv (pr2 (pr2 e) s t))))))
 
-  flattening-lemma-descent-data-pushout :
-    flattening-lemma-descent-data-pushout-statement f g c P Q e
-  flattening-lemma-descent-data-pushout dup-pushout =
-    universal-property-pushout-top-universal-property-pushout-bottom-cube-is-equiv
-      ( vertical-map-span-flattening-pushout Q f g c)
-      ( horizontal-map-span-flattening-pushout Q f g c)
-      ( horizontal-map-cocone-flattening-pushout Q f g c)
-      ( vertical-map-cocone-flattening-pushout Q f g c)
-      ( vertical-map-span-flattening-descent-data-pushout P)
-      ( horizontal-map-span-flattening-descent-data-pushout P)
-      ( horizontal-map-cocone-flattening-descent-data-pushout f g c P Q e)
-      ( vertical-map-cocone-flattening-descent-data-pushout f g c P Q e)
-      ( tot (Œª s ‚Üí map-equiv (pr1 e (f s))))
-      ( tot (Œª a ‚Üí map-equiv (pr1 e a)))
-      ( tot (Œª b ‚Üí map-equiv (pr1 (pr2 e) b)))
-      ( id)
-      ( coherence-square-cocone-flattening-descent-data-pushout f g c P Q e)
-      ( refl-htpy)
-      ( htpy-map-Œ£
-        ( Q ‚àò vertical-map-cocone f g c)
+  abstract
+    flattening-lemma-descent-data-pushout :
+      flattening-lemma-descent-data-pushout-statement f g c P Q e
+    flattening-lemma-descent-data-pushout up-c =
+      universal-property-pushout-top-universal-property-pushout-bottom-cube-is-equiv
+        ( vertical-map-span-flattening-pushout Q f g c)
+        ( horizontal-map-span-flattening-pushout Q f g c)
+        ( horizontal-map-cocone-flattening-pushout Q f g c)
+        ( vertical-map-cocone-flattening-pushout Q f g c)
+        ( vertical-map-span-flattening-descent-data-pushout P)
+        ( horizontal-map-span-flattening-descent-data-pushout P)
+        ( horizontal-map-cocone-flattening-descent-data-pushout f g c P Q e)
+        ( vertical-map-cocone-flattening-descent-data-pushout f g c P Q e)
+        ( tot (Œª s ‚Üí map-equiv (pr1 e (f s))))
+        ( tot (Œª a ‚Üí map-equiv (pr1 e a)))
+        ( tot (Œª b ‚Üí map-equiv (pr1 (pr2 e) b)))
+        ( id)
+        ( coherence-square-cocone-flattening-descent-data-pushout f g c P Q e)
         ( refl-htpy)
-        ( Œª s ‚Üí
-          tr Q (coherence-square-cocone f g c s) ‚àò (map-equiv (pr1 e (f s))))
-        ( Œª s ‚Üí inv-htpy (pr2 (pr2 e) s)))
-      ( refl-htpy)
-      ( refl-htpy)
-      ( coherence-square-cocone-flattening-pushout Q f g c)
-      ( coherence-cube-flattening-lemma-descent-data-pushout)
-      ( is-equiv-tot-is-fiberwise-equiv
-        ( Œª s ‚Üí is-equiv-map-equiv (pr1 e (f s))))
-      ( is-equiv-tot-is-fiberwise-equiv
-        ( Œª a ‚Üí is-equiv-map-equiv (pr1 e a)))
-      ( is-equiv-tot-is-fiberwise-equiv
-        ( Œª b ‚Üí is-equiv-map-equiv (pr1 (pr2 e) b)))
-      ( is-equiv-id)
-      ( flattening-lemma-pushout Q f g c dup-pushout)
+        ( htpy-map-Œ£
+          ( Q ‚àò vertical-map-cocone f g c)
+          ( refl-htpy)
+          ( Œª s ‚Üí
+            tr Q (coherence-square-cocone f g c s) ‚àò (map-equiv (pr1 e (f s))))
+          ( Œª s ‚Üí inv-htpy (pr2 (pr2 e) s)))
+        ( refl-htpy)
+        ( refl-htpy)
+        ( coherence-square-cocone-flattening-pushout Q f g c)
+        ( coherence-cube-flattening-lemma-descent-data-pushout)
+        ( is-equiv-tot-is-fiberwise-equiv
+          ( Œª s ‚Üí is-equiv-map-equiv (pr1 e (f s))))
+        ( is-equiv-tot-is-fiberwise-equiv
+          ( Œª a ‚Üí is-equiv-map-equiv (pr1 e a)))
+        ( is-equiv-tot-is-fiberwise-equiv
+          ( Œª b ‚Üí is-equiv-map-equiv (pr1 (pr2 e) b)))
+        ( is-equiv-id)
+        ( flattening-lemma-pushout Q f g c up-c)
 ```
diff --git a/src/synthetic-homotopy-theory/flattening-lemma-sequential-colimits.lagda.md b/src/synthetic-homotopy-theory/flattening-lemma-sequential-colimits.lagda.md
index 9dd5911269..1e014f974d 100644
--- a/src/synthetic-homotopy-theory/flattening-lemma-sequential-colimits.lagda.md
+++ b/src/synthetic-homotopy-theory/flattening-lemma-sequential-colimits.lagda.md
@@ -176,11 +176,9 @@ module _
           ( flattening-lemma-coequalizer _
             ( P)
             ( cofork-cocone-sequential-diagram c)
-            ( dependent-universal-property-coequalizer-dependent-universal-property-sequential-colimit
+            ( universal-property-coequalizer-universal-property-sequential-colimit
               ( c)
-              ( dependent-universal-property-universal-property-sequential-colimit
-                ( c)
-                ( up-c)))))
+              ( up-c))))
 ```
 
 ### Flattening lemma for sequential colimits with descent data
diff --git a/src/synthetic-homotopy-theory/identity-systems-descent-data-pushouts.lagda.md b/src/synthetic-homotopy-theory/identity-systems-descent-data-pushouts.lagda.md
new file mode 100644
index 0000000000..ed4ca2232d
--- /dev/null
+++ b/src/synthetic-homotopy-theory/identity-systems-descent-data-pushouts.lagda.md
@@ -0,0 +1,523 @@
+# Identity systems of descent data for pushouts
+
+```agda
+{-# OPTIONS --lossy-unification #-}
+
+module synthetic-homotopy-theory.identity-systems-descent-data-pushouts where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.commuting-squares-of-maps
+open import foundation.contractible-types
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.fundamental-theorem-of-identity-types
+open import foundation.homotopies
+open import foundation.identity-systems
+open import foundation.identity-types
+open import foundation.sections
+open import foundation.singleton-induction
+open import foundation.span-diagrams
+open import foundation.torsorial-type-families
+open import foundation.transposition-identifications-along-equivalences
+open import foundation.universal-property-dependent-pair-types
+open import foundation.universal-property-identity-types
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.cocones-under-spans
+open import synthetic-homotopy-theory.dependent-universal-property-pushouts
+open import synthetic-homotopy-theory.descent-data-equivalence-types-over-pushouts
+open import synthetic-homotopy-theory.descent-data-identity-types-over-pushouts
+open import synthetic-homotopy-theory.descent-data-pushouts
+open import synthetic-homotopy-theory.descent-property-pushouts
+open import synthetic-homotopy-theory.equivalences-descent-data-pushouts
+open import synthetic-homotopy-theory.families-descent-data-pushouts
+open import synthetic-homotopy-theory.flattening-lemma-pushouts
+open import synthetic-homotopy-theory.morphisms-descent-data-pushouts
+open import synthetic-homotopy-theory.sections-descent-data-pushouts
+open import synthetic-homotopy-theory.universal-property-pushouts
+```
+
+</details>
+
+## Idea
+
+We define a universal property of
+[descent data](synthetic-homotopy-theory.descent-data-pushouts.md) for the
+[identity types](foundation-core.identity-types.md) of
+[pushouts](synthetic-homotopy-theory.pushouts.md), which allows their
+alternative characterizations. The property is analogous to being an
+[identity system](foundation.identity-systems.md); in fact, we show that a type
+family over a pushout is an identity system if and only if the corresponding
+descent data satisfies this universal property.
+
+Given descent data `(PA, PB, PS)` for the pushout
+
+```text
+        g
+    S -----> B
+    |        |
+  f |   H    | j
+    ‚à®        ‚à®
+    A -----> X
+        i
+```
+
+and a point `p‚ÇÄ : PA a‚ÇÄ` over a basepoint `a‚ÇÄ : A`, we would like to mirror the
+definition of identity systems. A na√Øve translation would lead us to define
+dependent descent data and its sections. We choose to sidestep building that
+technical infrastructure. By the
+[descent property](synthetic-homotopy-theory.descent-property-pushouts.md),
+there is a [unique](foundation-core.contractible-types.md) type family
+`P : X ‚Üí ùí∞`
+[corresponding](synthetic-homotopy-theory.families-descent-data-pushouts.md) to
+`(PA, PB, PS)`. Observe that the type of dependent type families
+`(x : X) ‚Üí (p : P x) ‚Üí ùí∞` is [equivalent](foundation-core.equivalences.md) to
+the [uncurried](foundation.universal-property-dependent-pair-types.md) form
+`(Œ£ X P) ‚Üí ùí∞`. By the
+[flattening lemma](synthetic-homotopy-theory.flattening-lemma-pushouts.md), the
+total space `Œ£ X P` is the pushout of the
+[span diagram](foundation.span-diagrams.md) of total spaces
+
+```text
+  Œ£ A PA <----- Œ£ S (PA ‚àò f) -----> Œ£ B PB,
+```
+
+so, again by the descent property, descent data over it correspond to type
+families over `Œ£ X P`. Hence we can talk about descent data `(RŒ£A, RŒ£B, RŒ£S)`
+over the total span diagram instead of dependent descent data.
+
+Every such descent data induces an evaluation map `ev-refl` on its
+[sections](synthetic-homotopy-theory.sections-descent-data-pushouts.md), which
+takes a section `(tA, tB, tS)` of `(RŒ£A, RŒ£B, RŒ£S)` to the point
+`tA (a‚ÇÄ, p‚ÇÄ) : RŒ£A (a‚ÇÄ, p‚ÇÄ)`. We say that `(PA, PB, PS)` is an
+{{#concept "identity system" Disambiguation="descent data for pushouts" Agda=is-identity-system-descent-data-pushout}}
+based at `p‚ÇÄ` if `ev-refl` has a [section](foundation-core.sections.md), in the
+sense that there is a converse map
+`ind-R : RŒ£A (a‚ÇÄ, p‚ÇÄ) ‚Üí section-descent-data (RŒ£A, RŒ£B, RŒ£S)` such that
+`(ind-R r)A (a‚ÇÄ, p‚ÇÄ) = r` for all `r : RŒ£A (a‚ÇÄ, p‚ÇÄ)`. Mind the unfortunate
+terminology clash between "sections of descent data" and "sections of a map".
+
+Note that this development is biased towards to left --- we pick a basepoint in
+the domain `a‚ÇÄ : A`, a point in the left type family `p‚ÇÄ : PA a‚ÇÄ`, and the
+evaluation map evaluates the left map of the section. By symmetry of pushouts we
+could just as well work with the points `b‚ÇÄ : B`, `p‚ÇÄ : PB b‚ÇÄ`, and the
+evaluation map evaluating the right map of the section.
+
+By showing that the canonical
+[descent data for identity types](synthetic-homotopy-theory.descent-data-identity-types-over-pushouts.md)
+is an identity system, we recover the "induction principle for pushout equality"
+stated and proved by Kraus and von Raumer in {{#cite KvR19}}.
+
+First observe that the type of sections of the evaluation map is
+
+```text
+  Œ£ (ind-R : (r : RŒ£A (a‚ÇÄ, p‚ÇÄ)) ‚Üí section (RŒ£A, RŒ£B, RŒ£S))
+    (is-sect : (r : RŒ£A (a‚ÇÄ, p‚ÇÄ)) ‚Üí (ind-R r)A (a‚ÇÄ, p‚ÇÄ) = r),
+```
+
+which is equivalent to the type
+
+```text
+  (r : RŒ£A (a‚ÇÄ, p‚ÇÄ)) ‚Üí
+  Œ£ (ind : section (RŒ£A, RŒ£B, RŒ£S))
+    (preserves-pt : indA (a‚ÇÄ, p‚ÇÄ) = r)
+```
+
+by
+[distributivity of Œ† over Œ£](foundation-core.type-theoretic-principle-of-choice.md).
+
+Then the induction terms from {{#cite KvR19}} (with names changed to fit our
+naming scheme)
+
+```text
+  ind·¥¨ : (a : A) (q : ia‚ÇÄ = ia) ‚Üí RŒ£A (a, q)
+  ind·¥Æ : (b : B) (q : ia‚ÇÄ = jb) ‚Üí RŒ£B (b, q)
+```
+
+are the first and second components of the section of `(RŒ£A, RŒ£B, RŒ£S)` induced
+by `r`, and their computation rules
+
+```text
+  ind·¥¨ a‚ÇÄ refl = r
+  (s : S) (q : ia‚ÇÄ = ifa) ‚Üí RŒ£S (s, q) (ind·¥¨ fs q) = ind·¥Æ gs (q ‚àô H s)
+```
+
+arise as the `preserves-pt` component above, and the coherence condition of a
+section of `(RŒ£A, RŒ£B, RŒ£S)`, respectively.
+
+## Definitions
+
+### The evaluation map of a section of descent data for pushouts
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {ùíÆ : span-diagram l1 l2 l3}
+  (P : descent-data-pushout ùíÆ l4) {a‚ÇÄ : domain-span-diagram ùíÆ}
+  (p‚ÇÄ : left-family-descent-data-pushout P a‚ÇÄ)
+  where
+
+  ev-refl-section-descent-data-pushout :
+    {l5 : Level}
+    (R :
+      descent-data-pushout (span-diagram-flattening-descent-data-pushout P) l5)
+    (t : section-descent-data-pushout R) ‚Üí
+    left-family-descent-data-pushout R (a‚ÇÄ , p‚ÇÄ)
+  ev-refl-section-descent-data-pushout R t =
+    left-map-section-descent-data-pushout R t (a‚ÇÄ , p‚ÇÄ)
+```
+
+### The predicate of being an identity system on descent data for pushouts
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {ùíÆ : span-diagram l1 l2 l3}
+  (P : descent-data-pushout ùíÆ l4) {a‚ÇÄ : domain-span-diagram ùíÆ}
+  (p‚ÇÄ : left-family-descent-data-pushout P a‚ÇÄ)
+  where
+
+  is-identity-system-descent-data-pushout : UUœâ
+  is-identity-system-descent-data-pushout =
+    {l5 : Level}
+    (R :
+      descent-data-pushout
+        ( span-diagram-flattening-descent-data-pushout P)
+        ( l5)) ‚Üí
+    section (ev-refl-section-descent-data-pushout P p‚ÇÄ R)
+```
+
+## Properties
+
+### A type family over a pushout is an identity system if and only if the corresponding descent data is an identity system
+
+Given a family with descent data `P ‚âÉ (PA, PB, PS)` and a point `p‚ÇÄ : PA a‚ÇÄ`, we
+show that `(PA, PB, PS)` is an identity system at `p‚ÇÄ` if an only if `P` is an
+identity system at `(e·¥æA a)‚Åª¬π p‚ÇÄ : P (ia‚ÇÄ)`.
+
+**Proof:** Consider a family with descent data `RŒ£ ‚âà (RŒ£A, RŒ£B, RŒ£S)`. Recall
+that this datum consists of a type family `RŒ£ : Œ£ X P ‚Üí ùí∞`, descent data
+
+```text
+  RŒ£A : Œ£ A PA ‚Üí ùí∞
+  RŒ£B : Œ£ B PB ‚Üí ùí∞
+  RŒ£S : ((s, p) : (Œ£ (s : S) (p : PA fs))) ‚Üí RŒ£A (fs, p) ‚âÉ RŒ£B (gs, PS s p),
+```
+
+a pair of equivalences
+
+```text
+  e·¥øA : ((a, p) : Œ£ A PA) ‚Üí RŒ£ (ia, (e·¥æA a)‚Åª¬π p) ‚âÉ RŒ£A (a, p)
+  e·¥øB : ((b, p) : Œ£ B PB) ‚Üí RŒ£ (jb, (e·¥æB b)‚Åª¬π p) ‚âÉ RŒ£B (b, p),
+```
+
+and a coherence between them that isn't relevant here. Then there is a
+[commuting square](foundation-core.commuting-squares-of-maps.md)
+
+```text
+  (x : X) ‚Üí (p : P x) ‚Üí RŒ£ (x, p) ---> (u : Œ£ X P) ‚Üí RŒ£ u ----> section (RŒ£A, RŒ£B, RŒ£S)
+                |                                                           |
+                | ev-refl ((e·¥æA a)‚Åª¬π p‚ÇÄ)                                    | ev-refl p‚ÇÄ
+                |                                                           |
+                ‚à®                                                           ‚à®
+      RŒ£ (ia‚ÇÄ, (e·¥æA a)‚Åª¬π p‚ÇÄ) ---------------------------------------> RŒ£A (a‚ÇÄ, p‚ÇÄ).
+                                      e·¥øA (a‚ÇÄ, p‚ÇÄ)
+```
+
+Since the top and bottom maps are equivalences, we get that the left map has a
+section if and only if the right map has a section.
+
+```agda
+module _
+  {l1 l2 l3 l4 l5 : Level} {ùíÆ : span-diagram l1 l2 l3}
+  {X : UU l4} {c : cocone-span-diagram ùíÆ X}
+  (P : family-with-descent-data-pushout c l5)
+  {a‚ÇÄ : domain-span-diagram ùíÆ}
+  (p‚ÇÄ : left-family-family-with-descent-data-pushout P a‚ÇÄ)
+  where
+
+  private
+    cocone-flattening :
+      cocone-span-diagram
+        ( span-diagram-flattening-descent-data-pushout
+          ( descent-data-family-with-descent-data-pushout P))
+        ( Œ£ X (family-cocone-family-with-descent-data-pushout P))
+    cocone-flattening =
+      cocone-flattening-descent-data-pushout _ _ c
+        ( descent-data-family-with-descent-data-pushout P)
+        ( family-cocone-family-with-descent-data-pushout P)
+        ( inv-equiv-descent-data-family-with-descent-data-pushout P)
+
+  square-ev-refl-section-descent-data-pushout :
+    {l5 : Level}
+    (R :
+      family-with-descent-data-pushout
+        ( cocone-flattening-descent-data-pushout _ _ c
+          ( descent-data-family-with-descent-data-pushout P)
+          ( family-cocone-family-with-descent-data-pushout P)
+          ( inv-equiv-descent-data-pushout _ _
+            ( equiv-descent-data-family-with-descent-data-pushout P)))
+        ( l5)) ‚Üí
+    coherence-square-maps
+      ( section-descent-data-section-family-cocone-span-diagram R ‚àò ind-Œ£)
+      ( ev-refl-identity-system
+        ( inv-left-map-family-with-descent-data-pushout P a‚ÇÄ p‚ÇÄ))
+      ( ev-refl-section-descent-data-pushout
+        ( descent-data-family-with-descent-data-pushout P)
+        ( p‚ÇÄ)
+        ( descent-data-family-with-descent-data-pushout R))
+      ( left-map-family-with-descent-data-pushout R (a‚ÇÄ , p‚ÇÄ))
+  square-ev-refl-section-descent-data-pushout R = refl-htpy
+```
+
+To show the forward implication, assume that `(PA, PB, PS)` is an identity
+system at `p‚ÇÄ`. We need to show that for every `R : (x : X) (p : P x) ‚Üí ùí∞`, the
+evaluation map `ev-refl ((e·¥æA a)‚Åª¬π p‚ÇÄ)` has a section. By the descent property,
+there is unique descent data `(RŒ£A, RŒ£B, RŒ£S)` for the uncurried family
+`RŒ£ := Œª (x, p) ‚Üí R x p`. Then we get the above square, and by assumption the
+right map has a section, hence the left map has a section.
+
+```agda
+  abstract
+    is-identity-system-is-identity-system-descent-data-pushout :
+      universal-property-pushout _ _ c ‚Üí
+      is-identity-system-descent-data-pushout
+        ( descent-data-family-with-descent-data-pushout P)
+        ( p‚ÇÄ) ‚Üí
+      is-identity-system
+        ( family-cocone-family-with-descent-data-pushout P)
+        ( horizontal-map-cocone _ _ c a‚ÇÄ)
+        ( inv-left-map-family-with-descent-data-pushout P a‚ÇÄ p‚ÇÄ)
+    is-identity-system-is-identity-system-descent-data-pushout
+      up-c id-system-P {l} R =
+      section-left-map-triangle _ _ _
+        ( square-ev-refl-section-descent-data-pushout fam-R)
+        ( section-is-equiv
+          ( is-equiv-comp _ _
+            ( is-equiv-ind-Œ£)
+            ( is-equiv-section-descent-data-section-family-cocone-span-diagram
+              ( fam-R)
+              ( flattening-lemma-descent-data-pushout _ _ c
+                ( descent-data-family-with-descent-data-pushout P)
+                ( family-cocone-family-with-descent-data-pushout P)
+                ( inv-equiv-descent-data-family-with-descent-data-pushout P)
+                ( up-c)))))
+        ( id-system-P (descent-data-family-with-descent-data-pushout fam-R))
+      where
+        fam-R : family-with-descent-data-pushout cocone-flattening l
+        fam-R =
+          family-with-descent-data-pushout-family-cocone
+            ( cocone-flattening)
+            ( ind-Œ£ R)
+```
+
+Similarly, assume `P` is an identity system at `(e·¥æA a)‚Åª¬π p‚ÇÄ`, and assume
+descent data `(RŒ£A, RŒ£B, RŒ£S)`. There is a unique corresponding type family
+`RŒ£`. Then the square above commutes, and the left map has a section by
+assumption, so the right map has a section.
+
+```agda
+  abstract
+    is-identity-system-descent-data-pushout-is-identity-system :
+      universal-property-pushout _ _ c ‚Üí
+      is-identity-system
+        ( family-cocone-family-with-descent-data-pushout P)
+        ( horizontal-map-cocone _ _ c a‚ÇÄ)
+        ( inv-left-map-family-with-descent-data-pushout P a‚ÇÄ p‚ÇÄ) ‚Üí
+      is-identity-system-descent-data-pushout
+        ( descent-data-family-with-descent-data-pushout P)
+        ( p‚ÇÄ)
+    is-identity-system-descent-data-pushout-is-identity-system
+      up-c id-system-P {l} R =
+      section-right-map-triangle _ _ _
+        ( square-ev-refl-section-descent-data-pushout fam-R)
+        ( section-comp _ _
+          ( id-system-P
+            ( ev-pair (family-cocone-family-with-descent-data-pushout fam-R)))
+          ( section-map-equiv
+            ( left-equiv-family-with-descent-data-pushout fam-R (a‚ÇÄ , p‚ÇÄ))))
+      where
+        fam-R : family-with-descent-data-pushout cocone-flattening l
+        fam-R =
+          family-with-descent-data-pushout-descent-data-pushout
+            ( flattening-lemma-descent-data-pushout _ _ c
+              ( descent-data-family-with-descent-data-pushout P)
+              ( family-cocone-family-with-descent-data-pushout P)
+              ( inv-equiv-descent-data-family-with-descent-data-pushout P)
+              ( up-c))
+            ( R)
+```
+
+### The canonical descent data for families of identity types is an identity system
+
+**Proof:** By the above property, the descent data `(IA, IB, IS)` is an identity
+system at `refl : ia‚ÇÄ = ia‚ÇÄ` if and only if the corresponding type family
+`Id (ia‚ÇÄ) : X ‚Üí ùí∞` is an identity system at `refl`, which is already
+established.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {ùíÆ : span-diagram l1 l2 l3}
+  {X : UU l4} {c : cocone-span-diagram ùíÆ X}
+  (up-c : universal-property-pushout _ _ c)
+  (a‚ÇÄ : domain-span-diagram ùíÆ)
+  where
+
+  abstract
+    induction-principle-descent-data-pushout-identity-type :
+      is-identity-system-descent-data-pushout
+        ( descent-data-identity-type-pushout c (horizontal-map-cocone _ _ c a‚ÇÄ))
+        ( refl)
+    induction-principle-descent-data-pushout-identity-type =
+      is-identity-system-descent-data-pushout-is-identity-system
+        ( family-with-descent-data-identity-type-pushout c
+          ( horizontal-map-cocone _ _ c a‚ÇÄ))
+        ( refl)
+        ( up-c)
+        ( is-identity-system-is-torsorial
+          ( horizontal-map-cocone _ _ c a‚ÇÄ)
+          ( refl)
+          ( is-torsorial-Id _))
+```
+
+### Unique uniqueness of identity systems
+
+For any identity system `(PA, PB, PS)` at `p‚ÇÄ`, there is a unique
+[equivalence of descent data](synthetic-homotopy-theory.equivalences-descent-data-pushouts.md)
+`(IA, IB, IS) ‚âÉ (PA, PB, PS)` sending `refl` to `p‚ÇÄ`.
+
+**Proof:** Consider the unique type family `P : X ‚Üí ùí∞` corresponding to
+`(PA, PB, PS).` The type of point preserving equivalences between `(IA, IB, IS)`
+and `(PA, PB, PS)` is equivalent to the type of
+[fiberwise equivalences](foundation-core.families-of-equivalences.md)
+`(x : X) ‚Üí (ia‚ÇÄ = x) ‚âÉ P x` that send `refl` to `(e·¥æA a‚ÇÄ)‚Åª¬π p‚ÇÄ`. To show that
+this type is contractible, it suffices to show that `P` is
+[torsorial](foundation-core.torsorial-type-families.md). A type family is
+torsorial if it is an identity system, and we have shown that `(PA, PB, PS)`
+being an identity system implies that `P` is an identity system.
+
+```agda
+module _
+  {l1 l2 l3 l4 l5 : Level} {ùíÆ : span-diagram l1 l2 l3}
+  {X : UU l4} {c : cocone-span-diagram ùíÆ X}
+  (up-c : universal-property-pushout _ _ c)
+  (P : descent-data-pushout ùíÆ l5) {a‚ÇÄ : domain-span-diagram ùíÆ}
+  (p‚ÇÄ : left-family-descent-data-pushout P a‚ÇÄ)
+  (id-system-P : is-identity-system-descent-data-pushout P p‚ÇÄ)
+  where
+
+  abstract
+    unique-uniqueness-identity-system-descent-data-pushout :
+      is-contr
+        ( Œ£ ( equiv-descent-data-pushout
+              ( descent-data-identity-type-pushout c
+                ( horizontal-map-cocone _ _ c a‚ÇÄ))
+              ( P))
+            ( Œª e ‚Üí left-map-equiv-descent-data-pushout _ _ e a‚ÇÄ refl Ôºù p‚ÇÄ))
+    unique-uniqueness-identity-system-descent-data-pushout =
+      is-contr-is-equiv'
+        ( Œ£ ( (x : X) ‚Üí
+              (horizontal-map-cocone _ _ c a‚ÇÄ Ôºù x) ‚âÉ
+              family-cocone-family-with-descent-data-pushout fam-P x)
+            ( Œª e ‚Üí map-equiv (e (horizontal-map-cocone _ _ c a‚ÇÄ)) refl Ôºù p‚ÇÄ'))
+        ( _)
+        ( is-equiv-map-Œ£ _
+          ( is-equiv-equiv-descent-data-equiv-family-cocone-span-diagram
+            ( family-with-descent-data-identity-type-pushout c
+              ( horizontal-map-cocone _ _ c a‚ÇÄ))
+            ( fam-P)
+            ( up-c))
+          ( Œª e ‚Üí
+            is-equiv-map-inv-equiv
+              ( eq-transpose-equiv
+                ( left-equiv-family-with-descent-data-pushout fam-P a‚ÇÄ)
+                ( _)
+                ( p‚ÇÄ))))
+        ( is-torsorial-pointed-fam-equiv-is-torsorial p‚ÇÄ'
+          ( is-torsorial-is-identity-system
+            ( horizontal-map-cocone _ _ c a‚ÇÄ)
+            ( p‚ÇÄ')
+            ( is-identity-system-is-identity-system-descent-data-pushout
+              ( fam-P)
+              ( p‚ÇÄ)
+              ( up-c)
+              ( id-system-P))))
+      where
+      fam-P : family-with-descent-data-pushout c l5
+      fam-P = family-with-descent-data-pushout-descent-data-pushout up-c P
+      p‚ÇÄ' :
+        family-cocone-family-with-descent-data-pushout
+          ( fam-P)
+          ( horizontal-map-cocone _ _ c a‚ÇÄ)
+      p‚ÇÄ' =
+        map-compute-inv-left-family-cocone-descent-data-pushout up-c P a‚ÇÄ p‚ÇÄ
+```
+
+### Descent data with a converse to the evaluation map of sections of descent data is an identity system
+
+To show that `(PA, PB, PS)` is an identity system at `p‚ÇÄ : PA a‚ÇÄ`, it suffices
+to provide an element of the type `H : RŒ£A (a‚ÇÄ, p‚ÇÄ) ‚Üí section (RŒ£A, RŒ£B, RŒ£S)`
+for all `(RŒ£A, RŒ£B, RŒ£S)`.
+
+**Proof:** Consider the unique family `P : X ‚Üí ùí∞` for `(PA, PB, PS)`. It
+suffices to show that `P` is an identity system. As above, we can do that by
+showing that it is torsorial. By definition, that means that the total space
+`Œ£ X P` is contractible. We can prove that using the property that a type is
+contractible if we provide a point, here `(ia‚ÇÄ, (e·¥æA a)‚Åª¬π p‚ÇÄ)`, and a map
+
+```text
+  H' : (RŒ£ : Œ£ X P ‚Üí ùí∞) ‚Üí (r‚ÇÄ : RŒ£ (ia‚ÇÄ, (e·¥æA a)‚Åª¬π p‚ÇÄ)) ‚Üí (u : Œ£ X P) ‚Üí RŒ£ u.
+```
+
+Assume such `RŒ£` and `r‚ÇÄ`. A section `(u : Œ£ X P) ‚Üí RŒ£ u` is given by a section
+of `(RŒ£A, RŒ£B, RŒ£S)`, and we can get one by applying `H` to
+`e·¥øA (a‚ÇÄ, p‚ÇÄ) r‚ÇÄ : RŒ£A (a‚ÇÄ, p‚ÇÄ)`.
+
+```agda
+module _
+  {l1 l2 l3 l4 l5 : Level} {ùíÆ : span-diagram l1 l2 l3}
+  {X : UU l4} {c : cocone-span-diagram ùíÆ X}
+  (up-c : universal-property-pushout _ _ c)
+  (P : descent-data-pushout ùíÆ l5) {a‚ÇÄ : domain-span-diagram ùíÆ}
+  (p‚ÇÄ : left-family-descent-data-pushout P a‚ÇÄ)
+  where
+
+  abstract
+    is-identity-system-descent-data-pushout-ind-singleton :
+      (H :
+        {l6 : Level}
+        (R :
+          descent-data-pushout
+            ( span-diagram-flattening-descent-data-pushout P)
+            ( l6))
+        (r‚ÇÄ : left-family-descent-data-pushout R (a‚ÇÄ , p‚ÇÄ)) ‚Üí
+        section-descent-data-pushout R) ‚Üí
+      is-identity-system-descent-data-pushout P p‚ÇÄ
+    is-identity-system-descent-data-pushout-ind-singleton H =
+      is-identity-system-descent-data-pushout-is-identity-system
+        ( family-with-descent-data-pushout-descent-data-pushout up-c P)
+        ( p‚ÇÄ)
+        ( up-c)
+        ( is-identity-system-is-torsorial
+          ( horizontal-map-cocone _ _ c a‚ÇÄ)
+          ( p‚ÇÄ')
+          ( is-contr-ind-singleton _
+            ( horizontal-map-cocone _ _ c a‚ÇÄ , p‚ÇÄ')
+            ( Œª R r‚ÇÄ ‚Üí
+              section-family-section-descent-data-pushout
+                ( flattening-lemma-descent-data-pushout _ _ c P
+                  ( family-cocone-descent-data-pushout up-c P)
+                  ( inv-equiv-family-cocone-descent-data-pushout up-c P)
+                  ( up-c))
+                ( family-with-descent-data-pushout-family-cocone _ R)
+                ( H (descent-data-family-cocone-span-diagram _ R) r‚ÇÄ))))
+      where
+        p‚ÇÄ' :
+          family-cocone-descent-data-pushout up-c P
+            ( horizontal-map-cocone _ _ c a‚ÇÄ)
+        p‚ÇÄ' =
+          map-compute-inv-left-family-cocone-descent-data-pushout up-c P a‚ÇÄ p‚ÇÄ
+```
diff --git a/src/synthetic-homotopy-theory/pushouts.lagda.md b/src/synthetic-homotopy-theory/pushouts.lagda.md
index 11b54821d0..1b5112681f 100644
--- a/src/synthetic-homotopy-theory/pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/pushouts.lagda.md
@@ -578,7 +578,7 @@ square commute (almost) trivially.
         ( f)
         ( g)
         ( cocone-pushout f g)
-        ( dup-pushout f g))
+        ( up-pushout f g))
       ( refl-htpy)
       ( Œª _ ‚Üí
         inv
