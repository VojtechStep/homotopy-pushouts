From 94964591af2d17a80ef7037280c84d0eae37d890 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Wed, 26 Jul 2023 16:33:27 +0200
Subject: [PATCH 01/25] Move the universal property of the integers to its own
 file

---
 src/elementary-number-theory.lagda.md         |   1 +
 .../universal-property-integers.lagda.md      | 235 ++++++++++++++++++
 .../universal-cover-circle.lagda.md           | 206 +--------------
 3 files changed, 237 insertions(+), 205 deletions(-)
 create mode 100644 src/elementary-number-theory/universal-property-integers.lagda.md

diff --git a/src/elementary-number-theory.lagda.md b/src/elementary-number-theory.lagda.md
index 95ee6bb674..2226b9389c 100644
--- a/src/elementary-number-theory.lagda.md
+++ b/src/elementary-number-theory.lagda.md
@@ -113,6 +113,7 @@ open import elementary-number-theory.twin-prime-conjecture public
 open import elementary-number-theory.type-arithmetic-natural-numbers public
 open import elementary-number-theory.unit-elements-standard-finite-types public
 open import elementary-number-theory.unit-similarity-standard-finite-types public
+open import elementary-number-theory.universal-property-integers public
 open import elementary-number-theory.universal-property-natural-numbers public
 open import elementary-number-theory.upper-bounds-natural-numbers public
 open import elementary-number-theory.well-ordering-principle-natural-numbers public
diff --git a/src/elementary-number-theory/universal-property-integers.lagda.md b/src/elementary-number-theory/universal-property-integers.lagda.md
new file mode 100644
index 0000000000..b39ee64688
--- /dev/null
+++ b/src/elementary-number-theory/universal-property-integers.lagda.md
@@ -0,0 +1,235 @@
+# The universal property of the integers
+
+```agda
+module elementary-number-theory.universal-property-integers where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import elementary-number-theory.integers
+open import elementary-number-theory.natural-numbers
+
+open import foundation.cartesian-product-types
+open import foundation.contractible-types
+open import foundation.coproduct-types
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.fundamental-theorem-of-identity-types
+open import foundation.homotopies
+open import foundation.identity-types
+open import foundation.propositions
+open import foundation.structure-identity-principle
+open import foundation.unit-type
+open import foundation.universe-levels
+```
+
+</details>
+
+## Idea
+
+The universal property of [the integers](elementary-number-theory.integers.md)
+states that given any type `X` equipped with a point `x : X` and an
+[automorphism](foundation.automorphisms.md) `e : X ≃ X`, the type of structure
+preserving maps from `ℤ` to `X` is contractible.
+
+```agda
+abstract
+  elim-ℤ :
+    { l1 : Level} (P : ℤ → UU l1)
+    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+    ( k : ℤ) → P k
+  elim-ℤ P p0 pS (inl zero-ℕ) =
+    map-inv-is-equiv (is-equiv-map-equiv (pS neg-one-ℤ)) p0
+  elim-ℤ P p0 pS (inl (succ-ℕ x)) =
+    map-inv-is-equiv
+      ( is-equiv-map-equiv (pS (inl (succ-ℕ x))))
+      ( elim-ℤ P p0 pS (inl x))
+  elim-ℤ P p0 pS (inr (inl star)) = p0
+  elim-ℤ P p0 pS (inr (inr zero-ℕ)) = map-equiv (pS zero-ℤ) p0
+  elim-ℤ P p0 pS (inr (inr (succ-ℕ x))) =
+    map-equiv
+      ( pS (inr (inr x)))
+      ( elim-ℤ P p0 pS (inr (inr x)))
+
+  compute-zero-elim-ℤ :
+    { l1 : Level} (P : ℤ → UU l1)
+    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+    Id (elim-ℤ P p0 pS zero-ℤ) p0
+  compute-zero-elim-ℤ P p0 pS = refl
+
+  compute-succ-elim-ℤ :
+    { l1 : Level} (P : ℤ → UU l1)
+    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) (k : ℤ) →
+    Id (elim-ℤ P p0 pS (succ-ℤ k)) (map-equiv (pS k) (elim-ℤ P p0 pS k))
+  compute-succ-elim-ℤ P p0 pS (inl zero-ℕ) =
+    inv
+      ( is-section-map-inv-is-equiv
+        ( is-equiv-map-equiv (pS (inl zero-ℕ)))
+        ( elim-ℤ P p0 pS (succ-ℤ (inl zero-ℕ))))
+  compute-succ-elim-ℤ P p0 pS (inl (succ-ℕ x)) =
+    inv
+      ( is-section-map-inv-is-equiv
+        ( is-equiv-map-equiv (pS (inl (succ-ℕ x))))
+        ( elim-ℤ P p0 pS (succ-ℤ (inl (succ-ℕ x)))))
+  compute-succ-elim-ℤ P p0 pS (inr (inl star)) = refl
+  compute-succ-elim-ℤ P p0 pS (inr (inr x)) = refl
+
+ELIM-ℤ :
+  { l1 : Level} (P : ℤ → UU l1)
+  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) → UU l1
+ELIM-ℤ P p0 pS =
+  Σ ( (k : ℤ) → P k)
+    ( λ f →
+      ( ( Id (f zero-ℤ) p0) ×
+        ( (k : ℤ) → Id (f (succ-ℤ k)) ((map-equiv (pS k)) (f k)))))
+
+Elim-ℤ :
+  { l1 : Level} (P : ℤ → UU l1)
+  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) → ELIM-ℤ P p0 pS
+pr1 (Elim-ℤ P p0 pS) = elim-ℤ P p0 pS
+pr1 (pr2 (Elim-ℤ P p0 pS)) = compute-zero-elim-ℤ P p0 pS
+pr2 (pr2 (Elim-ℤ P p0 pS)) = compute-succ-elim-ℤ P p0 pS
+
+equiv-comparison-map-Eq-ELIM-ℤ :
+  { l1 : Level} (P : ℤ → UU l1)
+  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+  ( s t : ELIM-ℤ P p0 pS) (k : ℤ) →
+  Id ((pr1 s) k) ((pr1 t) k) ≃ Id ((pr1 s) (succ-ℤ k)) ((pr1 t) (succ-ℤ k))
+equiv-comparison-map-Eq-ELIM-ℤ P p0 pS s t k =
+  ( ( equiv-concat (pr2 (pr2 s) k) (pr1 t (succ-ℤ k))) ∘e
+    ( equiv-concat' (map-equiv (pS k) (pr1 s k)) (inv (pr2 (pr2 t) k)))) ∘e
+  ( equiv-ap (pS k) (pr1 s k) (pr1 t k))
+
+zero-Eq-ELIM-ℤ :
+  { l1 : Level} (P : ℤ → UU l1)
+  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+  ( s t : ELIM-ℤ P p0 pS) (H : (pr1 s) ~ (pr1 t)) → UU l1
+zero-Eq-ELIM-ℤ P p0 pS s t H =
+  Id (H zero-ℤ) ((pr1 (pr2 s)) ∙ (inv (pr1 (pr2 t))))
+
+succ-Eq-ELIM-ℤ :
+  { l1 : Level} (P : ℤ → UU l1)
+  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+  ( s t : ELIM-ℤ P p0 pS) (H : (pr1 s) ~ (pr1 t)) → UU l1
+succ-Eq-ELIM-ℤ P p0 pS s t H =
+  ( k : ℤ) →
+  Id
+    ( H (succ-ℤ k))
+    ( map-equiv (equiv-comparison-map-Eq-ELIM-ℤ P p0 pS s t k) (H k))
+
+Eq-ELIM-ℤ :
+  { l1 : Level} (P : ℤ → UU l1)
+  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+  ( s t : ELIM-ℤ P p0 pS) → UU l1
+Eq-ELIM-ℤ P p0 pS s t =
+  ELIM-ℤ
+    ( λ k → Id (pr1 s k) (pr1 t k))
+    ( (pr1 (pr2 s)) ∙ (inv (pr1 (pr2 t))))
+    ( equiv-comparison-map-Eq-ELIM-ℤ P p0 pS s t)
+
+reflexive-Eq-ELIM-ℤ :
+  { l1 : Level} (P : ℤ → UU l1)
+  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+  ( s : ELIM-ℤ P p0 pS) → Eq-ELIM-ℤ P p0 pS s s
+pr1 (reflexive-Eq-ELIM-ℤ P p0 pS (f , p , H)) = refl-htpy
+pr1 (pr2 (reflexive-Eq-ELIM-ℤ P p0 pS (f , p , H))) = inv (right-inv p)
+pr2 (pr2 (reflexive-Eq-ELIM-ℤ P p0 pS (f , p , H))) = inv ∘ (right-inv ∘ H)
+
+Eq-ELIM-ℤ-eq :
+  { l1 : Level} (P : ℤ → UU l1) →
+  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+  ( s t : ELIM-ℤ P p0 pS) → Id s t → Eq-ELIM-ℤ P p0 pS s t
+Eq-ELIM-ℤ-eq P p0 pS s .s refl = reflexive-Eq-ELIM-ℤ P p0 pS s
+
+abstract
+  is-contr-total-Eq-ELIM-ℤ :
+    { l1 : Level} (P : ℤ → UU l1) →
+    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+    ( s : ELIM-ℤ P p0 pS) → is-contr (Σ (ELIM-ℤ P p0 pS) (Eq-ELIM-ℤ P p0 pS s))
+  is-contr-total-Eq-ELIM-ℤ P p0 pS s =
+    is-contr-total-Eq-structure
+      ( λ f t H →
+        ( zero-Eq-ELIM-ℤ P p0 pS s (pair f t) H) ×
+        ( succ-Eq-ELIM-ℤ P p0 pS s (pair f t) H))
+      ( is-contr-total-htpy (pr1 s))
+      ( pair (pr1 s) refl-htpy)
+      ( is-contr-total-Eq-structure
+        ( λ p K
+          ( q : zero-Eq-ELIM-ℤ P p0 pS s
+            ( pair (pr1 s) (pair p K))
+            ( refl-htpy)) →
+          succ-Eq-ELIM-ℤ P p0 pS s
+            ( pair (pr1 s) (pair p K))
+            ( refl-htpy))
+        ( is-contr-is-equiv'
+          ( Σ (Id (pr1 s zero-ℤ) p0) (λ α → Id α (pr1 (pr2 s))))
+          ( tot (λ α → con-inv refl α (pr1 (pr2 s))))
+          ( is-equiv-tot-is-fiberwise-equiv
+            ( λ α → is-equiv-con-inv refl α (pr1 (pr2 s))))
+          ( is-contr-total-path' (pr1 (pr2 s))))
+        ( pair (pr1 (pr2 s)) (inv (right-inv (pr1 (pr2 s)))))
+        ( is-contr-is-equiv'
+          ( Σ ( ( k : ℤ) → Id (pr1 s (succ-ℤ k)) (pr1 (pS k) (pr1 s k)))
+              ( λ β → β ~ (pr2 (pr2 s))))
+          ( tot (λ β → con-inv-htpy refl-htpy β (pr2 (pr2 s))))
+          ( is-equiv-tot-is-fiberwise-equiv
+            ( λ β → is-equiv-con-inv-htpy refl-htpy β (pr2 (pr2 s))))
+          ( is-contr-total-htpy' (pr2 (pr2 s)))))
+
+abstract
+  is-equiv-Eq-ELIM-ℤ-eq :
+    { l1 : Level} (P : ℤ → UU l1) →
+    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+    ( s t : ELIM-ℤ P p0 pS) → is-equiv (Eq-ELIM-ℤ-eq P p0 pS s t)
+  is-equiv-Eq-ELIM-ℤ-eq P p0 pS s =
+    fundamental-theorem-id
+      ( is-contr-total-Eq-ELIM-ℤ P p0 pS s)
+      ( Eq-ELIM-ℤ-eq P p0 pS s)
+
+eq-Eq-ELIM-ℤ :
+  { l1 : Level} (P : ℤ → UU l1) →
+  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+  ( s t : ELIM-ℤ P p0 pS) → Eq-ELIM-ℤ P p0 pS s t → Id s t
+eq-Eq-ELIM-ℤ P p0 pS s t = map-inv-is-equiv (is-equiv-Eq-ELIM-ℤ-eq P p0 pS s t)
+
+abstract
+  is-prop-ELIM-ℤ :
+    { l1 : Level} (P : ℤ → UU l1) →
+    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+    is-prop (ELIM-ℤ P p0 pS)
+  is-prop-ELIM-ℤ P p0 pS =
+    is-prop-all-elements-equal
+      ( λ s t → eq-Eq-ELIM-ℤ P p0 pS s t
+        ( Elim-ℤ
+          ( λ k → Id (pr1 s k) (pr1 t k))
+          ( (pr1 (pr2 s)) ∙ (inv (pr1 (pr2 t))))
+          ( equiv-comparison-map-Eq-ELIM-ℤ P p0 pS s t)))
+```
+
+We finally arrive at the dependent universal property of ℤ
+
+```agda
+abstract
+  is-contr-ELIM-ℤ :
+    { l1 : Level} (P : ℤ → UU l1) →
+    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
+    is-contr (ELIM-ℤ P p0 pS)
+  is-contr-ELIM-ℤ P p0 pS =
+    is-proof-irrelevant-is-prop (is-prop-ELIM-ℤ P p0 pS) (Elim-ℤ P p0 pS)
+```
+
+The universal property of ℤ is now just a special case
+
+```agda
+ELIM-ℤ' :
+  { l1 : Level} {X : UU l1} (x : X) (e : X ≃ X) → UU l1
+ELIM-ℤ' {X = X} x e = ELIM-ℤ (λ k → X) x (λ k → e)
+
+abstract
+  universal-property-ℤ :
+    { l1 : Level} {X : UU l1} (x : X) (e : X ≃ X) → is-contr (ELIM-ℤ' x e)
+  universal-property-ℤ {X = X} x e = is-contr-ELIM-ℤ (λ k → X) x (λ k → e)
+```
diff --git a/src/synthetic-homotopy-theory/universal-cover-circle.lagda.md b/src/synthetic-homotopy-theory/universal-cover-circle.lagda.md
index 5802758f3c..12705fc72e 100644
--- a/src/synthetic-homotopy-theory/universal-cover-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/universal-cover-circle.lagda.md
@@ -8,13 +8,12 @@ module synthetic-homotopy-theory.universal-cover-circle where
 
 ```agda
 open import elementary-number-theory.integers
-open import elementary-number-theory.natural-numbers
+open import elementary-number-theory.universal-property-integers
 
 open import foundation.action-on-identifications-dependent-functions
 open import foundation.action-on-identifications-functions
 open import foundation.cartesian-product-types
 open import foundation.contractible-types
-open import foundation.coproduct-types
 open import foundation.dependent-identifications
 open import foundation.dependent-pair-types
 open import foundation.equality-dependent-pair-types
@@ -26,10 +25,8 @@ open import foundation.functoriality-dependent-pair-types
 open import foundation.fundamental-theorem-of-identity-types
 open import foundation.homotopies
 open import foundation.identity-types
-open import foundation.propositions
 open import foundation.raising-universe-levels
 open import foundation.sets
-open import foundation.structure-identity-principle
 open import foundation.transport
 open import foundation.truncated-types
 open import foundation.truncation-levels
@@ -514,207 +511,6 @@ pr2 (is-contr-total-fundamental-cover-circle-data l dup-circle h p) =
   contraction-total-fundamental-cover-circle-data l dup-circle h p
 ```
 
-### Section 12.4 The dependent universal property of ℤ
-
-```agda
-abstract
-  elim-ℤ :
-    { l1 : Level} (P : ℤ → UU l1)
-    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-    ( k : ℤ) → P k
-  elim-ℤ P p0 pS (inl zero-ℕ) =
-    map-inv-is-equiv (is-equiv-map-equiv (pS neg-one-ℤ)) p0
-  elim-ℤ P p0 pS (inl (succ-ℕ x)) =
-    map-inv-is-equiv
-      ( is-equiv-map-equiv (pS (inl (succ-ℕ x))))
-      ( elim-ℤ P p0 pS (inl x))
-  elim-ℤ P p0 pS (inr (inl star)) = p0
-  elim-ℤ P p0 pS (inr (inr zero-ℕ)) = map-equiv (pS zero-ℤ) p0
-  elim-ℤ P p0 pS (inr (inr (succ-ℕ x))) =
-    map-equiv
-      ( pS (inr (inr x)))
-      ( elim-ℤ P p0 pS (inr (inr x)))
-
-  compute-zero-elim-ℤ :
-    { l1 : Level} (P : ℤ → UU l1)
-    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-    Id (elim-ℤ P p0 pS zero-ℤ) p0
-  compute-zero-elim-ℤ P p0 pS = refl
-
-  compute-succ-elim-ℤ :
-    { l1 : Level} (P : ℤ → UU l1)
-    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) (k : ℤ) →
-    Id (elim-ℤ P p0 pS (succ-ℤ k)) (map-equiv (pS k) (elim-ℤ P p0 pS k))
-  compute-succ-elim-ℤ P p0 pS (inl zero-ℕ) =
-    inv
-      ( is-section-map-inv-is-equiv
-        ( is-equiv-map-equiv (pS (inl zero-ℕ)))
-        ( elim-ℤ P p0 pS (succ-ℤ (inl zero-ℕ))))
-  compute-succ-elim-ℤ P p0 pS (inl (succ-ℕ x)) =
-    inv
-      ( is-section-map-inv-is-equiv
-        ( is-equiv-map-equiv (pS (inl (succ-ℕ x))))
-        ( elim-ℤ P p0 pS (succ-ℤ (inl (succ-ℕ x)))))
-  compute-succ-elim-ℤ P p0 pS (inr (inl star)) = refl
-  compute-succ-elim-ℤ P p0 pS (inr (inr x)) = refl
-
-ELIM-ℤ :
-  { l1 : Level} (P : ℤ → UU l1)
-  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) → UU l1
-ELIM-ℤ P p0 pS =
-  Σ ( (k : ℤ) → P k)
-    ( λ f →
-      ( ( Id (f zero-ℤ) p0) ×
-        ( (k : ℤ) → Id (f (succ-ℤ k)) ((map-equiv (pS k)) (f k)))))
-
-Elim-ℤ :
-  { l1 : Level} (P : ℤ → UU l1)
-  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) → ELIM-ℤ P p0 pS
-pr1 (Elim-ℤ P p0 pS) = elim-ℤ P p0 pS
-pr1 (pr2 (Elim-ℤ P p0 pS)) = compute-zero-elim-ℤ P p0 pS
-pr2 (pr2 (Elim-ℤ P p0 pS)) = compute-succ-elim-ℤ P p0 pS
-
-equiv-comparison-map-Eq-ELIM-ℤ :
-  { l1 : Level} (P : ℤ → UU l1)
-  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-  ( s t : ELIM-ℤ P p0 pS) (k : ℤ) →
-  Id ((pr1 s) k) ((pr1 t) k) ≃ Id ((pr1 s) (succ-ℤ k)) ((pr1 t) (succ-ℤ k))
-equiv-comparison-map-Eq-ELIM-ℤ P p0 pS s t k =
-  ( ( equiv-concat (pr2 (pr2 s) k) (pr1 t (succ-ℤ k))) ∘e
-    ( equiv-concat' (map-equiv (pS k) (pr1 s k)) (inv (pr2 (pr2 t) k)))) ∘e
-  ( equiv-ap (pS k) (pr1 s k) (pr1 t k))
-
-zero-Eq-ELIM-ℤ :
-  { l1 : Level} (P : ℤ → UU l1)
-  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-  ( s t : ELIM-ℤ P p0 pS) (H : (pr1 s) ~ (pr1 t)) → UU l1
-zero-Eq-ELIM-ℤ P p0 pS s t H =
-  Id (H zero-ℤ) ((pr1 (pr2 s)) ∙ (inv (pr1 (pr2 t))))
-
-succ-Eq-ELIM-ℤ :
-  { l1 : Level} (P : ℤ → UU l1)
-  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-  ( s t : ELIM-ℤ P p0 pS) (H : (pr1 s) ~ (pr1 t)) → UU l1
-succ-Eq-ELIM-ℤ P p0 pS s t H =
-  ( k : ℤ) →
-  Id
-    ( H (succ-ℤ k))
-    ( map-equiv (equiv-comparison-map-Eq-ELIM-ℤ P p0 pS s t k) (H k))
-
-Eq-ELIM-ℤ :
-  { l1 : Level} (P : ℤ → UU l1)
-  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-  ( s t : ELIM-ℤ P p0 pS) → UU l1
-Eq-ELIM-ℤ P p0 pS s t =
-  ELIM-ℤ
-    ( λ k → Id (pr1 s k) (pr1 t k))
-    ( (pr1 (pr2 s)) ∙ (inv (pr1 (pr2 t))))
-    ( equiv-comparison-map-Eq-ELIM-ℤ P p0 pS s t)
-
-reflexive-Eq-ELIM-ℤ :
-  { l1 : Level} (P : ℤ → UU l1)
-  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-  ( s : ELIM-ℤ P p0 pS) → Eq-ELIM-ℤ P p0 pS s s
-pr1 (reflexive-Eq-ELIM-ℤ P p0 pS (f , p , H)) = refl-htpy
-pr1 (pr2 (reflexive-Eq-ELIM-ℤ P p0 pS (f , p , H))) = inv (right-inv p)
-pr2 (pr2 (reflexive-Eq-ELIM-ℤ P p0 pS (f , p , H))) = inv ∘ (right-inv ∘ H)
-
-Eq-ELIM-ℤ-eq :
-  { l1 : Level} (P : ℤ → UU l1) →
-  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-  ( s t : ELIM-ℤ P p0 pS) → Id s t → Eq-ELIM-ℤ P p0 pS s t
-Eq-ELIM-ℤ-eq P p0 pS s .s refl = reflexive-Eq-ELIM-ℤ P p0 pS s
-
-abstract
-  is-contr-total-Eq-ELIM-ℤ :
-    { l1 : Level} (P : ℤ → UU l1) →
-    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-    ( s : ELIM-ℤ P p0 pS) → is-contr (Σ (ELIM-ℤ P p0 pS) (Eq-ELIM-ℤ P p0 pS s))
-  is-contr-total-Eq-ELIM-ℤ P p0 pS s =
-    is-contr-total-Eq-structure
-      ( λ f t H →
-        ( zero-Eq-ELIM-ℤ P p0 pS s (pair f t) H) ×
-        ( succ-Eq-ELIM-ℤ P p0 pS s (pair f t) H))
-      ( is-contr-total-htpy (pr1 s))
-      ( pair (pr1 s) refl-htpy)
-      ( is-contr-total-Eq-structure
-        ( λ p K
-          ( q : zero-Eq-ELIM-ℤ P p0 pS s
-            ( pair (pr1 s) (pair p K))
-            ( refl-htpy)) →
-          succ-Eq-ELIM-ℤ P p0 pS s
-            ( pair (pr1 s) (pair p K))
-            ( refl-htpy))
-        ( is-contr-is-equiv'
-          ( Σ (Id (pr1 s zero-ℤ) p0) (λ α → Id α (pr1 (pr2 s))))
-          ( tot (λ α → con-inv refl α (pr1 (pr2 s))))
-          ( is-equiv-tot-is-fiberwise-equiv
-            ( λ α → is-equiv-con-inv refl α (pr1 (pr2 s))))
-          ( is-contr-total-path' (pr1 (pr2 s))))
-        ( pair (pr1 (pr2 s)) (inv (right-inv (pr1 (pr2 s)))))
-        ( is-contr-is-equiv'
-          ( Σ ( ( k : ℤ) → Id (pr1 s (succ-ℤ k)) (pr1 (pS k) (pr1 s k)))
-              ( λ β → β ~ (pr2 (pr2 s))))
-          ( tot (λ β → con-inv-htpy refl-htpy β (pr2 (pr2 s))))
-          ( is-equiv-tot-is-fiberwise-equiv
-            ( λ β → is-equiv-con-inv-htpy refl-htpy β (pr2 (pr2 s))))
-          ( is-contr-total-htpy' (pr2 (pr2 s)))))
-
-abstract
-  is-equiv-Eq-ELIM-ℤ-eq :
-    { l1 : Level} (P : ℤ → UU l1) →
-    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-    ( s t : ELIM-ℤ P p0 pS) → is-equiv (Eq-ELIM-ℤ-eq P p0 pS s t)
-  is-equiv-Eq-ELIM-ℤ-eq P p0 pS s =
-    fundamental-theorem-id
-      ( is-contr-total-Eq-ELIM-ℤ P p0 pS s)
-      ( Eq-ELIM-ℤ-eq P p0 pS s)
-
-eq-Eq-ELIM-ℤ :
-  { l1 : Level} (P : ℤ → UU l1) →
-  ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-  ( s t : ELIM-ℤ P p0 pS) → Eq-ELIM-ℤ P p0 pS s t → Id s t
-eq-Eq-ELIM-ℤ P p0 pS s t = map-inv-is-equiv (is-equiv-Eq-ELIM-ℤ-eq P p0 pS s t)
-
-abstract
-  is-prop-ELIM-ℤ :
-    { l1 : Level} (P : ℤ → UU l1) →
-    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-    is-prop (ELIM-ℤ P p0 pS)
-  is-prop-ELIM-ℤ P p0 pS =
-    is-prop-all-elements-equal
-      ( λ s t → eq-Eq-ELIM-ℤ P p0 pS s t
-        ( Elim-ℤ
-          ( λ k → Id (pr1 s k) (pr1 t k))
-          ( (pr1 (pr2 s)) ∙ (inv (pr1 (pr2 t))))
-          ( equiv-comparison-map-Eq-ELIM-ℤ P p0 pS s t)))
-```
-
-We finally arrive at the dependent universal property of ℤ
-
-```agda
-abstract
-  is-contr-ELIM-ℤ :
-    { l1 : Level} (P : ℤ → UU l1) →
-    ( p0 : P zero-ℤ) (pS : (k : ℤ) → (P k) ≃ (P (succ-ℤ k))) →
-    is-contr (ELIM-ℤ P p0 pS)
-  is-contr-ELIM-ℤ P p0 pS =
-    is-proof-irrelevant-is-prop (is-prop-ELIM-ℤ P p0 pS) (Elim-ℤ P p0 pS)
-```
-
-The universal property of ℤ is now just a special case
-
-```agda
-ELIM-ℤ' :
-  { l1 : Level} {X : UU l1} (x : X) (e : X ≃ X) → UU l1
-ELIM-ℤ' {X = X} x e = ELIM-ℤ (λ k → X) x (λ k → e)
-
-abstract
-  universal-property-ℤ :
-    { l1 : Level} {X : UU l1} (x : X) (e : X ≃ X) → is-contr (ELIM-ℤ' x e)
-  universal-property-ℤ {X = X} x e = is-contr-ELIM-ℤ (λ k → X) x (λ k → e)
-```
-
 ### Section 12.5 The identity type of the circle
 
 ```agda

From 9c6cb5fce2c596e07cd937f9253bbabf5b18935c Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Wed, 26 Jul 2023 16:41:59 +0200
Subject: [PATCH 02/25] Define dependent descent data; add prose

---
 .../descent-circle.lagda.md                   | 44 +++++++++++++++++++
 1 file changed, 44 insertions(+)

diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index 1efe950f82..7b498a18b0 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -46,6 +46,11 @@ The descent property uniquely characterizes type families over the circle.
 
 ### Descent data for the circle
 
+By the universal property of the circle and univalence, a type family
+`A : 𝕊¹ → U` is equivalent to a type `X : U` equipped with an automorphism
+`e : X ≃ X`, in a way made precise in further sections of this file. The pair
+`(X, e)` is called descent data for the circle.
+
 ```agda
 descent-data-circle :
   ( l1 : Level) → UU (lsuc l1)
@@ -62,8 +67,44 @@ module _
   aut-descent-data-circle = pr2 P
 ```
 
+### Dependent descent data for the circle
+
+The equivalence extends to the dependent case, where given a type family `A`
+over the circle with descent data `(X, e)`, a type family
+`B : (t : 𝕊¹) → A t → U` is equivalent to a type family `R : X → U` equipped
+with a family of equivalences `K : (x : X) → R(x) ≃ R(e(x))`. The pair `(R, K)`
+is called dependent descent data for the circle. Intuitively, this states that
+the types over points of `X` belonging to the same connected component in the
+total space `Σ 𝕊¹ A` are equivalent.
+
+```agda
+dependent-descent-data-circle :
+  { l1 : Level} → descent-data-circle l1 →
+  ( l2 : Level) → UU (l1 ⊔ lsuc l2)
+dependent-descent-data-circle P l2 =
+  Σ ( type-descent-data-circle P → UU l2)
+    ( λ R → equiv-fam R (R ∘ (map-equiv (aut-descent-data-circle P))))
+
+module _
+  { l1 l2 : Level} (P : descent-data-circle l1)
+  ( Q : dependent-descent-data-circle P l2)
+  where
+
+  type-dependent-descent-data-circle : type-descent-data-circle P → UU l2
+  type-dependent-descent-data-circle = pr1 Q
+
+  equiv-dependent-descent-data-circle :
+    equiv-fam
+      type-dependent-descent-data-circle
+      ( type-dependent-descent-data-circle ∘
+        ( map-equiv (aut-descent-data-circle P)))
+  equiv-dependent-descent-data-circle = pr2 Q
+```
+
 ### Fixpoints of the descent data
 
+A fixpoint of `(X, e)` is a fixpoint of `e`.
+
 ```agda
 fixpoint-descent-data-circle :
   { l1 l2 : Level} {X : UU l1} (l : free-loop X)
@@ -75,6 +116,9 @@ fixpoint-descent-data-circle l P =
 
 ### Homomorphisms between descent data for the circle
 
+A homomorphism between `(X, e)` and `(Y, f)` is a map from `X` to `Y` such that
+the obvious square commutes.
+
 ```agda
 hom-descent-data-circle :
   { l1 l2 l3 : Level} {X : UU l1} (l : free-loop X)

From 809286c9404c7adbbccfd70fe5f3d882396b96c3 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Wed, 26 Jul 2023 16:47:18 +0200
Subject: [PATCH 03/25] Cleanup unnecessary parameter

---
 .../descent-circle.lagda.md                   | 28 +++++++++----------
 1 file changed, 14 insertions(+), 14 deletions(-)

diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index 7b498a18b0..8d583b784b 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -107,9 +107,9 @@ A fixpoint of `(X, e)` is a fixpoint of `e`.
 
 ```agda
 fixpoint-descent-data-circle :
-  { l1 l2 : Level} {X : UU l1} (l : free-loop X)
-  ( P : descent-data-circle l2) → UU l2
-fixpoint-descent-data-circle l P =
+  { l1 : Level}
+  ( P : descent-data-circle l1) → UU l1
+fixpoint-descent-data-circle P =
   Σ ( type-descent-data-circle P)
     ( λ p → (map-equiv (aut-descent-data-circle P) p) ＝ p)
 ```
@@ -121,10 +121,10 @@ the obvious square commutes.
 
 ```agda
 hom-descent-data-circle :
-  { l1 l2 l3 : Level} {X : UU l1} (l : free-loop X)
-  ( P : descent-data-circle l2) (Q : descent-data-circle l3) →
-  UU (l2 ⊔ l3)
-hom-descent-data-circle _ P Q =
+  { l1 l2 : Level}
+  ( P : descent-data-circle l1) (Q : descent-data-circle l2) →
+  UU (l1 ⊔ l2)
+hom-descent-data-circle P Q =
   Σ ( (type-descent-data-circle P) → (type-descent-data-circle Q))
     ( λ h →
       coherence-square-maps
@@ -336,7 +336,7 @@ module _
     α = pr1 αH
 
   ev-fixpoint-descent-data-circle :
-    ( (x : X) → Q x) → fixpoint-descent-data-circle l P
+    ( (x : X) → Q x) → fixpoint-descent-data-circle P
   pr1 (ev-fixpoint-descent-data-circle s) =
     map-inv-equiv
       ( α)
@@ -357,7 +357,7 @@ module _
           ( inv (is-section-map-inv-equiv α (s (base-free-loop l))))))
 
   equiv-fixpoint-descent-data-circle-free-dependent-loop :
-    fixpoint-descent-data-circle l P ≃ free-dependent-loop l Q
+    fixpoint-descent-data-circle P ≃ free-dependent-loop l Q
   equiv-fixpoint-descent-data-circle-free-dependent-loop =
     equiv-Σ
       ( λ x → dependent-identification Q (loop-free-loop l) x x)
@@ -366,7 +366,7 @@ module _
         compute-dependent-identification-loop-circle l Q P αH x x)
 
   comparison-fixpoint-descent-data-circle :
-    fixpoint-descent-data-circle l P → free-dependent-loop l Q
+    fixpoint-descent-data-circle P → free-dependent-loop l Q
   comparison-fixpoint-descent-data-circle =
     map-equiv equiv-fixpoint-descent-data-circle-free-dependent-loop
 
@@ -427,7 +427,7 @@ module _
 
   equiv-ev-fixpoint-descent-data-circle :
     ( dependent-universal-property-circle l2 l) →
-    ( (x : X) → Q x) ≃ (fixpoint-descent-data-circle l P)
+    ( (x : X) → Q x) ≃ (fixpoint-descent-data-circle P)
   pr1 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
     ev-fixpoint-descent-data-circle
   pr2 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
@@ -500,8 +500,8 @@ module _
         ( map-equiv (pr1 eq-descent-data-circle-function-type) h)))
 
   equiv-fixpoint-descent-data-circle-function-type-hom :
-    fixpoint-descent-data-circle l descent-data-circle-function-type ≃
-    hom-descent-data-circle l P Q
+    fixpoint-descent-data-circle descent-data-circle-function-type ≃
+    hom-descent-data-circle P Q
   equiv-fixpoint-descent-data-circle-function-type-hom =
     equiv-tot
       (λ h →
@@ -512,7 +512,7 @@ module _
 
   equiv-ev-descent-data-circle-function-type-hom :
     dependent-universal-property-circle (l2 ⊔ l3) l →
-    ((s : X) → A s → B s) ≃ (hom-descent-data-circle l P Q)
+    ((s : X) → A s → B s) ≃ (hom-descent-data-circle P Q)
   equiv-ev-descent-data-circle-function-type-hom dup-circle =
     equiv-fixpoint-descent-data-circle-function-type-hom ∘e
     ( equiv-ev-fixpoint-descent-data-circle

From 5c28bdec285cc74a34292927c8793c1c40840b65 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Wed, 26 Jul 2023 16:57:06 +0200
Subject: [PATCH 04/25] Give `ev-descent-data-circle` its own paragraph

---
 .../descent-circle.lagda.md                   | 25 +++++++++++++------
 1 file changed, 17 insertions(+), 8 deletions(-)

diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index 8d583b784b..c19609aee1 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -134,6 +134,19 @@ hom-descent-data-circle P Q =
         ( h))
 ```
 
+### Canonical descent data for a family over the circle
+
+A type family over the circle gives rise to its canonical descent data, obtained
+by evaluation at `base` and transporting along `loop`.
+
+```agda
+ev-descent-data-circle :
+  { l1 l2 : Level } {X : UU l1} (l : free-loop X) →
+  (X → UU l2) → descent-data-circle l2
+pr1 (ev-descent-data-circle l P) = P (base-free-loop l)
+pr2 (ev-descent-data-circle l P) = equiv-tr P (loop-free-loop l)
+```
+
 ## Properties
 
 ### Characterization of the identity type of descent data for the circle
@@ -207,27 +220,23 @@ module _
   { l1 l2 : Level} {X : UU l1} (l : free-loop X)
   where
 
-  ev-descent-data-circle : (X → UU l2) → descent-data-circle l2
-  pr1 (ev-descent-data-circle P) = P (base-free-loop l)
-  pr2 (ev-descent-data-circle P) = equiv-tr P (loop-free-loop l)
-
   triangle-comparison-descent-data-circle :
     coherence-triangle-maps
-      ( ev-descent-data-circle)
+      ( ev-descent-data-circle l)
       ( comparison-descent-data-circle l2)
       ( ev-free-loop l (UU l2))
   triangle-comparison-descent-data-circle P =
     eq-Eq-descent-data-circle
-      ( ev-descent-data-circle P)
+      ( ev-descent-data-circle l P)
       ( comparison-descent-data-circle l2 (ev-free-loop l (UU l2) P))
       ( id-equiv , (htpy-eq (inv (compute-equiv-eq-ap (loop-free-loop l)))))
 
   is-equiv-ev-descent-data-circle-universal-property-circle :
     ( up-circle : universal-property-circle (lsuc l2) l) →
-    is-equiv ev-descent-data-circle
+    is-equiv (ev-descent-data-circle l)
   is-equiv-ev-descent-data-circle-universal-property-circle up-circle =
     is-equiv-comp-htpy
-      ( ev-descent-data-circle)
+      ( ev-descent-data-circle l)
       ( comparison-descent-data-circle l2)
       ( ev-free-loop l (UU l2))
       ( triangle-comparison-descent-data-circle)

From bf4f2e5cd340ad4d16fdd9d798a6cbfb169dcf12 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Wed, 26 Jul 2023 17:18:55 +0200
Subject: [PATCH 05/25] Use naming closer to the book

---
 .../descent-circle.lagda.md                   | 124 +++++++++---------
 1 file changed, 62 insertions(+), 62 deletions(-)

diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index c19609aee1..96dccd77e8 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -111,7 +111,7 @@ fixpoint-descent-data-circle :
   ( P : descent-data-circle l1) → UU l1
 fixpoint-descent-data-circle P =
   Σ ( type-descent-data-circle P)
-    ( λ p → (map-equiv (aut-descent-data-circle P) p) ＝ p)
+    ( λ x → (map-equiv (aut-descent-data-circle P) x) ＝ x)
 ```
 
 ### Homomorphisms between descent data for the circle
@@ -141,10 +141,10 @@ by evaluation at `base` and transporting along `loop`.
 
 ```agda
 ev-descent-data-circle :
-  { l1 l2 : Level } {X : UU l1} (l : free-loop X) →
-  (X → UU l2) → descent-data-circle l2
-pr1 (ev-descent-data-circle l P) = P (base-free-loop l)
-pr2 (ev-descent-data-circle l P) = equiv-tr P (loop-free-loop l)
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S) →
+  ( S → UU l2) → descent-data-circle l2
+pr1 (ev-descent-data-circle l A) = A (base-free-loop l)
+pr2 (ev-descent-data-circle l A) = equiv-tr A (loop-free-loop l)
 ```
 
 ## Properties
@@ -153,8 +153,8 @@ pr2 (ev-descent-data-circle l P) = equiv-tr P (loop-free-loop l)
 
 ```agda
 Eq-descent-data-circle :
-  { l1 : Level} → descent-data-circle l1 → descent-data-circle l1 →
-  UU l1
+  { l1 l2 : Level} → descent-data-circle l1 → descent-data-circle l2 →
+  UU (l1 ⊔ l2)
 Eq-descent-data-circle P Q =
   Σ ( (type-descent-data-circle P) ≃ (type-descent-data-circle Q))
     ( λ h →
@@ -217,7 +217,7 @@ is-equiv-comparison-descent-data-circle l1 =
   is-equiv-tot-is-fiberwise-equiv (λ Y → univalence Y Y)
 
 module _
-  { l1 l2 : Level} {X : UU l1} (l : free-loop X)
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
   where
 
   triangle-comparison-descent-data-circle :
@@ -225,10 +225,10 @@ module _
       ( ev-descent-data-circle l)
       ( comparison-descent-data-circle l2)
       ( ev-free-loop l (UU l2))
-  triangle-comparison-descent-data-circle P =
+  triangle-comparison-descent-data-circle A =
     eq-Eq-descent-data-circle
-      ( ev-descent-data-circle l P)
-      ( comparison-descent-data-circle l2 (ev-free-loop l (UU l2) P))
+      ( ev-descent-data-circle l A)
+      ( comparison-descent-data-circle l2 (ev-free-loop l (UU l2) A))
       ( id-equiv , (htpy-eq (inv (compute-equiv-eq-ap (loop-free-loop l)))))
 
   is-equiv-ev-descent-data-circle-universal-property-circle :
@@ -244,16 +244,16 @@ module _
       ( is-equiv-comparison-descent-data-circle l2)
 
 unique-family-property-circle :
-  { l1 : Level} (l2 : Level) {X : UU l1} (l : free-loop X) →
+  { l1 : Level} (l2 : Level) {S : UU l1} (l : free-loop S) →
   UU (l1 ⊔ lsuc l2)
-unique-family-property-circle l2 {X} l =
+unique-family-property-circle l2 {S} l =
   ( Q : descent-data-circle l2) →
     is-contr
-    ( Σ (X → UU l2)
-        (λ P → Eq-descent-data-circle Q (ev-descent-data-circle l P)))
+    ( Σ (S → UU l2)
+        (λ A → Eq-descent-data-circle Q (ev-descent-data-circle l A)))
 
 module _
-  { l1 l2 : Level} {X : UU l1} (l : free-loop X)
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
   where
 
   unique-family-property-universal-property-circle :
@@ -287,19 +287,19 @@ automorphism from the characteristic descent data.
 
 ```agda
 module _
-  { l1 l2 : Level} {X : UU l1} (l : free-loop X)
-  ( Q : X → UU l2) (P : descent-data-circle l2)
-  ( αH : Eq-descent-data-circle P (ev-descent-data-circle l Q))
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( A : S → UU l2) (P : descent-data-circle l2)
+  ( αH : Eq-descent-data-circle P (ev-descent-data-circle l A))
   where
 
   private
-    α : type-descent-data-circle P ≃ Q (base-free-loop l)
+    α : type-descent-data-circle P ≃ A (base-free-loop l)
     α = pr1 αH
 
   map-compute-dependent-identification-loop-circle :
     ( x y : type-descent-data-circle P) →
     map-equiv (aut-descent-data-circle P) x ＝ y →
-    dependent-identification Q
+    dependent-identification A
       ( loop-free-loop l)
       ( map-equiv α x)
       ( map-equiv α y)
@@ -312,18 +312,18 @@ module _
   is-equiv-map-compute-dependent-identification-loop-circle x y =
     fundamental-theorem-id
       ( is-contr-equiv'
-        ( fib (map-equiv α) (tr Q (loop-free-loop l) (map-equiv α x)))
+        ( fib (map-equiv α) (tr A (loop-free-loop l) (map-equiv α x)))
         ( equiv-fib _ _)
         ( is-contr-map-is-equiv
           ( is-equiv-map-equiv α)
-          ( tr Q (loop-free-loop l) (map-equiv α x))))
+          ( tr A (loop-free-loop l) (map-equiv α x))))
       ( map-compute-dependent-identification-loop-circle x)
       ( y)
 
   compute-dependent-identification-loop-circle :
     ( x y : type-descent-data-circle P) →
     ( map-equiv (aut-descent-data-circle P) x ＝ y) ≃
-    ( dependent-identification Q
+    ( dependent-identification A
       ( loop-free-loop l)
       ( map-equiv α x)
       ( map-equiv α y))
@@ -335,17 +335,17 @@ module _
 
 ```agda
 module _
-  { l1 l2 : Level} {X : UU l1} (l : free-loop X)
-  ( Q : X → UU l2) (P : descent-data-circle l2)
-  ( αH : Eq-descent-data-circle P (ev-descent-data-circle l Q))
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( A : S → UU l2) (P : descent-data-circle l2)
+  ( αH : Eq-descent-data-circle P (ev-descent-data-circle l A))
   where
 
   private
-    α : type-descent-data-circle P ≃ Q (base-free-loop l)
+    α : type-descent-data-circle P ≃ A (base-free-loop l)
     α = pr1 αH
 
   ev-fixpoint-descent-data-circle :
-    ( (x : X) → Q x) → fixpoint-descent-data-circle P
+    ( (x : S) → A x) → fixpoint-descent-data-circle P
   pr1 (ev-fixpoint-descent-data-circle s) =
     map-inv-equiv
       ( α)
@@ -354,50 +354,50 @@ module _
     map-inv-is-equiv
       ( is-equiv-map-compute-dependent-identification-loop-circle
         ( l)
-        ( Q)
+        ( A)
         ( P)
         ( αH)
         ( map-inv-equiv α (s (base-free-loop l)))
         ( map-inv-equiv α (s (base-free-loop l))))
       ( ( ap
-          ( tr Q (loop-free-loop l))
+          ( tr A (loop-free-loop l))
           ( is-section-map-inv-equiv α (s (base-free-loop l)))) ∙
         ( ( apd s (loop-free-loop l)) ∙
           ( inv (is-section-map-inv-equiv α (s (base-free-loop l))))))
 
   equiv-fixpoint-descent-data-circle-free-dependent-loop :
-    fixpoint-descent-data-circle P ≃ free-dependent-loop l Q
+    fixpoint-descent-data-circle P ≃ free-dependent-loop l A
   equiv-fixpoint-descent-data-circle-free-dependent-loop =
     equiv-Σ
-      ( λ x → dependent-identification Q (loop-free-loop l) x x)
+      ( λ x → dependent-identification A (loop-free-loop l) x x)
       ( α)
       ( λ x →
-        compute-dependent-identification-loop-circle l Q P αH x x)
+        compute-dependent-identification-loop-circle l A P αH x x)
 
   comparison-fixpoint-descent-data-circle :
-    fixpoint-descent-data-circle P → free-dependent-loop l Q
+    fixpoint-descent-data-circle P → free-dependent-loop l A
   comparison-fixpoint-descent-data-circle =
     map-equiv equiv-fixpoint-descent-data-circle-free-dependent-loop
 
   triangle-comparison-fixpoint-descent-data-circle :
     coherence-triangle-maps
-      ( ev-free-loop-Π l Q)
+      ( ev-free-loop-Π l A)
       ( comparison-fixpoint-descent-data-circle)
       ( ev-fixpoint-descent-data-circle)
   triangle-comparison-fixpoint-descent-data-circle s =
-    eq-Eq-free-dependent-loop l Q
-      ( ev-free-loop-Π l Q s)
+    eq-Eq-free-dependent-loop l A
+      ( ev-free-loop-Π l A s)
       ( ( comparison-fixpoint-descent-data-circle ∘
           ev-fixpoint-descent-data-circle)
         ( s))
       ( inv is-section-inv-α ,
         inv
         ( ( horizontal-concat-Id²
-            ( refl {x = ap (tr Q (loop-free-loop l)) (inv is-section-inv-α)})
+            ( refl {x = ap (tr A (loop-free-loop l)) (inv is-section-inv-α)})
             ( is-section-map-inv-is-equiv
               ( is-equiv-map-compute-dependent-identification-loop-circle
                 ( l)
-                ( Q)
+                ( A)
                 ( P)
                 ( αH)
                 ( map-inv-equiv α (s (base-free-loop l)))
@@ -406,7 +406,7 @@ module _
           ( ( inv (assoc (ap _ (inv is-section-inv-α)) _ _)) ∙
             ( horizontal-concat-Id²
               ( inv
-                ( ap-concat-eq (tr Q (loop-free-loop l))
+                ( ap-concat-eq (tr A (loop-free-loop l))
                   ( inv is-section-inv-α)
                   ( is-section-inv-α)
                   ( refl)
@@ -427,16 +427,16 @@ module _
     is-equiv ev-fixpoint-descent-data-circle
   is-equiv-ev-fixpoint-descent-data-circle dup-circle =
     is-equiv-right-factor-htpy
-      ( ev-free-loop-Π l Q)
+      ( ev-free-loop-Π l A)
       ( comparison-fixpoint-descent-data-circle)
       ( ev-fixpoint-descent-data-circle)
       ( triangle-comparison-fixpoint-descent-data-circle)
       ( is-equiv-comparison-fixpoint-descent-data-circle)
-      ( dup-circle Q)
+      ( dup-circle A)
 
   equiv-ev-fixpoint-descent-data-circle :
     ( dependent-universal-property-circle l2 l) →
-    ( (x : X) → Q x) ≃ (fixpoint-descent-data-circle P)
+    ( (x : S) → A x) ≃ (fixpoint-descent-data-circle P)
   pr1 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
     ev-fixpoint-descent-data-circle
   pr2 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
@@ -445,7 +445,7 @@ module _
   compute-ev-fixpoint-descent-data-circle :
     coherence-square-maps
       ( ev-fixpoint-descent-data-circle)
-      ( ev-point (base-free-loop l) {Q})
+      ( ev-point (base-free-loop l) {A})
       ( pr1)
       ( map-inv-equiv α)
   compute-ev-fixpoint-descent-data-circle = refl-htpy
@@ -458,40 +458,40 @@ automorphisms.
 
 ```agda
 module _
-  { l1 l2 l3 : Level} {X : UU l1} (l : free-loop X)
-  ( A : X → UU l2) (P : descent-data-circle l2)
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : S → UU l2) (P : descent-data-circle l2)
   ( αH : Eq-descent-data-circle P (ev-descent-data-circle l A))
-  ( B : X → UU l3) (Q : descent-data-circle l3)
+  ( B : S → UU l3) (Q : descent-data-circle l3)
   ( βK : Eq-descent-data-circle Q (ev-descent-data-circle l B))
   where
 
   private
-    Y : UU l2
-    Y = type-descent-data-circle P
-    e : Aut Y
+    X : UU l2
+    X = type-descent-data-circle P
+    e : Aut X
     e = aut-descent-data-circle P
-    Z : UU l3
-    Z = type-descent-data-circle Q
-    f : Aut Z
-    f = aut-descent-data-circle Q
-
-    α : Y ≃ A (base-free-loop l)
+    α : X ≃ A (base-free-loop l)
     α = pr1 αH
-    β : Z ≃ B (base-free-loop l)
+
+    Y : UU l3
+    Y = type-descent-data-circle Q
+    f : Aut Y
+    f = aut-descent-data-circle Q
+    β : Y ≃ B (base-free-loop l)
     β = pr1 βK
 
   descent-data-circle-function-type : descent-data-circle (l2 ⊔ l3)
   pr1 descent-data-circle-function-type =
-    Y → Z
+    X → Y
   pr2 descent-data-circle-function-type =
-    (equiv-postcomp Y f) ∘e (equiv-precomp (inv-equiv e) Z)
+    (equiv-postcomp X f) ∘e (equiv-precomp (inv-equiv e) Y)
 
   eq-descent-data-circle-function-type :
     Eq-descent-data-circle
       ( descent-data-circle-function-type)
       ( ev-descent-data-circle l (λ s → (A s → B s)))
   pr1 eq-descent-data-circle-function-type =
-    (equiv-postcomp (A (base-free-loop l)) β) ∘e (equiv-precomp (inv-equiv α) Z)
+    (equiv-postcomp (A (base-free-loop l)) β) ∘e (equiv-precomp (inv-equiv α) Y)
   pr2 eq-descent-data-circle-function-type h =
     ( eq-htpy
       ( htpy-comp-horizontal
@@ -521,7 +521,7 @@ module _
 
   equiv-ev-descent-data-circle-function-type-hom :
     dependent-universal-property-circle (l2 ⊔ l3) l →
-    ((s : X) → A s → B s) ≃ (hom-descent-data-circle P Q)
+    ((s : S) → A s → B s) ≃ (hom-descent-data-circle P Q)
   equiv-ev-descent-data-circle-function-type-hom dup-circle =
     equiv-fixpoint-descent-data-circle-function-type-hom ∘e
     ( equiv-ev-fixpoint-descent-data-circle

From 29e6bc52f9d5c0f2067b70a9fd76ca0c86572ead Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Wed, 23 Aug 2023 13:47:17 +0200
Subject: [PATCH 06/25] Define structures and helpers to work with descent data
 over the circle

---
 .../descent-circle.lagda.md                   | 439 +++++++++++++-----
 1 file changed, 330 insertions(+), 109 deletions(-)

diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index 96dccd77e8..8d13a17e4d 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -65,6 +65,9 @@ module _
 
   aut-descent-data-circle : Aut type-descent-data-circle
   aut-descent-data-circle = pr2 P
+
+  map-descent-data-circle : type-descent-data-circle → type-descent-data-circle
+  map-descent-data-circle = map-equiv aut-descent-data-circle
 ```
 
 ### Dependent descent data for the circle
@@ -83,7 +86,7 @@ dependent-descent-data-circle :
   ( l2 : Level) → UU (l1 ⊔ lsuc l2)
 dependent-descent-data-circle P l2 =
   Σ ( type-descent-data-circle P → UU l2)
-    ( λ R → equiv-fam R (R ∘ (map-equiv (aut-descent-data-circle P))))
+    ( λ R → equiv-fam R (R ∘ (map-descent-data-circle P)))
 
 module _
   { l1 l2 : Level} (P : descent-data-circle l1)
@@ -97,8 +100,15 @@ module _
     equiv-fam
       type-dependent-descent-data-circle
       ( type-dependent-descent-data-circle ∘
-        ( map-equiv (aut-descent-data-circle P)))
+        ( map-descent-data-circle P))
   equiv-dependent-descent-data-circle = pr2 Q
+
+  map-equiv-dependent-descent-data-circle :
+    ( x : type-descent-data-circle P) →
+    ( type-dependent-descent-data-circle x) →
+    ( type-dependent-descent-data-circle (map-descent-data-circle P x))
+  map-equiv-dependent-descent-data-circle x =
+    map-equiv (equiv-dependent-descent-data-circle x)
 ```
 
 ### Fixpoints of the descent data
@@ -111,7 +121,7 @@ fixpoint-descent-data-circle :
   ( P : descent-data-circle l1) → UU l1
 fixpoint-descent-data-circle P =
   Σ ( type-descent-data-circle P)
-    ( λ x → (map-equiv (aut-descent-data-circle P) x) ＝ x)
+    ( λ x → (map-descent-data-circle P x) ＝ x)
 ```
 
 ### Homomorphisms between descent data for the circle
@@ -129,8 +139,8 @@ hom-descent-data-circle P Q =
     ( λ h →
       coherence-square-maps
         ( h)
-        ( map-equiv (aut-descent-data-circle P))
-        ( map-equiv (aut-descent-data-circle Q))
+        ( map-descent-data-circle P)
+        ( map-descent-data-circle Q)
         ( h))
 ```
 
@@ -147,23 +157,170 @@ pr1 (ev-descent-data-circle l A) = A (base-free-loop l)
 pr2 (ev-descent-data-circle l A) = equiv-tr A (loop-free-loop l)
 ```
 
-## Properties
+### The identity type of descent data
 
-### Characterization of the identity type of descent data for the circle
+An equivalence between `(X, e)` and `(Y, f)` is a homomorphism between them,
+where the underlying map is an equivalence.
 
 ```agda
 Eq-descent-data-circle :
   { l1 l2 : Level} → descent-data-circle l1 → descent-data-circle l2 →
   UU (l1 ⊔ l2)
 Eq-descent-data-circle P Q =
-  Σ ( (type-descent-data-circle P) ≃ (type-descent-data-circle Q))
+  Σ ( type-descent-data-circle P ≃ type-descent-data-circle Q)
     ( λ h →
       coherence-square-maps
         ( map-equiv h)
-        ( map-equiv (aut-descent-data-circle P))
-        ( map-equiv (aut-descent-data-circle Q))
+        ( map-descent-data-circle P)
+        ( map-descent-data-circle Q)
         ( map-equiv h))
 
+module _
+  { l1 l2 : Level} (P : descent-data-circle l1) (Q : descent-data-circle l2)
+  ( αH : Eq-descent-data-circle P Q)
+  where
+
+  equiv-Eq-descent-data-circle :
+    type-descent-data-circle P ≃ type-descent-data-circle Q
+  equiv-Eq-descent-data-circle = pr1 αH
+
+  map-Eq-descent-data-circle :
+    type-descent-data-circle P → type-descent-data-circle Q
+  map-Eq-descent-data-circle = map-equiv equiv-Eq-descent-data-circle
+
+  coherence-square-Eq-descent-data-circle :
+    coherence-square-maps
+      ( map-equiv equiv-Eq-descent-data-circle)
+      ( map-descent-data-circle P)
+      ( map-descent-data-circle Q)
+      ( map-equiv equiv-Eq-descent-data-circle)
+  coherence-square-Eq-descent-data-circle = pr2 αH
+```
+
+### A family over the circle equipped with corresponding descent data
+
+A family for descent data `(X, e)` is a family over the circle, along with a
+proof that they are equivalent.
+
+Descent data for a family `A` is descent data with a proof that it's equivalent
+to `A`.
+
+A family with descent data is a family `A` over the circle, equipped with
+descent data `(X, e)`, and a proof of their equivalence.
+
+Ideally, every section characterizing descent data of a particular type family
+should include a term of type `family-with-descent-data-circle`, whose type
+family is the one being described.
+
+Note on naming: a `-for-` in a name indicates that the particular term contains
+a proof that it's somehow equivalent to the structure it's "for".
+
+```agda
+module _
+  { l1 : Level} {S : UU l1} (l : free-loop S)
+  where
+
+  family-for-descent-data-circle :
+    { l2 : Level} → descent-data-circle l2 → UU (l1 ⊔ lsuc l2)
+  family-for-descent-data-circle {l2} P =
+    Σ ( S → UU l2)
+      ( λ A →
+        Eq-descent-data-circle
+          ( P)
+          ( ev-descent-data-circle l A))
+
+  descent-data-circle-for-family :
+    { l2 : Level} → (S → UU l2) → UU (lsuc l2)
+  descent-data-circle-for-family {l2} A =
+    Σ ( descent-data-circle l2)
+      ( λ P →
+        Eq-descent-data-circle
+          ( P)
+          ( ev-descent-data-circle l A))
+
+  family-with-descent-data-circle :
+    ( l2 : Level) → UU (l1 ⊔ lsuc l2)
+  family-with-descent-data-circle l2 =
+    Σ ( S → UU l2) descent-data-circle-for-family
+
+module _
+  { l1 l2 : Level} {S : UU l1} {l : free-loop S}
+  ( A : family-with-descent-data-circle l l2)
+  where
+
+  family-family-with-descent-data-circle : S → UU l2
+  family-family-with-descent-data-circle = pr1 A
+
+  descent-data-for-family-with-descent-data-circle :
+    descent-data-circle-for-family l
+      family-family-with-descent-data-circle
+  descent-data-for-family-with-descent-data-circle = pr2 A
+
+  descent-data-family-with-descent-data-circle : descent-data-circle l2
+  descent-data-family-with-descent-data-circle =
+    pr1 descent-data-for-family-with-descent-data-circle
+
+  type-family-with-descent-data-circle : UU l2
+  type-family-with-descent-data-circle =
+    type-descent-data-circle descent-data-family-with-descent-data-circle
+
+  aut-family-with-descent-data-circle : Aut type-family-with-descent-data-circle
+  aut-family-with-descent-data-circle =
+    aut-descent-data-circle descent-data-family-with-descent-data-circle
+
+  map-aut-family-with-descent-data-circle :
+    type-family-with-descent-data-circle → type-family-with-descent-data-circle
+  map-aut-family-with-descent-data-circle =
+    map-descent-data-circle descent-data-family-with-descent-data-circle
+
+  eq-family-with-descent-data-circle :
+    Eq-descent-data-circle
+      ( descent-data-family-with-descent-data-circle)
+      ( ev-descent-data-circle l family-family-with-descent-data-circle)
+  eq-family-with-descent-data-circle =
+    pr2 descent-data-for-family-with-descent-data-circle
+
+  equiv-family-with-descent-data-circle :
+    type-family-with-descent-data-circle ≃
+    family-family-with-descent-data-circle (base-free-loop l)
+  equiv-family-with-descent-data-circle =
+    equiv-Eq-descent-data-circle
+      ( descent-data-family-with-descent-data-circle)
+      ( ev-descent-data-circle l family-family-with-descent-data-circle)
+      ( eq-family-with-descent-data-circle)
+
+  map-equiv-family-with-descent-data-circle :
+    type-family-with-descent-data-circle →
+    family-family-with-descent-data-circle (base-free-loop l)
+  map-equiv-family-with-descent-data-circle =
+    map-equiv equiv-family-with-descent-data-circle
+
+  coherence-square-family-with-descent-data-circle :
+    coherence-square-maps
+      ( map-equiv-family-with-descent-data-circle)
+      ( map-aut-family-with-descent-data-circle)
+      ( tr family-family-with-descent-data-circle (loop-free-loop l))
+      ( map-equiv-family-with-descent-data-circle)
+  coherence-square-family-with-descent-data-circle =
+    coherence-square-Eq-descent-data-circle
+      ( descent-data-family-with-descent-data-circle)
+      ( ev-descent-data-circle l family-family-with-descent-data-circle)
+      ( eq-family-with-descent-data-circle)
+
+  family-for-family-with-descent-data-circle :
+    family-for-descent-data-circle l
+      descent-data-family-with-descent-data-circle
+  pr1 family-for-family-with-descent-data-circle =
+    family-family-with-descent-data-circle
+  pr2 family-for-family-with-descent-data-circle =
+    eq-family-with-descent-data-circle
+```
+
+## Properties
+
+### Characterization of the identity type of descent data for the circle
+
+```agda
 refl-Eq-descent-data-circle :
   { l1 : Level} (P : descent-data-circle l1) →
   Eq-descent-data-circle P P
@@ -182,7 +339,7 @@ is-contr-total-Eq-descent-data-circle P =
     ( λ Y f h →
       coherence-square-maps
         ( map-equiv h)
-        ( map-equiv (aut-descent-data-circle P))
+        ( map-descent-data-circle P)
         ( map-equiv f)
         ( map-equiv h))
     ( is-contr-total-equiv (type-descent-data-circle P))
@@ -247,10 +404,7 @@ unique-family-property-circle :
   { l1 : Level} (l2 : Level) {S : UU l1} (l : free-loop S) →
   UU (l1 ⊔ lsuc l2)
 unique-family-property-circle l2 {S} l =
-  ( Q : descent-data-circle l2) →
-    is-contr
-    ( Σ (S → UU l2)
-        (λ A → Eq-descent-data-circle Q (ev-descent-data-circle l A)))
+  ( Q : descent-data-circle l2) → is-contr (family-for-descent-data-circle l Q)
 
 module _
   { l1 l2 : Level} {S : UU l1} (l : free-loop S)
@@ -288,45 +442,50 @@ automorphism from the characteristic descent data.
 ```agda
 module _
   { l1 l2 : Level} {S : UU l1} (l : free-loop S)
-  ( A : S → UU l2) (P : descent-data-circle l2)
-  ( αH : Eq-descent-data-circle P (ev-descent-data-circle l A))
+  ( A : family-with-descent-data-circle l l2)
   where
 
-  private
-    α : type-descent-data-circle P ≃ A (base-free-loop l)
-    α = pr1 αH
-
   map-compute-dependent-identification-loop-circle :
-    ( x y : type-descent-data-circle P) →
-    map-equiv (aut-descent-data-circle P) x ＝ y →
-    dependent-identification A
+    ( x y : type-family-with-descent-data-circle A) →
+    map-aut-family-with-descent-data-circle A x ＝ y →
+    dependent-identification (family-family-with-descent-data-circle A)
       ( loop-free-loop l)
-      ( map-equiv α x)
-      ( map-equiv α y)
+      ( map-equiv-family-with-descent-data-circle A x)
+      ( map-equiv-family-with-descent-data-circle A y)
   map-compute-dependent-identification-loop-circle x y q =
-    inv (pr2 αH x) ∙ (ap (map-equiv α) q)
+    inv (coherence-square-family-with-descent-data-circle A x) ∙
+    ( ap (map-equiv-family-with-descent-data-circle A) q)
 
   is-equiv-map-compute-dependent-identification-loop-circle :
-    ( x y : type-descent-data-circle P) →
+    ( x y : type-family-with-descent-data-circle A) →
     is-equiv (map-compute-dependent-identification-loop-circle x y)
   is-equiv-map-compute-dependent-identification-loop-circle x y =
     fundamental-theorem-id
       ( is-contr-equiv'
-        ( fib (map-equiv α) (tr A (loop-free-loop l) (map-equiv α x)))
+        ( fib
+          ( map-equiv-family-with-descent-data-circle A)
+          ( tr
+            ( family-family-with-descent-data-circle A)
+            ( loop-free-loop l)
+            ( map-equiv-family-with-descent-data-circle A x)))
         ( equiv-fib _ _)
         ( is-contr-map-is-equiv
-          ( is-equiv-map-equiv α)
-          ( tr A (loop-free-loop l) (map-equiv α x))))
+          ( is-equiv-map-equiv (equiv-family-with-descent-data-circle A))
+          ( tr
+            ( family-family-with-descent-data-circle A)
+            ( loop-free-loop l)
+            ( map-equiv-family-with-descent-data-circle A x))))
       ( map-compute-dependent-identification-loop-circle x)
       ( y)
 
   compute-dependent-identification-loop-circle :
-    ( x y : type-descent-data-circle P) →
-    ( map-equiv (aut-descent-data-circle P) x ＝ y) ≃
-    ( dependent-identification A
+    ( x y : type-family-with-descent-data-circle A) →
+    ( map-aut-family-with-descent-data-circle A x ＝ y) ≃
+    ( dependent-identification
+      ( family-family-with-descent-data-circle A)
       ( loop-free-loop l)
-      ( map-equiv α x)
-      ( map-equiv α y))
+      ( map-equiv-family-with-descent-data-circle A x)
+      ( map-equiv-family-with-descent-data-circle A y))
   pr1 (compute-dependent-identification-loop-circle x y) =
     map-compute-dependent-identification-loop-circle x y
   pr2 (compute-dependent-identification-loop-circle x y) =
@@ -336,77 +495,100 @@ module _
 ```agda
 module _
   { l1 l2 : Level} {S : UU l1} (l : free-loop S)
-  ( A : S → UU l2) (P : descent-data-circle l2)
-  ( αH : Eq-descent-data-circle P (ev-descent-data-circle l A))
+  ( A : family-with-descent-data-circle l l2)
   where
 
-  private
-    α : type-descent-data-circle P ≃ A (base-free-loop l)
-    α = pr1 αH
-
   ev-fixpoint-descent-data-circle :
-    ( (x : S) → A x) → fixpoint-descent-data-circle P
+    ( (x : S) → family-family-with-descent-data-circle A x) →
+    ( fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A))
   pr1 (ev-fixpoint-descent-data-circle s) =
     map-inv-equiv
-      ( α)
+      ( equiv-family-with-descent-data-circle A)
       ( s (base-free-loop l))
   pr2 (ev-fixpoint-descent-data-circle s) =
     map-inv-is-equiv
       ( is-equiv-map-compute-dependent-identification-loop-circle
         ( l)
         ( A)
-        ( P)
-        ( αH)
-        ( map-inv-equiv α (s (base-free-loop l)))
-        ( map-inv-equiv α (s (base-free-loop l))))
+        ( map-inv-equiv
+          ( equiv-family-with-descent-data-circle A)
+          ( s (base-free-loop l)))
+        ( map-inv-equiv
+          ( equiv-family-with-descent-data-circle A)
+          ( s (base-free-loop l))))
       ( ( ap
-          ( tr A (loop-free-loop l))
-          ( is-section-map-inv-equiv α (s (base-free-loop l)))) ∙
+          ( tr (family-family-with-descent-data-circle A) (loop-free-loop l))
+          ( is-section-map-inv-equiv
+            ( equiv-family-with-descent-data-circle A)
+            ( s (base-free-loop l)))) ∙
         ( ( apd s (loop-free-loop l)) ∙
-          ( inv (is-section-map-inv-equiv α (s (base-free-loop l))))))
+          ( inv
+            ( is-section-map-inv-equiv
+              ( equiv-family-with-descent-data-circle A)
+              ( s (base-free-loop l))))))
 
   equiv-fixpoint-descent-data-circle-free-dependent-loop :
-    fixpoint-descent-data-circle P ≃ free-dependent-loop l A
+    ( fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)) ≃
+    ( free-dependent-loop l (family-family-with-descent-data-circle A))
   equiv-fixpoint-descent-data-circle-free-dependent-loop =
     equiv-Σ
-      ( λ x → dependent-identification A (loop-free-loop l) x x)
-      ( α)
       ( λ x →
-        compute-dependent-identification-loop-circle l A P αH x x)
+        dependent-identification
+          ( family-family-with-descent-data-circle A)
+          ( loop-free-loop l)
+          ( x)
+          ( x))
+      ( equiv-family-with-descent-data-circle A)
+      ( λ x →
+        compute-dependent-identification-loop-circle l A x x)
 
   comparison-fixpoint-descent-data-circle :
-    fixpoint-descent-data-circle P → free-dependent-loop l A
+    ( fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)) →
+    ( free-dependent-loop l (family-family-with-descent-data-circle A))
   comparison-fixpoint-descent-data-circle =
     map-equiv equiv-fixpoint-descent-data-circle-free-dependent-loop
 
   triangle-comparison-fixpoint-descent-data-circle :
     coherence-triangle-maps
-      ( ev-free-loop-Π l A)
+      ( ev-free-loop-Π l (family-family-with-descent-data-circle A))
       ( comparison-fixpoint-descent-data-circle)
       ( ev-fixpoint-descent-data-circle)
   triangle-comparison-fixpoint-descent-data-circle s =
-    eq-Eq-free-dependent-loop l A
-      ( ev-free-loop-Π l A s)
+    eq-Eq-free-dependent-loop l
+      ( family-family-with-descent-data-circle A)
+      ( ev-free-loop-Π l (family-family-with-descent-data-circle A) s)
       ( ( comparison-fixpoint-descent-data-circle ∘
           ev-fixpoint-descent-data-circle)
         ( s))
       ( inv is-section-inv-α ,
         inv
         ( ( horizontal-concat-Id²
-            ( refl {x = ap (tr A (loop-free-loop l)) (inv is-section-inv-α)})
+            ( refl
+              { x =
+                ap
+                  ( tr
+                    ( family-family-with-descent-data-circle A)
+                    ( loop-free-loop l))
+                  ( inv is-section-inv-α)})
             ( is-section-map-inv-is-equiv
               ( is-equiv-map-compute-dependent-identification-loop-circle
                 ( l)
                 ( A)
-                ( P)
-                ( αH)
-                ( map-inv-equiv α (s (base-free-loop l)))
+                ( map-inv-equiv
+                  ( equiv-family-with-descent-data-circle A)
+                  ( s (base-free-loop l)))
                 ( pr1 (ev-fixpoint-descent-data-circle s)))
               ( _))) ∙
           ( ( inv (assoc (ap _ (inv is-section-inv-α)) _ _)) ∙
             ( horizontal-concat-Id²
               ( inv
-                ( ap-concat-eq (tr A (loop-free-loop l))
+                ( ap-concat-eq
+                  ( tr
+                    ( family-family-with-descent-data-circle A)
+                    ( loop-free-loop l))
                   ( inv is-section-inv-α)
                   ( is-section-inv-α)
                   ( refl)
@@ -414,8 +596,15 @@ module _
               ( refl)))))
     where
     is-section-inv-α :
-      eq-value (map-equiv α ∘ map-inv-equiv α) id (s (base-free-loop l))
-    is-section-inv-α = is-section-map-inv-equiv α (s (base-free-loop l))
+      eq-value
+        ( map-equiv-family-with-descent-data-circle A ∘
+          map-inv-equiv (equiv-family-with-descent-data-circle A))
+        ( id)
+        ( s (base-free-loop l))
+    is-section-inv-α =
+      is-section-map-inv-equiv
+        ( equiv-family-with-descent-data-circle A)
+        ( s (base-free-loop l))
 
   is-equiv-comparison-fixpoint-descent-data-circle :
     is-equiv comparison-fixpoint-descent-data-circle
@@ -427,16 +616,18 @@ module _
     is-equiv ev-fixpoint-descent-data-circle
   is-equiv-ev-fixpoint-descent-data-circle dup-circle =
     is-equiv-right-factor-htpy
-      ( ev-free-loop-Π l A)
+      ( ev-free-loop-Π l (family-family-with-descent-data-circle A))
       ( comparison-fixpoint-descent-data-circle)
       ( ev-fixpoint-descent-data-circle)
       ( triangle-comparison-fixpoint-descent-data-circle)
       ( is-equiv-comparison-fixpoint-descent-data-circle)
-      ( dup-circle A)
+      ( dup-circle (family-family-with-descent-data-circle A))
 
   equiv-ev-fixpoint-descent-data-circle :
     ( dependent-universal-property-circle l2 l) →
-    ( (x : S) → A x) ≃ (fixpoint-descent-data-circle P)
+    ( (x : S) → (family-family-with-descent-data-circle A) x) ≃
+    ( fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A))
   pr1 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
     ev-fixpoint-descent-data-circle
   pr2 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
@@ -445,9 +636,9 @@ module _
   compute-ev-fixpoint-descent-data-circle :
     coherence-square-maps
       ( ev-fixpoint-descent-data-circle)
-      ( ev-point (base-free-loop l) {A})
+      ( ev-point (base-free-loop l))
       ( pr1)
-      ( map-inv-equiv α)
+      ( map-inv-equiv (equiv-family-with-descent-data-circle A))
   compute-ev-fixpoint-descent-data-circle = refl-htpy
 ```
 
@@ -459,75 +650,105 @@ automorphisms.
 ```agda
 module _
   { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
-  ( A : S → UU l2) (P : descent-data-circle l2)
-  ( αH : Eq-descent-data-circle P (ev-descent-data-circle l A))
-  ( B : S → UU l3) (Q : descent-data-circle l3)
-  ( βK : Eq-descent-data-circle Q (ev-descent-data-circle l B))
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
   where
 
-  private
-    X : UU l2
-    X = type-descent-data-circle P
-    e : Aut X
-    e = aut-descent-data-circle P
-    α : X ≃ A (base-free-loop l)
-    α = pr1 αH
-
-    Y : UU l3
-    Y = type-descent-data-circle Q
-    f : Aut Y
-    f = aut-descent-data-circle Q
-    β : Y ≃ B (base-free-loop l)
-    β = pr1 βK
-
   descent-data-circle-function-type : descent-data-circle (l2 ⊔ l3)
   pr1 descent-data-circle-function-type =
-    X → Y
+    type-family-with-descent-data-circle A →
+    type-family-with-descent-data-circle B
   pr2 descent-data-circle-function-type =
-    (equiv-postcomp X f) ∘e (equiv-precomp (inv-equiv e) Y)
+    ( equiv-postcomp
+      ( type-family-with-descent-data-circle A)
+      ( aut-family-with-descent-data-circle B)) ∘e
+    ( equiv-precomp
+      ( inv-equiv (aut-family-with-descent-data-circle A))
+      ( type-family-with-descent-data-circle B))
 
   eq-descent-data-circle-function-type :
     Eq-descent-data-circle
       ( descent-data-circle-function-type)
-      ( ev-descent-data-circle l (λ s → (A s → B s)))
+      ( ev-descent-data-circle
+        ( l)
+        ( λ s →
+          ( family-family-with-descent-data-circle A s →
+            family-family-with-descent-data-circle B s)))
   pr1 eq-descent-data-circle-function-type =
-    (equiv-postcomp (A (base-free-loop l)) β) ∘e (equiv-precomp (inv-equiv α) Y)
+    ( equiv-postcomp
+      ( family-family-with-descent-data-circle A (base-free-loop l))
+      ( equiv-family-with-descent-data-circle B)) ∘e
+    ( equiv-precomp
+      ( inv-equiv (equiv-family-with-descent-data-circle A))
+      ( type-family-with-descent-data-circle B))
   pr2 eq-descent-data-circle-function-type h =
     ( eq-htpy
       ( htpy-comp-horizontal
         ( h ·l
           inv-htpy
             ( coherence-square-inv-all
-              ( α)
-              ( e)
-              ( equiv-tr A (loop-free-loop l))
-              ( α)
-              ( pr2 αH)))
-        ( pr2 βK))) ∙
+              ( equiv-family-with-descent-data-circle A)
+              ( aut-family-with-descent-data-circle A)
+              ( equiv-tr
+                ( family-family-with-descent-data-circle A)
+                ( loop-free-loop l))
+              ( equiv-family-with-descent-data-circle A)
+              ( coherence-square-family-with-descent-data-circle A)))
+        ( coherence-square-family-with-descent-data-circle B))) ∙
     ( inv
-      ( ( tr-function-type A B (loop-free-loop l))
-        ( map-equiv (pr1 eq-descent-data-circle-function-type) h)))
+      ( ( tr-function-type
+          ( family-family-with-descent-data-circle A)
+          ( family-family-with-descent-data-circle B) (loop-free-loop l))
+        ( map-Eq-descent-data-circle
+          ( descent-data-circle-function-type)
+          ( ev-descent-data-circle
+            ( l)
+            ( λ s →
+              ( family-family-with-descent-data-circle A s →
+                family-family-with-descent-data-circle B s)))
+          ( eq-descent-data-circle-function-type)
+          ( h))))
+
+  family-with-descent-data-circle-function-type :
+    family-with-descent-data-circle l (l2 ⊔ l3)
+  pr1 family-with-descent-data-circle-function-type x =
+    family-family-with-descent-data-circle A x →
+    family-family-with-descent-data-circle B x
+  pr1 (pr2 family-with-descent-data-circle-function-type) =
+    descent-data-circle-function-type
+  pr2 (pr2 family-with-descent-data-circle-function-type) =
+    eq-descent-data-circle-function-type
 
   equiv-fixpoint-descent-data-circle-function-type-hom :
     fixpoint-descent-data-circle descent-data-circle-function-type ≃
-    hom-descent-data-circle P Q
+    hom-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( descent-data-family-with-descent-data-circle B)
   equiv-fixpoint-descent-data-circle-function-type-hom =
     equiv-tot
       (λ h →
-        ( equiv-inv-htpy (((map-equiv f) ∘ h)) (h ∘ (map-equiv e))) ∘e
+        ( equiv-inv-htpy
+          ( map-aut-family-with-descent-data-circle B ∘ h)
+          ( h ∘ map-aut-family-with-descent-data-circle A)) ∘e
         ( ( inv-equiv
-            ( equiv-coherence-triangle-maps-inv-top ((map-equiv f) ∘ h) h e)) ∘e
+            ( equiv-coherence-triangle-maps-inv-top
+              ( map-aut-family-with-descent-data-circle B ∘ h)
+              ( h)
+              ( aut-family-with-descent-data-circle A))) ∘e
           ( equiv-funext)))
 
   equiv-ev-descent-data-circle-function-type-hom :
     dependent-universal-property-circle (l2 ⊔ l3) l →
-    ((s : S) → A s → B s) ≃ (hom-descent-data-circle P Q)
+    ( (x : S) →
+      family-family-with-descent-data-circle A x →
+      family-family-with-descent-data-circle B x) ≃
+    hom-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( descent-data-family-with-descent-data-circle B)
   equiv-ev-descent-data-circle-function-type-hom dup-circle =
     equiv-fixpoint-descent-data-circle-function-type-hom ∘e
     ( equiv-ev-fixpoint-descent-data-circle
       ( l)
-      ( λ s → A s → B s)
-      ( descent-data-circle-function-type)
-      ( eq-descent-data-circle-function-type)
+      ( family-with-descent-data-circle-function-type)
       ( dup-circle))
 ```

From 6a0101a7c4e0fe0a2f637ba14e23e6df57dc952e Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Wed, 23 Aug 2023 14:47:41 +0200
Subject: [PATCH 07/25] Nix: update mdbook-catppuccin

---
 flake.lock | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/flake.lock b/flake.lock
index 9584bfe814..b65861621d 100644
--- a/flake.lock
+++ b/flake.lock
@@ -103,11 +103,11 @@
         ]
       },
       "locked": {
-        "lastModified": 1689783639,
-        "narHash": "sha256-k6ExUOrKdlqfdhbdRLHYay0tAqSLcteQj/78qQ+l7kI=",
+        "lastModified": 1690590452,
+        "narHash": "sha256-d7jaMDFjlVoomGYjdxECpe+7xcLzQiF6LVLJSHj6q20=",
         "owner": "catppuccin",
         "repo": "mdBook",
-        "rev": "7616df4bfc8f63e44e4a9f6fc1849c975fd0fc03",
+        "rev": "b6a45ab31ac1f91d82b5302ab4f030bb0a751877",
         "type": "github"
       },
       "original": {

From 0d4e3c740585c90ddc4eff8348e69d622527a4a8 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Wed, 23 Aug 2023 15:38:31 +0200
Subject: [PATCH 08/25] Move descent data of function types to its own file

---
 src/synthetic-homotopy-theory.lagda.md        |   1 +
 .../descent-circle-function-types.lagda.md    | 166 ++++++++++++++++++
 .../descent-circle.lagda.md                   | 111 ------------
 3 files changed, 167 insertions(+), 111 deletions(-)
 create mode 100644 src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md

diff --git a/src/synthetic-homotopy-theory.lagda.md b/src/synthetic-homotopy-theory.lagda.md
index f570c1b178..d779e93e7d 100644
--- a/src/synthetic-homotopy-theory.lagda.md
+++ b/src/synthetic-homotopy-theory.lagda.md
@@ -20,6 +20,7 @@ open import synthetic-homotopy-theory.dependent-cocones-under-spans public
 open import synthetic-homotopy-theory.dependent-pullback-property-pushouts public
 open import synthetic-homotopy-theory.dependent-universal-property-pushouts public
 open import synthetic-homotopy-theory.descent-circle public
+open import synthetic-homotopy-theory.descent-circle-function-types public
 open import synthetic-homotopy-theory.double-loop-spaces public
 open import synthetic-homotopy-theory.free-loops public
 open import synthetic-homotopy-theory.functoriality-loop-spaces public
diff --git a/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
new file mode 100644
index 0000000000..e0ec3f8a14
--- /dev/null
+++ b/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
@@ -0,0 +1,166 @@
+# Descent data for function types over the circle
+
+```agda
+module synthetic-homotopy-theory.descent-circle-function-types where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.commuting-squares-of-maps
+open import foundation.commuting-triangles-of-maps
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.function-extensionality
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.functoriality-function-types
+open import foundation.homotopies
+open import foundation.identity-types
+open import foundation.transport
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.descent-circle
+open import synthetic-homotopy-theory.free-loops
+open import synthetic-homotopy-theory.universal-property-circle
+```
+
+</details>
+
+## Idea
+
+Given two families `A, B : 𝕊¹ → U` over the circle, the
+[descent data](synthetic-homotopy-theory.descent-circle.md) for the family
+`λ t → (A t → B t)` is `(X → Y, λ h → f ∘ h ∘ e⁻¹)`, where `(X, e)` is descent
+data for `A` and `(Y, f)` is descent data for `B`.
+
+This correspondence allows us to characterize sections of this family as
+homomorphisms from `(X, e)` to `(Y, f)`.
+
+## Definitions
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
+  family-descent-data-circle-function-type : S → UU (l2 ⊔ l3)
+  family-descent-data-circle-function-type x =
+    family-family-with-descent-data-circle A x →
+    family-family-with-descent-data-circle B x
+
+  descent-data-circle-function-type : descent-data-circle (l2 ⊔ l3)
+  pr1 descent-data-circle-function-type =
+    type-family-with-descent-data-circle A →
+    type-family-with-descent-data-circle B
+  pr2 descent-data-circle-function-type =
+    ( equiv-postcomp
+      ( type-family-with-descent-data-circle A)
+      ( aut-family-with-descent-data-circle B)) ∘e
+    ( equiv-precomp
+      ( inv-equiv (aut-family-with-descent-data-circle A))
+      ( type-family-with-descent-data-circle B))
+```
+
+## Properties
+
+### Characterization of descent data for function types over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
+  eq-descent-data-circle-function-type :
+    Eq-descent-data-circle
+      ( descent-data-circle-function-type l A B)
+      ( ev-descent-data-circle
+        ( l)
+        ( family-descent-data-circle-function-type l A B))
+  pr1 eq-descent-data-circle-function-type =
+    ( equiv-postcomp
+      ( family-family-with-descent-data-circle A (base-free-loop l))
+      ( equiv-family-with-descent-data-circle B)) ∘e
+    ( equiv-precomp
+      ( inv-equiv (equiv-family-with-descent-data-circle A))
+      ( type-family-with-descent-data-circle B))
+  pr2 eq-descent-data-circle-function-type h =
+    ( eq-htpy
+      ( htpy-comp-horizontal
+        ( h ·l
+          inv-htpy
+            ( coherence-square-inv-all
+              ( equiv-family-with-descent-data-circle A)
+              ( aut-family-with-descent-data-circle A)
+              ( equiv-tr
+                ( family-family-with-descent-data-circle A)
+                ( loop-free-loop l))
+              ( equiv-family-with-descent-data-circle A)
+              ( coherence-square-family-with-descent-data-circle A)))
+        ( coherence-square-family-with-descent-data-circle B))) ∙
+    ( inv
+      ( ( tr-function-type
+          ( family-family-with-descent-data-circle A)
+          ( family-family-with-descent-data-circle B) (loop-free-loop l))
+        ( map-Eq-descent-data-circle
+          ( descent-data-circle-function-type l A B)
+          ( ev-descent-data-circle
+            ( l)
+            ( family-descent-data-circle-function-type l A B))
+          ( eq-descent-data-circle-function-type)
+          ( h))))
+
+  family-with-descent-data-circle-function-type :
+    family-with-descent-data-circle l (l2 ⊔ l3)
+  pr1 family-with-descent-data-circle-function-type =
+    family-descent-data-circle-function-type l A B
+  pr1 (pr2 family-with-descent-data-circle-function-type) =
+    descent-data-circle-function-type l A B
+  pr2 (pr2 family-with-descent-data-circle-function-type) =
+    eq-descent-data-circle-function-type
+```
+
+### Maps between families over the circle are equivalent to homomorphisms between the families' descent data
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
+  equiv-fixpoint-descent-data-circle-function-type-hom :
+    fixpoint-descent-data-circle (descent-data-circle-function-type l A B) ≃
+    hom-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( descent-data-family-with-descent-data-circle B)
+  equiv-fixpoint-descent-data-circle-function-type-hom =
+    equiv-tot
+      ( λ h →
+        ( equiv-inv-htpy
+          ( map-aut-family-with-descent-data-circle B ∘ h)
+          ( h ∘ map-aut-family-with-descent-data-circle A)) ∘e
+        ( ( inv-equiv
+            ( equiv-coherence-triangle-maps-inv-top
+              ( map-aut-family-with-descent-data-circle B ∘ h)
+              ( h)
+              ( aut-family-with-descent-data-circle A))) ∘e
+          ( equiv-funext)))
+
+  equiv-ev-descent-data-circle-function-type-hom :
+    dependent-universal-property-circle (l2 ⊔ l3) l →
+    ( (x : S) → family-descent-data-circle-function-type l A B x) ≃
+    hom-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( descent-data-family-with-descent-data-circle B)
+  equiv-ev-descent-data-circle-function-type-hom dup-circle =
+    equiv-fixpoint-descent-data-circle-function-type-hom ∘e
+    ( equiv-ev-fixpoint-descent-data-circle
+      ( l)
+      ( family-with-descent-data-circle-function-type l A B)
+      ( dup-circle))
+```
diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index 8d13a17e4d..12dd81cc1f 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -22,7 +22,6 @@ open import foundation.fibers-of-maps
 open import foundation.function-extensionality
 open import foundation.function-types
 open import foundation.functoriality-dependent-pair-types
-open import foundation.functoriality-function-types
 open import foundation.fundamental-theorem-of-identity-types
 open import foundation.homotopies
 open import foundation.identity-types
@@ -642,113 +641,3 @@ module _
   compute-ev-fixpoint-descent-data-circle = refl-htpy
 ```
 
-### Characterization of families of maps over the circle
-
-Families of maps over the circle are maps commuting with the respective
-automorphisms.
-
-```agda
-module _
-  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
-  ( A : family-with-descent-data-circle l l2)
-  ( B : family-with-descent-data-circle l l3)
-  where
-
-  descent-data-circle-function-type : descent-data-circle (l2 ⊔ l3)
-  pr1 descent-data-circle-function-type =
-    type-family-with-descent-data-circle A →
-    type-family-with-descent-data-circle B
-  pr2 descent-data-circle-function-type =
-    ( equiv-postcomp
-      ( type-family-with-descent-data-circle A)
-      ( aut-family-with-descent-data-circle B)) ∘e
-    ( equiv-precomp
-      ( inv-equiv (aut-family-with-descent-data-circle A))
-      ( type-family-with-descent-data-circle B))
-
-  eq-descent-data-circle-function-type :
-    Eq-descent-data-circle
-      ( descent-data-circle-function-type)
-      ( ev-descent-data-circle
-        ( l)
-        ( λ s →
-          ( family-family-with-descent-data-circle A s →
-            family-family-with-descent-data-circle B s)))
-  pr1 eq-descent-data-circle-function-type =
-    ( equiv-postcomp
-      ( family-family-with-descent-data-circle A (base-free-loop l))
-      ( equiv-family-with-descent-data-circle B)) ∘e
-    ( equiv-precomp
-      ( inv-equiv (equiv-family-with-descent-data-circle A))
-      ( type-family-with-descent-data-circle B))
-  pr2 eq-descent-data-circle-function-type h =
-    ( eq-htpy
-      ( htpy-comp-horizontal
-        ( h ·l
-          inv-htpy
-            ( coherence-square-inv-all
-              ( equiv-family-with-descent-data-circle A)
-              ( aut-family-with-descent-data-circle A)
-              ( equiv-tr
-                ( family-family-with-descent-data-circle A)
-                ( loop-free-loop l))
-              ( equiv-family-with-descent-data-circle A)
-              ( coherence-square-family-with-descent-data-circle A)))
-        ( coherence-square-family-with-descent-data-circle B))) ∙
-    ( inv
-      ( ( tr-function-type
-          ( family-family-with-descent-data-circle A)
-          ( family-family-with-descent-data-circle B) (loop-free-loop l))
-        ( map-Eq-descent-data-circle
-          ( descent-data-circle-function-type)
-          ( ev-descent-data-circle
-            ( l)
-            ( λ s →
-              ( family-family-with-descent-data-circle A s →
-                family-family-with-descent-data-circle B s)))
-          ( eq-descent-data-circle-function-type)
-          ( h))))
-
-  family-with-descent-data-circle-function-type :
-    family-with-descent-data-circle l (l2 ⊔ l3)
-  pr1 family-with-descent-data-circle-function-type x =
-    family-family-with-descent-data-circle A x →
-    family-family-with-descent-data-circle B x
-  pr1 (pr2 family-with-descent-data-circle-function-type) =
-    descent-data-circle-function-type
-  pr2 (pr2 family-with-descent-data-circle-function-type) =
-    eq-descent-data-circle-function-type
-
-  equiv-fixpoint-descent-data-circle-function-type-hom :
-    fixpoint-descent-data-circle descent-data-circle-function-type ≃
-    hom-descent-data-circle
-      ( descent-data-family-with-descent-data-circle A)
-      ( descent-data-family-with-descent-data-circle B)
-  equiv-fixpoint-descent-data-circle-function-type-hom =
-    equiv-tot
-      (λ h →
-        ( equiv-inv-htpy
-          ( map-aut-family-with-descent-data-circle B ∘ h)
-          ( h ∘ map-aut-family-with-descent-data-circle A)) ∘e
-        ( ( inv-equiv
-            ( equiv-coherence-triangle-maps-inv-top
-              ( map-aut-family-with-descent-data-circle B ∘ h)
-              ( h)
-              ( aut-family-with-descent-data-circle A))) ∘e
-          ( equiv-funext)))
-
-  equiv-ev-descent-data-circle-function-type-hom :
-    dependent-universal-property-circle (l2 ⊔ l3) l →
-    ( (x : S) →
-      family-family-with-descent-data-circle A x →
-      family-family-with-descent-data-circle B x) ≃
-    hom-descent-data-circle
-      ( descent-data-family-with-descent-data-circle A)
-      ( descent-data-family-with-descent-data-circle B)
-  equiv-ev-descent-data-circle-function-type-hom dup-circle =
-    equiv-fixpoint-descent-data-circle-function-type-hom ∘e
-    ( equiv-ev-fixpoint-descent-data-circle
-      ( l)
-      ( family-with-descent-data-circle-function-type)
-      ( dup-circle))
-```

From 1cce09c16294a99b90e83e58512c104cfb8a374a Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Wed, 23 Aug 2023 18:37:51 +0200
Subject: [PATCH 09/25] Move sections of families over the circle to its own
 file

---
 src/synthetic-homotopy-theory.lagda.md        |   1 +
 .../descent-circle-function-types.lagda.md    |   1 +
 .../descent-circle.lagda.md                   | 234 +---------------
 .../sections-descent-circle.lagda.md          | 261 ++++++++++++++++++
 4 files changed, 267 insertions(+), 230 deletions(-)
 create mode 100644 src/synthetic-homotopy-theory/sections-descent-circle.lagda.md

diff --git a/src/synthetic-homotopy-theory.lagda.md b/src/synthetic-homotopy-theory.lagda.md
index d779e93e7d..8b516194c9 100644
--- a/src/synthetic-homotopy-theory.lagda.md
+++ b/src/synthetic-homotopy-theory.lagda.md
@@ -41,6 +41,7 @@ open import synthetic-homotopy-theory.prespectra public
 open import synthetic-homotopy-theory.pullback-property-pushouts public
 open import synthetic-homotopy-theory.pushouts public
 open import synthetic-homotopy-theory.pushouts-of-pointed-types public
+open import synthetic-homotopy-theory.sections-descent-circle public
 open import synthetic-homotopy-theory.smash-products-of-pointed-types public
 open import synthetic-homotopy-theory.spectra public
 open import synthetic-homotopy-theory.spheres public
diff --git a/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
index e0ec3f8a14..0a00005614 100644
--- a/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
@@ -22,6 +22,7 @@ open import foundation.universe-levels
 
 open import synthetic-homotopy-theory.descent-circle
 open import synthetic-homotopy-theory.free-loops
+open import synthetic-homotopy-theory.sections-descent-circle
 open import synthetic-homotopy-theory.universal-property-circle
 ```
 
diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index 12dd81cc1f..eab97690dd 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -7,14 +7,11 @@ module synthetic-homotopy-theory.descent-circle where
 <details><summary>Imports</summary>
 
 ```agda
-open import foundation.action-on-identifications-dependent-functions
-open import foundation.action-on-identifications-functions
 open import foundation.automorphisms
 open import foundation.commuting-squares-of-maps
 open import foundation.commuting-triangles-of-maps
 open import foundation.contractible-maps
 open import foundation.contractible-types
-open import foundation.dependent-identifications
 open import foundation.dependent-pair-types
 open import foundation.equivalence-extensionality
 open import foundation.equivalences
@@ -25,7 +22,6 @@ open import foundation.functoriality-dependent-pair-types
 open import foundation.fundamental-theorem-of-identity-types
 open import foundation.homotopies
 open import foundation.identity-types
-open import foundation.path-algebra
 open import foundation.structure-identity-principle
 open import foundation.transport
 open import foundation.univalence
@@ -48,7 +44,7 @@ The descent property uniquely characterizes type families over the circle.
 By the universal property of the circle and univalence, a type family
 `A : 𝕊¹ → U` is equivalent to a type `X : U` equipped with an automorphism
 `e : X ≃ X`, in a way made precise in further sections of this file. The pair
-`(X, e)` is called descent data for the circle.
+`(X, e)` is called **descent data** for the circle.
 
 ```agda
 descent-data-circle :
@@ -75,9 +71,9 @@ The equivalence extends to the dependent case, where given a type family `A`
 over the circle with descent data `(X, e)`, a type family
 `B : (t : 𝕊¹) → A t → U` is equivalent to a type family `R : X → U` equipped
 with a family of equivalences `K : (x : X) → R(x) ≃ R(e(x))`. The pair `(R, K)`
-is called dependent descent data for the circle. Intuitively, this states that
-the types over points of `X` belonging to the same connected component in the
-total space `Σ 𝕊¹ A` are equivalent.
+is called **dependent descent data** for the circle. Intuitively, this states
+that the types over points of `X` belonging to the same connected component in
+the total space `Σ 𝕊¹ A` are equivalent.
 
 ```agda
 dependent-descent-data-circle :
@@ -110,19 +106,6 @@ module _
     map-equiv (equiv-dependent-descent-data-circle x)
 ```
 
-### Fixpoints of the descent data
-
-A fixpoint of `(X, e)` is a fixpoint of `e`.
-
-```agda
-fixpoint-descent-data-circle :
-  { l1 : Level}
-  ( P : descent-data-circle l1) → UU l1
-fixpoint-descent-data-circle P =
-  Σ ( type-descent-data-circle P)
-    ( λ x → (map-descent-data-circle P x) ＝ x)
-```
-
 ### Homomorphisms between descent data for the circle
 
 A homomorphism between `(X, e)` and `(Y, f)` is a map from `X` to `Y` such that
@@ -432,212 +415,3 @@ module _
           ( up-circle))
         ( Q))
 ```
-
-### Characterization of sections of type families over the circle
-
-Sections of type families over the circle are exactly the fixpoints of the
-automorphism from the characteristic descent data.
-
-```agda
-module _
-  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
-  ( A : family-with-descent-data-circle l l2)
-  where
-
-  map-compute-dependent-identification-loop-circle :
-    ( x y : type-family-with-descent-data-circle A) →
-    map-aut-family-with-descent-data-circle A x ＝ y →
-    dependent-identification (family-family-with-descent-data-circle A)
-      ( loop-free-loop l)
-      ( map-equiv-family-with-descent-data-circle A x)
-      ( map-equiv-family-with-descent-data-circle A y)
-  map-compute-dependent-identification-loop-circle x y q =
-    inv (coherence-square-family-with-descent-data-circle A x) ∙
-    ( ap (map-equiv-family-with-descent-data-circle A) q)
-
-  is-equiv-map-compute-dependent-identification-loop-circle :
-    ( x y : type-family-with-descent-data-circle A) →
-    is-equiv (map-compute-dependent-identification-loop-circle x y)
-  is-equiv-map-compute-dependent-identification-loop-circle x y =
-    fundamental-theorem-id
-      ( is-contr-equiv'
-        ( fib
-          ( map-equiv-family-with-descent-data-circle A)
-          ( tr
-            ( family-family-with-descent-data-circle A)
-            ( loop-free-loop l)
-            ( map-equiv-family-with-descent-data-circle A x)))
-        ( equiv-fib _ _)
-        ( is-contr-map-is-equiv
-          ( is-equiv-map-equiv (equiv-family-with-descent-data-circle A))
-          ( tr
-            ( family-family-with-descent-data-circle A)
-            ( loop-free-loop l)
-            ( map-equiv-family-with-descent-data-circle A x))))
-      ( map-compute-dependent-identification-loop-circle x)
-      ( y)
-
-  compute-dependent-identification-loop-circle :
-    ( x y : type-family-with-descent-data-circle A) →
-    ( map-aut-family-with-descent-data-circle A x ＝ y) ≃
-    ( dependent-identification
-      ( family-family-with-descent-data-circle A)
-      ( loop-free-loop l)
-      ( map-equiv-family-with-descent-data-circle A x)
-      ( map-equiv-family-with-descent-data-circle A y))
-  pr1 (compute-dependent-identification-loop-circle x y) =
-    map-compute-dependent-identification-loop-circle x y
-  pr2 (compute-dependent-identification-loop-circle x y) =
-    is-equiv-map-compute-dependent-identification-loop-circle x y
-```
-
-```agda
-module _
-  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
-  ( A : family-with-descent-data-circle l l2)
-  where
-
-  ev-fixpoint-descent-data-circle :
-    ( (x : S) → family-family-with-descent-data-circle A x) →
-    ( fixpoint-descent-data-circle
-      ( descent-data-family-with-descent-data-circle A))
-  pr1 (ev-fixpoint-descent-data-circle s) =
-    map-inv-equiv
-      ( equiv-family-with-descent-data-circle A)
-      ( s (base-free-loop l))
-  pr2 (ev-fixpoint-descent-data-circle s) =
-    map-inv-is-equiv
-      ( is-equiv-map-compute-dependent-identification-loop-circle
-        ( l)
-        ( A)
-        ( map-inv-equiv
-          ( equiv-family-with-descent-data-circle A)
-          ( s (base-free-loop l)))
-        ( map-inv-equiv
-          ( equiv-family-with-descent-data-circle A)
-          ( s (base-free-loop l))))
-      ( ( ap
-          ( tr (family-family-with-descent-data-circle A) (loop-free-loop l))
-          ( is-section-map-inv-equiv
-            ( equiv-family-with-descent-data-circle A)
-            ( s (base-free-loop l)))) ∙
-        ( ( apd s (loop-free-loop l)) ∙
-          ( inv
-            ( is-section-map-inv-equiv
-              ( equiv-family-with-descent-data-circle A)
-              ( s (base-free-loop l))))))
-
-  equiv-fixpoint-descent-data-circle-free-dependent-loop :
-    ( fixpoint-descent-data-circle
-      ( descent-data-family-with-descent-data-circle A)) ≃
-    ( free-dependent-loop l (family-family-with-descent-data-circle A))
-  equiv-fixpoint-descent-data-circle-free-dependent-loop =
-    equiv-Σ
-      ( λ x →
-        dependent-identification
-          ( family-family-with-descent-data-circle A)
-          ( loop-free-loop l)
-          ( x)
-          ( x))
-      ( equiv-family-with-descent-data-circle A)
-      ( λ x →
-        compute-dependent-identification-loop-circle l A x x)
-
-  comparison-fixpoint-descent-data-circle :
-    ( fixpoint-descent-data-circle
-      ( descent-data-family-with-descent-data-circle A)) →
-    ( free-dependent-loop l (family-family-with-descent-data-circle A))
-  comparison-fixpoint-descent-data-circle =
-    map-equiv equiv-fixpoint-descent-data-circle-free-dependent-loop
-
-  triangle-comparison-fixpoint-descent-data-circle :
-    coherence-triangle-maps
-      ( ev-free-loop-Π l (family-family-with-descent-data-circle A))
-      ( comparison-fixpoint-descent-data-circle)
-      ( ev-fixpoint-descent-data-circle)
-  triangle-comparison-fixpoint-descent-data-circle s =
-    eq-Eq-free-dependent-loop l
-      ( family-family-with-descent-data-circle A)
-      ( ev-free-loop-Π l (family-family-with-descent-data-circle A) s)
-      ( ( comparison-fixpoint-descent-data-circle ∘
-          ev-fixpoint-descent-data-circle)
-        ( s))
-      ( inv is-section-inv-α ,
-        inv
-        ( ( horizontal-concat-Id²
-            ( refl
-              { x =
-                ap
-                  ( tr
-                    ( family-family-with-descent-data-circle A)
-                    ( loop-free-loop l))
-                  ( inv is-section-inv-α)})
-            ( is-section-map-inv-is-equiv
-              ( is-equiv-map-compute-dependent-identification-loop-circle
-                ( l)
-                ( A)
-                ( map-inv-equiv
-                  ( equiv-family-with-descent-data-circle A)
-                  ( s (base-free-loop l)))
-                ( pr1 (ev-fixpoint-descent-data-circle s)))
-              ( _))) ∙
-          ( ( inv (assoc (ap _ (inv is-section-inv-α)) _ _)) ∙
-            ( horizontal-concat-Id²
-              ( inv
-                ( ap-concat-eq
-                  ( tr
-                    ( family-family-with-descent-data-circle A)
-                    ( loop-free-loop l))
-                  ( inv is-section-inv-α)
-                  ( is-section-inv-α)
-                  ( refl)
-                  ( inv (left-inv is-section-inv-α))))
-              ( refl)))))
-    where
-    is-section-inv-α :
-      eq-value
-        ( map-equiv-family-with-descent-data-circle A ∘
-          map-inv-equiv (equiv-family-with-descent-data-circle A))
-        ( id)
-        ( s (base-free-loop l))
-    is-section-inv-α =
-      is-section-map-inv-equiv
-        ( equiv-family-with-descent-data-circle A)
-        ( s (base-free-loop l))
-
-  is-equiv-comparison-fixpoint-descent-data-circle :
-    is-equiv comparison-fixpoint-descent-data-circle
-  is-equiv-comparison-fixpoint-descent-data-circle =
-    is-equiv-map-equiv equiv-fixpoint-descent-data-circle-free-dependent-loop
-
-  is-equiv-ev-fixpoint-descent-data-circle :
-    ( dependent-universal-property-circle l2 l) →
-    is-equiv ev-fixpoint-descent-data-circle
-  is-equiv-ev-fixpoint-descent-data-circle dup-circle =
-    is-equiv-right-factor-htpy
-      ( ev-free-loop-Π l (family-family-with-descent-data-circle A))
-      ( comparison-fixpoint-descent-data-circle)
-      ( ev-fixpoint-descent-data-circle)
-      ( triangle-comparison-fixpoint-descent-data-circle)
-      ( is-equiv-comparison-fixpoint-descent-data-circle)
-      ( dup-circle (family-family-with-descent-data-circle A))
-
-  equiv-ev-fixpoint-descent-data-circle :
-    ( dependent-universal-property-circle l2 l) →
-    ( (x : S) → (family-family-with-descent-data-circle A) x) ≃
-    ( fixpoint-descent-data-circle
-      ( descent-data-family-with-descent-data-circle A))
-  pr1 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
-    ev-fixpoint-descent-data-circle
-  pr2 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
-    is-equiv-ev-fixpoint-descent-data-circle dup-circle
-
-  compute-ev-fixpoint-descent-data-circle :
-    coherence-square-maps
-      ( ev-fixpoint-descent-data-circle)
-      ( ev-point (base-free-loop l))
-      ( pr1)
-      ( map-inv-equiv (equiv-family-with-descent-data-circle A))
-  compute-ev-fixpoint-descent-data-circle = refl-htpy
-```
-
diff --git a/src/synthetic-homotopy-theory/sections-descent-circle.lagda.md b/src/synthetic-homotopy-theory/sections-descent-circle.lagda.md
new file mode 100644
index 0000000000..d7d69480bb
--- /dev/null
+++ b/src/synthetic-homotopy-theory/sections-descent-circle.lagda.md
@@ -0,0 +1,261 @@
+# Sections of families over the circle
+
+```agda
+module synthetic-homotopy-theory.sections-descent-circle where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.action-on-identifications-dependent-functions
+open import foundation.action-on-identifications-functions
+open import foundation.commuting-squares-of-maps
+open import foundation.commuting-triangles-of-maps
+open import foundation.contractible-maps
+open import foundation.contractible-types
+open import foundation.dependent-identifications
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.fibers-of-maps
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.fundamental-theorem-of-identity-types
+open import foundation.homotopies
+open import foundation.identity-types
+open import foundation.path-algebra
+open import foundation.transport
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.descent-circle
+open import synthetic-homotopy-theory.free-loops
+open import synthetic-homotopy-theory.universal-property-circle
+```
+
+</details>
+
+## Idea
+
+Sections of type families over the circle are exactly the fixpoints of the
+automorphism from the corresponding descent data.
+
+## Definitions
+
+### Fixpoints of descent data
+
+A fixpoint of `(X, e)` is a fixpoint of `e`.
+
+```agda
+fixpoint-descent-data-circle :
+  { l1 : Level}
+  ( P : descent-data-circle l1) → UU l1
+fixpoint-descent-data-circle P =
+  Σ ( type-descent-data-circle P)
+    ( λ x → (map-descent-data-circle P x) ＝ x)
+```
+
+## Properties
+
+### Characterization of sections of type families over the circle
+
+```agda
+module _
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  where
+
+  map-compute-dependent-identification-loop-circle :
+    ( x y : type-family-with-descent-data-circle A) →
+    map-aut-family-with-descent-data-circle A x ＝ y →
+    dependent-identification (family-family-with-descent-data-circle A)
+      ( loop-free-loop l)
+      ( map-equiv-family-with-descent-data-circle A x)
+      ( map-equiv-family-with-descent-data-circle A y)
+  map-compute-dependent-identification-loop-circle x y q =
+    inv (coherence-square-family-with-descent-data-circle A x) ∙
+    ( ap (map-equiv-family-with-descent-data-circle A) q)
+
+  is-equiv-map-compute-dependent-identification-loop-circle :
+    ( x y : type-family-with-descent-data-circle A) →
+    is-equiv (map-compute-dependent-identification-loop-circle x y)
+  is-equiv-map-compute-dependent-identification-loop-circle x y =
+    fundamental-theorem-id
+      ( is-contr-equiv'
+        ( fib
+          ( map-equiv-family-with-descent-data-circle A)
+          ( tr
+            ( family-family-with-descent-data-circle A)
+            ( loop-free-loop l)
+            ( map-equiv-family-with-descent-data-circle A x)))
+        ( equiv-fib _ _)
+        ( is-contr-map-is-equiv
+          ( is-equiv-map-equiv (equiv-family-with-descent-data-circle A))
+          ( tr
+            ( family-family-with-descent-data-circle A)
+            ( loop-free-loop l)
+            ( map-equiv-family-with-descent-data-circle A x))))
+      ( map-compute-dependent-identification-loop-circle x)
+      ( y)
+
+  compute-dependent-identification-loop-circle :
+    ( x y : type-family-with-descent-data-circle A) →
+    ( map-aut-family-with-descent-data-circle A x ＝ y) ≃
+    ( dependent-identification
+      ( family-family-with-descent-data-circle A)
+      ( loop-free-loop l)
+      ( map-equiv-family-with-descent-data-circle A x)
+      ( map-equiv-family-with-descent-data-circle A y))
+  pr1 (compute-dependent-identification-loop-circle x y) =
+    map-compute-dependent-identification-loop-circle x y
+  pr2 (compute-dependent-identification-loop-circle x y) =
+    is-equiv-map-compute-dependent-identification-loop-circle x y
+```
+
+```agda
+module _
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  where
+
+  ev-fixpoint-descent-data-circle :
+    ( (x : S) → family-family-with-descent-data-circle A x) →
+    ( fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A))
+  pr1 (ev-fixpoint-descent-data-circle s) =
+    map-inv-equiv
+      ( equiv-family-with-descent-data-circle A)
+      ( s (base-free-loop l))
+  pr2 (ev-fixpoint-descent-data-circle s) =
+    map-inv-equiv
+      ( compute-dependent-identification-loop-circle
+        ( l)
+        ( A)
+        ( map-inv-equiv
+          ( equiv-family-with-descent-data-circle A)
+          ( s (base-free-loop l)))
+        ( map-inv-equiv
+          ( equiv-family-with-descent-data-circle A)
+          ( s (base-free-loop l))))
+      ( ( ap
+          ( tr (family-family-with-descent-data-circle A) (loop-free-loop l))
+          ( is-section-map-inv-equiv
+            ( equiv-family-with-descent-data-circle A)
+            ( s (base-free-loop l)))) ∙
+        ( ( apd s (loop-free-loop l)) ∙
+          ( inv
+            ( is-section-map-inv-equiv
+              ( equiv-family-with-descent-data-circle A)
+              ( s (base-free-loop l))))))
+
+  equiv-fixpoint-descent-data-circle-free-dependent-loop :
+    ( fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)) ≃
+    ( free-dependent-loop l (family-family-with-descent-data-circle A))
+  equiv-fixpoint-descent-data-circle-free-dependent-loop =
+    equiv-Σ
+      ( λ x →
+        dependent-identification
+          ( family-family-with-descent-data-circle A)
+          ( loop-free-loop l)
+          ( x)
+          ( x))
+      ( equiv-family-with-descent-data-circle A)
+      ( λ x →
+        compute-dependent-identification-loop-circle l A x x)
+
+  comparison-fixpoint-descent-data-circle :
+    ( fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)) →
+    ( free-dependent-loop l (family-family-with-descent-data-circle A))
+  comparison-fixpoint-descent-data-circle =
+    map-equiv equiv-fixpoint-descent-data-circle-free-dependent-loop
+
+  triangle-comparison-fixpoint-descent-data-circle :
+    coherence-triangle-maps
+      ( ev-free-loop-Π l (family-family-with-descent-data-circle A))
+      ( comparison-fixpoint-descent-data-circle)
+      ( ev-fixpoint-descent-data-circle)
+  triangle-comparison-fixpoint-descent-data-circle s =
+    eq-Eq-free-dependent-loop l
+      ( family-family-with-descent-data-circle A)
+      ( ev-free-loop-Π l (family-family-with-descent-data-circle A) s)
+      ( ( comparison-fixpoint-descent-data-circle ∘
+          ev-fixpoint-descent-data-circle)
+        ( s))
+      ( inv is-section-inv-α ,
+        inv
+        ( ( horizontal-concat-Id²
+            ( refl
+              { x =
+                ap
+                  ( tr
+                    ( family-family-with-descent-data-circle A)
+                    ( loop-free-loop l))
+                  ( inv is-section-inv-α)})
+            ( is-section-map-inv-is-equiv
+              ( is-equiv-map-compute-dependent-identification-loop-circle
+                ( l)
+                ( A)
+                ( map-inv-equiv
+                  ( equiv-family-with-descent-data-circle A)
+                  ( s (base-free-loop l)))
+                ( pr1 (ev-fixpoint-descent-data-circle s)))
+              ( _))) ∙
+          ( ( inv (assoc (ap _ (inv is-section-inv-α)) _ _)) ∙
+            ( horizontal-concat-Id²
+              ( inv
+                ( ap-concat-eq
+                  ( tr
+                    ( family-family-with-descent-data-circle A)
+                    ( loop-free-loop l))
+                  ( inv is-section-inv-α)
+                  ( is-section-inv-α)
+                  ( refl)
+                  ( inv (left-inv is-section-inv-α))))
+              ( refl)))))
+    where
+    is-section-inv-α :
+      eq-value
+        ( map-equiv-family-with-descent-data-circle A ∘
+          map-inv-equiv (equiv-family-with-descent-data-circle A))
+        ( id)
+        ( s (base-free-loop l))
+    is-section-inv-α =
+      is-section-map-inv-equiv
+        ( equiv-family-with-descent-data-circle A)
+        ( s (base-free-loop l))
+
+  is-equiv-comparison-fixpoint-descent-data-circle :
+    is-equiv comparison-fixpoint-descent-data-circle
+  is-equiv-comparison-fixpoint-descent-data-circle =
+    is-equiv-map-equiv equiv-fixpoint-descent-data-circle-free-dependent-loop
+
+  is-equiv-ev-fixpoint-descent-data-circle :
+    ( dependent-universal-property-circle l2 l) →
+    is-equiv ev-fixpoint-descent-data-circle
+  is-equiv-ev-fixpoint-descent-data-circle dup-circle =
+    is-equiv-right-factor-htpy
+      ( ev-free-loop-Π l (family-family-with-descent-data-circle A))
+      ( comparison-fixpoint-descent-data-circle)
+      ( ev-fixpoint-descent-data-circle)
+      ( triangle-comparison-fixpoint-descent-data-circle)
+      ( is-equiv-comparison-fixpoint-descent-data-circle)
+      ( dup-circle (family-family-with-descent-data-circle A))
+
+  equiv-ev-fixpoint-descent-data-circle :
+    ( dependent-universal-property-circle l2 l) →
+    ( (x : S) → (family-family-with-descent-data-circle A) x) ≃
+    ( fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A))
+  pr1 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
+    ev-fixpoint-descent-data-circle
+  pr2 (equiv-ev-fixpoint-descent-data-circle dup-circle) =
+    is-equiv-ev-fixpoint-descent-data-circle dup-circle
+
+  compute-ev-fixpoint-descent-data-circle :
+    coherence-square-maps
+      ( ev-fixpoint-descent-data-circle)
+      ( ev-point (base-free-loop l))
+      ( pr1)
+      ( map-inv-equiv (equiv-family-with-descent-data-circle A))
+  compute-ev-fixpoint-descent-data-circle = refl-htpy
+```

From 0a4f15ce5e16accfc2229c37eb1419ea366ca9e9 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Wed, 23 Aug 2023 18:55:18 +0200
Subject: [PATCH 10/25] Add accessors for descent data homomorphisms

---
 .../descent-circle.lagda.md                   | 21 +++++++++++++++++--
 1 file changed, 19 insertions(+), 2 deletions(-)

diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index eab97690dd..d04943fe5a 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -124,6 +124,23 @@ hom-descent-data-circle P Q =
         ( map-descent-data-circle P)
         ( map-descent-data-circle Q)
         ( h))
+
+module _
+  { l1 l2 : Level} (P : descent-data-circle l1) (Q : descent-data-circle l2)
+  ( h : hom-descent-data-circle P Q)
+  where
+
+  map-hom-descent-data-circle :
+    type-descent-data-circle P → type-descent-data-circle Q
+  map-hom-descent-data-circle = pr1 h
+
+  coherence-hom-descent-data-circle :
+    coherence-square-maps
+      ( map-hom-descent-data-circle)
+      ( map-descent-data-circle P)
+      ( map-descent-data-circle Q)
+      ( map-hom-descent-data-circle)
+  coherence-hom-descent-data-circle = pr2 h
 ```
 
 ### Canonical descent data for a family over the circle
@@ -141,8 +158,8 @@ pr2 (ev-descent-data-circle l A) = equiv-tr A (loop-free-loop l)
 
 ### The identity type of descent data
 
-An equivalence between `(X, e)` and `(Y, f)` is a homomorphism between them,
-where the underlying map is an equivalence.
+An equivalence between `(X, e)` and `(Y, f)` is an equivalence between `X` and
+`Y` which commutes with the automorphisms.
 
 ```agda
 Eq-descent-data-circle :

From 201d04d6471ed05c407d6246635b8bab81f189ae Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Thu, 24 Aug 2023 00:38:23 +0200
Subject: [PATCH 11/25] Add accessors for dependent descent data

---
 .../descent-circle.lagda.md                   | 399 ++++++++++++++++--
 1 file changed, 354 insertions(+), 45 deletions(-)

diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index d04943fe5a..73d5ea8903 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -13,6 +13,8 @@ open import foundation.commuting-triangles-of-maps
 open import foundation.contractible-maps
 open import foundation.contractible-types
 open import foundation.dependent-pair-types
+open import foundation.equality-dependent-function-types
+open import foundation.equality-dependent-pair-types
 open import foundation.equivalence-extensionality
 open import foundation.equivalences
 open import foundation.fibers-of-maps
@@ -65,47 +67,6 @@ module _
   map-descent-data-circle = map-equiv aut-descent-data-circle
 ```
 
-### Dependent descent data for the circle
-
-The equivalence extends to the dependent case, where given a type family `A`
-over the circle with descent data `(X, e)`, a type family
-`B : (t : 𝕊¹) → A t → U` is equivalent to a type family `R : X → U` equipped
-with a family of equivalences `K : (x : X) → R(x) ≃ R(e(x))`. The pair `(R, K)`
-is called **dependent descent data** for the circle. Intuitively, this states
-that the types over points of `X` belonging to the same connected component in
-the total space `Σ 𝕊¹ A` are equivalent.
-
-```agda
-dependent-descent-data-circle :
-  { l1 : Level} → descent-data-circle l1 →
-  ( l2 : Level) → UU (l1 ⊔ lsuc l2)
-dependent-descent-data-circle P l2 =
-  Σ ( type-descent-data-circle P → UU l2)
-    ( λ R → equiv-fam R (R ∘ (map-descent-data-circle P)))
-
-module _
-  { l1 l2 : Level} (P : descent-data-circle l1)
-  ( Q : dependent-descent-data-circle P l2)
-  where
-
-  type-dependent-descent-data-circle : type-descent-data-circle P → UU l2
-  type-dependent-descent-data-circle = pr1 Q
-
-  equiv-dependent-descent-data-circle :
-    equiv-fam
-      type-dependent-descent-data-circle
-      ( type-dependent-descent-data-circle ∘
-        ( map-descent-data-circle P))
-  equiv-dependent-descent-data-circle = pr2 Q
-
-  map-equiv-dependent-descent-data-circle :
-    ( x : type-descent-data-circle P) →
-    ( type-dependent-descent-data-circle x) →
-    ( type-dependent-descent-data-circle (map-descent-data-circle P x))
-  map-equiv-dependent-descent-data-circle x =
-    map-equiv (equiv-dependent-descent-data-circle x)
-```
-
 ### Homomorphisms between descent data for the circle
 
 A homomorphism between `(X, e)` and `(Y, f)` is a map from `X` to `Y` such that
@@ -156,7 +117,7 @@ pr1 (ev-descent-data-circle l A) = A (base-free-loop l)
 pr2 (ev-descent-data-circle l A) = equiv-tr A (loop-free-loop l)
 ```
 
-### The identity type of descent data
+### The identity type of descent data for the circle
 
 An equivalence between `(X, e)` and `(Y, f)` is an equivalence between `X` and
 `Y` which commutes with the automorphisms.
@@ -189,10 +150,10 @@ module _
 
   coherence-square-Eq-descent-data-circle :
     coherence-square-maps
-      ( map-equiv equiv-Eq-descent-data-circle)
+      ( map-Eq-descent-data-circle)
       ( map-descent-data-circle P)
       ( map-descent-data-circle Q)
-      ( map-equiv equiv-Eq-descent-data-circle)
+      ( map-Eq-descent-data-circle)
   coherence-square-Eq-descent-data-circle = pr2 αH
 ```
 
@@ -315,6 +276,271 @@ module _
     eq-family-with-descent-data-circle
 ```
 
+### Dependent descent data for the circle
+
+The equivalence extends to the dependent case, where given a type family `A`
+over the circle with descent data `(X, e)`, a type family
+`B : (t : 𝕊¹) → A t → U` is equivalent to a type family `R : X → U` equipped
+with a family of equivalences `K : (x : X) → R(x) ≃ R(e(x))`. The pair `(R, K)`
+is called **dependent descent data** for the circle. Intuitively, this states
+that the types over points of `X` belonging to the same connected component in
+the total space `Σ 𝕊¹ A` are equivalent.
+
+```agda
+dependent-descent-data-circle :
+  { l1 : Level} → descent-data-circle l1 →
+  ( l2 : Level) → UU (l1 ⊔ lsuc l2)
+dependent-descent-data-circle P l2 =
+  Σ ( type-descent-data-circle P → UU l2)
+    ( λ R → equiv-fam R (R ∘ (map-descent-data-circle P)))
+
+module _
+  { l1 l2 : Level} (P : descent-data-circle l1)
+  ( Q : dependent-descent-data-circle P l2)
+  where
+
+  type-dependent-descent-data-circle : type-descent-data-circle P → UU l2
+  type-dependent-descent-data-circle = pr1 Q
+
+  pseudo-aut-dependent-descent-data-circle :
+    equiv-fam
+      ( type-dependent-descent-data-circle)
+      ( type-dependent-descent-data-circle ∘ (map-descent-data-circle P))
+  pseudo-aut-dependent-descent-data-circle = pr2 Q
+
+  map-dependent-descent-data-circle :
+    ( x : type-descent-data-circle P) →
+    ( type-dependent-descent-data-circle x) →
+    ( type-dependent-descent-data-circle (map-descent-data-circle P x))
+  map-dependent-descent-data-circle x =
+    map-equiv (pseudo-aut-dependent-descent-data-circle x)
+```
+
+### Canonical dependent descent data for a family over a family oveer the circle
+
+```agda
+ev-dependent-descent-data-circle :
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S) →
+  ( A : family-with-descent-data-circle l l2) →
+  ( (x : S) → (family-family-with-descent-data-circle A x) → UU l3) →
+  dependent-descent-data-circle
+    ( descent-data-family-with-descent-data-circle A)
+    ( l3)
+pr1 (ev-dependent-descent-data-circle l A B) x =
+  B (base-free-loop l) (map-equiv-family-with-descent-data-circle A x)
+pr2 (ev-dependent-descent-data-circle l A B) x =
+  equiv-tr
+    ( ind-Σ B)
+    ( eq-pair-Σ
+      ( loop-free-loop l)
+      ( inv (coherence-square-family-with-descent-data-circle A x)))
+```
+
+### The identity type of dependent descent data for the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} (P : descent-data-circle l1)
+  where
+
+  Eq-dependent-descent-data-circle :
+    dependent-descent-data-circle P l2 → dependent-descent-data-circle P l3 →
+    UU (l1 ⊔ l2 ⊔ l3)
+  Eq-dependent-descent-data-circle Q T =
+    Σ ( equiv-fam
+        ( type-dependent-descent-data-circle P Q)
+        ( type-dependent-descent-data-circle P T))
+      ( λ H →
+        ( x : type-descent-data-circle P) →
+        coherence-square-maps
+          ( map-equiv (H x))
+          ( map-dependent-descent-data-circle P Q x)
+          ( map-dependent-descent-data-circle P T x)
+          ( map-equiv (H (map-descent-data-circle P x))))
+
+module _
+  { l1 l2 l3 : Level} (P : descent-data-circle l1)
+  ( Q : dependent-descent-data-circle P l2)
+  ( T : dependent-descent-data-circle P l3)
+  ( αH : Eq-dependent-descent-data-circle P Q T)
+  where
+
+  equiv-Eq-dependent-descent-data-circle :
+    equiv-fam
+      ( type-dependent-descent-data-circle P Q)
+      ( type-dependent-descent-data-circle P T)
+  equiv-Eq-dependent-descent-data-circle = pr1 αH
+
+  map-Eq-dependent-descent-data-circle :
+    ( x : type-descent-data-circle P) →
+    ( type-dependent-descent-data-circle P Q x) →
+    ( type-dependent-descent-data-circle P T x)
+  map-Eq-dependent-descent-data-circle x =
+    map-equiv (equiv-Eq-dependent-descent-data-circle x)
+
+  coherence-square-Eq-dependent-descent-data-circle :
+    ( x : type-descent-data-circle P) →
+    coherence-square-maps
+      ( map-Eq-dependent-descent-data-circle x)
+      ( map-dependent-descent-data-circle P Q x)
+      ( map-dependent-descent-data-circle P T x)
+      ( map-Eq-dependent-descent-data-circle
+        ( map-descent-data-circle P x))
+  coherence-square-Eq-dependent-descent-data-circle = pr2 αH
+```
+
+### A dependent family over the circle with corresponding dependent descent data
+
+```agda
+module _
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  where
+
+  family-for-dependent-descent-data-circle :
+    { l3 : Level} →
+    dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( l3) →
+    UU (l1 ⊔ l2 ⊔ lsuc l3)
+  family-for-dependent-descent-data-circle {l3} Q =
+    Σ ( (x : S) → (family-family-with-descent-data-circle A x) → UU l3)
+      ( λ B →
+        Eq-dependent-descent-data-circle
+          ( descent-data-family-with-descent-data-circle A)
+          ( Q)
+          ( ev-dependent-descent-data-circle l A B))
+
+  dependent-descent-data-circle-for-family :
+    { l3 : Level} →
+    ( (x : S) → (family-family-with-descent-data-circle A x) → UU l3) →
+    UU (l2 ⊔ lsuc l3)
+  dependent-descent-data-circle-for-family {l3} B =
+    Σ ( dependent-descent-data-circle
+        ( descent-data-family-with-descent-data-circle A)
+        ( l3))
+      ( λ Q →
+        Eq-dependent-descent-data-circle
+          ( descent-data-family-with-descent-data-circle A)
+          ( Q)
+          ( ev-dependent-descent-data-circle l A B))
+
+  family-with-dependent-descent-data-circle :
+    ( l3 : Level) → UU (l1 ⊔ l2 ⊔ lsuc l3)
+  family-with-dependent-descent-data-circle l3 =
+    Σ ( (x : S) → (family-family-with-descent-data-circle A x) → UU l3)
+      dependent-descent-data-circle-for-family
+
+module _
+  { l1 l2 l3 : Level} {S : UU l1} {l : free-loop S}
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-dependent-descent-data-circle l A l3)
+  where
+
+  family-family-with-dependent-descent-data-circle :
+    ( x : S) → (family-family-with-descent-data-circle A x) → UU l3
+  family-family-with-dependent-descent-data-circle = pr1 B
+
+  dependent-descent-data-for-family-with-dependent-descent-data-circle :
+    dependent-descent-data-circle-for-family l A
+      family-family-with-dependent-descent-data-circle
+  dependent-descent-data-for-family-with-dependent-descent-data-circle = pr2 B
+
+  dependent-descent-data-family-with-dependent-descent-data-circle :
+    dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( l3)
+  dependent-descent-data-family-with-dependent-descent-data-circle =
+    pr1 dependent-descent-data-for-family-with-dependent-descent-data-circle
+
+  type-family-with-dependent-descent-data-circle :
+    type-family-with-descent-data-circle A → UU l3
+  type-family-with-dependent-descent-data-circle =
+    type-dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( dependent-descent-data-family-with-dependent-descent-data-circle)
+
+  pseudo-aut-family-with-dependent-descent-data-circle :
+    equiv-fam
+    ( type-family-with-dependent-descent-data-circle)
+    ( type-family-with-dependent-descent-data-circle ∘
+      ( map-aut-family-with-descent-data-circle A))
+  pseudo-aut-family-with-dependent-descent-data-circle =
+    pseudo-aut-dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( dependent-descent-data-family-with-dependent-descent-data-circle)
+
+  map-pseudo-aut-family-with-dependent-descent-data-circle :
+    ( x : type-family-with-descent-data-circle A) →
+    ( type-family-with-dependent-descent-data-circle x) →
+    ( type-family-with-dependent-descent-data-circle
+      ( map-aut-family-with-descent-data-circle A x))
+  map-pseudo-aut-family-with-dependent-descent-data-circle =
+    map-dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( dependent-descent-data-family-with-dependent-descent-data-circle)
+
+  eq-family-with-dependent-descent-data-circle :
+    Eq-dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( dependent-descent-data-family-with-dependent-descent-data-circle)
+      ( ev-dependent-descent-data-circle l A
+        ( family-family-with-dependent-descent-data-circle))
+  eq-family-with-dependent-descent-data-circle =
+    pr2 dependent-descent-data-for-family-with-dependent-descent-data-circle
+
+  equiv-family-with-dependent-descent-data-circle :
+    ( x : type-family-with-descent-data-circle A) →
+    ( type-family-with-dependent-descent-data-circle x) ≃
+    ( family-family-with-dependent-descent-data-circle
+      ( base-free-loop l)
+      ( map-equiv-family-with-descent-data-circle A x))
+  equiv-family-with-dependent-descent-data-circle =
+    equiv-Eq-dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( dependent-descent-data-family-with-dependent-descent-data-circle)
+      ( ev-dependent-descent-data-circle l A
+        ( family-family-with-dependent-descent-data-circle))
+      ( eq-family-with-dependent-descent-data-circle)
+
+  map-equiv-family-with-dependent-descent-data-circle :
+    ( x : type-family-with-descent-data-circle A) →
+    ( type-family-with-dependent-descent-data-circle x) →
+    ( family-family-with-dependent-descent-data-circle
+      ( base-free-loop l)
+      ( map-equiv-family-with-descent-data-circle A x))
+  map-equiv-family-with-dependent-descent-data-circle x =
+    map-equiv (equiv-family-with-dependent-descent-data-circle x)
+
+  coherence-square-family-with-dependent-descent-data-circle :
+    ( x : type-family-with-descent-data-circle A) →
+    coherence-square-maps
+      ( map-equiv-family-with-dependent-descent-data-circle x)
+      ( map-pseudo-aut-family-with-dependent-descent-data-circle x)
+      ( tr
+        ( ind-Σ (family-family-with-dependent-descent-data-circle))
+        ( eq-pair-Σ
+          ( loop-free-loop l)
+          ( inv (coherence-square-family-with-descent-data-circle A x))))
+      ( map-equiv-family-with-dependent-descent-data-circle
+        ( map-aut-family-with-descent-data-circle A x))
+  coherence-square-family-with-dependent-descent-data-circle =
+    coherence-square-Eq-dependent-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( dependent-descent-data-family-with-dependent-descent-data-circle)
+      ( ev-dependent-descent-data-circle l A
+        ( family-family-with-dependent-descent-data-circle))
+      ( eq-family-with-dependent-descent-data-circle)
+
+  family-for-family-with-dependent-descent-data-circle :
+    family-for-dependent-descent-data-circle l A
+      dependent-descent-data-family-with-dependent-descent-data-circle
+  pr1 family-for-family-with-dependent-descent-data-circle =
+    family-family-with-dependent-descent-data-circle
+  pr2 family-for-family-with-dependent-descent-data-circle =
+    eq-family-with-dependent-descent-data-circle
+```
+
 ## Properties
 
 ### Characterization of the identity type of descent data for the circle
@@ -360,7 +586,7 @@ eq-Eq-descent-data-circle P Q =
   map-inv-is-equiv (is-equiv-Eq-eq-descent-data-circle P Q)
 ```
 
-### Uniqueness of descent data characterizing a particular type family over the circle
+### Uniqueness of descent data characterizing a type family over the circle
 
 ```agda
 comparison-descent-data-circle :
@@ -432,3 +658,86 @@ module _
           ( up-circle))
         ( Q))
 ```
+
+### Characterization of the identity type of dependent descent data for the circle
+
+```agda
+module _
+  { l1 l2 : Level} (P : descent-data-circle l1)
+  where
+
+  refl-Eq-dependent-descent-data-circle :
+    ( Q : dependent-descent-data-circle P l2) →
+    Eq-dependent-descent-data-circle P Q Q
+  pr1 (refl-Eq-dependent-descent-data-circle Q) =
+    id-equiv-fam (type-dependent-descent-data-circle P Q)
+  pr2 (refl-Eq-dependent-descent-data-circle Q) x = refl-htpy
+
+  Eq-eq-dependent-descent-data-circle :
+    ( Q T : dependent-descent-data-circle P l2) →
+    Q ＝ T → Eq-dependent-descent-data-circle P Q T
+  Eq-eq-dependent-descent-data-circle Q .Q refl =
+    refl-Eq-dependent-descent-data-circle Q
+
+  is-contr-total-Eq-dependent-descent-data-circle :
+    ( Q : dependent-descent-data-circle P l2) →
+    is-contr
+      ( Σ ( dependent-descent-data-circle P l2)
+          ( Eq-dependent-descent-data-circle P Q))
+  is-contr-total-Eq-dependent-descent-data-circle Q =
+    is-contr-total-Eq-structure
+      ( λ R K H →
+        ( x : type-descent-data-circle P) →
+        coherence-square-maps
+          ( map-equiv (H x))
+          ( map-dependent-descent-data-circle P Q x)
+          ( map-equiv (K x))
+          ( map-equiv (H (map-descent-data-circle P x))))
+      ( is-contr-total-equiv-fam (type-dependent-descent-data-circle P Q))
+      ( type-dependent-descent-data-circle P Q ,
+        id-equiv-fam (type-dependent-descent-data-circle P Q))
+      ( is-contr-total-Eq-Π
+        ( λ x K →
+          ( map-dependent-descent-data-circle P Q x) ~
+          ( map-equiv K))
+        ( λ x →
+          is-contr-total-htpy-equiv
+            ( pseudo-aut-dependent-descent-data-circle P Q x)))
+
+  is-equiv-Eq-eq-dependent-descent-data-circle :
+    ( Q T : dependent-descent-data-circle P l2) →
+    is-equiv (Eq-eq-dependent-descent-data-circle Q T)
+  is-equiv-Eq-eq-dependent-descent-data-circle Q =
+    fundamental-theorem-id
+      ( is-contr-total-Eq-dependent-descent-data-circle Q)
+      ( Eq-eq-dependent-descent-data-circle Q)
+
+  eq-Eq-dependent-descent-data-circle :
+    ( Q T : dependent-descent-data-circle P l2) →
+    Eq-dependent-descent-data-circle P Q T → Q ＝ T
+  eq-Eq-dependent-descent-data-circle Q T =
+    map-inv-is-equiv (is-equiv-Eq-eq-dependent-descent-data-circle Q T)
+```
+
+### Uniqueness of dependent descent data characterizing a type family over a family over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  where
+
+  unique-dependent-family-property-circle : UU (l1 ⊔ l2 ⊔ lsuc l3)
+  unique-dependent-family-property-circle =
+    ( Q :
+      dependent-descent-data-circle
+        ( descent-data-family-with-descent-data-circle A)
+        ( l3)) →
+    is-contr (family-for-dependent-descent-data-circle l A Q)
+
+  unique-dependent-family-property-circle-dependent-universal-property-circle :
+    dependent-universal-property-circle (l2 ⊔ lsuc l3) l →
+    unique-dependent-family-property-circle
+  unique-dependent-family-property-circle-dependent-universal-property-circle
+    dup-circle Q = {!!}
+```

From ee5b265b31b66775180ad6d5480749b4725de7b5 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Thu, 24 Aug 2023 01:47:01 +0200
Subject: [PATCH 12/25] Descent data for constant families

---
 src/synthetic-homotopy-theory.lagda.md        |  1 +
 .../descent-circle-constant-families.lagda.md | 56 +++++++++++++++++++
 2 files changed, 57 insertions(+)
 create mode 100644 src/synthetic-homotopy-theory/descent-circle-constant-families.lagda.md

diff --git a/src/synthetic-homotopy-theory.lagda.md b/src/synthetic-homotopy-theory.lagda.md
index 8b516194c9..80246b547e 100644
--- a/src/synthetic-homotopy-theory.lagda.md
+++ b/src/synthetic-homotopy-theory.lagda.md
@@ -20,6 +20,7 @@ open import synthetic-homotopy-theory.dependent-cocones-under-spans public
 open import synthetic-homotopy-theory.dependent-pullback-property-pushouts public
 open import synthetic-homotopy-theory.dependent-universal-property-pushouts public
 open import synthetic-homotopy-theory.descent-circle public
+open import synthetic-homotopy-theory.descent-circle-constant-families public
 open import synthetic-homotopy-theory.descent-circle-function-types public
 open import synthetic-homotopy-theory.double-loop-spaces public
 open import synthetic-homotopy-theory.free-loops public
diff --git a/src/synthetic-homotopy-theory/descent-circle-constant-families.lagda.md b/src/synthetic-homotopy-theory/descent-circle-constant-families.lagda.md
new file mode 100644
index 0000000000..bcfe977093
--- /dev/null
+++ b/src/synthetic-homotopy-theory/descent-circle-constant-families.lagda.md
@@ -0,0 +1,56 @@
+# Descent data for constant type families over the circle
+
+```agda
+module synthetic-homotopy-theory.descent-circle-constant-families where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.constant-type-families
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.identity-types
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.descent-circle
+open import synthetic-homotopy-theory.free-loops
+```
+
+</details>
+
+## Idea
+
+Descent data for a constant type family is simply the type it evaluates to,
+together with the identity.
+
+## Properties
+
+### Characterization of descent data for constant type families over the circle
+
+```agda
+module _
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( X : UU l2)
+  where
+
+  descent-data-circle-constant-type : descent-data-circle l2
+  pr1 descent-data-circle-constant-type = X
+  pr2 descent-data-circle-constant-type = id-equiv
+
+  eq-descent-data-circle-constant-type :
+    Eq-descent-data-circle
+      ( descent-data-circle-constant-type)
+      ( ev-descent-data-circle l (constant-type-family S X))
+  pr1 eq-descent-data-circle-constant-type = id-equiv
+  pr2 eq-descent-data-circle-constant-type x =
+    inv (tr-constant-type-family (loop-free-loop l) x)
+
+  family-with-descent-data-constant-type :
+    family-with-descent-data-circle l l2
+  pr1 family-with-descent-data-constant-type = constant-type-family S X
+  pr1 (pr2 family-with-descent-data-constant-type) =
+    descent-data-circle-constant-type
+  pr2 (pr2 family-with-descent-data-constant-type) =
+    eq-descent-data-circle-constant-type
+```

From 0bff899cde37bb4cb1af2db8d09f46d65a84cedb Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Thu, 24 Aug 2023 09:56:39 +0200
Subject: [PATCH 13/25] Descent data for dependent pair types

---
 src/synthetic-homotopy-theory.lagda.md        |  1 +
 ...scent-circle-dependent-pair-types.lagda.md | 99 +++++++++++++++++++
 2 files changed, 100 insertions(+)
 create mode 100644 src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md

diff --git a/src/synthetic-homotopy-theory.lagda.md b/src/synthetic-homotopy-theory.lagda.md
index 80246b547e..6094e19fde 100644
--- a/src/synthetic-homotopy-theory.lagda.md
+++ b/src/synthetic-homotopy-theory.lagda.md
@@ -21,6 +21,7 @@ open import synthetic-homotopy-theory.dependent-pullback-property-pushouts publi
 open import synthetic-homotopy-theory.dependent-universal-property-pushouts public
 open import synthetic-homotopy-theory.descent-circle public
 open import synthetic-homotopy-theory.descent-circle-constant-families public
+open import synthetic-homotopy-theory.descent-circle-dependent-pair-types public
 open import synthetic-homotopy-theory.descent-circle-function-types public
 open import synthetic-homotopy-theory.double-loop-spaces public
 open import synthetic-homotopy-theory.free-loops public
diff --git a/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
new file mode 100644
index 0000000000..28c3ab6556
--- /dev/null
+++ b/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
@@ -0,0 +1,99 @@
+# Descent data for dependent pair types over the circle
+
+```agda
+module synthetic-homotopy-theory.descent-circle-dependent-pair-types where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.commuting-squares-of-maps
+open import foundation.commuting-triangles-of-maps
+open import foundation.dependent-pair-types
+open import foundation.equality-dependent-pair-types
+open import foundation.equivalences
+open import foundation.function-extensionality
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.functoriality-function-types
+open import foundation.homotopies
+open import foundation.identity-types
+open import foundation.transport
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.descent-circle
+open import synthetic-homotopy-theory.free-loops
+open import synthetic-homotopy-theory.sections-descent-circle
+open import synthetic-homotopy-theory.universal-property-circle
+```
+
+</details>
+
+## Idea
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-dependent-descent-data-circle l A l3)
+  where
+
+  family-descent-data-circle-dependent-pair-type : S → UU (l2 ⊔ l3)
+  family-descent-data-circle-dependent-pair-type x =
+    Σ ( family-family-with-descent-data-circle A x)
+      ( family-family-with-dependent-descent-data-circle A B x)
+
+  descent-data-circle-dependent-pair-type : descent-data-circle (l2 ⊔ l3)
+  pr1 descent-data-circle-dependent-pair-type =
+    Σ ( type-family-with-descent-data-circle A)
+      ( type-family-with-dependent-descent-data-circle A B)
+  pr2 descent-data-circle-dependent-pair-type =
+    equiv-Σ
+      ( type-family-with-dependent-descent-data-circle A B)
+      ( aut-family-with-descent-data-circle A)
+      ( pseudo-aut-family-with-dependent-descent-data-circle A B)
+
+  eq-descent-data-circle-dependent-pair-type :
+    Eq-descent-data-circle
+      ( descent-data-circle-dependent-pair-type)
+      ( ev-descent-data-circle l family-descent-data-circle-dependent-pair-type)
+  pr1 eq-descent-data-circle-dependent-pair-type =
+    equiv-Σ
+      ( family-family-with-dependent-descent-data-circle A B (base-free-loop l))
+      ( equiv-family-with-descent-data-circle A)
+      ( equiv-family-with-dependent-descent-data-circle A B)
+  pr2 eq-descent-data-circle-dependent-pair-type u =
+    inv
+      ( tr-Σ
+          ( family-family-with-dependent-descent-data-circle A B)
+          ( loop-free-loop l)
+          ( map-Σ
+            ( family-family-with-dependent-descent-data-circle A B
+              ( base-free-loop l))
+            ( map-equiv-family-with-descent-data-circle A)
+            ( map-equiv-family-with-dependent-descent-data-circle A B)
+            ( u)) ∙
+        eq-pair-Σ
+          ( inv (coherence-square-family-with-descent-data-circle A (pr1 u)))
+          ( inv
+            ( coherence-square-family-with-dependent-descent-data-circle A B
+              ( pr1 u)
+              ( pr2 u) ∙
+              tr-eq-pair-Σ
+                ( ind-Σ (family-family-with-dependent-descent-data-circle A B))
+                ( loop-free-loop l)
+                ( inv
+                  ( coherence-square-family-with-descent-data-circle A (pr1 u)))
+                ( map-equiv-family-with-dependent-descent-data-circle A B
+                  ( pr1 u)
+                  ( pr2 u)))))
+
+  family-with-descent-data-circle-dependent-pair-type :
+    family-with-descent-data-circle l (l2 ⊔ l3)
+  pr1 family-with-descent-data-circle-dependent-pair-type =
+    family-descent-data-circle-dependent-pair-type
+  pr1 (pr2 family-with-descent-data-circle-dependent-pair-type) =
+    descent-data-circle-dependent-pair-type
+  pr2 (pr2 family-with-descent-data-circle-dependent-pair-type) =
+    eq-descent-data-circle-dependent-pair-type
+```

From 0e31080d32f73625b407ade17d224c3c91906eda Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Thu, 24 Aug 2023 09:57:20 +0200
Subject: [PATCH 14/25] Leave uniqueness of dependent descent data unproven

---
 src/synthetic-homotopy-theory/descent-circle.lagda.md | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index 73d5ea8903..f9e10de05b 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -735,9 +735,9 @@ module _
         ( l3)) →
     is-contr (family-for-dependent-descent-data-circle l A Q)
 
-  unique-dependent-family-property-circle-dependent-universal-property-circle :
-    dependent-universal-property-circle (l2 ⊔ lsuc l3) l →
-    unique-dependent-family-property-circle
-  unique-dependent-family-property-circle-dependent-universal-property-circle
-    dup-circle Q = {!!}
+  -- unique-dependent-family-property-circle-dependent-universal-property-circle :
+  --   dependent-universal-property-circle (l2 ⊔ lsuc l3) l →
+  --   unique-dependent-family-property-circle
+  -- unique-dependent-family-property-circle-dependent-universal-property-circle
+  --   dup-circle Q = {!!}
 ```

From 15e1c380f7eee3da2c3735e4add0793476cdeabc Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Thu, 24 Aug 2023 11:40:58 +0200
Subject: [PATCH 15/25] Wording

---
 .../descent-circle-dependent-pair-types.lagda.md     | 12 +++++++++++-
 .../descent-circle-function-types.lagda.md           |  8 ++++----
 2 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
index 28c3ab6556..f1d2fb33f0 100644
--- a/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
@@ -1,4 +1,4 @@
-# Descent data for dependent pair types over the circle
+# Descent data for families of dependent pair types over the circle
 
 ```agda
 module synthetic-homotopy-theory.descent-circle-dependent-pair-types where
@@ -31,6 +31,16 @@ open import synthetic-homotopy-theory.universal-property-circle
 
 ## Idea
 
+Given a family `A : 𝕊¹ → U` over the circle and a family
+`B : (t : 𝕊¹) → (A t) → U` over `A`, the
+[descent data](synthetic-homotopy-theory.descent-circle.md) for the family of
+dependent pair types `λ t → Σ (A t) (B t)` is `(Σ X R, map-Σ e k)`, where
+`(X, e)` is descent data for `A` and `(R, k)` is dependent descent data for `B`.
+
+## Properties
+
+### Characterization of descent data for families of dependent pair types over the circle
+
 ```agda
 module _
   { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
diff --git a/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
index 0a00005614..300860dc90 100644
--- a/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
@@ -1,4 +1,4 @@
-# Descent data for function types over the circle
+# Descent data for families of function types over the circle
 
 ```agda
 module synthetic-homotopy-theory.descent-circle-function-types where
@@ -31,9 +31,9 @@ open import synthetic-homotopy-theory.universal-property-circle
 ## Idea
 
 Given two families `A, B : 𝕊¹ → U` over the circle, the
-[descent data](synthetic-homotopy-theory.descent-circle.md) for the family
-`λ t → (A t → B t)` is `(X → Y, λ h → f ∘ h ∘ e⁻¹)`, where `(X, e)` is descent
-data for `A` and `(Y, f)` is descent data for `B`.
+[descent data](synthetic-homotopy-theory.descent-circle.md) for the family of
+function types `λ t → (A t → B t)` is `(X → Y, λ h → f ∘ h ∘ e⁻¹)`, where
+`(X, e)` is descent data for `A` and `(Y, f)` is descent data for `B`.
 
 This correspondence allows us to characterize sections of this family as
 homomorphisms from `(X, e)` to `(Y, f)`.

From 74c339d3f043de391467c56c47c1e9f3d2675c22 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Thu, 24 Aug 2023 11:54:04 +0200
Subject: [PATCH 16/25] Remove unused imports

---
 .../descent-circle-dependent-pair-types.lagda.md         | 9 ---------
 1 file changed, 9 deletions(-)

diff --git a/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
index f1d2fb33f0..f1ecbb4a90 100644
--- a/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
@@ -7,24 +7,15 @@ module synthetic-homotopy-theory.descent-circle-dependent-pair-types where
 <details><summary>Imports</summary>
 
 ```agda
-open import foundation.commuting-squares-of-maps
-open import foundation.commuting-triangles-of-maps
 open import foundation.dependent-pair-types
 open import foundation.equality-dependent-pair-types
 open import foundation.equivalences
-open import foundation.function-extensionality
-open import foundation.function-types
 open import foundation.functoriality-dependent-pair-types
-open import foundation.functoriality-function-types
-open import foundation.homotopies
 open import foundation.identity-types
-open import foundation.transport
 open import foundation.universe-levels
 
 open import synthetic-homotopy-theory.descent-circle
 open import synthetic-homotopy-theory.free-loops
-open import synthetic-homotopy-theory.sections-descent-circle
-open import synthetic-homotopy-theory.universal-property-circle
 ```
 
 </details>

From bbf99c2515a6a288f6bb4892c29514f1bce1bee2 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 25 Aug 2023 00:55:23 +0200
Subject: [PATCH 17/25] Sections of families of subtypes

---
 src/synthetic-homotopy-theory.lagda.md        |   1 +
 .../descent-circle-subtypes.lagda.md          | 136 ++++++++++++++++++
 2 files changed, 137 insertions(+)
 create mode 100644 src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md

diff --git a/src/synthetic-homotopy-theory.lagda.md b/src/synthetic-homotopy-theory.lagda.md
index 6094e19fde..0a2c7399a0 100644
--- a/src/synthetic-homotopy-theory.lagda.md
+++ b/src/synthetic-homotopy-theory.lagda.md
@@ -23,6 +23,7 @@ open import synthetic-homotopy-theory.descent-circle public
 open import synthetic-homotopy-theory.descent-circle-constant-families public
 open import synthetic-homotopy-theory.descent-circle-dependent-pair-types public
 open import synthetic-homotopy-theory.descent-circle-function-types public
+open import synthetic-homotopy-theory.descent-circle-subtypes public
 open import synthetic-homotopy-theory.double-loop-spaces public
 open import synthetic-homotopy-theory.free-loops public
 open import synthetic-homotopy-theory.functoriality-loop-spaces public
diff --git a/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md b/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md
new file mode 100644
index 0000000000..174daa83ce
--- /dev/null
+++ b/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md
@@ -0,0 +1,136 @@
+# Subtypes of descent data for the circle
+
+```agda
+module synthetic-homotopy-theory.descent-circle-subtypes where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.cartesian-product-types
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.functoriality-dependent-pair-types
+open import foundation.identity-types
+open import foundation.propositions
+open import foundation.subtypes
+open import foundation.type-arithmetic-cartesian-product-types
+open import foundation.type-arithmetic-dependent-pair-types
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.descent-circle
+open import synthetic-homotopy-theory.descent-circle-dependent-pair-types
+open import synthetic-homotopy-theory.free-loops
+open import synthetic-homotopy-theory.sections-descent-circle
+open import synthetic-homotopy-theory.universal-property-circle
+```
+
+</details>
+
+## Idea
+
+Given a family `A : 𝕊¹ → U` over the circle and a family
+`B : (t : 𝕊¹) → (A t) → U` over `A` with corresponding
+[descent data](synthetic-homotopy-theory.descent-circle.md) `(X, e)` and
+dependent descent data `(R, k)`, where `R` is a subtype of `X`,
+we get that dependent functions of type `(t : 𝕊¹) → Σ (A t) (B t)` are exactly
+the fixpoints of `e` which belong to `R`.
+
+## Properties
+
+### Characterization of sections of families of subtypes
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-dependent-descent-data-circle l A l3)
+  ( is-subtype-B :
+    ( t : S) →
+    is-subtype (family-family-with-dependent-descent-data-circle A B t))
+  where
+
+  subtype-descent-data-circle-subtype :
+    subtype l3 (type-family-with-descent-data-circle A)
+  pr1 (subtype-descent-data-circle-subtype x) =
+    type-family-with-dependent-descent-data-circle A B x
+  pr2 (subtype-descent-data-circle-subtype x) =
+    is-prop-equiv
+      ( equiv-family-with-dependent-descent-data-circle A B x)
+      ( is-subtype-B
+        ( base-free-loop l)
+        ( map-equiv-family-with-descent-data-circle A x))
+
+  equiv-fixpoint-descent-data-circle-subtype-fixpoint-in-subtype :
+    fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle
+        ( family-with-descent-data-circle-dependent-pair-type l A B)) ≃
+    ( Σ ( fixpoint-descent-data-circle
+          ( descent-data-family-with-descent-data-circle A))
+        ( λ x → is-in-subtype subtype-descent-data-circle-subtype (pr1 x)))
+  equiv-fixpoint-descent-data-circle-subtype-fixpoint-in-subtype =
+    equivalence-reasoning
+    fixpoint-descent-data-circle
+      ( descent-data-family-with-descent-data-circle
+        ( family-with-descent-data-circle-dependent-pair-type l A B))
+    ≃ Σ ( type-family-with-descent-data-circle A)
+        ( λ x →
+          Σ ( type-family-with-dependent-descent-data-circle A B x)
+            ( λ r →
+              map-Σ
+                ( type-family-with-dependent-descent-data-circle A B)
+                ( map-aut-family-with-descent-data-circle A)
+                ( map-pseudo-aut-family-with-dependent-descent-data-circle A B)
+                ( x , r) ＝
+              ( x , r)))
+      by
+        associative-Σ
+          ( type-family-with-descent-data-circle A)
+          ( type-family-with-dependent-descent-data-circle A B)
+          ( λ u →
+            map-Σ
+              ( type-family-with-dependent-descent-data-circle A B)
+              ( map-aut-family-with-descent-data-circle A)
+              ( map-pseudo-aut-family-with-dependent-descent-data-circle A B)
+              ( u) ＝
+            u)
+    ≃ Σ ( type-family-with-descent-data-circle A)
+        ( λ x →
+          ( is-in-subtype subtype-descent-data-circle-subtype x) ×
+          ( map-aut-family-with-descent-data-circle A x ＝ x))
+      by
+        equiv-tot
+          ( λ x →
+            equiv-tot
+              ( λ r →
+                extensionality-type-subtype'
+                  ( subtype-descent-data-circle-subtype)
+                  ( _)
+                  ( x , r)))
+    ≃ Σ ( type-family-with-descent-data-circle A)
+        ( λ x →
+          ( map-aut-family-with-descent-data-circle A x ＝ x) ×
+          ( is-in-subtype subtype-descent-data-circle-subtype x))
+      by equiv-tot (λ _ → commutative-prod)
+    ≃ Σ ( fixpoint-descent-data-circle
+          ( descent-data-family-with-descent-data-circle A))
+        ( λ x → is-in-subtype subtype-descent-data-circle-subtype (pr1 x))
+      by
+        inv-associative-Σ
+          ( type-family-with-descent-data-circle A)
+          ( λ x → map-aut-family-with-descent-data-circle A x ＝ x)
+          ( λ x → is-in-subtype subtype-descent-data-circle-subtype (pr1 x))
+
+  equiv-section-descent-data-circle-subtype-fixpoint-in-subtype :
+    dependent-universal-property-circle (l2 ⊔ l3) l →
+    ( (x : S) → family-descent-data-circle-dependent-pair-type l A B x) ≃
+    ( Σ ( fixpoint-descent-data-circle
+          ( descent-data-family-with-descent-data-circle A))
+        ( λ x → is-in-subtype subtype-descent-data-circle-subtype (pr1 x)))
+  equiv-section-descent-data-circle-subtype-fixpoint-in-subtype dup-circle =
+    equiv-fixpoint-descent-data-circle-subtype-fixpoint-in-subtype ∘e
+    ( equiv-ev-fixpoint-descent-data-circle
+      ( l)
+      ( family-with-descent-data-circle-dependent-pair-type l A B)
+      ( dup-circle))
+```

From 00ef0c2c89fb84ecc74b9eebad6619c7e52e64bc Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 25 Aug 2023 13:13:15 +0200
Subject: [PATCH 18/25] pre-commit

---
 .../descent-circle-subtypes.lagda.md                        | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md b/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md
index 174daa83ce..994cd47dc5 100644
--- a/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md
@@ -32,9 +32,9 @@ open import synthetic-homotopy-theory.universal-property-circle
 Given a family `A : 𝕊¹ → U` over the circle and a family
 `B : (t : 𝕊¹) → (A t) → U` over `A` with corresponding
 [descent data](synthetic-homotopy-theory.descent-circle.md) `(X, e)` and
-dependent descent data `(R, k)`, where `R` is a subtype of `X`,
-we get that dependent functions of type `(t : 𝕊¹) → Σ (A t) (B t)` are exactly
-the fixpoints of `e` which belong to `R`.
+dependent descent data `(R, k)`, where `R` is a subtype of `X`, we get that
+dependent functions of type `(t : 𝕊¹) → Σ (A t) (B t)` are exactly the fixpoints
+of `e` which belong to `R`.
 
 ## Properties
 

From c0e5b23711c9c401dac3ec86f507e633fc7c85a3 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 25 Aug 2023 13:21:02 +0200
Subject: [PATCH 19/25] Characterize families of equivalences over the circle

---
 src/foundation/equivalences.lagda.md          |  52 ++++++++
 src/synthetic-homotopy-theory.lagda.md        |   1 +
 .../descent-circle-equivalence-types.lagda.md | 125 ++++++++++++++++++
 .../descent-circle.lagda.md                   |  20 +++
 4 files changed, 198 insertions(+)
 create mode 100644 src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md

diff --git a/src/foundation/equivalences.lagda.md b/src/foundation/equivalences.lagda.md
index ae1f1e6ca5..252b2fccc9 100644
--- a/src/foundation/equivalences.lagda.md
+++ b/src/foundation/equivalences.lagda.md
@@ -337,6 +337,58 @@ module _
   pr2 emb-map-equiv = is-emb-map-equiv
 ```
 
+### Being an equivalence is closed under postcompositions by equivalences
+
+```agda
+module _
+  { l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {C : UU l3}
+  where
+
+  equiv-is-equiv-postcomp-is-equiv :
+    { f : A → B} (e : B ≃ C) →
+    is-equiv f ≃ is-equiv (map-equiv e ∘ f)
+  equiv-is-equiv-postcomp-is-equiv {f} e =
+    equiv-prop
+      ( is-property-is-equiv f)
+      ( is-property-is-equiv (map-equiv e ∘ f))
+      ( λ is-equiv-f →
+        is-equiv-comp
+          ( map-equiv e)
+          ( f)
+          ( is-equiv-f)
+          ( is-equiv-map-equiv e))
+      ( is-equiv-right-factor
+        ( map-equiv e)
+        ( f)
+        ( is-equiv-map-equiv e))
+```
+
+### Being an equivalence is closed under precompositions by equivalences
+
+```agda
+module _
+  { l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {C : UU l3}
+  where
+
+  equiv-is-equiv-precomp-is-equiv :
+    ( e : A ≃ B) {f : B → C} →
+    is-equiv f ≃ is-equiv (f ∘ map-equiv e)
+  equiv-is-equiv-precomp-is-equiv e {f} =
+    equiv-prop
+      ( is-property-is-equiv f)
+      ( is-property-is-equiv (f ∘ map-equiv e))
+      ( is-equiv-comp
+        ( f)
+        ( map-equiv e)
+        ( is-equiv-map-equiv e))
+      ( λ is-equiv-f-e →
+        is-equiv-left-factor
+          ( f)
+          ( map-equiv e)
+          ( is-equiv-f-e)
+          ( is-equiv-map-equiv e))
+```
+
 ### Homotopy induction for homotopies between equivalences
 
 ```agda
diff --git a/src/synthetic-homotopy-theory.lagda.md b/src/synthetic-homotopy-theory.lagda.md
index 0a2c7399a0..58d0c18a4e 100644
--- a/src/synthetic-homotopy-theory.lagda.md
+++ b/src/synthetic-homotopy-theory.lagda.md
@@ -22,6 +22,7 @@ open import synthetic-homotopy-theory.dependent-universal-property-pushouts publ
 open import synthetic-homotopy-theory.descent-circle public
 open import synthetic-homotopy-theory.descent-circle-constant-families public
 open import synthetic-homotopy-theory.descent-circle-dependent-pair-types public
+open import synthetic-homotopy-theory.descent-circle-equivalence-types public
 open import synthetic-homotopy-theory.descent-circle-function-types public
 open import synthetic-homotopy-theory.descent-circle-subtypes public
 open import synthetic-homotopy-theory.double-loop-spaces public
diff --git a/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
new file mode 100644
index 0000000000..676422eb3a
--- /dev/null
+++ b/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
@@ -0,0 +1,125 @@
+# Descent data for families of equivalence types over the circle
+
+```agda
+module synthetic-homotopy-theory.descent-circle-equivalence-types where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.contractible-types
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.functoriality-dependent-pair-types
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.descent-circle
+open import synthetic-homotopy-theory.descent-circle-dependent-pair-types
+open import synthetic-homotopy-theory.descent-circle-function-types
+open import synthetic-homotopy-theory.descent-circle-subtypes
+open import synthetic-homotopy-theory.free-loops
+open import synthetic-homotopy-theory.sections-descent-circle
+open import synthetic-homotopy-theory.universal-property-circle
+```
+
+</details>
+
+## Idea
+
+## Properties
+
+### Characterization of descent data for families of equivalence types over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
+  dependent-descent-data-circle-is-equiv :
+    dependent-descent-data-circle
+      ( descent-data-circle-function-type l A B)
+      ( l2 ⊔ l3)
+  pr1 dependent-descent-data-circle-is-equiv = is-equiv
+  pr2 dependent-descent-data-circle-is-equiv f =
+    equiv-is-equiv-postcomp-is-equiv
+      ( aut-family-with-descent-data-circle B) ∘e
+    ( equiv-is-equiv-precomp-is-equiv
+      ( inv-equiv (aut-family-with-descent-data-circle A)))
+
+  family-with-dependent-descent-data-circle-is-equiv :
+    family-with-dependent-descent-data-circle l
+      ( family-with-descent-data-circle-function-type l A B)
+      ( l2 ⊔ l3)
+  pr1 family-with-dependent-descent-data-circle-is-equiv t = is-equiv
+  pr1 (pr2 family-with-dependent-descent-data-circle-is-equiv) =
+    dependent-descent-data-circle-is-equiv
+  pr1 (pr2 (pr2 family-with-dependent-descent-data-circle-is-equiv)) f =
+    equiv-is-equiv-postcomp-is-equiv
+      ( equiv-family-with-descent-data-circle B) ∘e
+    ( equiv-is-equiv-precomp-is-equiv
+      ( inv-equiv (equiv-family-with-descent-data-circle A)))
+  pr2 (pr2 (pr2 family-with-dependent-descent-data-circle-is-equiv)) f p =
+    center (is-property-is-equiv _ _ _)
+
+  family-with-descent-data-circle-equivalence-type :
+    family-with-descent-data-circle l (l2 ⊔ l3)
+  family-with-descent-data-circle-equivalence-type =
+    family-with-descent-data-circle-dependent-pair-type l
+      ( family-with-descent-data-circle-function-type l A B)
+      ( family-with-dependent-descent-data-circle-is-equiv)
+```
+
+### A family of equivalences between families over the circle is given by an equivalence of the corresponding descent data
+
+```agda
+  equiv-section-descent-data-circle-equiv-Eq-descent-data-circle :
+    dependent-universal-property-circle (l2 ⊔ l3) l →
+    ( (t : S) →
+      ( family-family-with-descent-data-circle A t) ≃
+      ( family-family-with-descent-data-circle B t)) ≃
+    ( Eq-descent-data-circle
+      ( descent-data-family-with-descent-data-circle A)
+      ( descent-data-family-with-descent-data-circle B))
+  equiv-section-descent-data-circle-equiv-Eq-descent-data-circle dup-circle =
+    equivalence-reasoning
+    ( (t : S) →
+        family-family-with-descent-data-circle A t ≃
+        family-family-with-descent-data-circle B t)
+    ≃ Σ ( fixpoint-descent-data-circle
+          ( descent-data-circle-function-type l A B))
+        ( λ x → is-equiv (pr1 x))
+      by
+        equiv-section-descent-data-circle-subtype-fixpoint-in-subtype l
+          ( family-with-descent-data-circle-function-type l A B)
+          ( family-with-dependent-descent-data-circle-is-equiv)
+          ( λ t f → is-property-is-equiv f)
+          ( dup-circle)
+    ≃ Σ ( hom-descent-data-circle
+          ( descent-data-family-with-descent-data-circle A)
+          ( descent-data-family-with-descent-data-circle B))
+        ( λ h →
+          is-equiv
+            ( map-hom-descent-data-circle
+              ( descent-data-family-with-descent-data-circle A)
+              ( descent-data-family-with-descent-data-circle B)
+              ( h)))
+      by
+        equiv-Σ-equiv-base
+          ( λ h →
+            is-equiv
+              ( map-hom-descent-data-circle
+                ( descent-data-family-with-descent-data-circle A)
+                ( descent-data-family-with-descent-data-circle B)
+                ( h)))
+          ( equiv-fixpoint-descent-data-circle-function-type-hom l A B)
+    ≃ Eq-descent-data-circle
+        ( descent-data-family-with-descent-data-circle A)
+        ( descent-data-family-with-descent-data-circle B)
+      by
+        inv-equiv
+          ( equiv-Eq-descent-data-circle-hom-is-equiv
+            ( descent-data-family-with-descent-data-circle A)
+            ( descent-data-family-with-descent-data-circle B))
+```
diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index f9e10de05b..d998f8ea5e 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -26,6 +26,7 @@ open import foundation.homotopies
 open import foundation.identity-types
 open import foundation.structure-identity-principle
 open import foundation.transport
+open import foundation.type-arithmetic-dependent-pair-types
 open import foundation.univalence
 open import foundation.universe-levels
 
@@ -586,6 +587,25 @@ eq-Eq-descent-data-circle P Q =
   map-inv-is-equiv (is-equiv-Eq-eq-descent-data-circle P Q)
 ```
 
+### Alternative definition of equality of descent data as homomorphisms which are equivalences
+
+```agda
+module _
+  { l1 l2 : Level}
+  ( P : descent-data-circle l1)
+  ( Q : descent-data-circle l2)
+  where
+
+  Eq-descent-data-circle' : UU (l1 ⊔ l2)
+  Eq-descent-data-circle' =
+    Σ ( hom-descent-data-circle P Q)
+      ( λ h → is-equiv (map-hom-descent-data-circle P Q h))
+
+  equiv-Eq-descent-data-circle-hom-is-equiv :
+    Eq-descent-data-circle P Q ≃ Eq-descent-data-circle'
+  equiv-Eq-descent-data-circle-hom-is-equiv = equiv-right-swap-Σ
+```
+
 ### Uniqueness of descent data characterizing a type family over the circle
 
 ```agda

From 8cd1e4675b1b87bbfed46b7bd7e5429a0df82f9d Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 25 Aug 2023 14:34:29 +0200
Subject: [PATCH 20/25] Prose

---
 .../descent-circle-equivalence-types.lagda.md                  | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
index 676422eb3a..7867cd4c82 100644
--- a/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
@@ -26,6 +26,9 @@ open import synthetic-homotopy-theory.universal-property-circle
 
 ## Idea
 
+Given two families `A, B : 𝕊¹ → U` over the circle, to show that they are
+equivalent is the same as showing that their descent data is equivalent.
+
 ## Properties
 
 ### Characterization of descent data for families of equivalence types over the circle

From cdbb2869f19e027b73247e339a7b137a94750c91 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 25 Aug 2023 15:08:28 +0200
Subject: [PATCH 21/25] Prose, construction of a family for descent data

---
 .../descent-circle.lagda.md                   | 37 ++++++++++++++++---
 1 file changed, 31 insertions(+), 6 deletions(-)

diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index d998f8ea5e..1c32fd89a9 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -282,10 +282,10 @@ module _
 The equivalence extends to the dependent case, where given a type family `A`
 over the circle with descent data `(X, e)`, a type family
 `B : (t : 𝕊¹) → A t → U` is equivalent to a type family `R : X → U` equipped
-with a family of equivalences `K : (x : X) → R(x) ≃ R(e(x))`. The pair `(R, K)`
-is called **dependent descent data** for the circle. Intuitively, this states
-that the types over points of `X` belonging to the same connected component in
-the total space `Σ 𝕊¹ A` are equivalent.
+with a family of equivalences `k : (x : X) → R(x) ≃ R(e(x))`. The pair `(R, k)`
+is called **dependent descent data** for the circle over `A`. Intuitively, this
+states that the types over points of `X` belonging to the same connected
+component in the total space `Σ 𝕊¹ A` are equivalent.
 
 ```agda
 dependent-descent-data-circle :
@@ -608,6 +608,9 @@ module _
 
 ### Uniqueness of descent data characterizing a type family over the circle
 
+Given a type `X` and an automorphism `e : X ≃ X`, there is a unique type family
+`𝓓(X, e) : 𝕊¹ → U` for which `(X, e)` is descent data.
+
 ```agda
 comparison-descent-data-circle :
   ( l1 : Level) → free-loop (UU l1) → descent-data-circle l1
@@ -653,12 +656,12 @@ unique-family-property-circle l2 {S} l =
 
 module _
   { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( up-circle : universal-property-circle (lsuc l2) l)
   where
 
   unique-family-property-universal-property-circle :
-    universal-property-circle (lsuc l2) l →
     unique-family-property-circle l2 l
-  unique-family-property-universal-property-circle up-circle Q =
+  unique-family-property-universal-property-circle Q =
     is-contr-is-equiv'
       ( fib (ev-descent-data-circle l) Q)
       ( tot
@@ -677,6 +680,21 @@ module _
           ( l)
           ( up-circle))
         ( Q))
+
+  family-for-descent-data-circle-descent-data :
+    ( P : descent-data-circle l2) →
+    family-for-descent-data-circle l P
+  family-for-descent-data-circle-descent-data P =
+    center (unique-family-property-universal-property-circle P)
+
+  family-with-descent-data-circle-descent-data :
+    ( P : descent-data-circle l2) →
+    ( family-with-descent-data-circle l l2)
+  pr1 (family-with-descent-data-circle-descent-data P) =
+    pr1 (family-for-descent-data-circle-descent-data P)
+  pr1 (pr2 (family-with-descent-data-circle-descent-data P)) = P
+  pr2 (pr2 (family-with-descent-data-circle-descent-data P)) =
+    pr2 (family-for-descent-data-circle-descent-data P)
 ```
 
 ### Characterization of the identity type of dependent descent data for the circle
@@ -741,6 +759,13 @@ module _
 
 ### Uniqueness of dependent descent data characterizing a type family over a family over the circle
 
+Given a type family `A : 𝕊¹ → U` with corresponding descent data `(X, e)`, and a
+type family `R : X → U` over `X` invariant under `e` as witnessed by `k`, there
+is a unique family `B : (t : 𝕊¹) → A t → U` for which `(R, k)` is dependent
+descent data over `A`.
+
+This is so far a conjecture which remains to be shown.
+
 ```agda
 module _
   { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)

From fe7db293b7fb70f52bb4e8b0299b03a4460ef909 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 25 Aug 2023 16:11:56 +0200
Subject: [PATCH 22/25] Miniscule surface cleanup of the universal cover of the
 circle

---
 .../universal-cover-circle.lagda.md           | 97 +++++++++----------
 .../universal-property-circle.lagda.md        |  2 +-
 2 files changed, 47 insertions(+), 52 deletions(-)

diff --git a/src/synthetic-homotopy-theory/universal-cover-circle.lagda.md b/src/synthetic-homotopy-theory/universal-cover-circle.lagda.md
index 12705fc72e..719258c5f5 100644
--- a/src/synthetic-homotopy-theory/universal-cover-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/universal-cover-circle.lagda.md
@@ -13,6 +13,7 @@ open import elementary-number-theory.universal-property-integers
 open import foundation.action-on-identifications-dependent-functions
 open import foundation.action-on-identifications-functions
 open import foundation.cartesian-product-types
+open import foundation.commuting-squares-of-maps
 open import foundation.contractible-types
 open import foundation.dependent-identifications
 open import foundation.dependent-pair-types
@@ -46,22 +47,16 @@ circle with respect to any universe level, then it satisfies the induction
 principle with respect to the zeroth universe level.
 
 ```agda
-naturality-tr-fiberwise-transformation :
-  { l1 l2 l3 : Level} {X : UU l1} {P : X → UU l2} {Q : X → UU l3}
-  ( f : (x : X) → P x → Q x) {x y : X} (α : Id x y) (p : P x) →
-  Id (tr Q α (f x p)) (f y (tr P α p))
-naturality-tr-fiberwise-transformation f refl p = refl
-
 functor-free-dependent-loop :
   { l1 l2 l3 : Level} {X : UU l1} (l : free-loop X)
   { P : X → UU l2} {Q : X → UU l3} (f : (x : X) → P x → Q x) →
   free-dependent-loop l P → free-dependent-loop l Q
 functor-free-dependent-loop l {P} {Q} f =
   map-Σ
-    ( λ q₀ → Id (tr Q (loop-free-loop l) q₀) q₀)
+    ( λ q → dependent-identification Q (loop-free-loop l) q q)
     ( f (base-free-loop l))
-    ( λ p₀ α →
-      ( naturality-tr-fiberwise-transformation f (loop-free-loop l) p₀) ∙
+    ( λ p α →
+      inv (preserves-tr f (loop-free-loop l) p) ∙
       ( ap (f (base-free-loop l)) α))
 
 coherence-square-functor-free-dependent-loop :
@@ -69,7 +64,7 @@ coherence-square-functor-free-dependent-loop :
   ( f : (x : X) → P x → Q x) {x y : X} (α : Id x y)
   ( h : (x : X) → P x) →
   Id
-    ( ( naturality-tr-fiberwise-transformation f α (h x)) ∙
+    ( inv ( preserves-tr f α (h x)) ∙
       ( ap (f y) (apd h α)))
     ( apd (map-Π f h) α)
 coherence-square-functor-free-dependent-loop f refl h = refl
@@ -103,12 +98,12 @@ abstract
       ( λ p₀ →
         is-equiv-comp
           ( concat
-            ( naturality-tr-fiberwise-transformation f l p₀)
+            ( inv (preserves-tr f l p₀))
             ( f x p₀))
           ( ap (f x))
           ( is-emb-is-equiv (is-equiv-f x) (tr P l p₀) p₀)
           ( is-equiv-concat
-            ( naturality-tr-fiberwise-transformation f l p₀)
+            ( inv (preserves-tr f l p₀))
             ( f x p₀)))
 
 abstract
@@ -140,45 +135,45 @@ abstract
 ### The fundamental cover
 
 ```agda
-abstract
-  Fundamental-cover-circle :
-    { l1 : Level} {X : UU l1} (l : free-loop X) →
-    ( {l2 : Level} → dependent-universal-property-circle l2 l) →
-    Σ ( X → UU lzero)
-      ( λ P →
-        Eq-descent-data-circle
-        ( pair ℤ equiv-succ-ℤ)
-        ( ev-descent-data-circle l P))
-  Fundamental-cover-circle {l1} l dup-circle =
-    center
-      ( unique-family-property-universal-property-circle l
-        ( universal-property-dependent-universal-property-circle l
-          ( dup-circle))
-        ( pair ℤ equiv-succ-ℤ))
-
-  fundamental-cover-circle :
-    { l1 : Level} {X : UU l1} (l : free-loop X) →
-    ({k : Level} → dependent-universal-property-circle k l) →
-    X → UU lzero
-  fundamental-cover-circle l dup-circle =
-    pr1 (Fundamental-cover-circle l dup-circle)
-
-  compute-fiber-fundamental-cover-circle :
-    { l1 : Level} {X : UU l1} (l : free-loop X) →
-    ( dup-circle : {l2 : Level} → dependent-universal-property-circle l2 l) →
-    ℤ ≃ fundamental-cover-circle l dup-circle (base-free-loop l)
-  compute-fiber-fundamental-cover-circle l dup-circle =
-    pr1 ( pr2 ( Fundamental-cover-circle l dup-circle))
-
-  compute-tr-fundamental-cover-circle :
-    { l1 : Level} {X : UU l1} (l : free-loop X) →
-    ( dup-circle : {l2 : Level} → dependent-universal-property-circle l2 l) →
-    ( ( map-equiv (compute-fiber-fundamental-cover-circle l dup-circle)) ∘
-      ( succ-ℤ)) ~
-    ( ( tr (fundamental-cover-circle l dup-circle) (loop-free-loop l)) ∘
-      ( map-equiv (compute-fiber-fundamental-cover-circle l dup-circle)))
-  compute-tr-fundamental-cover-circle l dup-circle =
-    pr2 ( pr2 ( Fundamental-cover-circle l dup-circle))
+module _
+  { l1 : Level} {S : UU l1} (l : free-loop S)
+  where
+
+  descent-data-Fundamental-cover-circle :
+    descent-data-circle lzero
+  pr1 descent-data-Fundamental-cover-circle = ℤ
+  pr2 descent-data-Fundamental-cover-circle = equiv-succ-ℤ
+
+  module _
+    ( dup-circle : {l2 : Level} → dependent-universal-property-circle l2 l)
+    where
+
+    abstract
+
+      Fundamental-cover-circle : family-with-descent-data-circle l lzero
+      Fundamental-cover-circle =
+        family-with-descent-data-circle-descent-data l
+          ( universal-property-dependent-universal-property-circle l dup-circle)
+          ( descent-data-Fundamental-cover-circle)
+
+      fundamental-cover-circle : S → UU lzero
+      fundamental-cover-circle =
+        family-family-with-descent-data-circle Fundamental-cover-circle
+
+      compute-fiber-fundamental-cover-circle :
+        ℤ ≃ fundamental-cover-circle (base-free-loop l)
+      compute-fiber-fundamental-cover-circle =
+        equiv-family-with-descent-data-circle Fundamental-cover-circle
+
+      compute-tr-fundamental-cover-circle :
+        coherence-square-maps
+          ( map-equiv compute-fiber-fundamental-cover-circle)
+          ( succ-ℤ)
+          ( tr fundamental-cover-circle (loop-free-loop l))
+          ( map-equiv compute-fiber-fundamental-cover-circle)
+      compute-tr-fundamental-cover-circle =
+        coherence-square-family-with-descent-data-circle
+          Fundamental-cover-circle
 ```
 
 ### The fundamental cover of the circle is a family of sets
diff --git a/src/synthetic-homotopy-theory/universal-property-circle.lagda.md b/src/synthetic-homotopy-theory/universal-property-circle.lagda.md
index 002fc6ebb1..eaeaf94f8f 100644
--- a/src/synthetic-homotopy-theory/universal-property-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/universal-property-circle.lagda.md
@@ -263,5 +263,5 @@ abstract
   is-connected-circle' l dup-circle P is-prop-P p =
     map-inv-is-equiv
       ( dup-circle P)
-      ( pair p (center (is-prop-P _ (tr P (pr2 l) p) p)))
+      ( pair p (center (is-prop-P _ (tr P (loop-free-loop l) p) p)))
 ```

From ac4884ebd115b55da3f6ecc968ea135cabfcbf34 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Sat, 26 Aug 2023 13:25:50 +0200
Subject: [PATCH 23/25] Reword a property of is-equiv as a 3-for-2 property

---
 src/foundation/equivalences.lagda.md          | 60 ++++++++++---------
 .../descent-circle-equivalence-types.lagda.md |  8 +--
 2 files changed, 35 insertions(+), 33 deletions(-)

diff --git a/src/foundation/equivalences.lagda.md b/src/foundation/equivalences.lagda.md
index 252b2fccc9..4a0aa8f82e 100644
--- a/src/foundation/equivalences.lagda.md
+++ b/src/foundation/equivalences.lagda.md
@@ -337,56 +337,58 @@ module _
   pr2 emb-map-equiv = is-emb-map-equiv
 ```
 
-### Being an equivalence is closed under postcompositions by equivalences
+### The 3-for-2 property of being an equivalence
+
+#### If a right factor is an equivalence, then the left factor is an equivalence iff the composite is
 
 ```agda
 module _
   { l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {C : UU l3}
   where
 
-  equiv-is-equiv-postcomp-is-equiv :
-    { f : A → B} (e : B ≃ C) →
-    is-equiv f ≃ is-equiv (map-equiv e ∘ f)
-  equiv-is-equiv-postcomp-is-equiv {f} e =
+  equiv-is-equiv-left-factor-htpy :
+    { f : A → B} (e : B ≃ C) (h : A → C) (H : h ~ (map-equiv e ∘ f)) →
+    is-equiv f ≃ is-equiv h
+  equiv-is-equiv-left-factor-htpy {f} e h H =
     equiv-prop
       ( is-property-is-equiv f)
-      ( is-property-is-equiv (map-equiv e ∘ f))
+      ( is-property-is-equiv h)
       ( λ is-equiv-f →
-        is-equiv-comp
-          ( map-equiv e)
-          ( f)
-          ( is-equiv-f)
+        is-equiv-comp-htpy h (map-equiv e) f H is-equiv-f
           ( is-equiv-map-equiv e))
-      ( is-equiv-right-factor
-        ( map-equiv e)
-        ( f)
-        ( is-equiv-map-equiv e))
+      ( is-equiv-right-factor-htpy h (map-equiv e) f H (is-equiv-map-equiv e))
+
+  equiv-is-equiv-left-factor :
+    { f : A → B} (e : B ≃ C) →
+    is-equiv f ≃ is-equiv (map-equiv e ∘ f)
+  equiv-is-equiv-left-factor {f} e =
+    equiv-is-equiv-left-factor-htpy e (map-equiv e ∘ f) refl-htpy
 ```
 
-### Being an equivalence is closed under precompositions by equivalences
+#### If a left factor is an equivalence, then the right factor is an equivalence iff the composite is
 
 ```agda
 module _
   { l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {C : UU l3}
   where
 
-  equiv-is-equiv-precomp-is-equiv :
-    ( e : A ≃ B) {f : B → C} →
-    is-equiv f ≃ is-equiv (f ∘ map-equiv e)
-  equiv-is-equiv-precomp-is-equiv e {f} =
+  equiv-is-equiv-right-factor-htpy :
+    ( e : A ≃ B) {f : B → C} (h : A → C) (H : h ~ (f ∘ map-equiv e)) →
+    is-equiv f ≃ is-equiv h
+  equiv-is-equiv-right-factor-htpy e {f} h H =
     equiv-prop
       ( is-property-is-equiv f)
-      ( is-property-is-equiv (f ∘ map-equiv e))
-      ( is-equiv-comp
-        ( f)
-        ( map-equiv e)
-        ( is-equiv-map-equiv e))
-      ( λ is-equiv-f-e →
-        is-equiv-left-factor
-          ( f)
-          ( map-equiv e)
-          ( is-equiv-f-e)
+      ( is-property-is-equiv h)
+      ( is-equiv-comp-htpy h f (map-equiv e) H (is-equiv-map-equiv e))
+      ( λ is-equiv-h →
+        is-equiv-left-factor-htpy h f (map-equiv e) H is-equiv-h
           ( is-equiv-map-equiv e))
+
+  equiv-is-equiv-right-factor :
+    ( e : A ≃ B) {f : B → C} →
+    is-equiv f ≃ is-equiv (f ∘ map-equiv e)
+  equiv-is-equiv-right-factor e {f} =
+    equiv-is-equiv-right-factor-htpy e (f ∘ map-equiv e) refl-htpy
 ```
 
 ### Homotopy induction for homotopies between equivalences
diff --git a/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
index 7867cd4c82..6b919fbf0f 100644
--- a/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
@@ -46,9 +46,9 @@ module _
       ( l2 ⊔ l3)
   pr1 dependent-descent-data-circle-is-equiv = is-equiv
   pr2 dependent-descent-data-circle-is-equiv f =
-    equiv-is-equiv-postcomp-is-equiv
+    equiv-is-equiv-left-factor
       ( aut-family-with-descent-data-circle B) ∘e
-    ( equiv-is-equiv-precomp-is-equiv
+    ( equiv-is-equiv-right-factor
       ( inv-equiv (aut-family-with-descent-data-circle A)))
 
   family-with-dependent-descent-data-circle-is-equiv :
@@ -59,9 +59,9 @@ module _
   pr1 (pr2 family-with-dependent-descent-data-circle-is-equiv) =
     dependent-descent-data-circle-is-equiv
   pr1 (pr2 (pr2 family-with-dependent-descent-data-circle-is-equiv)) f =
-    equiv-is-equiv-postcomp-is-equiv
+    equiv-is-equiv-left-factor
       ( equiv-family-with-descent-data-circle B) ∘e
-    ( equiv-is-equiv-precomp-is-equiv
+    ( equiv-is-equiv-right-factor
       ( inv-equiv (equiv-family-with-descent-data-circle A)))
   pr2 (pr2 (pr2 family-with-dependent-descent-data-circle-is-equiv)) f p =
     center (is-property-is-equiv _ _ _)

From 59386c1699bdc7dc57c93a31f6fabca4c8dfb1dd Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Sat, 26 Aug 2023 14:29:18 +0200
Subject: [PATCH 24/25] Prose, links

---
 .../descent-circle-constant-families.lagda.md | 33 ++++++--
 ...scent-circle-dependent-pair-types.lagda.md | 43 ++++++----
 .../descent-circle-equivalence-types.lagda.md | 80 +++++++++++++++----
 .../descent-circle-function-types.lagda.md    |  7 +-
 .../descent-circle-subtypes.lagda.md          | 11 ++-
 .../descent-circle.lagda.md                   | 32 ++++----
 6 files changed, 147 insertions(+), 59 deletions(-)

diff --git a/src/synthetic-homotopy-theory/descent-circle-constant-families.lagda.md b/src/synthetic-homotopy-theory/descent-circle-constant-families.lagda.md
index bcfe977093..3e6384785c 100644
--- a/src/synthetic-homotopy-theory/descent-circle-constant-families.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle-constant-families.lagda.md
@@ -21,12 +21,13 @@ open import synthetic-homotopy-theory.free-loops
 
 ## Idea
 
-Descent data for a constant type family is simply the type it evaluates to,
-together with the identity.
+[Descent data for the circle](synthetic-homotopy-theory.descent-circle.md) for a
+[constant type family](foundation.constant-type-families.md) is simply the type
+it evaluates to, together with the identity.
 
-## Properties
+## Definitions
 
-### Characterization of descent data for constant type families over the circle
+### Descent data for constant type families over the circle
 
 ```agda
 module _
@@ -38,19 +39,35 @@ module _
   pr1 descent-data-circle-constant-type = X
   pr2 descent-data-circle-constant-type = id-equiv
 
+  family-descent-data-circle-constant-type : S → UU l2
+  family-descent-data-circle-constant-type x = X
+```
+
+## Properties
+
+### Characterization of descent data for constant type families over the circle
+
+```agda
+module _
+  { l1 l2 : Level} {S : UU l1} (l : free-loop S)
+  ( X : UU l2)
+  where
+
   eq-descent-data-circle-constant-type :
     Eq-descent-data-circle
-      ( descent-data-circle-constant-type)
-      ( ev-descent-data-circle l (constant-type-family S X))
+      ( descent-data-circle-constant-type l X)
+      ( ev-descent-data-circle l
+        ( family-descent-data-circle-constant-type l X))
   pr1 eq-descent-data-circle-constant-type = id-equiv
   pr2 eq-descent-data-circle-constant-type x =
     inv (tr-constant-type-family (loop-free-loop l) x)
 
   family-with-descent-data-constant-type :
     family-with-descent-data-circle l l2
-  pr1 family-with-descent-data-constant-type = constant-type-family S X
+  pr1 family-with-descent-data-constant-type =
+    family-descent-data-circle-constant-type l X
   pr1 (pr2 family-with-descent-data-constant-type) =
-    descent-data-circle-constant-type
+    descent-data-circle-constant-type l X
   pr2 (pr2 family-with-descent-data-constant-type) =
     eq-descent-data-circle-constant-type
 ```
diff --git a/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
index f1ecbb4a90..e0cc330f78 100644
--- a/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle-dependent-pair-types.lagda.md
@@ -22,15 +22,17 @@ open import synthetic-homotopy-theory.free-loops
 
 ## Idea
 
-Given a family `A : 𝕊¹ → U` over the circle and a family
+Given a family `A : 𝕊¹ → U` over the
+[circle](synthetic-homotopy-theory.circle.md) and a family
 `B : (t : 𝕊¹) → (A t) → U` over `A`, the
 [descent data](synthetic-homotopy-theory.descent-circle.md) for the family of
-dependent pair types `λ t → Σ (A t) (B t)` is `(Σ X R, map-Σ e k)`, where
-`(X, e)` is descent data for `A` and `(R, k)` is dependent descent data for `B`.
+[dependent pair types](foundation.dependent-pair-types.md) `λ t → Σ (A t) (B t)`
+is `(Σ X R, map-Σ e k)`, where `(X, e)` is descent data for `A` and `(R, k)` is
+dependent descent data for `B`.
 
-## Properties
+## Definitions
 
-### Characterization of descent data for families of dependent pair types over the circle
+### Descent data for families of dependent pair types over the circle
 
 ```agda
 module _
@@ -39,11 +41,6 @@ module _
   ( B : family-with-dependent-descent-data-circle l A l3)
   where
 
-  family-descent-data-circle-dependent-pair-type : S → UU (l2 ⊔ l3)
-  family-descent-data-circle-dependent-pair-type x =
-    Σ ( family-family-with-descent-data-circle A x)
-      ( family-family-with-dependent-descent-data-circle A B x)
-
   descent-data-circle-dependent-pair-type : descent-data-circle (l2 ⊔ l3)
   pr1 descent-data-circle-dependent-pair-type =
     Σ ( type-family-with-descent-data-circle A)
@@ -54,10 +51,28 @@ module _
       ( aut-family-with-descent-data-circle A)
       ( pseudo-aut-family-with-dependent-descent-data-circle A B)
 
+  family-descent-data-circle-dependent-pair-type : S → UU (l2 ⊔ l3)
+  family-descent-data-circle-dependent-pair-type x =
+    Σ ( family-family-with-descent-data-circle A x)
+      ( family-family-with-dependent-descent-data-circle A B x)
+```
+
+## Properties
+
+### Characterization of descent data for families of dependent pair types over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-dependent-descent-data-circle l A l3)
+  where
+
   eq-descent-data-circle-dependent-pair-type :
     Eq-descent-data-circle
-      ( descent-data-circle-dependent-pair-type)
-      ( ev-descent-data-circle l family-descent-data-circle-dependent-pair-type)
+      ( descent-data-circle-dependent-pair-type l A B)
+      ( ev-descent-data-circle l
+        ( family-descent-data-circle-dependent-pair-type l A B))
   pr1 eq-descent-data-circle-dependent-pair-type =
     equiv-Σ
       ( family-family-with-dependent-descent-data-circle A B (base-free-loop l))
@@ -92,9 +107,9 @@ module _
   family-with-descent-data-circle-dependent-pair-type :
     family-with-descent-data-circle l (l2 ⊔ l3)
   pr1 family-with-descent-data-circle-dependent-pair-type =
-    family-descent-data-circle-dependent-pair-type
+    family-descent-data-circle-dependent-pair-type l A B
   pr1 (pr2 family-with-descent-data-circle-dependent-pair-type) =
-    descent-data-circle-dependent-pair-type
+    descent-data-circle-dependent-pair-type l A B
   pr2 (pr2 family-with-descent-data-circle-dependent-pair-type) =
     eq-descent-data-circle-dependent-pair-type
 ```
diff --git a/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
index 6b919fbf0f..50f406815d 100644
--- a/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle-equivalence-types.lagda.md
@@ -26,12 +26,14 @@ open import synthetic-homotopy-theory.universal-property-circle
 
 ## Idea
 
-Given two families `A, B : 𝕊¹ → U` over the circle, to show that they are
-equivalent is the same as showing that their descent data is equivalent.
+Given two families `A, B : 𝕊¹ → U` over the
+[circle](synthetic-homotopy-theory.circle.md), to show that they are
+[equivalent](foundation.equivalences.md) is the same as showing that their
+[descent data](synthetic-homotopy-theory.descent-circle.md) is equivalent.
 
-## Properties
+## Definitions
 
-### Characterization of descent data for families of equivalence types over the circle
+### Dependent descent data for being an equivalence of families over the circle
 
 ```agda
 module _
@@ -40,6 +42,11 @@ module _
   ( B : family-with-descent-data-circle l l3)
   where
 
+  family-dependent-descent-data-circle-is-equiv :
+    ( t : S) → family-descent-data-circle-function-type l A B t →
+    UU (l2 ⊔ l3)
+  family-dependent-descent-data-circle-is-equiv t = is-equiv
+
   dependent-descent-data-circle-is-equiv :
     dependent-descent-data-circle
       ( descent-data-circle-function-type l A B)
@@ -50,36 +57,75 @@ module _
       ( aut-family-with-descent-data-circle B) ∘e
     ( equiv-is-equiv-right-factor
       ( inv-equiv (aut-family-with-descent-data-circle A)))
+```
 
-  family-with-dependent-descent-data-circle-is-equiv :
-    family-with-dependent-descent-data-circle l
-      ( family-with-descent-data-circle-function-type l A B)
-      ( l2 ⊔ l3)
-  pr1 family-with-dependent-descent-data-circle-is-equiv t = is-equiv
-  pr1 (pr2 family-with-dependent-descent-data-circle-is-equiv) =
-    dependent-descent-data-circle-is-equiv
-  pr1 (pr2 (pr2 family-with-dependent-descent-data-circle-is-equiv)) f =
+## Properties
+
+### Characterization of dependent descent data for being an equivalence of families over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
+  eq-dependent-descent-data-circle-is-equiv :
+    Eq-dependent-descent-data-circle
+      ( descent-data-circle-function-type l A B)
+      ( dependent-descent-data-circle-is-equiv l A B)
+      ( ev-dependent-descent-data-circle l
+        ( family-with-descent-data-circle-function-type l A B)
+        ( family-dependent-descent-data-circle-is-equiv l A B))
+  pr1 eq-dependent-descent-data-circle-is-equiv f =
     equiv-is-equiv-left-factor
       ( equiv-family-with-descent-data-circle B) ∘e
     ( equiv-is-equiv-right-factor
       ( inv-equiv (equiv-family-with-descent-data-circle A)))
-  pr2 (pr2 (pr2 family-with-dependent-descent-data-circle-is-equiv)) f p =
+  pr2 eq-dependent-descent-data-circle-is-equiv f p =
     center (is-property-is-equiv _ _ _)
 
+  family-with-dependent-descent-data-circle-is-equiv :
+    family-with-dependent-descent-data-circle l
+      ( family-with-descent-data-circle-function-type l A B)
+      ( l2 ⊔ l3)
+  pr1 family-with-dependent-descent-data-circle-is-equiv =
+    family-dependent-descent-data-circle-is-equiv l A B
+  pr1 (pr2 family-with-dependent-descent-data-circle-is-equiv) =
+    dependent-descent-data-circle-is-equiv l A B
+  pr2 (pr2 family-with-dependent-descent-data-circle-is-equiv) =
+    eq-dependent-descent-data-circle-is-equiv
+```
+
+### Characterization of descent data for families of equivalence types over the circle
+
+```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
   family-with-descent-data-circle-equivalence-type :
     family-with-descent-data-circle l (l2 ⊔ l3)
   family-with-descent-data-circle-equivalence-type =
     family-with-descent-data-circle-dependent-pair-type l
       ( family-with-descent-data-circle-function-type l A B)
-      ( family-with-dependent-descent-data-circle-is-equiv)
+      ( family-with-dependent-descent-data-circle-is-equiv l A B)
 ```
 
 ### A family of equivalences between families over the circle is given by an equivalence of the corresponding descent data
 
 ```agda
+module _
+  { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
+  ( A : family-with-descent-data-circle l l2)
+  ( B : family-with-descent-data-circle l l3)
+  where
+
   equiv-section-descent-data-circle-equiv-Eq-descent-data-circle :
     dependent-universal-property-circle (l2 ⊔ l3) l →
-    ( (t : S) →
+    ( ( t : S) →
       ( family-family-with-descent-data-circle A t) ≃
       ( family-family-with-descent-data-circle B t)) ≃
     ( Eq-descent-data-circle
@@ -87,7 +133,7 @@ module _
       ( descent-data-family-with-descent-data-circle B))
   equiv-section-descent-data-circle-equiv-Eq-descent-data-circle dup-circle =
     equivalence-reasoning
-    ( (t : S) →
+    ( ( t : S) →
         family-family-with-descent-data-circle A t ≃
         family-family-with-descent-data-circle B t)
     ≃ Σ ( fixpoint-descent-data-circle
@@ -96,7 +142,7 @@ module _
       by
         equiv-section-descent-data-circle-subtype-fixpoint-in-subtype l
           ( family-with-descent-data-circle-function-type l A B)
-          ( family-with-dependent-descent-data-circle-is-equiv)
+          ( family-with-dependent-descent-data-circle-is-equiv l A B)
           ( λ t f → is-property-is-equiv f)
           ( dup-circle)
     ≃ Σ ( hom-descent-data-circle
diff --git a/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md b/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
index 300860dc90..15f9bbe907 100644
--- a/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle-function-types.lagda.md
@@ -30,7 +30,8 @@ open import synthetic-homotopy-theory.universal-property-circle
 
 ## Idea
 
-Given two families `A, B : 𝕊¹ → U` over the circle, the
+Given two families `A, B : 𝕊¹ → U` over the
+[circle](synthetic-homotopy-theory.circle.md), the
 [descent data](synthetic-homotopy-theory.descent-circle.md) for the family of
 function types `λ t → (A t → B t)` is `(X → Y, λ h → f ∘ h ∘ e⁻¹)`, where
 `(X, e)` is descent data for `A` and `(Y, f)` is descent data for `B`.
@@ -40,6 +41,8 @@ homomorphisms from `(X, e)` to `(Y, f)`.
 
 ## Definitions
 
+### Descent data for families of function types over the circle
+
 ```agda
 module _
   { l1 l2 l3 : Level} {S : UU l1} (l : free-loop S)
@@ -67,7 +70,7 @@ module _
 
 ## Properties
 
-### Characterization of descent data for function types over the circle
+### Characterization of descent data for families of function types over the circle
 
 ```agda
 module _
diff --git a/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md b/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md
index 994cd47dc5..9e596982b2 100644
--- a/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle-subtypes.lagda.md
@@ -29,12 +29,15 @@ open import synthetic-homotopy-theory.universal-property-circle
 
 ## Idea
 
-Given a family `A : 𝕊¹ → U` over the circle and a family
+Given a family `A : 𝕊¹ → U` over the
+[circle](synthetic-homotopy-theory.circle.md) and a family
 `B : (t : 𝕊¹) → (A t) → U` over `A` with corresponding
 [descent data](synthetic-homotopy-theory.descent-circle.md) `(X, e)` and
-dependent descent data `(R, k)`, where `R` is a subtype of `X`, we get that
-dependent functions of type `(t : 𝕊¹) → Σ (A t) (B t)` are exactly the fixpoints
-of `e` which belong to `R`.
+dependent descent data `(R, k)`, where `R` is a
+[subtype](foundation-core.subtypes.md) of `X`, we get that dependent functions
+of type `(t : 𝕊¹) → Σ (A t) (B t)` are exactly the
+[fixpoints](synthetic-homotopy-theory.sections-descent-circle.md) of `e` which
+belong to `R`.
 
 ## Properties
 
diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index 1c32fd89a9..0023ea5e44 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -44,10 +44,13 @@ The descent property uniquely characterizes type families over the circle.
 
 ### Descent data for the circle
 
-By the universal property of the circle and univalence, a type family
-`A : 𝕊¹ → U` is equivalent to a type `X : U` equipped with an automorphism
-`e : X ≃ X`, in a way made precise in further sections of this file. The pair
-`(X, e)` is called **descent data** for the circle.
+By the
+[universal property of the circle](synthetic-homotopy-theory.universal-property-circle.md)
+and [univalence](foundation.univalence.md), a type family `A : 𝕊¹ → U` over the
+[circle](synthetic-homotopy-theory.circle.md) is equivalent to a type `X : U`
+equipped with an [automorphism](foundation.automorphisms.md) `e : X ≃ X`, in a
+way made precise in further sections of this file. The pair `(X, e)` is called
+**descent data** for the circle.
 
 ```agda
 descent-data-circle :
@@ -71,7 +74,7 @@ module _
 ### Homomorphisms between descent data for the circle
 
 A homomorphism between `(X, e)` and `(Y, f)` is a map from `X` to `Y` such that
-the obvious square commutes.
+the obvious square [commutes](foundation.commuting-squares-of-maps.md).
 
 ```agda
 hom-descent-data-circle :
@@ -108,7 +111,8 @@ module _
 ### Canonical descent data for a family over the circle
 
 A type family over the circle gives rise to its canonical descent data, obtained
-by evaluation at `base` and transporting along `loop`.
+by evaluation at `base` and [transporting](foundation-core.transport.md) along
+`loop`.
 
 ```agda
 ev-descent-data-circle :
@@ -120,8 +124,8 @@ pr2 (ev-descent-data-circle l A) = equiv-tr A (loop-free-loop l)
 
 ### The identity type of descent data for the circle
 
-An equivalence between `(X, e)` and `(Y, f)` is an equivalence between `X` and
-`Y` which commutes with the automorphisms.
+An [equivalence](foundation.equivalences.md) between `(X, e)` and `(Y, f)` is an
+equivalence between `X` and `Y` which commutes with the automorphisms.
 
 ```agda
 Eq-descent-data-circle :
@@ -161,13 +165,13 @@ module _
 ### A family over the circle equipped with corresponding descent data
 
 A family for descent data `(X, e)` is a family over the circle, along with a
-proof that they are equivalent.
+proof that `(X, e)` is equivalent to the canonical descent data of the family.
 
-Descent data for a family `A` is descent data with a proof that it's equivalent
-to `A`.
+Descent data for a family `A : 𝕊¹ → U` is descent data with a proof that it's
+equivalent to the canonical descent data of `A`.
 
-A family with descent data is a family `A` over the circle, equipped with
-descent data `(X, e)`, and a proof of their equivalence.
+A family with descent data is a family `A : 𝕊¹ → U` over the circle, equipped
+with descent data `(X, e)`, and a proof of their equivalence.
 
 Ideally, every section characterizing descent data of a particular type family
 should include a term of type `family-with-descent-data-circle`, whose type
@@ -317,7 +321,7 @@ module _
     map-equiv (pseudo-aut-dependent-descent-data-circle x)
 ```
 
-### Canonical dependent descent data for a family over a family oveer the circle
+### Canonical dependent descent data for a family over a family over the circle
 
 ```agda
 ev-dependent-descent-data-circle :

From e8dd3eb0d3b1e7f8016473e80eb008cbc0c5adce Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Mon, 28 Aug 2023 11:24:51 +0200
Subject: [PATCH 25/25] Wording, links, diagrams

Addresses PR review
---
 .../universal-property-integers.lagda.md      | 12 ++++---
 src/foundation/equivalences.lagda.md          |  4 +--
 .../descent-circle.lagda.md                   | 33 ++++++++++++++-----
 .../sections-descent-circle.lagda.md          |  6 ++--
 4 files changed, 38 insertions(+), 17 deletions(-)

diff --git a/src/elementary-number-theory/universal-property-integers.lagda.md b/src/elementary-number-theory/universal-property-integers.lagda.md
index b39ee64688..c175953cab 100644
--- a/src/elementary-number-theory/universal-property-integers.lagda.md
+++ b/src/elementary-number-theory/universal-property-integers.lagda.md
@@ -32,8 +32,9 @@ open import foundation.universe-levels
 
 The universal property of [the integers](elementary-number-theory.integers.md)
 states that given any type `X` equipped with a point `x : X` and an
-[automorphism](foundation.automorphisms.md) `e : X ≃ X`, the type of structure
-preserving maps from `ℤ` to `X` is contractible.
+[automorphism](foundation.automorphisms.md) `e : X ≃ X`, there is a
+[unique](foundation.contractible-types.md) structure preserving map from `ℤ` to
+`X`.
 
 ```agda
 abstract
@@ -209,7 +210,7 @@ abstract
           ( equiv-comparison-map-Eq-ELIM-ℤ P p0 pS s t)))
 ```
 
-We finally arrive at the dependent universal property of ℤ
+### The dependent universal property of the integers
 
 ```agda
 abstract
@@ -221,7 +222,10 @@ abstract
     is-proof-irrelevant-is-prop (is-prop-ELIM-ℤ P p0 pS) (Elim-ℤ P p0 pS)
 ```
 
-The universal property of ℤ is now just a special case
+### The universal property of the integers
+
+The non-dependent universal property of the integers is a special case of the
+dependent universal property applied to constant type families.
 
 ```agda
 ELIM-ℤ' :
diff --git a/src/foundation/equivalences.lagda.md b/src/foundation/equivalences.lagda.md
index 4a0aa8f82e..4991d3c347 100644
--- a/src/foundation/equivalences.lagda.md
+++ b/src/foundation/equivalences.lagda.md
@@ -339,7 +339,7 @@ module _
 
 ### The 3-for-2 property of being an equivalence
 
-#### If a right factor is an equivalence, then the left factor is an equivalence iff the composite is
+#### If the right factor is an equivalence, then the left factor being an equivalence is equivalent to the composite being one
 
 ```agda
 module _
@@ -365,7 +365,7 @@ module _
     equiv-is-equiv-left-factor-htpy e (map-equiv e ∘ f) refl-htpy
 ```
 
-#### If a left factor is an equivalence, then the right factor is an equivalence iff the composite is
+#### If the left factor is an equivalence, then the right factor being an equivalence is equivalent to the composite being one
 
 ```agda
 module _
diff --git a/src/synthetic-homotopy-theory/descent-circle.lagda.md b/src/synthetic-homotopy-theory/descent-circle.lagda.md
index 0023ea5e44..050124368f 100644
--- a/src/synthetic-homotopy-theory/descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/descent-circle.lagda.md
@@ -73,8 +73,18 @@ module _
 
 ### Homomorphisms between descent data for the circle
 
-A homomorphism between `(X, e)` and `(Y, f)` is a map from `X` to `Y` such that
-the obvious square [commutes](foundation.commuting-squares-of-maps.md).
+A homomorphism `h` between `(X, e)` and `(Y, f)` is a map from `X` to `Y` such
+that the obvious square [commutes](foundation.commuting-squares-of-maps.md).
+
+```text
+      h
+  X -----> Y
+  |        |
+ e|        |f
+  v        v
+  X -----> Y
+      h
+```
 
 ```agda
 hom-descent-data-circle :
@@ -171,7 +181,18 @@ Descent data for a family `A : 𝕊¹ → U` is descent data with a proof that i
 equivalent to the canonical descent data of `A`.
 
 A family with descent data is a family `A : 𝕊¹ → U` over the circle, equipped
-with descent data `(X, e)`, and a proof of their equivalence.
+with descent data `(X, e)`, and a proof of their equivalence. This can be
+described as a diagram
+
+```text
+      α
+  X -----> A base
+  |         |
+ e|         | tr A loop
+  v         v
+  X -----> A base
+      α
+```
 
 Ideally, every section characterizing descent data of a particular type family
 should include a term of type `family-with-descent-data-circle`, whose type
@@ -783,10 +804,4 @@ module _
         ( descent-data-family-with-descent-data-circle A)
         ( l3)) →
     is-contr (family-for-dependent-descent-data-circle l A Q)
-
-  -- unique-dependent-family-property-circle-dependent-universal-property-circle :
-  --   dependent-universal-property-circle (l2 ⊔ lsuc l3) l →
-  --   unique-dependent-family-property-circle
-  -- unique-dependent-family-property-circle-dependent-universal-property-circle
-  --   dup-circle Q = {!!}
 ```
diff --git a/src/synthetic-homotopy-theory/sections-descent-circle.lagda.md b/src/synthetic-homotopy-theory/sections-descent-circle.lagda.md
index d7d69480bb..af2782990c 100644
--- a/src/synthetic-homotopy-theory/sections-descent-circle.lagda.md
+++ b/src/synthetic-homotopy-theory/sections-descent-circle.lagda.md
@@ -35,8 +35,10 @@ open import synthetic-homotopy-theory.universal-property-circle
 
 ## Idea
 
-Sections of type families over the circle are exactly the fixpoints of the
-automorphism from the corresponding descent data.
+Sections of type families over the [circle](synthetic-homotopy-theory.circle.md)
+are exactly the fixpoints of the [automorphism](foundation.automorphisms.md)
+from the corresponding
+[descent data](synthetic-homotopy-theory.descent-circle.md).
 
 ## Definitions
 
