From a240f9b0af9f22b86d82e3b354e51d1649c1cb63 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Tue, 12 Mar 2024 17:10:28 +0100
Subject: [PATCH 01/14] More approachable definition of morphisms of sequential
 diagrams

---
 .../morphisms-sequential-diagrams.lagda.md         | 14 ++++----------
 1 file changed, 4 insertions(+), 10 deletions(-)

diff --git a/src/synthetic-homotopy-theory/morphisms-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/morphisms-sequential-diagrams.lagda.md
index 86c6950684..47a9948110 100644
--- a/src/synthetic-homotopy-theory/morphisms-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/morphisms-sequential-diagrams.lagda.md
@@ -71,8 +71,8 @@ module _
 
   hom-sequential-diagram : UU (l1 ‚äî l2)
   hom-sequential-diagram =
-    section-dependent-sequential-diagram A
-      ( constant-dependent-sequential-diagram A B)
+    Œ£ ( (n : ‚Ñï) ‚Üí family-sequential-diagram A n ‚Üí family-sequential-diagram B n)
+      ( naturality-hom-sequential-diagram)
 ```
 
 ### Components of morphisms of sequential diagrams
@@ -91,17 +91,11 @@ module _
 
   map-hom-sequential-diagram :
     ( n : ‚Ñï) ‚Üí family-sequential-diagram A n ‚Üí family-sequential-diagram B n
-  map-hom-sequential-diagram =
-    map-section-dependent-sequential-diagram A
-      ( constant-dependent-sequential-diagram A B)
-      ( h)
+  map-hom-sequential-diagram = pr1 h
 
   naturality-map-hom-sequential-diagram :
     naturality-hom-sequential-diagram A B map-hom-sequential-diagram
-  naturality-map-hom-sequential-diagram =
-    naturality-map-section-dependent-sequential-diagram A
-      ( constant-dependent-sequential-diagram A B)
-      ( h)
+  naturality-map-hom-sequential-diagram = pr2 h
 ```
 
 ### The identity morphism of sequential diagrams

From b5af65554f25ff8a72dc36f8424f6ae324508df4 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Tue, 12 Mar 2024 18:37:10 +0100
Subject: [PATCH 02/14] Total diagrams of dependent sequential diagrams

---
 src/synthetic-homotopy-theory.lagda.md        |   1 +
 .../total-sequential-diagrams.lagda.md        | 112 ++++++++++++++++++
 2 files changed, 113 insertions(+)
 create mode 100644 src/synthetic-homotopy-theory/total-sequential-diagrams.lagda.md

diff --git a/src/synthetic-homotopy-theory.lagda.md b/src/synthetic-homotopy-theory.lagda.md
index 89173b31c2..63177ce7fa 100644
--- a/src/synthetic-homotopy-theory.lagda.md
+++ b/src/synthetic-homotopy-theory.lagda.md
@@ -95,6 +95,7 @@ open import synthetic-homotopy-theory.suspension-structures public
 open import synthetic-homotopy-theory.suspensions-of-pointed-types public
 open import synthetic-homotopy-theory.suspensions-of-types public
 open import synthetic-homotopy-theory.tangent-spheres public
+open import synthetic-homotopy-theory.total-sequential-diagrams public
 open import synthetic-homotopy-theory.triple-loop-spaces public
 open import synthetic-homotopy-theory.truncated-acyclic-maps public
 open import synthetic-homotopy-theory.truncated-acyclic-types public
diff --git a/src/synthetic-homotopy-theory/total-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/total-sequential-diagrams.lagda.md
new file mode 100644
index 0000000000..03d997f681
--- /dev/null
+++ b/src/synthetic-homotopy-theory/total-sequential-diagrams.lagda.md
@@ -0,0 +1,112 @@
+# Total diagrams of dependent sequential diagrams
+
+```agda
+module synthetic-homotopy-theory.total-sequential-diagrams where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import elementary-number-theory.natural-numbers
+
+open import foundation.dependent-pair-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.homotopies
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.cocones-under-sequential-diagrams
+open import synthetic-homotopy-theory.dependent-sequential-diagrams
+open import synthetic-homotopy-theory.functoriality-sequential-colimits
+open import synthetic-homotopy-theory.morphisms-sequential-diagrams
+open import synthetic-homotopy-theory.sequential-colimits
+open import synthetic-homotopy-theory.sequential-diagrams
+open import synthetic-homotopy-theory.universal-property-sequential-colimits
+```
+
+</details>
+
+## Idea
+
+The {{#concept "total diagram" Disambiguation="dependent sequential diagrams"}}
+of a dependent sequential diagram `B : (A, a) ‚Üí ùí∞` is the sequential diagram
+consisting of total spaces `Œ£ A‚Çô B‚Çô`.
+
+## Definitions
+
+### Total sequential diagram of a dependent sequential diagram
+
+```agda
+module _
+  {l1 l2 : Level}
+  {A : sequential-diagram l1} (B : dependent-sequential-diagram A l2)
+  where
+
+  family-total-sequential-diagram : ‚Ñï ‚Üí UU (l1 ‚äî l2)
+  family-total-sequential-diagram n =
+    Œ£ (family-sequential-diagram A n)
+      (family-dependent-sequential-diagram A B n)
+
+  map-total-sequential-diagram :
+    (n : ‚Ñï) ‚Üí family-total-sequential-diagram n ‚Üí
+    family-total-sequential-diagram (succ-‚Ñï n)
+  map-total-sequential-diagram n =
+    map-Œ£
+      ( family-dependent-sequential-diagram A B (succ-‚Ñï n))
+      ( map-sequential-diagram A n)
+      ( map-dependent-sequential-diagram A B n)
+
+  total-sequential-diagram : sequential-diagram (l1 ‚äî l2)
+  pr1 total-sequential-diagram = family-total-sequential-diagram
+  pr2 total-sequential-diagram = map-total-sequential-diagram
+```
+
+### The projection morphism onto the base of the total sequential diagram
+
+```agda
+module _
+  {l1 l2 : Level}
+  {A : sequential-diagram l1} (B : dependent-sequential-diagram A l2)
+  where
+
+  pr1-total-sequential-diagram :
+    hom-sequential-diagram
+      ( total-sequential-diagram B)
+      ( A)
+  pr1 pr1-total-sequential-diagram n = pr1
+  pr2 pr1-total-sequential-diagram n = refl-htpy
+```
+
+### The induced projection map on sequential colimits
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level}
+  {A : sequential-diagram l1} (B : dependent-sequential-diagram A l2)
+  {X : UU l3} {c : cocone-sequential-diagram (total-sequential-diagram B) X}
+  (up-c : universal-property-sequential-colimit c)
+  {Y : UU l4} (c' : cocone-sequential-diagram A Y)
+  where
+
+  pr1-sequential-colimit-total-sequential-diagram : X ‚Üí Y
+  pr1-sequential-colimit-total-sequential-diagram =
+    map-sequential-colimit-hom-sequential-diagram
+      ( up-c)
+      ( c')
+      ( pr1-total-sequential-diagram B)
+```
+
+### The induced projection map on standard sequential colimits
+
+```agda
+module _
+  {l1 l2 : Level}
+  {A : sequential-diagram l1} (B : dependent-sequential-diagram A l2)
+  where
+
+  pr1-standard-sequential-colimit-total-sequential-diagram :
+    standard-sequential-colimit (total-sequential-diagram B) ‚Üí
+    standard-sequential-colimit A
+  pr1-standard-sequential-colimit-total-sequential-diagram =
+    map-hom-standard-sequential-colimit A
+      ( pr1-total-sequential-diagram B)
+```

From 552836ed094e663b5e5b311d250959ccd4590307 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Tue, 12 Mar 2024 18:38:33 +0100
Subject: [PATCH 03/14] Shifts of sequential diagrams

---
 src/synthetic-homotopy-theory.lagda.md        |   1 +
 .../shifts-sequential-diagrams.lagda.md       | 364 ++++++++++++++++++
 2 files changed, 365 insertions(+)
 create mode 100644 src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md

diff --git a/src/synthetic-homotopy-theory.lagda.md b/src/synthetic-homotopy-theory.lagda.md
index 63177ce7fa..d0edc20c56 100644
--- a/src/synthetic-homotopy-theory.lagda.md
+++ b/src/synthetic-homotopy-theory.lagda.md
@@ -86,6 +86,7 @@ open import synthetic-homotopy-theory.sections-descent-circle public
 open import synthetic-homotopy-theory.sequential-colimits public
 open import synthetic-homotopy-theory.sequential-diagrams public
 open import synthetic-homotopy-theory.sequentially-compact-types public
+open import synthetic-homotopy-theory.shifts-sequential-diagrams public
 open import synthetic-homotopy-theory.smash-products-of-pointed-types public
 open import synthetic-homotopy-theory.spectra public
 open import synthetic-homotopy-theory.sphere-prespectrum public
diff --git a/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
new file mode 100644
index 0000000000..d7249b9ca3
--- /dev/null
+++ b/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
@@ -0,0 +1,364 @@
+# Shifts of sequential diagrams
+
+```agda
+module synthetic-homotopy-theory.shifts-sequential-diagrams where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import elementary-number-theory.natural-numbers
+
+open import foundation.commuting-squares-of-maps
+open import foundation.commuting-triangles-of-identifications
+open import foundation.commuting-triangles-of-maps
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.function-types
+open import foundation.homotopies
+open import foundation.identity-types
+open import foundation.retractions
+open import foundation.sections
+open import foundation.universe-levels
+open import foundation.whiskering-homotopies-composition
+open import foundation.whiskering-homotopies-concatenation
+
+open import synthetic-homotopy-theory.cocones-under-sequential-diagrams
+open import synthetic-homotopy-theory.functoriality-sequential-colimits
+open import synthetic-homotopy-theory.morphisms-sequential-diagrams
+open import synthetic-homotopy-theory.sequential-colimits
+open import synthetic-homotopy-theory.sequential-diagrams
+open import synthetic-homotopy-theory.universal-property-sequential-colimits
+```
+
+</details>
+
+## Idea
+
+A
+{{#concept "shift" Disambiguation="sequential diagram" Agda=shift-sequential-diagram}}
+of a [sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md) is a
+sequential diagram consisting of the types and maps shifted by one. It is also
+denoted `A[1]`.
+
+Similarly, a
+{{#concept "shift" Disambiguation="morphism of sequential diagrams" Agda=shift-hom-sequential-diagram}}
+of a
+[morphism of sequential diagrams](synthetic-homotopy-theory.morphisms-sequential-diagrams.md)
+is a morphism from the shifted domain into the shifted codomain.
+
+Importantly, the sequential colimit of a shifted sequential diagram is
+equivalent to the colimit of the original diagram.
+
+## Definitions
+
+### Shifts of sequential diagrams
+
+```agda
+module _
+  {l1 : Level} (A : sequential-diagram l1)
+  where
+
+  shift-sequential-diagram : sequential-diagram l1
+  pr1 shift-sequential-diagram n = family-sequential-diagram A (succ-‚Ñï n)
+  pr2 shift-sequential-diagram n = map-sequential-diagram A (succ-‚Ñï n)
+```
+
+### Shifts of morphisms of sequential diagrams
+
+```agda
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1} (B : sequential-diagram l2)
+  (f : hom-sequential-diagram A B)
+  where
+
+  shift-hom-sequential-diagram :
+    hom-sequential-diagram
+      ( shift-sequential-diagram A)
+      ( shift-sequential-diagram B)
+  pr1 shift-hom-sequential-diagram n =
+    map-hom-sequential-diagram B f (succ-‚Ñï n)
+  pr2 shift-hom-sequential-diagram n =
+    naturality-map-hom-sequential-diagram B f (succ-‚Ñï n)
+```
+
+## Properties
+
+### Sequential diagrams map into their shifts
+
+The morphism is obtained by observing that the squares in the diagram
+
+```text
+        a‚ÇÄ      a‚ÇÅ
+    A‚ÇÄ ---> A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
+    |       |       |
+ a‚ÇÄ |       | a‚ÇÅ    | a‚ÇÇ
+    v       v       v
+    A‚ÇÅ ---> A‚ÇÇ ---> A‚ÇÉ ---> ‚ãØ
+        a‚ÇÅ      a‚ÇÇ
+```
+
+commute by reflexivity.
+
+```agda
+module _
+  {l1 : Level} (A : sequential-diagram l1)
+  where
+
+  hom-shift-sequential-diagram :
+    hom-sequential-diagram
+      ( A)
+      ( shift-sequential-diagram A)
+  pr1 hom-shift-sequential-diagram = map-sequential-diagram A
+  pr2 hom-shift-sequential-diagram n = refl-htpy
+```
+
+### The type of cocones under a sequential diagram is equivalent to the type of cocones under its shift
+
+Given a cocone
+
+```text
+      a‚ÇÄ      a‚ÇÅ
+  A‚ÇÄ ---> A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
+   \      |      /
+    \     |     /
+  i‚ÇÄ \    | i‚ÇÅ / i‚ÇÇ
+      \   |   /
+       V  V  V
+          X
+```
+
+under `A`, we may forget the first injection and homotopy to get the cocone
+
+```text
+              a‚ÇÅ
+          A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
+          |      /
+          |     /
+          | i‚ÇÅ / i‚ÇÇ
+          |   /
+          V  V
+          X
+```
+
+under `A[1]`.
+
+Conversely, given a cocone
+
+```text
+        a‚ÇÅ      a‚ÇÅ
+    A‚ÇÅ ---> A‚ÇÇ ---> A‚ÇÉ ---> ‚ãØ
+     \      |      /
+      \     |     /
+    i‚ÇÅ \    | i‚ÇÇ / i‚ÇÉ
+        \   |   /
+         V  V  V
+            X
+```
+
+under `A[1]`, we may precompose it with the morphism `A ‚Üí A[1]` to get the
+cocone
+
+```text
+        a‚ÇÄ      a‚ÇÅ
+    A‚ÇÄ ---> A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
+    |       |       |
+ a‚ÇÄ |       | a‚ÇÅ    | a‚ÇÇ
+    v       v       v
+    A‚ÇÅ ---> A‚ÇÇ ---> A‚ÇÉ ---> ‚ãØ
+     \  a‚ÇÅ  |   a‚ÇÅ  /
+      \     |     /
+    i‚ÇÅ \    | i‚ÇÇ / i‚ÇÉ
+        \   |   /
+         V  V  V
+            X
+```
+
+under `A`.
+
+```agda
+module _
+  {l1 l2 : Level} (A : sequential-diagram l1)
+  {X : UU l2}
+  where
+
+  cocone-shift-sequential-diagram :
+    cocone-sequential-diagram A X ‚Üí
+    cocone-sequential-diagram (shift-sequential-diagram A) X
+  pr1 (cocone-shift-sequential-diagram c) n =
+    map-cocone-sequential-diagram c (succ-‚Ñï n)
+  pr2 (cocone-shift-sequential-diagram c) n =
+    coherence-cocone-sequential-diagram c (succ-‚Ñï n)
+
+  cocone-unshift-sequential-diagram :
+    cocone-sequential-diagram (shift-sequential-diagram A) X ‚Üí
+    cocone-sequential-diagram A X
+  cocone-unshift-sequential-diagram c =
+    map-cocone-hom-sequential-diagram
+      ( hom-shift-sequential-diagram A)
+      ( c)
+
+module _
+  {l1 l2 : Level} (A : sequential-diagram l1)
+  (X : UU l2)
+  where
+
+  -- TODO: Why are these two proofs so similar? Could it be abstracted?
+  -- The diff is whiskering with the map of A or A[1]
+  -- htpy-is-section-cocone-unshift-sequential-diagram :
+  --   (c : cocone-sequential-diagram (shift-sequential-diagram A) X) ‚Üí
+  --   htpy-cocone-sequential-diagram
+  --     ( cocone-shift-sequential-diagram A
+  --       ( cocone-unshift-sequential-diagram A c))
+  --     ( c)
+  -- pr1 (htpy-is-section-cocone-unshift-sequential-diagram c) n =
+  --   inv-htpy (coherence-cocone-sequential-diagram c n)
+  -- pr2 (htpy-is-section-cocone-unshift-sequential-diagram c) n =
+  --   ( ap-concat-htpy'
+  --     ( inv-htpy
+  --       ( ( coherence-cocone-sequential-diagram c (succ-‚Ñï n))) ¬∑r
+  --         ( map-sequential-diagram (shift-sequential-diagram A) n))
+  --     ( right-unit-htpy)) ‚àôh
+  --   ( right-inv-htpy
+  --     ( ( coherence-cocone-sequential-diagram c (succ-‚Ñï n)) ¬∑r
+  --       ( map-sequential-diagram (shift-sequential-diagram A) n))) ‚àôh
+  --   ( inv-htpy-left-inv-htpy (coherence-cocone-sequential-diagram c n))
+
+  htpy-is-section-cocone-unshift-sequential-diagram' :
+    (c : cocone-sequential-diagram (shift-sequential-diagram A) X) ‚Üí
+    htpy-cocone-sequential-diagram
+      ( c)
+      ( cocone-shift-sequential-diagram A
+        ( cocone-unshift-sequential-diagram A c))
+  pr1 (htpy-is-section-cocone-unshift-sequential-diagram' c) =
+    coherence-cocone-sequential-diagram c
+  pr2 (htpy-is-section-cocone-unshift-sequential-diagram' c) n =
+    left-whisker-concat-htpy
+      ( coherence-cocone-sequential-diagram c n)
+      ( inv-htpy-right-unit-htpy)
+
+  is-section-cocone-unshift-sequential-diagram :
+    is-section
+      ( cocone-shift-sequential-diagram A {X})
+      ( cocone-unshift-sequential-diagram A {X})
+  is-section-cocone-unshift-sequential-diagram c =
+    inv
+      ( eq-htpy-cocone-sequential-diagram
+        ( shift-sequential-diagram A)
+        ( _)
+        ( _)
+        ( htpy-is-section-cocone-unshift-sequential-diagram' c))
+
+  -- htpy-is-retraction-cocone-unshift-sequential-diagram :
+  --   (c : cocone-sequential-diagram A X) ‚Üí
+  --   htpy-cocone-sequential-diagram
+  --     ( cocone-unshift-sequential-diagram A
+  --       ( cocone-shift-sequential-diagram A c))
+  --     ( c)
+  -- pr1 (htpy-is-retraction-cocone-unshift-sequential-diagram c) n =
+  --   inv-htpy (coherence-cocone-sequential-diagram c n)
+  -- pr2 (htpy-is-retraction-cocone-unshift-sequential-diagram c) n =
+  --   ( ap-concat-htpy'
+  --     ( inv-htpy
+  --       ( ( coherence-cocone-sequential-diagram c (succ-‚Ñï n))) ¬∑r
+  --         ( map-sequential-diagram A n))
+  --     ( right-unit-htpy)) ‚àôh
+  --   ( right-inv-htpy
+  --     ( ( coherence-cocone-sequential-diagram c (succ-‚Ñï n)) ¬∑r
+  --       ( map-sequential-diagram A n))) ‚àôh
+  --   ( inv-htpy-left-inv-htpy (coherence-cocone-sequential-diagram c n))
+
+  htpy-is-retraction-cocone-unshift-sequential-diagram' :
+    (c : cocone-sequential-diagram A X) ‚Üí
+    htpy-cocone-sequential-diagram
+      ( c)
+      ( cocone-unshift-sequential-diagram A
+        ( cocone-shift-sequential-diagram A c))
+  pr1 (htpy-is-retraction-cocone-unshift-sequential-diagram' c) =
+    coherence-cocone-sequential-diagram c
+  pr2 (htpy-is-retraction-cocone-unshift-sequential-diagram' c) n =
+    left-whisker-concat-htpy
+      ( coherence-cocone-sequential-diagram c n)
+      ( inv-htpy-right-unit-htpy)
+
+  is-retraction-cocone-unshift-sequential-diagram :
+    is-retraction
+      ( cocone-shift-sequential-diagram A {X})
+      ( cocone-unshift-sequential-diagram A {X})
+  is-retraction-cocone-unshift-sequential-diagram c =
+    inv
+      ( eq-htpy-cocone-sequential-diagram A _ _
+        ( htpy-is-retraction-cocone-unshift-sequential-diagram' c))
+
+  is-equiv-cocone-shift-sequential-diagram :
+    is-equiv (cocone-shift-sequential-diagram A {X})
+  is-equiv-cocone-shift-sequential-diagram =
+    is-equiv-is-invertible
+      ( cocone-unshift-sequential-diagram A {X})
+      ( is-section-cocone-unshift-sequential-diagram)
+      ( is-retraction-cocone-unshift-sequential-diagram)
+
+  equiv-cocone-shift-unshift-sequential-diagram :
+    cocone-sequential-diagram A X ‚âÉ
+    cocone-sequential-diagram (shift-sequential-diagram A) X
+  pr1 equiv-cocone-shift-unshift-sequential-diagram =
+    cocone-shift-sequential-diagram A {X}
+  pr2 equiv-cocone-shift-unshift-sequential-diagram =
+    is-equiv-cocone-shift-sequential-diagram
+```
+
+### The sequential colimit of a sequential diagram is also the sequential colimit of the shifted diagram
+
+Given a sequential colimit
+
+```text
+     a‚ÇÄ      a‚ÇÅ      a‚ÇÇ
+ A‚ÇÄ ---> A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ --> X,
+```
+
+there is a commuting triangle
+
+```text
+              cocone-map
+      X ‚Üí Y ------------> cocone A Y
+            \           /
+  cocone-map  \       / ‚âÉ
+                V   V
+             cocone A[1] Y,
+```
+
+where the top map is an equivalence by the universal property of `X`, and the
+right map was shown to be an equivalence above. It follows that the third map is
+also an equivalence, which makes `X` the sequential colimit of `A[1]`.
+
+```agda
+module _
+  {l1 l2 : Level} (A : sequential-diagram l1)
+  {X : UU l2} {c : cocone-sequential-diagram A X}
+  where
+
+  triangle-cocone-map-blabla :
+    {l : Level} (Y : UU l) ‚Üí
+    coherence-triangle-maps
+      ( cocone-map-sequential-diagram
+        ( cocone-shift-sequential-diagram A c)
+        { Y = Y})
+      ( cocone-shift-sequential-diagram A)
+      ( cocone-map-sequential-diagram c)
+  triangle-cocone-map-blabla Y = refl-htpy
+
+  up-cocone-shift-sequential-diagram :
+    universal-property-sequential-colimit c ‚Üí
+    universal-property-sequential-colimit (cocone-shift-sequential-diagram A c)
+  up-cocone-shift-sequential-diagram up-c Y =
+    is-equiv-left-map-triangle
+      ( cocone-map-sequential-diagram
+        ( cocone-shift-sequential-diagram A c)
+        { Y = Y})
+      ( cocone-shift-sequential-diagram A)
+      ( cocone-map-sequential-diagram c)
+      ( triangle-cocone-map-blabla Y)
+      ( up-c Y)
+      ( is-equiv-cocone-shift-sequential-diagram A Y)
+```
+

From 61c69689fafea3e66917b8a7e5235aa82140dbd4 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Tue, 12 Mar 2024 18:39:01 +0100
Subject: [PATCH 04/14] Start collecting paper formalizations on their own
 pages

---
 src/papers.lagda.md       |   7 ++
 src/papers/SDR20.lagda.md | 203 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 210 insertions(+)
 create mode 100644 src/papers.lagda.md
 create mode 100644 src/papers/SDR20.lagda.md

diff --git a/src/papers.lagda.md b/src/papers.lagda.md
new file mode 100644
index 0000000000..94654734a6
--- /dev/null
+++ b/src/papers.lagda.md
@@ -0,0 +1,7 @@
+# Formalizations of papers in the library
+
+```agda
+module papers where
+
+open import papers.SDR20 public
+```
diff --git a/src/papers/SDR20.lagda.md b/src/papers/SDR20.lagda.md
new file mode 100644
index 0000000000..cb61a71a14
--- /dev/null
+++ b/src/papers/SDR20.lagda.md
@@ -0,0 +1,203 @@
+# Sequential Colimits in Homotopy Type Theory
+
+{{#cite SDR20}}
+
+```agda
+module papers.SDR20 where
+```
+
+## 3. Sequences and Sequential Colimits
+
+Definition 3.1: Sequences. We call sequences _sequential diagrams_.
+
+```agda
+import synthetic-homotopy-theory.sequential-diagrams using
+  ( sequential-diagram)
+```
+
+Definition 3.2: Sequential colimits and their induction and recursion
+principles, given by the dependent and non-dependent universal properties,
+respectively. Our homotopies in the definitions of cocones go from left to
+right, instead of right to left.
+
+```agda
+import synthetic-homotopy-theory.sequential-colimits using
+  ( standard-sequential-colimit ;
+    map-cocone-standard-sequential-colimit ;
+    coherence-cocone-standard-sequential-colimit ;
+    dup-standard-sequential-colimit ;
+    up-standard-sequential-colimit)
+```
+
+Lemma 3.3: Uniqueness property of the sequential colimit.
+
+```agda
+import synthetic-homotopy-theory.sequential-colimits using
+  ( equiv-htpy-htpy-out-of-standard-sequential-colimit ;
+    htpy-htpy-out-of-standard-sequential-colimit)
+```
+
+Definition 3.4: Natural transformations and natural equivalences between
+sequential diagrams. We call natural transformations _morphisms of sequential
+diagrams_.
+
+```agda
+import synthetic-homotopy-theory.morphisms-sequential-diagrams using
+  ( hom-sequential-diagram ;
+    id-hom-sequential-diagram ;
+    comp-hom-sequential-diagram)
+import synthetic-homotopy-theory.equivalences-sequential-diagrams using
+  ( equiv-sequential-diagram)
+```
+
+Lemma 3.5: Functoriality of the Sequential Colimit.
+
+```agda
+import synthetic-homotopy-theory.functoriality-sequential-colimits using
+  ( map-hom-standard-sequential-colimit ; -- 1)
+    preserves-id-map-hom-standard-sequential-colimit ; -- 2
+    preserves-comp-map-hom-standard-sequential-colimit ; -- 3
+    htpy-map-hom-standard-sequential-colimit-htpy-hom-sequential-diagram ; -- 4
+    equiv-equiv-standard-sequential-colimit) -- 5
+```
+
+Lemma 3.6: Dropping a head of a sequential diagram preserves the sequential
+colimit.
+
+TODO: the actual equivalence
+
+```agda
+import synthetic-homotopy-theory.shifts-sequential-diagrams using
+  ( up-cocone-shift-sequential-diagram)
+```
+
+Lemma 3.7: Dropping finitely many objects from the head of a sequential diagram
+preserves the sequential colimit.
+
+```agda
+-- TODO
+```
+
+Liftings?
+
+## 4. Fibered Sequences
+
+Definition 4.1: Fibered sequences. In agda-unimath, a "sequence fibered over a
+sequence (A, a)" is called a "dependent sequential diagram over (A, a)", and it
+is defined in its curried form: instead of `B : Œ£ (n : ‚Ñï) A(n) ‚Üí ùí∞`, we use
+`B : (n : N) ‚Üí A(n) ‚Üí ùí∞`.
+
+```agda
+import synthetic-homotopy-theory.dependent-sequential-diagrams using
+  ( dependent-sequential-diagram)
+  -- TODO?: equifibered sequences
+```
+
+Lemma 4.2: The descent property of sequential colimits
+
+```agda
+-- TODO
+```
+
+Definition 4.3: Total sequential diagram of a dependent sequential diagram.
+
+```agda
+import synthetic-homotopy-theory.total-sequential-diagrams using
+  ( total-sequential-diagram ;
+    pr1-total-sequential-diagram)
+```
+
+TODO: Decide how to treat (C‚àû, c‚àû).
+
+## 5. Colimits and Sums
+
+Theorem 5.1: Interaction between `colim` and `Œ£`.
+
+```agda
+-- TODO
+```
+
+## 6. Induction on the Sum of Sequential Colimits
+
+-- The induction principle for a sum of sequential colimits follows from the
+
+## 7. Applications of the Main Theorem
+
+Lemma 7.1: TODO description
+
+```agda
+-- TODO
+```
+
+Lemma 7.2: Colimit of the terminal sequential diagram is contractible
+
+```agda
+-- TODO
+```
+
+Lemma 7.3: Encode-decode. This principle is called the _Fundamental theorem of
+identity types_ in the library.
+
+```agda
+import foundation.fundamental-theorem-of-identity-types using
+  ( fundamental-theorem-id)
+```
+
+Lemma 7.4: Characterization of path spaces of images of the canonical maps into
+the sequential colimit.
+
+```agda
+-- TODO
+```
+
+Corollary 7.5: The loop space of a sequential colimit is the sequential colimit
+of loop spaces.
+
+```agda
+-- TODO
+```
+
+Corollary 7.6: For a morphism of sequential diagrams, the fibers of the induced
+map between sequential colimits are characterized as sequential colimits of the
+fibers.
+
+```agda
+-- TODO
+```
+
+Corollary 7.7.1: If each type in a sequential diagram is `k`-truncated, then the
+colimit is `k`-truncated.
+
+```agda
+-- TODO
+```
+
+Corollary 7.7.2: The `k`-truncation of a sequential colimit is the sequential
+colimit of `k`-truncations.
+
+```agda
+-- TODO
+```
+
+Corollary 7.7.3: If each type in a sequential diagram is `k`-connected, then the
+colimit is `k`-connected.
+
+```agda
+-- TODO
+```
+
+Corollary 7.7.4: If each component of a morphism between sequential diagrams is
+`k`-truncated/`k`-connected, then the induced map of sequential colimits is
+`k`-truncated/`k`-connected.
+
+```agda
+-- TODO
+```
+
+Corollary 7.7.5: If each map in a sequential diagram is
+`k`-truncated/`k`-connected, then the first injection into the colimit is
+`k`-truncated/`k`-connected.
+
+```agda
+-- TODO
+```

From 8144c07a700f5f7348fd74a0aef86bace8b30e29 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 15 Mar 2024 00:09:08 +0100
Subject: [PATCH 05/14] Shifts and unshifts

---
 src/papers/SDR20.lagda.md                     |   8 +-
 ...cocones-under-sequential-diagrams.lagda.md |  31 +-
 ...cocones-under-sequential-diagrams.lagda.md |   2 +-
 .../dependent-sequential-diagrams.lagda.md    |   2 +-
 .../sequential-diagrams.lagda.md              |   2 +-
 .../shifts-sequential-diagrams.lagda.md       | 762 +++++++++++++-----
 6 files changed, 610 insertions(+), 197 deletions(-)

diff --git a/src/papers/SDR20.lagda.md b/src/papers/SDR20.lagda.md
index cb61a71a14..a9c2461d19 100644
--- a/src/papers/SDR20.lagda.md
+++ b/src/papers/SDR20.lagda.md
@@ -64,18 +64,18 @@ import synthetic-homotopy-theory.functoriality-sequential-colimits using
 Lemma 3.6: Dropping a head of a sequential diagram preserves the sequential
 colimit.
 
-TODO: the actual equivalence
-
 ```agda
 import synthetic-homotopy-theory.shifts-sequential-diagrams using
-  ( up-cocone-shift-sequential-diagram)
+  ( up-cocone-shift-sequential-diagram ;
+    compute-sequential-colimit-shift-sequential-diagram) -- apply to 1
 ```
 
 Lemma 3.7: Dropping finitely many objects from the head of a sequential diagram
 preserves the sequential colimit.
 
 ```agda
--- TODO
+import synthetic-homotopy-theory.shifts-sequential-diagrams using
+  ( compute-sequential-colimit-shift-sequential-diagram)
 ```
 
 Liftings?
diff --git a/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md
index 7eb8ec69fd..fae7b5e423 100644
--- a/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md
@@ -37,7 +37,7 @@ open import synthetic-homotopy-theory.sequential-diagrams
 
 A **cocone under a
 [sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md)
-`(A, a)`** with codomain `X : ùì§` consists of a family of maps `i‚Çô : A n ‚Üí C` and
+`(A, a)`** with codomain `X : ùí∞` consists of a family of maps `i‚Çô : A n ‚Üí C` and
 a family of [homotopies](foundation.homotopies.md) `H‚Çô` asserting that the
 triangles
 
@@ -154,6 +154,35 @@ module _
   coherence-htpy-htpy-cocone-sequential-diagram = pr2 H
 ```
 
+### Concatenation of homotopies of cocones under a sequential diagram
+
+```agda
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1} {X : UU l2}
+  {c c' c'' : cocone-sequential-diagram A X}
+  (H : htpy-cocone-sequential-diagram c c')
+  (K : htpy-cocone-sequential-diagram c' c'')
+  where
+
+  concat-htpy-cocone-sequential-diagram : htpy-cocone-sequential-diagram c c''
+  pr1 concat-htpy-cocone-sequential-diagram n =
+    ( htpy-htpy-cocone-sequential-diagram H n) ‚àôh
+    ( htpy-htpy-cocone-sequential-diagram K n)
+  pr2 concat-htpy-cocone-sequential-diagram n =
+    horizontal-pasting-coherence-square-homotopies
+      ( htpy-htpy-cocone-sequential-diagram H n)
+      ( htpy-htpy-cocone-sequential-diagram K n)
+      ( coherence-cocone-sequential-diagram c n)
+      ( coherence-cocone-sequential-diagram c' n)
+      ( coherence-cocone-sequential-diagram c'' n)
+      ( ( htpy-htpy-cocone-sequential-diagram H (succ-‚Ñï n)) ¬∑r
+        ( map-sequential-diagram A n))
+      ( ( htpy-htpy-cocone-sequential-diagram K (succ-‚Ñï n)) ¬∑r
+        ( map-sequential-diagram A n))
+      ( coherence-htpy-htpy-cocone-sequential-diagram H n)
+      ( coherence-htpy-htpy-cocone-sequential-diagram K n)
+```
+
 ### Postcomposing cocones under a sequential diagram with a map
 
 Given a cocone `c` with vertex `X` under `(A, a)` and a map `f : X ‚Üí Y`, we may
diff --git a/src/synthetic-homotopy-theory/dependent-cocones-under-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/dependent-cocones-under-sequential-diagrams.lagda.md
index dcee6298d0..6711f8276f 100644
--- a/src/synthetic-homotopy-theory/dependent-cocones-under-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-cocones-under-sequential-diagrams.lagda.md
@@ -41,7 +41,7 @@ open import synthetic-homotopy-theory.sequential-diagrams
 Given a [sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md)
 `(A, a)`, a
 [cocone](synthetic-homotopy-theory.cocones-under-sequential-diagrams.md) `c`
-with vertex `X` under it, and a type family `P : X ‚Üí ùì§`, we may construct
+with vertex `X` under it, and a type family `P : X ‚Üí ùí∞`, we may construct
 _dependent_ cocones on `P` over `c`.
 
 A **dependent cocone under a
diff --git a/src/synthetic-homotopy-theory/dependent-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/dependent-sequential-diagrams.lagda.md
index 7cafe2e7ee..a4554336de 100644
--- a/src/synthetic-homotopy-theory/dependent-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-sequential-diagrams.lagda.md
@@ -24,7 +24,7 @@ open import synthetic-homotopy-theory.sequential-diagrams
 A **dependent sequential diagram** over a
 [sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md) `(A, a)`
 is a [sequence](foundation.dependent-sequences.md) of families of types
-`B : (n : ‚Ñï) ‚Üí A‚Çô ‚Üí ùì§` over the types in the base sequential diagram, equipped
+`B : (n : ‚Ñï) ‚Üí A‚Çô ‚Üí ùí∞` over the types in the base sequential diagram, equipped
 with fiberwise maps
 
 ```text
diff --git a/src/synthetic-homotopy-theory/sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/sequential-diagrams.lagda.md
index 33166e8430..34fe7194f0 100644
--- a/src/synthetic-homotopy-theory/sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/sequential-diagrams.lagda.md
@@ -18,7 +18,7 @@ open import foundation.universe-levels
 ## Idea
 
 A **sequential diagram** `(A, a)` is a [sequence](foundation.sequences.md) of
-types `A : ‚Ñï ‚Üí ùì§` over the natural numbers, equipped with a family of maps
+types `A : ‚Ñï ‚Üí ùí∞` over the natural numbers, equipped with a family of maps
 `a‚Çô : A‚Çô ‚Üí A‚Çô‚Çä‚ÇÅ` for all `n`.
 
 They can be represented by diagrams
diff --git a/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
index d7249b9ca3..f17c42b843 100644
--- a/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
@@ -9,8 +9,6 @@ module synthetic-homotopy-theory.shifts-sequential-diagrams where
 ```agda
 open import elementary-number-theory.natural-numbers
 
-open import foundation.commuting-squares-of-maps
-open import foundation.commuting-triangles-of-identifications
 open import foundation.commuting-triangles-of-maps
 open import foundation.dependent-pair-types
 open import foundation.equivalences
@@ -21,10 +19,8 @@ open import foundation.retractions
 open import foundation.sections
 open import foundation.universe-levels
 open import foundation.whiskering-homotopies-composition
-open import foundation.whiskering-homotopies-concatenation
 
 open import synthetic-homotopy-theory.cocones-under-sequential-diagrams
-open import synthetic-homotopy-theory.functoriality-sequential-colimits
 open import synthetic-homotopy-theory.morphisms-sequential-diagrams
 open import synthetic-homotopy-theory.sequential-colimits
 open import synthetic-homotopy-theory.sequential-diagrams
@@ -39,83 +35,143 @@ A
 {{#concept "shift" Disambiguation="sequential diagram" Agda=shift-sequential-diagram}}
 of a [sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md) is a
 sequential diagram consisting of the types and maps shifted by one. It is also
-denoted `A[1]`.
+denoted `A[1]`. This shifting can be iterated for any natural number `k`; then
+the resulting sequential diagram is denoted `A[k]`.
 
 Similarly, a
 {{#concept "shift" Disambiguation="morphism of sequential diagrams" Agda=shift-hom-sequential-diagram}}
 of a
 [morphism of sequential diagrams](synthetic-homotopy-theory.morphisms-sequential-diagrams.md)
-is a morphism from the shifted domain into the shifted codomain.
+is a morphism from the shifted domain into the shifted codomain. In symbols,
+given a morphism `f : A ‚Üí B`, we have `f[k] : A[k] ‚Üí B[k]`.
 
-Importantly, the sequential colimit of a shifted sequential diagram is
-equivalent to the colimit of the original diagram.
+We also define shifts of cocones and homotopies of cocones, which can
+additionally be unshifted.
+
+Importantly the type of cocones under a sequential diagram is equivalent to the
+type of cocones under its shift, which implies that the sequential colimit of a
+shifted sequential diagram is equivalent to the colimit of the original diagram.
 
 ## Definitions
 
+_Implementation note_: the constructions are defined by first defining a shift
+by one, and then recursively shifting by one according to the argument. An
+alternative would be to shift all data using addition on the natural numbers.
+
+However, addition computes only on one side, so we have a choice to make: given
+a shift `k`, do we define the `n`-th level of the shifted structure to be
+`n+k`-th or `k+n`-th level of the original?
+
+The former runs into issues already when defining the shifted sequence, since
+`a‚Çô‚Çä‚Çñ : A‚Çô‚Çä‚Çñ ‚Üí A‚Çç‚Çô‚Çä‚ÇÅ‚Çé`, but we need a map of type `A‚Çô‚Çä‚Çñ ‚Üí A‚Çç‚Çô‚Çä‚Çñ‚Çé‚Çä‚ÇÅ`, which
+forces us to introduce a transport.
+
+On the other hand, the latter requires transport when proving anything by
+induction on `k` and doesn't satisfy the judgmental equality `A[0] ‚âê A`, because
+`A‚Çç‚Çñ‚Çä‚ÇÅ‚Çé‚Çä‚Çô` is not `A‚Çç‚Çñ‚Çä‚Çô‚Çé‚Çä‚ÇÅ` and `A‚ÇÄ‚Çä‚Çô` is not `A‚Çô`, and it requires more
+infrastructure for working with horizontal compositions in sequential colimit to
+be formalized in terms of addition.
+
 ### Shifts of sequential diagrams
 
+Given a sequential diagram `A`
+
+```text
+     a‚ÇÄ      a‚ÇÅ      a‚ÇÇ
+ A‚ÇÄ ---> A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ ,
+```
+
+we can forget the first type and map to get the diagram
+
+```text
+     a‚ÇÅ      a‚ÇÇ
+ A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ ,
+```
+
+which we call `A[1]`. Inductively, we define `A[k + 1] ‚âê A[k][1]`.
+
 ```agda
 module _
   {l1 : Level} (A : sequential-diagram l1)
   where
 
-  shift-sequential-diagram : sequential-diagram l1
-  pr1 shift-sequential-diagram n = family-sequential-diagram A (succ-‚Ñï n)
-  pr2 shift-sequential-diagram n = map-sequential-diagram A (succ-‚Ñï n)
-```
-
-### Shifts of morphisms of sequential diagrams
+  shift-sequential-diagram-once : sequential-diagram l1
+  pr1 shift-sequential-diagram-once n = family-sequential-diagram A (succ-‚Ñï n)
+  pr2 shift-sequential-diagram-once n = map-sequential-diagram A (succ-‚Ñï n)
 
-```agda
 module _
-  {l1 l2 : Level} {A : sequential-diagram l1} (B : sequential-diagram l2)
-  (f : hom-sequential-diagram A B)
+  {l1 : Level}
   where
 
-  shift-hom-sequential-diagram :
-    hom-sequential-diagram
-      ( shift-sequential-diagram A)
-      ( shift-sequential-diagram B)
-  pr1 shift-hom-sequential-diagram n =
-    map-hom-sequential-diagram B f (succ-‚Ñï n)
-  pr2 shift-hom-sequential-diagram n =
-    naturality-map-hom-sequential-diagram B f (succ-‚Ñï n)
+  shift-sequential-diagram : ‚Ñï ‚Üí sequential-diagram l1 ‚Üí sequential-diagram l1
+  shift-sequential-diagram zero-‚Ñï A = A
+  shift-sequential-diagram (succ-‚Ñï k) A =
+    shift-sequential-diagram-once (shift-sequential-diagram k A)
 ```
 
-## Properties
-
-### Sequential diagrams map into their shifts
+### Shifts of morphisms of sequential diagrams
 
-The morphism is obtained by observing that the squares in the diagram
+Given a morphism of sequential diagrams `f : A ‚Üí B`
 
 ```text
         a‚ÇÄ      a‚ÇÅ
     A‚ÇÄ ---> A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
     |       |       |
- a‚ÇÄ |       | a‚ÇÅ    | a‚ÇÇ
+ f‚ÇÄ |       | f‚ÇÅ    | f‚ÇÇ
     v       v       v
-    A‚ÇÅ ---> A‚ÇÇ ---> A‚ÇÉ ---> ‚ãØ
-        a‚ÇÅ      a‚ÇÇ
+    B‚ÇÄ ---> B‚ÇÅ ---> B‚ÇÇ ---> ‚ãØ ,
+        b‚ÇÄ      b‚ÇÅ
 ```
 
-commute by reflexivity.
+we can drop the first square to get the morphism
+
+```text
+        a‚ÇÅ
+    A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
+    |       |
+ f‚ÇÅ |       | f‚ÇÇ
+    v       v
+    B‚ÇÅ ---> B‚ÇÇ ---> ‚ãØ ,
+        b‚ÇÅ
+```
+
+which we call `f[1] : A[1] ‚Üí B[1]`. Inductively, we define `f[k + 1] ‚âê f[k][1]`.
 
 ```agda
 module _
-  {l1 : Level} (A : sequential-diagram l1)
+  {l1 l2 : Level} {A : sequential-diagram l1} (B : sequential-diagram l2)
+  (f : hom-sequential-diagram A B)
   where
 
-  hom-shift-sequential-diagram :
+  shift-hom-sequential-diagram-once :
     hom-sequential-diagram
-      ( A)
-      ( shift-sequential-diagram A)
-  pr1 hom-shift-sequential-diagram = map-sequential-diagram A
-  pr2 hom-shift-sequential-diagram n = refl-htpy
+      ( shift-sequential-diagram-once A)
+      ( shift-sequential-diagram-once B)
+  pr1 shift-hom-sequential-diagram-once n =
+    map-hom-sequential-diagram B f (succ-‚Ñï n)
+  pr2 shift-hom-sequential-diagram-once n =
+    naturality-map-hom-sequential-diagram B f (succ-‚Ñï n)
+
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1} (B : sequential-diagram l2)
+  where
+
+  shift-hom-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
+    hom-sequential-diagram A B ‚Üí
+    hom-sequential-diagram
+      ( shift-sequential-diagram k A)
+      ( shift-sequential-diagram k B)
+  shift-hom-sequential-diagram zero-‚Ñï f = f
+  shift-hom-sequential-diagram (succ-‚Ñï k) f =
+    shift-hom-sequential-diagram-once
+      ( shift-sequential-diagram k B)
+      ( shift-hom-sequential-diagram k f)
 ```
 
-### The type of cocones under a sequential diagram is equivalent to the type of cocones under its shift
+### Shifts of cocones under sequential diagrams
 
-Given a cocone
+Given a cocone `c`
 
 ```text
       a‚ÇÄ      a‚ÇÅ
@@ -131,33 +187,232 @@ Given a cocone
 under `A`, we may forget the first injection and homotopy to get the cocone
 
 ```text
-              a‚ÇÅ
-          A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
-          |      /
-          |     /
-          | i‚ÇÅ / i‚ÇÇ
-          |   /
-          V  V
-          X
+         a‚ÇÅ
+     A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
+     |      /
+     |     /
+  i‚ÇÅ |    / i‚ÇÇ
+     |   /
+     V  V
+     X
 ```
 
-under `A[1]`.
+under `A[1]`. We denote this cocone `c[1]`. Inductively, we define
+`c[k + 1] ‚âê c[k][1]`.
 
-Conversely, given a cocone
+```agda
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1}
+  {X : UU l2} (c : cocone-sequential-diagram A X)
+  where
+
+  shift-cocone-sequential-diagram-once :
+    cocone-sequential-diagram (shift-sequential-diagram-once A) X
+  pr1 shift-cocone-sequential-diagram-once n =
+    map-cocone-sequential-diagram c (succ-‚Ñï n)
+  pr2 shift-cocone-sequential-diagram-once n =
+    coherence-cocone-sequential-diagram c (succ-‚Ñï n)
+
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1}
+  {X : UU l2}
+  where
+
+  shift-cocone-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
+    cocone-sequential-diagram A X ‚Üí
+    cocone-sequential-diagram (shift-sequential-diagram k A) X
+  shift-cocone-sequential-diagram zero-‚Ñï c =
+    c
+  shift-cocone-sequential-diagram (succ-‚Ñï k) c =
+    shift-cocone-sequential-diagram-once
+      ( shift-cocone-sequential-diagram k c)
+```
+
+### Unshifts of cocones under sequential diagrams
+
+Conversely, given a cocone `c`
 
 ```text
-        a‚ÇÅ      a‚ÇÅ
-    A‚ÇÅ ---> A‚ÇÇ ---> A‚ÇÉ ---> ‚ãØ
-     \      |      /
-      \     |     /
-    i‚ÇÅ \    | i‚ÇÇ / i‚ÇÉ
-        \   |   /
-         V  V  V
-            X
+         a‚ÇÅ
+     A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
+     |      /
+     |     /
+  i‚ÇÅ |    / i‚ÇÇ
+     |   /
+     V  V
+     X
+```
+
+under `A[1]`, we may prepend a map
+
+```text
+           a‚ÇÄ      a‚ÇÅ
+       A‚ÇÄ ---> A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
+        \      |      /
+         \     |     /
+  i‚ÇÅ ‚àò a‚ÇÄ \    | i‚ÇÅ / i‚ÇÇ
+           \   |   /
+            V  V  V
+               X
+```
+
+which commutes by reflexivity, giving us a cocone under `A`, which we call
+`c[-1]`.
+
+Notice that by restricting the type of `c` to be the cocones under an already
+shifted diagram, we ensure that unshifting cannot get out of bounds of the
+original diagram.
+
+Inductively, we define `c[-(k + 1)] ‚âê c[-1][-k]`. One might expect that
+following the pattern of shifts, this should be `c[-k][-1]`, but recall that we
+only know how to unshift a cocone under `A[n]` by `n`; since this `c` is under
+`A[k][1]`, we first need to unshift by 1 to get `c[-1]` under `A[k]`, and only
+then we can unshift by `k` to get `c[-1][-k]` under `A`.
+
+```agda
+module _
+  {l1 l2 : Level} (A : sequential-diagram l1)
+  {X : UU l2}
+  (c : cocone-sequential-diagram (shift-sequential-diagram-once A) X)
+  where
+
+  cocone-unshift-sequential-diagram-once :
+    cocone-sequential-diagram A X
+  pr1 cocone-unshift-sequential-diagram-once zero-‚Ñï =
+    map-cocone-sequential-diagram c zero-‚Ñï ‚àò map-sequential-diagram A zero-‚Ñï
+  pr1 cocone-unshift-sequential-diagram-once (succ-‚Ñï n) =
+    map-cocone-sequential-diagram c n
+  pr2 cocone-unshift-sequential-diagram-once zero-‚Ñï =
+    refl-htpy
+  pr2 cocone-unshift-sequential-diagram-once (succ-‚Ñï n) =
+    coherence-cocone-sequential-diagram c n
+
+module _
+  {l1 l2 : Level} (A : sequential-diagram l1)
+  {X : UU l2}
+  where
+
+  cocone-unshift-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
+    cocone-sequential-diagram (shift-sequential-diagram k A) X ‚Üí
+    cocone-sequential-diagram A X
+  cocone-unshift-sequential-diagram zero-‚Ñï c =
+    c
+  cocone-unshift-sequential-diagram (succ-‚Ñï k) c =
+    cocone-unshift-sequential-diagram k
+      ( cocone-unshift-sequential-diagram-once
+        ( shift-sequential-diagram k A)
+        ( c))
+```
+
+### Shifts of homotopies of cocones under sequential diagrams
+
+Given cocones `c` and `c'` under `A`, and a homotopy `H : c ~ c'` between them,
+which I'm not sufficiently artistically equipped to put into an ASCII diagram,
+we can again forget the first homotopy of maps and coherence to get the homotopy
+`H[1] : c[1] ~ c'[1]`. Inductively, we define `H[k + 1] ‚âê H[k][1]`.
+
+```agda
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1} {X : UU l2}
+  {c c' : cocone-sequential-diagram A X}
+  (H : htpy-cocone-sequential-diagram c c')
+  where
+
+  shift-htpy-cocone-sequential-diagram-once :
+    htpy-cocone-sequential-diagram
+      ( shift-cocone-sequential-diagram-once c)
+      ( shift-cocone-sequential-diagram-once c')
+  pr1 shift-htpy-cocone-sequential-diagram-once n =
+    htpy-htpy-cocone-sequential-diagram H (succ-‚Ñï n)
+  pr2 shift-htpy-cocone-sequential-diagram-once n =
+    coherence-htpy-htpy-cocone-sequential-diagram
+      ( H)
+      ( succ-‚Ñï n)
+
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1} {X : UU l2}
+  {c c' : cocone-sequential-diagram A X}
+  where
+
+  shift-htpy-cocone-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
+    htpy-cocone-sequential-diagram c c' ‚Üí
+    htpy-cocone-sequential-diagram
+      ( shift-cocone-sequential-diagram k c)
+      ( shift-cocone-sequential-diagram k c')
+  shift-htpy-cocone-sequential-diagram zero-‚Ñï H =
+    H
+  shift-htpy-cocone-sequential-diagram (succ-‚Ñï k) H =
+    shift-htpy-cocone-sequential-diagram-once
+      ( shift-htpy-cocone-sequential-diagram k H)
 ```
 
-under `A[1]`, we may precompose it with the morphism `A ‚Üí A[1]` to get the
-cocone
+### Unshifts of homotopies of cocones under sequential diagrams
+
+Similarly to unshifting cocones, we can synthesize the first homotopy and
+coherence to unshift a homotopy of cocones. Given two cocones `c`, `c'` under
+`A[1]`
+
+```text
+         a‚ÇÅ                     a‚ÇÅ
+     A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ      A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
+     |      /               |      /
+     |     /                |     /
+  i‚ÇÅ |    / i‚ÇÇ     ~    i'‚ÇÅ |    / i'‚ÇÇ
+     |   /                  |   /
+     V  V                   V  V
+     X                      X
+```
+
+and a homotopy `H : c ~ c'`, we need to show that `i‚ÇÅ ‚àò a‚ÇÄ ~ i'‚ÇÅ ‚àò a‚ÇÄ`. This can
+be obtained by whiskering `H‚ÇÄ ¬∑r a‚ÇÄ`, which makes the coherence trivial.
+
+Inductively, we define `H[-(k + 1)] ‚âê H[-1][-k]`.
+
+```agda
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1} {X : UU l2}
+  {c c' : cocone-sequential-diagram (shift-sequential-diagram-once A) X}
+  (H : htpy-cocone-sequential-diagram c c')
+  where
+
+  unshift-htpy-cocone-sequential-diagram-once :
+    htpy-cocone-sequential-diagram
+      ( cocone-unshift-sequential-diagram-once A c)
+      ( cocone-unshift-sequential-diagram-once A c')
+  pr1 unshift-htpy-cocone-sequential-diagram-once zero-‚Ñï =
+    ( htpy-htpy-cocone-sequential-diagram H zero-‚Ñï) ¬∑r
+    ( map-sequential-diagram A zero-‚Ñï)
+  pr1 unshift-htpy-cocone-sequential-diagram-once (succ-‚Ñï n) =
+    htpy-htpy-cocone-sequential-diagram H n
+  pr2 unshift-htpy-cocone-sequential-diagram-once zero-‚Ñï =
+    inv-htpy-right-unit-htpy
+  pr2 unshift-htpy-cocone-sequential-diagram-once (succ-‚Ñï n) =
+    coherence-htpy-htpy-cocone-sequential-diagram H n
+
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1} {X : UU l2}
+  where
+
+  unshift-htpy-cocone-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
+    {c c' : cocone-sequential-diagram (shift-sequential-diagram k A) X} ‚Üí
+    htpy-cocone-sequential-diagram c c' ‚Üí
+    htpy-cocone-sequential-diagram
+      ( cocone-unshift-sequential-diagram A k c)
+      ( cocone-unshift-sequential-diagram A k c')
+  unshift-htpy-cocone-sequential-diagram zero-‚Ñï H =
+    H
+  unshift-htpy-cocone-sequential-diagram (succ-‚Ñï k) H =
+    unshift-htpy-cocone-sequential-diagram k
+      (unshift-htpy-cocone-sequential-diagram-once H)
+```
+
+### Morphisms from sequential diagrams into their shifts
+
+The morphism is obtained by observing that the squares in the diagram
 
 ```text
         a‚ÇÄ      a‚ÇÅ
@@ -166,148 +421,197 @@ cocone
  a‚ÇÄ |       | a‚ÇÅ    | a‚ÇÇ
     v       v       v
     A‚ÇÅ ---> A‚ÇÇ ---> A‚ÇÉ ---> ‚ãØ
-     \  a‚ÇÅ  |   a‚ÇÅ  /
-      \     |     /
-    i‚ÇÅ \    | i‚ÇÇ / i‚ÇÉ
-        \   |   /
-         V  V  V
-            X
+        a‚ÇÅ      a‚ÇÇ
 ```
 
-under `A`.
+commute by reflexivity.
 
 ```agda
 module _
-  {l1 l2 : Level} (A : sequential-diagram l1)
-  {X : UU l2}
+  {l1 : Level} (A : sequential-diagram l1)
   where
 
-  cocone-shift-sequential-diagram :
-    cocone-sequential-diagram A X ‚Üí
-    cocone-sequential-diagram (shift-sequential-diagram A) X
-  pr1 (cocone-shift-sequential-diagram c) n =
-    map-cocone-sequential-diagram c (succ-‚Ñï n)
-  pr2 (cocone-shift-sequential-diagram c) n =
-    coherence-cocone-sequential-diagram c (succ-‚Ñï n)
+  hom-shift-sequential-diagram-once :
+    hom-sequential-diagram
+      ( A)
+      ( shift-sequential-diagram-once A)
+  pr1 hom-shift-sequential-diagram-once = map-sequential-diagram A
+  pr2 hom-shift-sequential-diagram-once n = refl-htpy
 
-  cocone-unshift-sequential-diagram :
-    cocone-sequential-diagram (shift-sequential-diagram A) X ‚Üí
-    cocone-sequential-diagram A X
-  cocone-unshift-sequential-diagram c =
-    map-cocone-hom-sequential-diagram
-      ( hom-shift-sequential-diagram A)
-      ( c)
+module _
+  {l1 : Level} (A : sequential-diagram l1)
+  where
+
+  hom-shift-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
+    hom-sequential-diagram
+      ( A)
+      ( shift-sequential-diagram k A)
+  hom-shift-sequential-diagram zero-‚Ñï = id-hom-sequential-diagram A
+  hom-shift-sequential-diagram (succ-‚Ñï k) =
+    comp-hom-sequential-diagram
+      ( A)
+      ( shift-sequential-diagram k A)
+      ( shift-sequential-diagram (succ-‚Ñï k) A)
+      ( hom-shift-sequential-diagram-once
+        ( shift-sequential-diagram k A))
+      ( hom-shift-sequential-diagram k)
+```
+
+## Properties
+
+### The type of cocones under a sequential diagram is equivalent to the type of cocones under its shift
+
+This is shown by proving that shifting and unshifting of cocones are mutually
+inverse operations.
 
+To show that `shift ‚àò unshift ~ id` is trivial, since the first step synthesizes
+some data for the first level, which the second step promptly forgets.
+
+In the inductive step, we need to show `c[-(k + 1)][k + 1] ~ c`. The left-hand
+side computes to `c[-1][-k][k][1]`, which is homotopic to `c[-1][1]` by shifting
+the homotopy given by the inductive hypothesis, and that computes to `c`.
+
+```agda
 module _
-  {l1 l2 : Level} (A : sequential-diagram l1)
-  (X : UU l2)
+  {l1 l2 : Level} {A : sequential-diagram l1}
+  {X : UU l2}
   where
 
-  -- TODO: Why are these two proofs so similar? Could it be abstracted?
-  -- The diff is whiskering with the map of A or A[1]
-  -- htpy-is-section-cocone-unshift-sequential-diagram :
-  --   (c : cocone-sequential-diagram (shift-sequential-diagram A) X) ‚Üí
-  --   htpy-cocone-sequential-diagram
-  --     ( cocone-shift-sequential-diagram A
-  --       ( cocone-unshift-sequential-diagram A c))
-  --     ( c)
-  -- pr1 (htpy-is-section-cocone-unshift-sequential-diagram c) n =
-  --   inv-htpy (coherence-cocone-sequential-diagram c n)
-  -- pr2 (htpy-is-section-cocone-unshift-sequential-diagram c) n =
-  --   ( ap-concat-htpy'
-  --     ( inv-htpy
-  --       ( ( coherence-cocone-sequential-diagram c (succ-‚Ñï n))) ¬∑r
-  --         ( map-sequential-diagram (shift-sequential-diagram A) n))
-  --     ( right-unit-htpy)) ‚àôh
-  --   ( right-inv-htpy
-  --     ( ( coherence-cocone-sequential-diagram c (succ-‚Ñï n)) ¬∑r
-  --       ( map-sequential-diagram (shift-sequential-diagram A) n))) ‚àôh
-  --   ( inv-htpy-left-inv-htpy (coherence-cocone-sequential-diagram c n))
+  htpy-is-section-cocone-unshift-sequential-diagram :
+    (c : cocone-sequential-diagram (shift-sequential-diagram-once A) X) ‚Üí
+    htpy-cocone-sequential-diagram
+      ( shift-cocone-sequential-diagram-once
+        ( cocone-unshift-sequential-diagram-once A c))
+      ( c)
+  htpy-is-section-cocone-unshift-sequential-diagram c =
+    refl-htpy-cocone-sequential-diagram (shift-sequential-diagram-once A) c
+
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1}
+  {X : UU l2}
+  where
 
   htpy-is-section-cocone-unshift-sequential-diagram' :
-    (c : cocone-sequential-diagram (shift-sequential-diagram A) X) ‚Üí
+    (k : ‚Ñï) ‚Üí
+    (c : cocone-sequential-diagram (shift-sequential-diagram k A) X) ‚Üí
     htpy-cocone-sequential-diagram
+      ( shift-cocone-sequential-diagram k
+        ( cocone-unshift-sequential-diagram A k c))
       ( c)
-      ( cocone-shift-sequential-diagram A
-        ( cocone-unshift-sequential-diagram A c))
-  pr1 (htpy-is-section-cocone-unshift-sequential-diagram' c) =
-    coherence-cocone-sequential-diagram c
-  pr2 (htpy-is-section-cocone-unshift-sequential-diagram' c) n =
-    left-whisker-concat-htpy
-      ( coherence-cocone-sequential-diagram c n)
-      ( inv-htpy-right-unit-htpy)
+  htpy-is-section-cocone-unshift-sequential-diagram' zero-‚Ñï c =
+    refl-htpy-cocone-sequential-diagram A c
+  htpy-is-section-cocone-unshift-sequential-diagram' (succ-‚Ñï k) c =
+    shift-htpy-cocone-sequential-diagram-once
+      ( htpy-is-section-cocone-unshift-sequential-diagram' k
+        ( cocone-unshift-sequential-diagram-once
+          ( shift-sequential-diagram k A)
+          ( c)))
 
   is-section-cocone-unshift-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
     is-section
-      ( cocone-shift-sequential-diagram A {X})
-      ( cocone-unshift-sequential-diagram A {X})
-  is-section-cocone-unshift-sequential-diagram c =
-    inv
-      ( eq-htpy-cocone-sequential-diagram
-        ( shift-sequential-diagram A)
-        ( _)
-        ( _)
-        ( htpy-is-section-cocone-unshift-sequential-diagram' c))
-
-  -- htpy-is-retraction-cocone-unshift-sequential-diagram :
-  --   (c : cocone-sequential-diagram A X) ‚Üí
-  --   htpy-cocone-sequential-diagram
-  --     ( cocone-unshift-sequential-diagram A
-  --       ( cocone-shift-sequential-diagram A c))
-  --     ( c)
-  -- pr1 (htpy-is-retraction-cocone-unshift-sequential-diagram c) n =
-  --   inv-htpy (coherence-cocone-sequential-diagram c n)
-  -- pr2 (htpy-is-retraction-cocone-unshift-sequential-diagram c) n =
-  --   ( ap-concat-htpy'
-  --     ( inv-htpy
-  --       ( ( coherence-cocone-sequential-diagram c (succ-‚Ñï n))) ¬∑r
-  --         ( map-sequential-diagram A n))
-  --     ( right-unit-htpy)) ‚àôh
-  --   ( right-inv-htpy
-  --     ( ( coherence-cocone-sequential-diagram c (succ-‚Ñï n)) ¬∑r
-  --       ( map-sequential-diagram A n))) ‚àôh
-  --   ( inv-htpy-left-inv-htpy (coherence-cocone-sequential-diagram c n))
-
-  htpy-is-retraction-cocone-unshift-sequential-diagram' :
+      ( shift-cocone-sequential-diagram k)
+      ( cocone-unshift-sequential-diagram A {X} k)
+  is-section-cocone-unshift-sequential-diagram k c =
+    eq-htpy-cocone-sequential-diagram
+      ( shift-sequential-diagram k A)
+      ( _)
+      ( _)
+      ( htpy-is-section-cocone-unshift-sequential-diagram' k c)
+```
+
+For the other direction, we need to show that the synthesized data, namely the
+map `i‚ÇÅ ‚àò a‚ÇÄ : A‚ÇÄ ‚Üí X` and the reflexive homotopy, is consistent with the
+original data `i‚ÇÄ : A‚ÇÄ ‚Üí X` and the homotopy `H‚ÇÄ : i‚ÇÄ ~ i‚ÇÅ ‚àò a‚ÇÄ`. It is more
+convenient to show the inverse homotopy `id ~ unshift ‚àò shift`, because `H‚ÇÄ`
+gives us exactly the right homotopy for the first level, so the rest of the
+coherences are also trivial.
+
+In the inductive step, we need to show
+`c ~ c[k + 1][-(k + 1)] ‚âê c[k][1][-1][-k]`. This follows from the inductive
+hypothesis, which states that `c ~ c[k][-k]`, and which we compose with the
+homotopy `c[k] ~ c[k][1][-1]` unshifted by `k`.
+
+```agda
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1}
+  {X : UU l2}
+  where
+
+  inv-htpy-is-retraction-cocone-sequential-diagram :
+    (c : cocone-sequential-diagram A X) ‚Üí
+    htpy-cocone-sequential-diagram
+      ( c)
+      ( cocone-unshift-sequential-diagram-once A
+        ( shift-cocone-sequential-diagram-once c))
+  pr1 (inv-htpy-is-retraction-cocone-sequential-diagram c) zero-‚Ñï =
+    coherence-cocone-sequential-diagram c zero-‚Ñï
+  pr1 (inv-htpy-is-retraction-cocone-sequential-diagram c) (succ-‚Ñï n) =
+    refl-htpy
+  pr2 (inv-htpy-is-retraction-cocone-sequential-diagram c) zero-‚Ñï =
+    refl-htpy
+  pr2 (inv-htpy-is-retraction-cocone-sequential-diagram c) (succ-‚Ñï n) =
+    right-unit-htpy
+
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1}
+  {X : UU l2}
+  where
+
+  inv-htpy-is-retraction-cocone-sequential-diagram' :
+    (k : ‚Ñï) ‚Üí
     (c : cocone-sequential-diagram A X) ‚Üí
     htpy-cocone-sequential-diagram
       ( c)
-      ( cocone-unshift-sequential-diagram A
-        ( cocone-shift-sequential-diagram A c))
-  pr1 (htpy-is-retraction-cocone-unshift-sequential-diagram' c) =
-    coherence-cocone-sequential-diagram c
-  pr2 (htpy-is-retraction-cocone-unshift-sequential-diagram' c) n =
-    left-whisker-concat-htpy
-      ( coherence-cocone-sequential-diagram c n)
-      ( inv-htpy-right-unit-htpy)
+      ( cocone-unshift-sequential-diagram A k
+        ( shift-cocone-sequential-diagram k c))
+  inv-htpy-is-retraction-cocone-sequential-diagram' zero-‚Ñï c =
+    refl-htpy-cocone-sequential-diagram A c
+  inv-htpy-is-retraction-cocone-sequential-diagram' (succ-‚Ñï k) c =
+    concat-htpy-cocone-sequential-diagram
+      ( inv-htpy-is-retraction-cocone-sequential-diagram' k c)
+      ( unshift-htpy-cocone-sequential-diagram k
+        ( inv-htpy-is-retraction-cocone-sequential-diagram
+          ( shift-cocone-sequential-diagram k c)))
 
   is-retraction-cocone-unshift-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
     is-retraction
-      ( cocone-shift-sequential-diagram A {X})
-      ( cocone-unshift-sequential-diagram A {X})
-  is-retraction-cocone-unshift-sequential-diagram c =
-    inv
-      ( eq-htpy-cocone-sequential-diagram A _ _
-        ( htpy-is-retraction-cocone-unshift-sequential-diagram' c))
-
-  is-equiv-cocone-shift-sequential-diagram :
-    is-equiv (cocone-shift-sequential-diagram A {X})
-  is-equiv-cocone-shift-sequential-diagram =
+      ( shift-cocone-sequential-diagram k)
+      ( cocone-unshift-sequential-diagram A {X} k)
+  is-retraction-cocone-unshift-sequential-diagram k c =
+    inv (eq-htpy-cocone-sequential-diagram
+      ( A)
+      ( _)
+      ( _)
+      ( inv-htpy-is-retraction-cocone-sequential-diagram' k c))
+
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1}
+  {X : UU l2}
+  where
+
+  is-equiv-shift-cocone-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
+    is-equiv (shift-cocone-sequential-diagram {X = X} k)
+  is-equiv-shift-cocone-sequential-diagram k =
     is-equiv-is-invertible
-      ( cocone-unshift-sequential-diagram A {X})
-      ( is-section-cocone-unshift-sequential-diagram)
-      ( is-retraction-cocone-unshift-sequential-diagram)
+      ( cocone-unshift-sequential-diagram A k)
+      ( is-section-cocone-unshift-sequential-diagram k)
+      ( is-retraction-cocone-unshift-sequential-diagram k)
 
   equiv-cocone-shift-unshift-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
     cocone-sequential-diagram A X ‚âÉ
-    cocone-sequential-diagram (shift-sequential-diagram A) X
-  pr1 equiv-cocone-shift-unshift-sequential-diagram =
-    cocone-shift-sequential-diagram A {X}
-  pr2 equiv-cocone-shift-unshift-sequential-diagram =
-    is-equiv-cocone-shift-sequential-diagram
+    cocone-sequential-diagram (shift-sequential-diagram k A) X
+  pr1 (equiv-cocone-shift-unshift-sequential-diagram k) =
+    shift-cocone-sequential-diagram k
+  pr2 (equiv-cocone-shift-unshift-sequential-diagram k) =
+    is-equiv-shift-cocone-sequential-diagram k
 ```
 
-### The sequential colimit of a sequential diagram is also the sequential colimit of the shifted diagram
+### The sequential colimit of a sequential diagram is also the sequential colimit of its shift
 
 Given a sequential colimit
 
@@ -322,43 +626,123 @@ there is a commuting triangle
               cocone-map
       X ‚Üí Y ------------> cocone A Y
             \           /
+  cocone-map  \       /
+                V   V
+             cocone A[1] Y.
+```
+
+Inductively, we compose this triangle in the following way
+
+```text
+              cocone-map
+      X ‚Üí Y ------------> cocone A Y
+            \‚üç             |
+             \ ‚üç           |
+              \  ‚üç         |
+               \   ‚üç       V
+                \    > cocone A[k] Y
+     cocone-map  \       /
+                  \     /
+                   \   /
+                    V V
+             cocone A[k + 1] Y,
+```
+
+where the top triangle is the inductive hypothesis, and the bottom triangle is
+the step instantiated at `A[k]`.
+
+This gives us the commuting triangle
+
+```text
+              cocone-map
+      X ‚Üí Y ------------> cocone A Y
+            \     ‚âÉ     /
   cocone-map  \       / ‚âÉ
                 V   V
-             cocone A[1] Y,
+             cocone A[k] Y,
 ```
 
-where the top map is an equivalence by the universal property of `X`, and the
-right map was shown to be an equivalence above. It follows that the third map is
-also an equivalence, which makes `X` the sequential colimit of `A[1]`.
+where the top map is an equivalence by the universal property of the cocone on
+`X`, and the right map is an equivalence by a theorem shown above, which implies
+that the left map is an equivalence, which exactly says that `X` is the
+sequential colimit of `A[k]`.
 
 ```agda
 module _
-  {l1 l2 : Level} (A : sequential-diagram l1)
-  {X : UU l2} {c : cocone-sequential-diagram A X}
+  {l1 l2 : Level} {A : sequential-diagram l1}
+  {X : UU l2} (c : cocone-sequential-diagram A X)
   where
 
-  triangle-cocone-map-blabla :
+  triangle-cocone-map-shift-sequential-diagram-once :
     {l : Level} (Y : UU l) ‚Üí
     coherence-triangle-maps
       ( cocone-map-sequential-diagram
-        ( cocone-shift-sequential-diagram A c)
+        ( shift-cocone-sequential-diagram-once c)
         { Y = Y})
-      ( cocone-shift-sequential-diagram A)
+      ( shift-cocone-sequential-diagram-once)
+      ( cocone-map-sequential-diagram c)
+  triangle-cocone-map-shift-sequential-diagram-once Y = refl-htpy
+
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1}
+  {X : UU l2} (c : cocone-sequential-diagram A X)
+  where
+
+  triangle-cocone-map-shift-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
+    {l : Level} (Y : UU l) ‚Üí
+    coherence-triangle-maps
+      ( cocone-map-sequential-diagram
+        ( shift-cocone-sequential-diagram k c))
+      ( shift-cocone-sequential-diagram k)
       ( cocone-map-sequential-diagram c)
-  triangle-cocone-map-blabla Y = refl-htpy
+  triangle-cocone-map-shift-sequential-diagram zero-‚Ñï Y =
+    refl-htpy
+  triangle-cocone-map-shift-sequential-diagram (succ-‚Ñï k) Y =
+    ( triangle-cocone-map-shift-sequential-diagram-once
+      ( shift-cocone-sequential-diagram k c)
+      ( Y)) ‚àôh
+    ( ( shift-cocone-sequential-diagram-once) ¬∑l
+      ( triangle-cocone-map-shift-sequential-diagram k Y))
+
+module _
+  {l1 l2 : Level} {A : sequential-diagram l1}
+  {X : UU l2} {c : cocone-sequential-diagram A X}
+  where
 
   up-cocone-shift-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
     universal-property-sequential-colimit c ‚Üí
-    universal-property-sequential-colimit (cocone-shift-sequential-diagram A c)
-  up-cocone-shift-sequential-diagram up-c Y =
+    universal-property-sequential-colimit (shift-cocone-sequential-diagram k c)
+  up-cocone-shift-sequential-diagram k up-c Y =
     is-equiv-left-map-triangle
       ( cocone-map-sequential-diagram
-        ( cocone-shift-sequential-diagram A c)
-        { Y = Y})
-      ( cocone-shift-sequential-diagram A)
+        ( shift-cocone-sequential-diagram k c))
+      ( shift-cocone-sequential-diagram k)
       ( cocone-map-sequential-diagram c)
-      ( triangle-cocone-map-blabla Y)
+      ( triangle-cocone-map-shift-sequential-diagram c k Y)
       ( up-c Y)
-      ( is-equiv-cocone-shift-sequential-diagram A Y)
+      ( is-equiv-shift-cocone-sequential-diagram k)
 ```
 
+We instantiate this theorem for the standard sequential colimits, giving us
+`A[k]‚àû ‚âÉ A‚àû`.
+
+```agda
+module _
+  {l1 : Level} (A : sequential-diagram l1)
+  where
+
+  compute-sequential-colimit-shift-sequential-diagram :
+    (k : ‚Ñï) ‚Üí
+    standard-sequential-colimit (shift-sequential-diagram k A) ‚âÉ
+    standard-sequential-colimit A
+  pr1 (compute-sequential-colimit-shift-sequential-diagram k) =
+    cogap-standard-sequential-colimit
+      ( shift-cocone-sequential-diagram
+        ( k)
+        ( cocone-standard-sequential-colimit A))
+  pr2 (compute-sequential-colimit-shift-sequential-diagram k) =
+    is-sequential-colimit-universal-property _
+      ( up-cocone-shift-sequential-diagram k up-standard-sequential-colimit)
+```

From 56cb51633594343cda4cad1c19aac49deace15b0 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 15 Mar 2024 18:00:10 +0100
Subject: [PATCH 06/14] Remove "Content created by" from the list of formalized
 papers

---
 book.toml | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/book.toml b/book.toml
index 206b2b5041..0bc75d67ed 100644
--- a/book.toml
+++ b/book.toml
@@ -42,7 +42,8 @@ suppress_processing = [
   "USERS.md",
   "GRANT-ACKNOWLEDGEMENTS.md",
   "SUMMARY.md",
-  "ART.md"
+  "ART.md",
+  "src/papers.md"
 ]
 
 [preprocessor.concepts]

From 3afea860b42c6e3c8223088adae91df6b3ffc062 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 15 Mar 2024 18:00:46 +0100
Subject: [PATCH 07/14] Add bibliography to the list of formalized papers

---
 src/papers.lagda.md | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/papers.lagda.md b/src/papers.lagda.md
index 94654734a6..f7c92b1c2e 100644
--- a/src/papers.lagda.md
+++ b/src/papers.lagda.md
@@ -1,5 +1,11 @@
 # Formalizations of papers in the library
 
+## References
+
+{{#bibliography}} {{#reference SDR20}}
+
+## Files in the namespace
+
 ```agda
 module papers where
 

From 3e6186e78ed9edec64a366a08ee252ef19af6e23 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 15 Mar 2024 18:01:02 +0100
Subject: [PATCH 08/14] Cleanup style and prose for SDR20 formalization

---
 src/papers/SDR20.lagda.md | 273 ++++++++++++++++++++++++++------------
 1 file changed, 188 insertions(+), 85 deletions(-)

diff --git a/src/papers/SDR20.lagda.md b/src/papers/SDR20.lagda.md
index a9c2461d19..0706a00141 100644
--- a/src/papers/SDR20.lagda.md
+++ b/src/papers/SDR20.lagda.md
@@ -1,200 +1,303 @@
 # Sequential Colimits in Homotopy Type Theory
 
-{{#cite SDR20}}
+This file collects references to formalization of constructions and theorems
+from {{#cite SDR20}}.
 
 ```agda
 module papers.SDR20 where
 ```
 
-## 3. Sequences and Sequential Colimits
+## 2 Homotopy Type Theory
 
-Definition 3.1: Sequences. We call sequences _sequential diagrams_.
+The second section introduces basic notions from homotopy type theory, which we
+import below for completeness.
 
 ```agda
-import synthetic-homotopy-theory.sequential-diagrams using
-  ( sequential-diagram)
+open import foundation.universe-levels using
+  ( UU
+  )
+open import foundation.identity-types using
+  ( Id -- "path"
+  ; refl -- "constant path"
+  ; inv -- "inverse path"
+  ; concat -- "concatenation of paths"
+  ; assoc -- "associativity of concatenation"
+  )
+open import foundation.action-on-identifications-functions using
+  ( ap -- "functions respect paths"
+  )
+open import foundation.homotopies using
+  ( _~_ -- "homotopy"
+  )
+open import foundation.equivalences using
+  ( equiv -- "equivalence"
+  )
+open import foundation.univalence using
+  ( univalence -- "the univalence axiom"
+  ; map-eq -- "function pÃÖ associated to a path"
+  )
+open import foundation.function-extensionality using
+  ( funext -- "the function extensionality axiom"
+  )
+open import foundation.fibers-of-maps using
+  ( fiber -- "the homotopy fiber of a function"
+  )
+open import foundation.transport-along-identifications using
+  ( tr -- "transport"
+  )
+open import foundation.action-on-identifications-dependent-functions using
+  ( apd -- "dependent functions respect paths"
+  )
+open import foundation.truncated-types using
+  ( is-trunc -- "`n`-truncated types"
+  )
+open import foundation.truncations using
+  ( trunc -- "the `n`-truncation of a type"
+  ; unit-trunc -- "the unit map into a type's `n`-truncation"
+  ; is-truncation-trunc -- "precomposing by the unit is an equivalence"
+  )
+open import foundation.connected-types using
+  ( is-connected -- "`n`-connected types"
+  )
+open import foundation.truncated-maps using
+  ( is-trunc-map -- "`n`-truncated functions"
+  )
+open import foundation.connected-maps using
+  ( is-connected-map -- "`n`-connected functions"
+  )
 ```
 
-Definition 3.2: Sequential colimits and their induction and recursion
-principles, given by the dependent and non-dependent universal properties,
-respectively. Our homotopies in the definitions of cocones go from left to
-right, instead of right to left.
+## 3 Sequences and Sequential Colimits
+
+The third section defines what one might call the (wild) category of sequences
+(which are called _sequential diagrams_ in agda-unimath) and the colimiting
+functor. It concludes by defining shifts of sequences, showing that they induce
+equivalences on sequential colimits, and defines lifts of elements in a
+sequential diagram.
+
+**Definition 3.1**: Sequences.
 
 ```agda
-import synthetic-homotopy-theory.sequential-colimits using
-  ( standard-sequential-colimit ;
-    map-cocone-standard-sequential-colimit ;
-    coherence-cocone-standard-sequential-colimit ;
-    dup-standard-sequential-colimit ;
-    up-standard-sequential-colimit)
+open import synthetic-homotopy-theory.sequential-diagrams using
+  ( sequential-diagram
+  )
 ```
 
-Lemma 3.3: Uniqueness property of the sequential colimit.
+**Definition 3.2**: Sequential colimits and their induction and recursion
+principles.
+
+Induction and recursion are given by the dependent and non-dependent universal
+properties, respectively. Since we work in a setting without computational
+higher inductive types, the maps induced by induction and recursion only compute
+up to a path, even on points. Our homotopies in the definitions of cocones go
+from left to right (i.e. `i‚Çô ~ i‚Çô‚Çä‚ÇÅ ‚àò a‚Çô`), instead of right to left.
+
+Our formalization works with sequential colimits specified by a cocone with a
+universal property, and results about the standard construction of colimits are
+obtained by specialization to the canonical cocone.
 
 ```agda
-import synthetic-homotopy-theory.sequential-colimits using
-  ( equiv-htpy-htpy-out-of-standard-sequential-colimit ;
-    htpy-htpy-out-of-standard-sequential-colimit)
+open import synthetic-homotopy-theory.sequential-colimits using
+  ( standard-sequential-colimit -- the canonical colimit type
+  ; map-cocone-standard-sequential-colimit -- "the canonical injection"
+  ; coherence-cocone-standard-sequential-colimit -- "the glue"
+  ; dup-standard-sequential-colimit -- "the induction principle"
+  ; up-standard-sequential-colimit -- "the recursion principle"
+  )
 ```
 
-Definition 3.4: Natural transformations and natural equivalences between
-sequential diagrams. We call natural transformations _morphisms of sequential
-diagrams_.
+**Lemma 3.3**: Uniqueness property of the sequential colimit.
+
+The data of a homotopy between two functions out of the standard sequential
+colimit is specified by the type `htpy-out-of-standard-sequential-colimit`,
+which we can then turn into a proper homotopy.
 
 ```agda
-import synthetic-homotopy-theory.morphisms-sequential-diagrams using
-  ( hom-sequential-diagram ;
-    id-hom-sequential-diagram ;
-    comp-hom-sequential-diagram)
-import synthetic-homotopy-theory.equivalences-sequential-diagrams using
-  ( equiv-sequential-diagram)
+open import synthetic-homotopy-theory.sequential-colimits using
+  ( htpy-out-of-standard-sequential-colimit -- data of a homotopy
+  ; htpy-htpy-out-of-standard-sequential-colimit -- "data of a homotopy induces a homotopy"
+  )
 ```
 
-Lemma 3.5: Functoriality of the Sequential Colimit.
+**Definition 3.4**: Natural transformations and natural equivalences between
+sequential diagrams.
+
+We call natural transformations _morphisms of sequential diagrams_, and natural
+equivalences _equivalences of sequential diagrams_.
 
 ```agda
-import synthetic-homotopy-theory.functoriality-sequential-colimits using
-  ( map-hom-standard-sequential-colimit ; -- 1)
-    preserves-id-map-hom-standard-sequential-colimit ; -- 2
-    preserves-comp-map-hom-standard-sequential-colimit ; -- 3
-    htpy-map-hom-standard-sequential-colimit-htpy-hom-sequential-diagram ; -- 4
-    equiv-equiv-standard-sequential-colimit) -- 5
+open import synthetic-homotopy-theory.morphisms-sequential-diagrams using
+  ( hom-sequential-diagram -- "natural transformation"
+  ; id-hom-sequential-diagram -- "identity natural transformation"
+  ; comp-hom-sequential-diagram -- "composition of natural transformations"
+  )
+open import synthetic-homotopy-theory.equivalences-sequential-diagrams using
+  ( equiv-sequential-diagram -- "natural equivalence"
+  )
 ```
 
-Lemma 3.6: Dropping a head of a sequential diagram preserves the sequential
-colimit.
+**Lemma 3.5**: Functoriality of the Sequential Colimit.
 
 ```agda
-import synthetic-homotopy-theory.shifts-sequential-diagrams using
-  ( up-cocone-shift-sequential-diagram ;
-    compute-sequential-colimit-shift-sequential-diagram) -- apply to 1
+open import synthetic-homotopy-theory.functoriality-sequential-colimits using
+  ( map-hom-standard-sequential-colimit -- "a natural transformation induces a map"
+  ; preserves-id-map-hom-standard-sequential-colimit -- "1‚àû ~ id(A‚àû)"
+  ; preserves-comp-map-hom-standard-sequential-colimit -- "(œÉ ‚àò œÑ)‚àû ~ œÉ‚àû ‚àò œÑ‚àû"
+  ; htpy-map-hom-standard-sequential-colimit-htpy-hom-sequential-diagram -- "homotopy of natural transformations induces a homotopy"
+  ; equiv-equiv-standard-sequential-colimit -- "if œÑ is an equivalence, then œÑ‚àû is an equivalence"
+  )
 ```
 
-Lemma 3.7: Dropping finitely many objects from the head of a sequential diagram
-preserves the sequential colimit.
+**Lemma 3.6**: Dropping a head of a sequential diagram preserves the sequential
+colimit.
+
+**Lemma 3.7**: Dropping finitely many vertices from the beginning of a
+sequential diagram preserves the sequential colimit.
+
+Denoting by `A[k]` the sequence `A` with the first `k` vertices removed, we show
+that the type of cocones under `A[k]` is equivalent to the type of cocones under
+`A`, and conclude that any sequential colimit of `A[k]` also has the universal
+property of a colimit of `A`. Specializing to the standard sequential colimit,
+we get and equivalence `A[k]‚àû ‚âÉ A‚àû`.
 
 ```agda
-import synthetic-homotopy-theory.shifts-sequential-diagrams using
-  ( compute-sequential-colimit-shift-sequential-diagram)
+open import synthetic-homotopy-theory.shifts-sequential-diagrams using
+  ( compute-sequential-colimit-shift-sequential-diagram -- "A[k]‚àû ‚âÉ A‚àû"
+  )
+compute-sequential-colimit-shift-sequential-diagram-once =
+  Œª l (A : sequential-diagram l) ‚Üí
+    compute-sequential-colimit-shift-sequential-diagram A 1
 ```
 
-Liftings?
+## 4 Fibered Sequences
 
-## 4. Fibered Sequences
+The fourth section defines fibered sequences, which we call _dependenct
+sequential diagrams_ in the library. It introduces the "Œ£ of a sequence", which
+we call the _total sequential diagram_, and asks the main question about the
+interplay between Œ£ and taking the colimit.
 
-Definition 4.1: Fibered sequences. In agda-unimath, a "sequence fibered over a
-sequence (A, a)" is called a "dependent sequential diagram over (A, a)", and it
-is defined in its curried form: instead of `B : Œ£ (n : ‚Ñï) A(n) ‚Üí ùí∞`, we use
-`B : (n : N) ‚Üí A(n) ‚Üí ùí∞`.
+The paper defines fibered sequences as a family over the total space
+`B : Œ£ ‚Ñï A ‚Üí ùí∞`, but we use the curried definition `B : (n : ‚Ñï) ‚Üí A(n) ‚Üí ùí∞`.
+
+**Definition 4.1**: Fibered sequences. Equifibered sequences.
 
 ```agda
-import synthetic-homotopy-theory.dependent-sequential-diagrams using
-  ( dependent-sequential-diagram)
-  -- TODO?: equifibered sequences
+open import synthetic-homotopy-theory.dependent-sequential-diagrams using
+  ( dependent-sequential-diagram -- "A sequence (B, b) fibered over (A, a)"
+  )
 ```
 
-Lemma 4.2: The descent property of sequential colimits
+**Lemma 4.2**: The type of families over a colimit is equivalent to the type of
+equifibered sequences.
+
+This property is also called the _descent property of sequential colimits_,
+because it characterizes families over a sequential colimit.
 
 ```agda
 -- TODO
 ```
 
-Definition 4.3: Total sequential diagram of a dependent sequential diagram.
+**Definition 4.3**: Œ£ of a fibered sequence.
 
 ```agda
-import synthetic-homotopy-theory.total-sequential-diagrams using
-  ( total-sequential-diagram ;
-    pr1-total-sequential-diagram)
+open import synthetic-homotopy-theory.total-sequential-diagrams using
+  ( total-sequential-diagram -- "Œ£ (A, a) (B, b)"
+  ; pr1-total-sequential-diagram -- "the canonical projection"
+  )
 ```
 
-TODO: Decide how to treat (C‚àû, c‚àû).
+TODO: (C‚àû, c‚àû).
 
-## 5. Colimits and Sums
+## 5 Colimits and Sums
 
-Theorem 5.1: Interaction between `colim` and `Œ£`.
+**Theorem 5.1**: Interaction between `colim` and `Œ£`.
 
 ```agda
 -- TODO
 ```
 
-## 6. Induction on the Sum of Sequential Colimits
+## 6 Induction on the Sum of Sequential Colimits
 
--- The induction principle for a sum of sequential colimits follows from the
+```agda
+-- TODO
+```
 
-## 7. Applications of the Main Theorem
+## 7 Applications of the Main Theorem
 
-Lemma 7.1: TODO description
+**Lemma 7.1**: TODO description.
 
 ```agda
 -- TODO
 ```
 
-Lemma 7.2: Colimit of the terminal sequential diagram is contractible
+**Lemma 7.2**: Colimit of the terminal sequential diagram is contractible.
 
 ```agda
 -- TODO
 ```
 
-Lemma 7.3: Encode-decode. This principle is called the _Fundamental theorem of
-identity types_ in the library.
+**Lemma 7.3**: Encode-decode.
+
+This principle is called the _Fundamental theorem of identity types_ in the
+library.
 
 ```agda
-import foundation.fundamental-theorem-of-identity-types using
+open import foundation.fundamental-theorem-of-identity-types using
   ( fundamental-theorem-id)
 ```
 
-Lemma 7.4: Characterization of path spaces of images of the canonical maps into
-the sequential colimit.
+**Lemma 7.4**: Characterization of path spaces of images of the canonical maps
+into the sequential colimit.
 
 ```agda
 -- TODO
 ```
 
-Corollary 7.5: The loop space of a sequential colimit is the sequential colimit
-of loop spaces.
+**Corollary 7.5**: The loop space of a sequential colimit is the sequential
+colimit of loop spaces.
 
 ```agda
 -- TODO
 ```
 
-Corollary 7.6: For a morphism of sequential diagrams, the fibers of the induced
-map between sequential colimits are characterized as sequential colimits of the
-fibers.
+**Corollary 7.6**: For a morphism of sequential diagrams, the fibers of the
+induced map between sequential colimits are characterized as sequential colimits
+of the fibers.
 
 ```agda
 -- TODO
 ```
 
-Corollary 7.7.1: If each type in a sequential diagram is `k`-truncated, then the
-colimit is `k`-truncated.
+**Corollary 7.7.1**: If each type in a sequential diagram is `k`-truncated, then
+the colimit is `k`-truncated.
 
 ```agda
 -- TODO
 ```
 
-Corollary 7.7.2: The `k`-truncation of a sequential colimit is the sequential
-colimit of `k`-truncations.
+**Corollary 7.7.2**: The `k`-truncation of a sequential colimit is the
+sequential colimit of `k`-truncations.
 
 ```agda
 -- TODO
 ```
 
-Corollary 7.7.3: If each type in a sequential diagram is `k`-connected, then the
-colimit is `k`-connected.
+**Corollary 7.7.3**: If each type in a sequential diagram is `k`-connected, then
+the colimit is `k`-connected.
 
 ```agda
 -- TODO
 ```
 
-Corollary 7.7.4: If each component of a morphism between sequential diagrams is
-`k`-truncated/`k`-connected, then the induced map of sequential colimits is
+**Corollary 7.7.4**: If each component of a morphism between sequential diagrams
+is `k`-truncated/`k`-connected, then the induced map of sequential colimits is
 `k`-truncated/`k`-connected.
 
 ```agda
 -- TODO
 ```
 
-Corollary 7.7.5: If each map in a sequential diagram is
+**Corollary 7.7.5**: If each map in a sequential diagram is
 `k`-truncated/`k`-connected, then the first injection into the colimit is
 `k`-truncated/`k`-connected.
 

From 72a7749d90b16c6d6c07e0346729a526554fbb89 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 22 Mar 2024 14:17:22 +0100
Subject: [PATCH 09/14] Prose, links

---
 src/papers/SDR20.lagda.md                     | 53 +++++++++----------
 ...cocones-under-sequential-diagrams.lagda.md |  7 +--
 .../total-sequential-diagrams.lagda.md        | 14 +++--
 3 files changed, 39 insertions(+), 35 deletions(-)

diff --git a/src/papers/SDR20.lagda.md b/src/papers/SDR20.lagda.md
index 0706a00141..d7d3006fc8 100644
--- a/src/papers/SDR20.lagda.md
+++ b/src/papers/SDR20.lagda.md
@@ -69,13 +69,12 @@ open import foundation.connected-maps using
 
 ## 3 Sequences and Sequential Colimits
 
-The third section defines what one might call the (wild) category of sequences
-(which are called _sequential diagrams_ in agda-unimath) and the colimiting
-functor. It concludes by defining shifts of sequences, showing that they induce
-equivalences on sequential colimits, and defines lifts of elements in a
-sequential diagram.
+The third section defines categorical properties of sequences (which are called
+_sequential diagrams_ in agda-unimath) and the colimiting functor. It concludes
+by defining shifts of sequences, showing that they induce equivalences on
+sequential colimits, and defines lifts of elements in a sequential diagram.
 
-**Definition 3.1**: Sequences.
+**Definition 3.1.** Sequences.
 
 ```agda
 open import synthetic-homotopy-theory.sequential-diagrams using
@@ -83,7 +82,7 @@ open import synthetic-homotopy-theory.sequential-diagrams using
   )
 ```
 
-**Definition 3.2**: Sequential colimits and their induction and recursion
+**Definition 3.2.** Sequential colimits and their induction and recursion
 principles.
 
 Induction and recursion are given by the dependent and non-dependent universal
@@ -106,7 +105,7 @@ open import synthetic-homotopy-theory.sequential-colimits using
   )
 ```
 
-**Lemma 3.3**: Uniqueness property of the sequential colimit.
+**Lemma 3.3.** Uniqueness property of the sequential colimit.
 
 The data of a homotopy between two functions out of the standard sequential
 colimit is specified by the type `htpy-out-of-standard-sequential-colimit`,
@@ -119,7 +118,7 @@ open import synthetic-homotopy-theory.sequential-colimits using
   )
 ```
 
-**Definition 3.4**: Natural transformations and natural equivalences between
+**Definition 3.4.** Natural transformations and natural equivalences between
 sequential diagrams.
 
 We call natural transformations _morphisms of sequential diagrams_, and natural
@@ -136,7 +135,7 @@ open import synthetic-homotopy-theory.equivalences-sequential-diagrams using
   )
 ```
 
-**Lemma 3.5**: Functoriality of the Sequential Colimit.
+**Lemma 3.5.** Functoriality of the Sequential Colimit.
 
 ```agda
 open import synthetic-homotopy-theory.functoriality-sequential-colimits using
@@ -148,10 +147,10 @@ open import synthetic-homotopy-theory.functoriality-sequential-colimits using
   )
 ```
 
-**Lemma 3.6**: Dropping a head of a sequential diagram preserves the sequential
+**Lemma 3.6.** Dropping a head of a sequential diagram preserves the sequential
 colimit.
 
-**Lemma 3.7**: Dropping finitely many vertices from the beginning of a
+**Lemma 3.7.** Dropping finitely many vertices from the beginning of a
 sequential diagram preserves the sequential colimit.
 
 Denoting by `A[k]` the sequence `A` with the first `k` vertices removed, we show
@@ -179,7 +178,7 @@ interplay between Œ£ and taking the colimit.
 The paper defines fibered sequences as a family over the total space
 `B : Œ£ ‚Ñï A ‚Üí ùí∞`, but we use the curried definition `B : (n : ‚Ñï) ‚Üí A(n) ‚Üí ùí∞`.
 
-**Definition 4.1**: Fibered sequences. Equifibered sequences.
+**Definition 4.1.** Fibered sequences. Equifibered sequences.
 
 ```agda
 open import synthetic-homotopy-theory.dependent-sequential-diagrams using
@@ -187,7 +186,7 @@ open import synthetic-homotopy-theory.dependent-sequential-diagrams using
   )
 ```
 
-**Lemma 4.2**: The type of families over a colimit is equivalent to the type of
+**Lemma 4.2.** The type of families over a colimit is equivalent to the type of
 equifibered sequences.
 
 This property is also called the _descent property of sequential colimits_,
@@ -197,7 +196,7 @@ because it characterizes families over a sequential colimit.
 -- TODO
 ```
 
-**Definition 4.3**: Œ£ of a fibered sequence.
+**Definition 4.3.** Œ£ of a fibered sequence.
 
 ```agda
 open import synthetic-homotopy-theory.total-sequential-diagrams using
@@ -210,7 +209,7 @@ TODO: (C‚àû, c‚àû).
 
 ## 5 Colimits and Sums
 
-**Theorem 5.1**: Interaction between `colim` and `Œ£`.
+**Theorem 5.1.** Interaction between `colim` and `Œ£`.
 
 ```agda
 -- TODO
@@ -224,19 +223,19 @@ TODO: (C‚àû, c‚àû).
 
 ## 7 Applications of the Main Theorem
 
-**Lemma 7.1**: TODO description.
+**Lemma 7.1.** TODO description.
 
 ```agda
 -- TODO
 ```
 
-**Lemma 7.2**: Colimit of the terminal sequential diagram is contractible.
+**Lemma 7.2.** Colimit of the terminal sequential diagram is contractible.
 
 ```agda
 -- TODO
 ```
 
-**Lemma 7.3**: Encode-decode.
+**Lemma 7.3.** Encode-decode.
 
 This principle is called the _Fundamental theorem of identity types_ in the
 library.
@@ -246,21 +245,21 @@ open import foundation.fundamental-theorem-of-identity-types using
   ( fundamental-theorem-id)
 ```
 
-**Lemma 7.4**: Characterization of path spaces of images of the canonical maps
+**Lemma 7.4.** Characterization of path spaces of images of the canonical maps
 into the sequential colimit.
 
 ```agda
 -- TODO
 ```
 
-**Corollary 7.5**: The loop space of a sequential colimit is the sequential
+**Corollary 7.5.** The loop space of a sequential colimit is the sequential
 colimit of loop spaces.
 
 ```agda
 -- TODO
 ```
 
-**Corollary 7.6**: For a morphism of sequential diagrams, the fibers of the
+**Corollary 7.6.** For a morphism of sequential diagrams, the fibers of the
 induced map between sequential colimits are characterized as sequential colimits
 of the fibers.
 
@@ -268,28 +267,28 @@ of the fibers.
 -- TODO
 ```
 
-**Corollary 7.7.1**: If each type in a sequential diagram is `k`-truncated, then
+**Corollary 7.7.1.** If each type in a sequential diagram is `k`-truncated, then
 the colimit is `k`-truncated.
 
 ```agda
 -- TODO
 ```
 
-**Corollary 7.7.2**: The `k`-truncation of a sequential colimit is the
+**Corollary 7.7.2.** The `k`-truncation of a sequential colimit is the
 sequential colimit of `k`-truncations.
 
 ```agda
 -- TODO
 ```
 
-**Corollary 7.7.3**: If each type in a sequential diagram is `k`-connected, then
+**Corollary 7.7.3.** If each type in a sequential diagram is `k`-connected, then
 the colimit is `k`-connected.
 
 ```agda
 -- TODO
 ```
 
-**Corollary 7.7.4**: If each component of a morphism between sequential diagrams
+**Corollary 7.7.4.** If each component of a morphism between sequential diagrams
 is `k`-truncated/`k`-connected, then the induced map of sequential colimits is
 `k`-truncated/`k`-connected.
 
@@ -297,7 +296,7 @@ is `k`-truncated/`k`-connected, then the induced map of sequential colimits is
 -- TODO
 ```
 
-**Corollary 7.7.5**: If each map in a sequential diagram is
+**Corollary 7.7.5.** If each map in a sequential diagram is
 `k`-truncated/`k`-connected, then the first injection into the colimit is
 `k`-truncated/`k`-connected.
 
diff --git a/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md
index fae7b5e423..92c9f2b7f7 100644
--- a/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md
@@ -35,9 +35,10 @@ open import synthetic-homotopy-theory.sequential-diagrams
 
 ## Idea
 
-A **cocone under a
-[sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md)
-`(A, a)`** with codomain `X : ùí∞` consists of a family of maps `i‚Çô : A n ‚Üí C` and
+A
+{{#concept "cocone" Disambiguation="sequential diagram" Agda=cocone-sequential-diagram}}
+under a [sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md)
+`(A, a)` with codomain `X : ùí∞` consists of a family of maps `i‚Çô : A n ‚Üí C` and
 a family of [homotopies](foundation.homotopies.md) `H‚Çô` asserting that the
 triangles
 
diff --git a/src/synthetic-homotopy-theory/total-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/total-sequential-diagrams.lagda.md
index 03d997f681..ffd1a3935d 100644
--- a/src/synthetic-homotopy-theory/total-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/total-sequential-diagrams.lagda.md
@@ -1,4 +1,4 @@
-# Total diagrams of dependent sequential diagrams
+# Total sequential diagrams of dependent sequential diagrams
 
 ```agda
 module synthetic-homotopy-theory.total-sequential-diagrams where
@@ -27,13 +27,17 @@ open import synthetic-homotopy-theory.universal-property-sequential-colimits
 
 ## Idea
 
-The {{#concept "total diagram" Disambiguation="dependent sequential diagrams"}}
-of a dependent sequential diagram `B : (A, a) ‚Üí ùí∞` is the sequential diagram
-consisting of total spaces `Œ£ A‚Çô B‚Çô`.
+The
+{{#concept "total diagram" Disambiguation="dependent sequential diagrams" Agda=total-sequential-diagram}}
+of a
+[dependent sequential diagram](synthetic-homotopy-theory.dependent-sequential-diagrams.md)
+`B : (A, a) ‚Üí ùí∞` is the
+[sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md)
+consisting of [total spaces](foundation.dependent-pair-types.md) `Œ£ A‚Çô B‚Çô`.
 
 ## Definitions
 
-### Total sequential diagram of a dependent sequential diagram
+### The total sequential diagram of a dependent sequential diagram
 
 ```agda
 module _

From 08b094d20a488cda69ef2bff5f67432e0b927d29 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 22 Mar 2024 14:55:35 +0100
Subject: [PATCH 10/14] Names and diagrams

---
 src/papers/SDR20.lagda.md                     |   6 +-
 .../shifts-sequential-diagrams.lagda.md       | 234 +++++++++---------
 2 files changed, 121 insertions(+), 119 deletions(-)

diff --git a/src/papers/SDR20.lagda.md b/src/papers/SDR20.lagda.md
index d7d3006fc8..1959e95bf0 100644
--- a/src/papers/SDR20.lagda.md
+++ b/src/papers/SDR20.lagda.md
@@ -205,7 +205,11 @@ open import synthetic-homotopy-theory.total-sequential-diagrams using
   )
 ```
 
-TODO: (C‚àû, c‚àû).
+**Construction.** The equifibered family associated to a fibered sequence.
+
+```agda
+-- TODO
+```
 
 ## 5 Colimits and Sums
 
diff --git a/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
index f17c42b843..994a64b1cd 100644
--- a/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
@@ -95,9 +95,9 @@ module _
   {l1 : Level} (A : sequential-diagram l1)
   where
 
-  shift-sequential-diagram-once : sequential-diagram l1
-  pr1 shift-sequential-diagram-once n = family-sequential-diagram A (succ-‚Ñï n)
-  pr2 shift-sequential-diagram-once n = map-sequential-diagram A (succ-‚Ñï n)
+  shift-once-sequential-diagram : sequential-diagram l1
+  pr1 shift-once-sequential-diagram n = family-sequential-diagram A (succ-‚Ñï n)
+  pr2 shift-once-sequential-diagram n = map-sequential-diagram A (succ-‚Ñï n)
 
 module _
   {l1 : Level}
@@ -106,7 +106,7 @@ module _
   shift-sequential-diagram : ‚Ñï ‚Üí sequential-diagram l1 ‚Üí sequential-diagram l1
   shift-sequential-diagram zero-‚Ñï A = A
   shift-sequential-diagram (succ-‚Ñï k) A =
-    shift-sequential-diagram-once (shift-sequential-diagram k A)
+    shift-once-sequential-diagram (shift-sequential-diagram k A)
 ```
 
 ### Shifts of morphisms of sequential diagrams
@@ -118,7 +118,7 @@ Given a morphism of sequential diagrams `f : A ‚Üí B`
     A‚ÇÄ ---> A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
     |       |       |
  f‚ÇÄ |       | f‚ÇÅ    | f‚ÇÇ
-    v       v       v
+    ‚à®       ‚à®       ‚à®
     B‚ÇÄ ---> B‚ÇÅ ---> B‚ÇÇ ---> ‚ãØ ,
         b‚ÇÄ      b‚ÇÅ
 ```
@@ -130,7 +130,7 @@ we can drop the first square to get the morphism
     A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
     |       |
  f‚ÇÅ |       | f‚ÇÇ
-    v       v
+    ‚à®       ‚à®
     B‚ÇÅ ---> B‚ÇÇ ---> ‚ãØ ,
         b‚ÇÅ
 ```
@@ -143,13 +143,13 @@ module _
   (f : hom-sequential-diagram A B)
   where
 
-  shift-hom-sequential-diagram-once :
+  shift-once-hom-sequential-diagram :
     hom-sequential-diagram
-      ( shift-sequential-diagram-once A)
-      ( shift-sequential-diagram-once B)
-  pr1 shift-hom-sequential-diagram-once n =
+      ( shift-once-sequential-diagram A)
+      ( shift-once-sequential-diagram B)
+  pr1 shift-once-hom-sequential-diagram n =
     map-hom-sequential-diagram B f (succ-‚Ñï n)
-  pr2 shift-hom-sequential-diagram-once n =
+  pr2 shift-once-hom-sequential-diagram n =
     naturality-map-hom-sequential-diagram B f (succ-‚Ñï n)
 
 module _
@@ -164,7 +164,7 @@ module _
       ( shift-sequential-diagram k B)
   shift-hom-sequential-diagram zero-‚Ñï f = f
   shift-hom-sequential-diagram (succ-‚Ñï k) f =
-    shift-hom-sequential-diagram-once
+    shift-once-hom-sequential-diagram
       ( shift-sequential-diagram k B)
       ( shift-hom-sequential-diagram k f)
 ```
@@ -180,7 +180,7 @@ Given a cocone `c`
     \     |     /
   i‚ÇÄ \    | i‚ÇÅ / i‚ÇÇ
       \   |   /
-       V  V  V
+       ‚à®  ‚à®  ‚à®
           X
 ```
 
@@ -193,7 +193,7 @@ under `A`, we may forget the first injection and homotopy to get the cocone
      |     /
   i‚ÇÅ |    / i‚ÇÇ
      |   /
-     V  V
+     ‚à®  ‚à®
      X
 ```
 
@@ -206,11 +206,11 @@ module _
   {X : UU l2} (c : cocone-sequential-diagram A X)
   where
 
-  shift-cocone-sequential-diagram-once :
-    cocone-sequential-diagram (shift-sequential-diagram-once A) X
-  pr1 shift-cocone-sequential-diagram-once n =
+  shift-once-cocone-sequential-diagram :
+    cocone-sequential-diagram (shift-once-sequential-diagram A) X
+  pr1 shift-once-cocone-sequential-diagram n =
     map-cocone-sequential-diagram c (succ-‚Ñï n)
-  pr2 shift-cocone-sequential-diagram-once n =
+  pr2 shift-once-cocone-sequential-diagram n =
     coherence-cocone-sequential-diagram c (succ-‚Ñï n)
 
 module _
@@ -225,7 +225,7 @@ module _
   shift-cocone-sequential-diagram zero-‚Ñï c =
     c
   shift-cocone-sequential-diagram (succ-‚Ñï k) c =
-    shift-cocone-sequential-diagram-once
+    shift-once-cocone-sequential-diagram
       ( shift-cocone-sequential-diagram k c)
 ```
 
@@ -240,7 +240,7 @@ Conversely, given a cocone `c`
      |     /
   i‚ÇÅ |    / i‚ÇÇ
      |   /
-     V  V
+     ‚à®  ‚à®
      X
 ```
 
@@ -253,7 +253,7 @@ under `A[1]`, we may prepend a map
          \     |     /
   i‚ÇÅ ‚àò a‚ÇÄ \    | i‚ÇÅ / i‚ÇÇ
            \   |   /
-            V  V  V
+            ‚à®  ‚à®  ‚à®
                X
 ```
 
@@ -274,18 +274,18 @@ then we can unshift by `k` to get `c[-1][-k]` under `A`.
 module _
   {l1 l2 : Level} (A : sequential-diagram l1)
   {X : UU l2}
-  (c : cocone-sequential-diagram (shift-sequential-diagram-once A) X)
+  (c : cocone-sequential-diagram (shift-once-sequential-diagram A) X)
   where
 
-  cocone-unshift-sequential-diagram-once :
+  unshift-once-cocone-sequential-diagram :
     cocone-sequential-diagram A X
-  pr1 cocone-unshift-sequential-diagram-once zero-‚Ñï =
+  pr1 unshift-once-cocone-sequential-diagram zero-‚Ñï =
     map-cocone-sequential-diagram c zero-‚Ñï ‚àò map-sequential-diagram A zero-‚Ñï
-  pr1 cocone-unshift-sequential-diagram-once (succ-‚Ñï n) =
+  pr1 unshift-once-cocone-sequential-diagram (succ-‚Ñï n) =
     map-cocone-sequential-diagram c n
-  pr2 cocone-unshift-sequential-diagram-once zero-‚Ñï =
+  pr2 unshift-once-cocone-sequential-diagram zero-‚Ñï =
     refl-htpy
-  pr2 cocone-unshift-sequential-diagram-once (succ-‚Ñï n) =
+  pr2 unshift-once-cocone-sequential-diagram (succ-‚Ñï n) =
     coherence-cocone-sequential-diagram c n
 
 module _
@@ -293,15 +293,15 @@ module _
   {X : UU l2}
   where
 
-  cocone-unshift-sequential-diagram :
+  unshift-cocone-sequential-diagram :
     (k : ‚Ñï) ‚Üí
     cocone-sequential-diagram (shift-sequential-diagram k A) X ‚Üí
     cocone-sequential-diagram A X
-  cocone-unshift-sequential-diagram zero-‚Ñï c =
+  unshift-cocone-sequential-diagram zero-‚Ñï c =
     c
-  cocone-unshift-sequential-diagram (succ-‚Ñï k) c =
-    cocone-unshift-sequential-diagram k
-      ( cocone-unshift-sequential-diagram-once
+  unshift-cocone-sequential-diagram (succ-‚Ñï k) c =
+    unshift-cocone-sequential-diagram k
+      ( unshift-once-cocone-sequential-diagram
         ( shift-sequential-diagram k A)
         ( c))
 ```
@@ -320,13 +320,13 @@ module _
   (H : htpy-cocone-sequential-diagram c c')
   where
 
-  shift-htpy-cocone-sequential-diagram-once :
+  shift-once-htpy-cocone-sequential-diagram :
     htpy-cocone-sequential-diagram
-      ( shift-cocone-sequential-diagram-once c)
-      ( shift-cocone-sequential-diagram-once c')
-  pr1 shift-htpy-cocone-sequential-diagram-once n =
+      ( shift-once-cocone-sequential-diagram c)
+      ( shift-once-cocone-sequential-diagram c')
+  pr1 shift-once-htpy-cocone-sequential-diagram n =
     htpy-htpy-cocone-sequential-diagram H (succ-‚Ñï n)
-  pr2 shift-htpy-cocone-sequential-diagram-once n =
+  pr2 shift-once-htpy-cocone-sequential-diagram n =
     coherence-htpy-htpy-cocone-sequential-diagram
       ( H)
       ( succ-‚Ñï n)
@@ -345,7 +345,7 @@ module _
   shift-htpy-cocone-sequential-diagram zero-‚Ñï H =
     H
   shift-htpy-cocone-sequential-diagram (succ-‚Ñï k) H =
-    shift-htpy-cocone-sequential-diagram-once
+    shift-once-htpy-cocone-sequential-diagram
       ( shift-htpy-cocone-sequential-diagram k H)
 ```
 
@@ -362,7 +362,7 @@ coherence to unshift a homotopy of cocones. Given two cocones `c`, `c'` under
      |     /                |     /
   i‚ÇÅ |    / i‚ÇÇ     ~    i'‚ÇÅ |    / i'‚ÇÇ
      |   /                  |   /
-     V  V                   V  V
+     ‚à®  ‚à®                   ‚à®  ‚à®
      X                      X
 ```
 
@@ -374,22 +374,22 @@ Inductively, we define `H[-(k + 1)] ‚âê H[-1][-k]`.
 ```agda
 module _
   {l1 l2 : Level} {A : sequential-diagram l1} {X : UU l2}
-  {c c' : cocone-sequential-diagram (shift-sequential-diagram-once A) X}
+  {c c' : cocone-sequential-diagram (shift-once-sequential-diagram A) X}
   (H : htpy-cocone-sequential-diagram c c')
   where
 
-  unshift-htpy-cocone-sequential-diagram-once :
+  unshift-once-htpy-cocone-sequential-diagram :
     htpy-cocone-sequential-diagram
-      ( cocone-unshift-sequential-diagram-once A c)
-      ( cocone-unshift-sequential-diagram-once A c')
-  pr1 unshift-htpy-cocone-sequential-diagram-once zero-‚Ñï =
+      ( unshift-once-cocone-sequential-diagram A c)
+      ( unshift-once-cocone-sequential-diagram A c')
+  pr1 unshift-once-htpy-cocone-sequential-diagram zero-‚Ñï =
     ( htpy-htpy-cocone-sequential-diagram H zero-‚Ñï) ¬∑r
     ( map-sequential-diagram A zero-‚Ñï)
-  pr1 unshift-htpy-cocone-sequential-diagram-once (succ-‚Ñï n) =
+  pr1 unshift-once-htpy-cocone-sequential-diagram (succ-‚Ñï n) =
     htpy-htpy-cocone-sequential-diagram H n
-  pr2 unshift-htpy-cocone-sequential-diagram-once zero-‚Ñï =
+  pr2 unshift-once-htpy-cocone-sequential-diagram zero-‚Ñï =
     inv-htpy-right-unit-htpy
-  pr2 unshift-htpy-cocone-sequential-diagram-once (succ-‚Ñï n) =
+  pr2 unshift-once-htpy-cocone-sequential-diagram (succ-‚Ñï n) =
     coherence-htpy-htpy-cocone-sequential-diagram H n
 
 module _
@@ -401,13 +401,13 @@ module _
     {c c' : cocone-sequential-diagram (shift-sequential-diagram k A) X} ‚Üí
     htpy-cocone-sequential-diagram c c' ‚Üí
     htpy-cocone-sequential-diagram
-      ( cocone-unshift-sequential-diagram A k c)
-      ( cocone-unshift-sequential-diagram A k c')
+      ( unshift-cocone-sequential-diagram A k c)
+      ( unshift-cocone-sequential-diagram A k c')
   unshift-htpy-cocone-sequential-diagram zero-‚Ñï H =
     H
   unshift-htpy-cocone-sequential-diagram (succ-‚Ñï k) H =
     unshift-htpy-cocone-sequential-diagram k
-      (unshift-htpy-cocone-sequential-diagram-once H)
+      (unshift-once-htpy-cocone-sequential-diagram H)
 ```
 
 ### Morphisms from sequential diagrams into their shifts
@@ -419,7 +419,7 @@ The morphism is obtained by observing that the squares in the diagram
     A‚ÇÄ ---> A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
     |       |       |
  a‚ÇÄ |       | a‚ÇÅ    | a‚ÇÇ
-    v       v       v
+    ‚à®       ‚à®       ‚à®
     A‚ÇÅ ---> A‚ÇÇ ---> A‚ÇÉ ---> ‚ãØ
         a‚ÇÅ      a‚ÇÇ
 ```
@@ -431,12 +431,12 @@ module _
   {l1 : Level} (A : sequential-diagram l1)
   where
 
-  hom-shift-sequential-diagram-once :
+  hom-shift-once-sequential-diagram :
     hom-sequential-diagram
       ( A)
-      ( shift-sequential-diagram-once A)
-  pr1 hom-shift-sequential-diagram-once = map-sequential-diagram A
-  pr2 hom-shift-sequential-diagram-once n = refl-htpy
+      ( shift-once-sequential-diagram A)
+  pr1 hom-shift-once-sequential-diagram = map-sequential-diagram A
+  pr2 hom-shift-once-sequential-diagram n = refl-htpy
 
 module _
   {l1 : Level} (A : sequential-diagram l1)
@@ -453,7 +453,7 @@ module _
       ( A)
       ( shift-sequential-diagram k A)
       ( shift-sequential-diagram (succ-‚Ñï k) A)
-      ( hom-shift-sequential-diagram-once
+      ( hom-shift-once-sequential-diagram
         ( shift-sequential-diagram k A))
       ( hom-shift-sequential-diagram k)
 ```
@@ -478,47 +478,47 @@ module _
   {X : UU l2}
   where
 
-  htpy-is-section-cocone-unshift-sequential-diagram :
-    (c : cocone-sequential-diagram (shift-sequential-diagram-once A) X) ‚Üí
+  htpy-is-section-unshift-once-cocone-sequential-diagram :
+    (c : cocone-sequential-diagram (shift-once-sequential-diagram A) X) ‚Üí
     htpy-cocone-sequential-diagram
-      ( shift-cocone-sequential-diagram-once
-        ( cocone-unshift-sequential-diagram-once A c))
+      ( shift-once-cocone-sequential-diagram
+        ( unshift-once-cocone-sequential-diagram A c))
       ( c)
-  htpy-is-section-cocone-unshift-sequential-diagram c =
-    refl-htpy-cocone-sequential-diagram (shift-sequential-diagram-once A) c
+  htpy-is-section-unshift-once-cocone-sequential-diagram c =
+    refl-htpy-cocone-sequential-diagram (shift-once-sequential-diagram A) c
 
 module _
   {l1 l2 : Level} {A : sequential-diagram l1}
   {X : UU l2}
   where
 
-  htpy-is-section-cocone-unshift-sequential-diagram' :
+  htpy-is-section-unshift-cocone-sequential-diagram :
     (k : ‚Ñï) ‚Üí
     (c : cocone-sequential-diagram (shift-sequential-diagram k A) X) ‚Üí
     htpy-cocone-sequential-diagram
       ( shift-cocone-sequential-diagram k
-        ( cocone-unshift-sequential-diagram A k c))
+        ( unshift-cocone-sequential-diagram A k c))
       ( c)
-  htpy-is-section-cocone-unshift-sequential-diagram' zero-‚Ñï c =
+  htpy-is-section-unshift-cocone-sequential-diagram zero-‚Ñï c =
     refl-htpy-cocone-sequential-diagram A c
-  htpy-is-section-cocone-unshift-sequential-diagram' (succ-‚Ñï k) c =
-    shift-htpy-cocone-sequential-diagram-once
-      ( htpy-is-section-cocone-unshift-sequential-diagram' k
-        ( cocone-unshift-sequential-diagram-once
+  htpy-is-section-unshift-cocone-sequential-diagram (succ-‚Ñï k) c =
+    shift-once-htpy-cocone-sequential-diagram
+      ( htpy-is-section-unshift-cocone-sequential-diagram k
+        ( unshift-once-cocone-sequential-diagram
           ( shift-sequential-diagram k A)
           ( c)))
 
-  is-section-cocone-unshift-sequential-diagram :
+  is-section-unshift-cocone-sequential-diagram :
     (k : ‚Ñï) ‚Üí
     is-section
       ( shift-cocone-sequential-diagram k)
-      ( cocone-unshift-sequential-diagram A {X} k)
-  is-section-cocone-unshift-sequential-diagram k c =
+      ( unshift-cocone-sequential-diagram A {X} k)
+  is-section-unshift-cocone-sequential-diagram k c =
     eq-htpy-cocone-sequential-diagram
       ( shift-sequential-diagram k A)
       ( _)
       ( _)
-      ( htpy-is-section-cocone-unshift-sequential-diagram' k c)
+      ( htpy-is-section-unshift-cocone-sequential-diagram k c)
 ```
 
 For the other direction, we need to show that the synthesized data, namely the
@@ -539,19 +539,19 @@ module _
   {X : UU l2}
   where
 
-  inv-htpy-is-retraction-cocone-sequential-diagram :
+  inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram :
     (c : cocone-sequential-diagram A X) ‚Üí
     htpy-cocone-sequential-diagram
       ( c)
-      ( cocone-unshift-sequential-diagram-once A
-        ( shift-cocone-sequential-diagram-once c))
-  pr1 (inv-htpy-is-retraction-cocone-sequential-diagram c) zero-‚Ñï =
+      ( unshift-once-cocone-sequential-diagram A
+        ( shift-once-cocone-sequential-diagram c))
+  pr1 (inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram c) zero-‚Ñï =
     coherence-cocone-sequential-diagram c zero-‚Ñï
-  pr1 (inv-htpy-is-retraction-cocone-sequential-diagram c) (succ-‚Ñï n) =
+  pr1 (inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram c) (succ-‚Ñï n) =
     refl-htpy
-  pr2 (inv-htpy-is-retraction-cocone-sequential-diagram c) zero-‚Ñï =
+  pr2 (inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram c) zero-‚Ñï =
     refl-htpy
-  pr2 (inv-htpy-is-retraction-cocone-sequential-diagram c) (succ-‚Ñï n) =
+  pr2 (inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram c) (succ-‚Ñï n) =
     right-unit-htpy
 
 module _
@@ -559,33 +559,31 @@ module _
   {X : UU l2}
   where
 
-  inv-htpy-is-retraction-cocone-sequential-diagram' :
+  inv-htpy-is-retraction-unshift-cocone-sequential-diagram :
     (k : ‚Ñï) ‚Üí
     (c : cocone-sequential-diagram A X) ‚Üí
     htpy-cocone-sequential-diagram
       ( c)
-      ( cocone-unshift-sequential-diagram A k
+      ( unshift-cocone-sequential-diagram A k
         ( shift-cocone-sequential-diagram k c))
-  inv-htpy-is-retraction-cocone-sequential-diagram' zero-‚Ñï c =
+  inv-htpy-is-retraction-unshift-cocone-sequential-diagram zero-‚Ñï c =
     refl-htpy-cocone-sequential-diagram A c
-  inv-htpy-is-retraction-cocone-sequential-diagram' (succ-‚Ñï k) c =
+  inv-htpy-is-retraction-unshift-cocone-sequential-diagram (succ-‚Ñï k) c =
     concat-htpy-cocone-sequential-diagram
-      ( inv-htpy-is-retraction-cocone-sequential-diagram' k c)
+      ( inv-htpy-is-retraction-unshift-cocone-sequential-diagram k c)
       ( unshift-htpy-cocone-sequential-diagram k
-        ( inv-htpy-is-retraction-cocone-sequential-diagram
+        ( inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram
           ( shift-cocone-sequential-diagram k c)))
 
-  is-retraction-cocone-unshift-sequential-diagram :
+  is-retraction-unshift-cocone-sequential-diagram :
     (k : ‚Ñï) ‚Üí
     is-retraction
       ( shift-cocone-sequential-diagram k)
-      ( cocone-unshift-sequential-diagram A {X} k)
-  is-retraction-cocone-unshift-sequential-diagram k c =
-    inv (eq-htpy-cocone-sequential-diagram
-      ( A)
-      ( _)
-      ( _)
-      ( inv-htpy-is-retraction-cocone-sequential-diagram' k c))
+      ( unshift-cocone-sequential-diagram A {X} k)
+  is-retraction-unshift-cocone-sequential-diagram k c =
+    inv
+      ( eq-htpy-cocone-sequential-diagram A _ _
+        ( inv-htpy-is-retraction-unshift-cocone-sequential-diagram k c))
 
 module _
   {l1 l2 : Level} {A : sequential-diagram l1}
@@ -597,17 +595,17 @@ module _
     is-equiv (shift-cocone-sequential-diagram {X = X} k)
   is-equiv-shift-cocone-sequential-diagram k =
     is-equiv-is-invertible
-      ( cocone-unshift-sequential-diagram A k)
-      ( is-section-cocone-unshift-sequential-diagram k)
-      ( is-retraction-cocone-unshift-sequential-diagram k)
+      ( unshift-cocone-sequential-diagram A k)
+      ( is-section-unshift-cocone-sequential-diagram k)
+      ( is-retraction-unshift-cocone-sequential-diagram k)
 
-  equiv-cocone-shift-unshift-sequential-diagram :
+  equiv-shift-cocone-sequential-diagram :
     (k : ‚Ñï) ‚Üí
     cocone-sequential-diagram A X ‚âÉ
     cocone-sequential-diagram (shift-sequential-diagram k A) X
-  pr1 (equiv-cocone-shift-unshift-sequential-diagram k) =
+  pr1 (equiv-shift-cocone-sequential-diagram k) =
     shift-cocone-sequential-diagram k
-  pr2 (equiv-cocone-shift-unshift-sequential-diagram k) =
+  pr2 (equiv-shift-cocone-sequential-diagram k) =
     is-equiv-shift-cocone-sequential-diagram k
 ```
 
@@ -627,7 +625,7 @@ there is a commuting triangle
       X ‚Üí Y ------------> cocone A Y
             \           /
   cocone-map  \       /
-                V   V
+                ‚à®   ‚à®
              cocone A[1] Y.
 ```
 
@@ -639,12 +637,12 @@ Inductively, we compose this triangle in the following way
             \‚üç             |
              \ ‚üç           |
               \  ‚üç         |
-               \   ‚üç       V
+               \   ‚üç       ‚à®
                 \    > cocone A[k] Y
      cocone-map  \       /
                   \     /
                    \   /
-                    V V
+                    ‚à® ‚à®
              cocone A[k + 1] Y,
 ```
 
@@ -658,7 +656,7 @@ This gives us the commuting triangle
       X ‚Üí Y ------------> cocone A Y
             \     ‚âÉ     /
   cocone-map  \       / ‚âÉ
-                V   V
+                ‚à®   ‚à®
              cocone A[k] Y,
 ```
 
@@ -673,22 +671,22 @@ module _
   {X : UU l2} (c : cocone-sequential-diagram A X)
   where
 
-  triangle-cocone-map-shift-sequential-diagram-once :
+  triangle-cocone-map-shift-once-cocone-sequential-diagram :
     {l : Level} (Y : UU l) ‚Üí
     coherence-triangle-maps
       ( cocone-map-sequential-diagram
-        ( shift-cocone-sequential-diagram-once c)
+        ( shift-once-cocone-sequential-diagram c)
         { Y = Y})
-      ( shift-cocone-sequential-diagram-once)
+      ( shift-once-cocone-sequential-diagram)
       ( cocone-map-sequential-diagram c)
-  triangle-cocone-map-shift-sequential-diagram-once Y = refl-htpy
+  triangle-cocone-map-shift-once-cocone-sequential-diagram Y = refl-htpy
 
 module _
   {l1 l2 : Level} {A : sequential-diagram l1}
   {X : UU l2} (c : cocone-sequential-diagram A X)
   where
 
-  triangle-cocone-map-shift-sequential-diagram :
+  triangle-cocone-map-shift-cocone-sequential-diagram :
     (k : ‚Ñï) ‚Üí
     {l : Level} (Y : UU l) ‚Üí
     coherence-triangle-maps
@@ -696,31 +694,31 @@ module _
         ( shift-cocone-sequential-diagram k c))
       ( shift-cocone-sequential-diagram k)
       ( cocone-map-sequential-diagram c)
-  triangle-cocone-map-shift-sequential-diagram zero-‚Ñï Y =
+  triangle-cocone-map-shift-cocone-sequential-diagram zero-‚Ñï Y =
     refl-htpy
-  triangle-cocone-map-shift-sequential-diagram (succ-‚Ñï k) Y =
-    ( triangle-cocone-map-shift-sequential-diagram-once
+  triangle-cocone-map-shift-cocone-sequential-diagram (succ-‚Ñï k) Y =
+    ( triangle-cocone-map-shift-once-cocone-sequential-diagram
       ( shift-cocone-sequential-diagram k c)
       ( Y)) ‚àôh
-    ( ( shift-cocone-sequential-diagram-once) ¬∑l
-      ( triangle-cocone-map-shift-sequential-diagram k Y))
+    ( ( shift-once-cocone-sequential-diagram) ¬∑l
+      ( triangle-cocone-map-shift-cocone-sequential-diagram k Y))
 
 module _
   {l1 l2 : Level} {A : sequential-diagram l1}
   {X : UU l2} {c : cocone-sequential-diagram A X}
   where
 
-  up-cocone-shift-sequential-diagram :
+  up-shift-cocone-sequential-diagram :
     (k : ‚Ñï) ‚Üí
     universal-property-sequential-colimit c ‚Üí
     universal-property-sequential-colimit (shift-cocone-sequential-diagram k c)
-  up-cocone-shift-sequential-diagram k up-c Y =
+  up-shift-cocone-sequential-diagram k up-c Y =
     is-equiv-left-map-triangle
       ( cocone-map-sequential-diagram
         ( shift-cocone-sequential-diagram k c))
       ( shift-cocone-sequential-diagram k)
       ( cocone-map-sequential-diagram c)
-      ( triangle-cocone-map-shift-sequential-diagram c k Y)
+      ( triangle-cocone-map-shift-cocone-sequential-diagram c k Y)
       ( up-c Y)
       ( is-equiv-shift-cocone-sequential-diagram k)
 ```
@@ -744,5 +742,5 @@ module _
         ( cocone-standard-sequential-colimit A))
   pr2 (compute-sequential-colimit-shift-sequential-diagram k) =
     is-sequential-colimit-universal-property _
-      ( up-cocone-shift-sequential-diagram k up-standard-sequential-colimit)
+      ( up-shift-cocone-sequential-diagram k up-standard-sequential-colimit)
 ```

From 30841eea3d8b08deab2b7cd1441c7b98975c6170 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 22 Mar 2024 15:47:56 +0100
Subject: [PATCH 11/14] Links, prose

---
 .../shifts-sequential-diagrams.lagda.md       | 32 +++++++++++++------
 1 file changed, 22 insertions(+), 10 deletions(-)

diff --git a/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
index 994a64b1cd..45e2765b67 100644
--- a/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
@@ -35,8 +35,9 @@ A
 {{#concept "shift" Disambiguation="sequential diagram" Agda=shift-sequential-diagram}}
 of a [sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md) is a
 sequential diagram consisting of the types and maps shifted by one. It is also
-denoted `A[1]`. This shifting can be iterated for any natural number `k`; then
-the resulting sequential diagram is denoted `A[k]`.
+denoted `A[1]`. This shifting can be iterated for any
+[natural number](elementary-number-theory.natural-numbers.md) `k`; then the
+resulting sequential diagram is denoted `A[k]`.
 
 Similarly, a
 {{#concept "shift" Disambiguation="morphism of sequential diagrams" Agda=shift-hom-sequential-diagram}}
@@ -45,26 +46,33 @@ of a
 is a morphism from the shifted domain into the shifted codomain. In symbols,
 given a morphism `f : A ‚Üí B`, we have `f[k] : A[k] ‚Üí B[k]`.
 
-We also define shifts of cocones and homotopies of cocones, which can
-additionally be unshifted.
+We also define shifts of
+[cocones](synthetic-homotopy-theory.cocones-under-sequential-diagrams.md) and
+[homotopies of cocones](synthetic-homotopy-theory.cocones-under-sequential-diagrams.md),
+which can additionally be unshifted.
 
-Importantly the type of cocones under a sequential diagram is equivalent to the
-type of cocones under its shift, which implies that the sequential colimit of a
+Importantly the type of cocones under a sequential diagram is
+[equivalent](foundation-core.equivalences.md) to the type of cocones under its
+shift, which implies that the
+[sequential colimit](synthetic-homotopy-theory.sequential-colimits.md) of a
 shifted sequential diagram is equivalent to the colimit of the original diagram.
 
 ## Definitions
 
 _Implementation note_: the constructions are defined by first defining a shift
 by one, and then recursively shifting by one according to the argument. An
-alternative would be to shift all data using addition on the natural numbers.
+alternative would be to shift all data using
+[addition](elementary-number-theory.addition-natural-numbers.md) on the natural
+numbers.
 
 However, addition computes only on one side, so we have a choice to make: given
 a shift `k`, do we define the `n`-th level of the shifted structure to be
-`n+k`-th or `k+n`-th level of the original?
+the `n+k`-th or `k+n`-th level of the original?
 
 The former runs into issues already when defining the shifted sequence, since
-`a‚Çô‚Çä‚Çñ : A‚Çô‚Çä‚Çñ ‚Üí A‚Çç‚Çô‚Çä‚ÇÅ‚Çé`, but we need a map of type `A‚Çô‚Çä‚Çñ ‚Üí A‚Çç‚Çô‚Çä‚Çñ‚Çé‚Çä‚ÇÅ`, which
-forces us to introduce a transport.
+`a‚Çô‚Çä‚Çñ : A‚Çô‚Çä‚Çñ ‚Üí A‚Çç‚Çô‚Çä‚ÇÅ‚Çé‚Çä‚Çñ`, but we need a map of type `A‚Çô‚Çä‚Çñ ‚Üí A‚Çç‚Çô‚Çä‚Çñ‚Çé‚Çä‚ÇÅ`, which
+forces us to introduce a
+[transport](foundation-core.transport-along-identifications.md).
 
 On the other hand, the latter requires transport when proving anything by
 induction on `k` and doesn't satisfy the judgmental equality `A[0] ‚âê A`, because
@@ -72,6 +80,10 @@ induction on `k` and doesn't satisfy the judgmental equality `A[0] ‚âê A`, becau
 infrastructure for working with horizontal compositions in sequential colimit to
 be formalized in terms of addition.
 
+To contrast, defining the operations by induction does satisfy `A[0] ‚âê A`, it
+computes when proving properties by induction, which is the expected primary
+use-case, and no further infrastructure is necessary.
+
 ### Shifts of sequential diagrams
 
 Given a sequential diagram `A`

From c51b9d477c2b96ac169f4e852703b7d555eece43 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 22 Mar 2024 15:52:40 +0100
Subject: [PATCH 12/14] pre-commit

---
 .../cocones-under-sequential-diagrams.lagda.md   |  4 ++--
 .../shifts-sequential-diagrams.lagda.md          | 16 ++++++++++------
 2 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md
index 92c9f2b7f7..1da0704bf2 100644
--- a/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md
@@ -38,8 +38,8 @@ open import synthetic-homotopy-theory.sequential-diagrams
 A
 {{#concept "cocone" Disambiguation="sequential diagram" Agda=cocone-sequential-diagram}}
 under a [sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md)
-`(A, a)` with codomain `X : ùí∞` consists of a family of maps `i‚Çô : A n ‚Üí C` and
-a family of [homotopies](foundation.homotopies.md) `H‚Çô` asserting that the
+`(A, a)` with codomain `X : ùí∞` consists of a family of maps `i‚Çô : A n ‚Üí C` and a
+family of [homotopies](foundation.homotopies.md) `H‚Çô` asserting that the
 triangles
 
 ```text
diff --git a/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
index 45e2765b67..7cb80f94a4 100644
--- a/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
@@ -66,8 +66,8 @@ alternative would be to shift all data using
 numbers.
 
 However, addition computes only on one side, so we have a choice to make: given
-a shift `k`, do we define the `n`-th level of the shifted structure to be
-the `n+k`-th or `k+n`-th level of the original?
+a shift `k`, do we define the `n`-th level of the shifted structure to be the
+`n+k`-th or `k+n`-th level of the original?
 
 The former runs into issues already when defining the shifted sequence, since
 `a‚Çô‚Çä‚Çñ : A‚Çô‚Çä‚Çñ ‚Üí A‚Çç‚Çô‚Çä‚ÇÅ‚Çé‚Çä‚Çñ`, but we need a map of type `A‚Çô‚Çä‚Çñ ‚Üí A‚Çç‚Çô‚Çä‚Çñ‚Çé‚Çä‚ÇÅ`, which
@@ -557,13 +557,17 @@ module _
       ( c)
       ( unshift-once-cocone-sequential-diagram A
         ( shift-once-cocone-sequential-diagram c))
-  pr1 (inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram c) zero-‚Ñï =
+  pr1 (inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram c)
+    zero-‚Ñï =
     coherence-cocone-sequential-diagram c zero-‚Ñï
-  pr1 (inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram c) (succ-‚Ñï n) =
+  pr1 (inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram c)
+    (succ-‚Ñï n) =
     refl-htpy
-  pr2 (inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram c) zero-‚Ñï =
+  pr2 (inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram c)
+    zero-‚Ñï =
     refl-htpy
-  pr2 (inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram c) (succ-‚Ñï n) =
+  pr2 (inv-htpy-is-retraction-unshift-once-cocone-sequential-diagram c)
+    (succ-‚Ñï n) =
     right-unit-htpy
 
 module _

From ae383f3c176dba4bc07062d53c76de0acf08b3f6 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Sat, 6 Apr 2024 23:17:23 +0200
Subject: [PATCH 13/14] Remove SDR20 paper summary

---
 book.toml                 |   3 +-
 src/papers.lagda.md       |  13 --
 src/papers/SDR20.lagda.md | 309 --------------------------------------
 3 files changed, 1 insertion(+), 324 deletions(-)
 delete mode 100644 src/papers.lagda.md
 delete mode 100644 src/papers/SDR20.lagda.md

diff --git a/book.toml b/book.toml
index 0bc75d67ed..206b2b5041 100644
--- a/book.toml
+++ b/book.toml
@@ -42,8 +42,7 @@ suppress_processing = [
   "USERS.md",
   "GRANT-ACKNOWLEDGEMENTS.md",
   "SUMMARY.md",
-  "ART.md",
-  "src/papers.md"
+  "ART.md"
 ]
 
 [preprocessor.concepts]
diff --git a/src/papers.lagda.md b/src/papers.lagda.md
deleted file mode 100644
index f7c92b1c2e..0000000000
--- a/src/papers.lagda.md
+++ /dev/null
@@ -1,13 +0,0 @@
-# Formalizations of papers in the library
-
-## References
-
-{{#bibliography}} {{#reference SDR20}}
-
-## Files in the namespace
-
-```agda
-module papers where
-
-open import papers.SDR20 public
-```
diff --git a/src/papers/SDR20.lagda.md b/src/papers/SDR20.lagda.md
deleted file mode 100644
index 1959e95bf0..0000000000
--- a/src/papers/SDR20.lagda.md
+++ /dev/null
@@ -1,309 +0,0 @@
-# Sequential Colimits in Homotopy Type Theory
-
-This file collects references to formalization of constructions and theorems
-from {{#cite SDR20}}.
-
-```agda
-module papers.SDR20 where
-```
-
-## 2 Homotopy Type Theory
-
-The second section introduces basic notions from homotopy type theory, which we
-import below for completeness.
-
-```agda
-open import foundation.universe-levels using
-  ( UU
-  )
-open import foundation.identity-types using
-  ( Id -- "path"
-  ; refl -- "constant path"
-  ; inv -- "inverse path"
-  ; concat -- "concatenation of paths"
-  ; assoc -- "associativity of concatenation"
-  )
-open import foundation.action-on-identifications-functions using
-  ( ap -- "functions respect paths"
-  )
-open import foundation.homotopies using
-  ( _~_ -- "homotopy"
-  )
-open import foundation.equivalences using
-  ( equiv -- "equivalence"
-  )
-open import foundation.univalence using
-  ( univalence -- "the univalence axiom"
-  ; map-eq -- "function pÃÖ associated to a path"
-  )
-open import foundation.function-extensionality using
-  ( funext -- "the function extensionality axiom"
-  )
-open import foundation.fibers-of-maps using
-  ( fiber -- "the homotopy fiber of a function"
-  )
-open import foundation.transport-along-identifications using
-  ( tr -- "transport"
-  )
-open import foundation.action-on-identifications-dependent-functions using
-  ( apd -- "dependent functions respect paths"
-  )
-open import foundation.truncated-types using
-  ( is-trunc -- "`n`-truncated types"
-  )
-open import foundation.truncations using
-  ( trunc -- "the `n`-truncation of a type"
-  ; unit-trunc -- "the unit map into a type's `n`-truncation"
-  ; is-truncation-trunc -- "precomposing by the unit is an equivalence"
-  )
-open import foundation.connected-types using
-  ( is-connected -- "`n`-connected types"
-  )
-open import foundation.truncated-maps using
-  ( is-trunc-map -- "`n`-truncated functions"
-  )
-open import foundation.connected-maps using
-  ( is-connected-map -- "`n`-connected functions"
-  )
-```
-
-## 3 Sequences and Sequential Colimits
-
-The third section defines categorical properties of sequences (which are called
-_sequential diagrams_ in agda-unimath) and the colimiting functor. It concludes
-by defining shifts of sequences, showing that they induce equivalences on
-sequential colimits, and defines lifts of elements in a sequential diagram.
-
-**Definition 3.1.** Sequences.
-
-```agda
-open import synthetic-homotopy-theory.sequential-diagrams using
-  ( sequential-diagram
-  )
-```
-
-**Definition 3.2.** Sequential colimits and their induction and recursion
-principles.
-
-Induction and recursion are given by the dependent and non-dependent universal
-properties, respectively. Since we work in a setting without computational
-higher inductive types, the maps induced by induction and recursion only compute
-up to a path, even on points. Our homotopies in the definitions of cocones go
-from left to right (i.e. `i‚Çô ~ i‚Çô‚Çä‚ÇÅ ‚àò a‚Çô`), instead of right to left.
-
-Our formalization works with sequential colimits specified by a cocone with a
-universal property, and results about the standard construction of colimits are
-obtained by specialization to the canonical cocone.
-
-```agda
-open import synthetic-homotopy-theory.sequential-colimits using
-  ( standard-sequential-colimit -- the canonical colimit type
-  ; map-cocone-standard-sequential-colimit -- "the canonical injection"
-  ; coherence-cocone-standard-sequential-colimit -- "the glue"
-  ; dup-standard-sequential-colimit -- "the induction principle"
-  ; up-standard-sequential-colimit -- "the recursion principle"
-  )
-```
-
-**Lemma 3.3.** Uniqueness property of the sequential colimit.
-
-The data of a homotopy between two functions out of the standard sequential
-colimit is specified by the type `htpy-out-of-standard-sequential-colimit`,
-which we can then turn into a proper homotopy.
-
-```agda
-open import synthetic-homotopy-theory.sequential-colimits using
-  ( htpy-out-of-standard-sequential-colimit -- data of a homotopy
-  ; htpy-htpy-out-of-standard-sequential-colimit -- "data of a homotopy induces a homotopy"
-  )
-```
-
-**Definition 3.4.** Natural transformations and natural equivalences between
-sequential diagrams.
-
-We call natural transformations _morphisms of sequential diagrams_, and natural
-equivalences _equivalences of sequential diagrams_.
-
-```agda
-open import synthetic-homotopy-theory.morphisms-sequential-diagrams using
-  ( hom-sequential-diagram -- "natural transformation"
-  ; id-hom-sequential-diagram -- "identity natural transformation"
-  ; comp-hom-sequential-diagram -- "composition of natural transformations"
-  )
-open import synthetic-homotopy-theory.equivalences-sequential-diagrams using
-  ( equiv-sequential-diagram -- "natural equivalence"
-  )
-```
-
-**Lemma 3.5.** Functoriality of the Sequential Colimit.
-
-```agda
-open import synthetic-homotopy-theory.functoriality-sequential-colimits using
-  ( map-hom-standard-sequential-colimit -- "a natural transformation induces a map"
-  ; preserves-id-map-hom-standard-sequential-colimit -- "1‚àû ~ id(A‚àû)"
-  ; preserves-comp-map-hom-standard-sequential-colimit -- "(œÉ ‚àò œÑ)‚àû ~ œÉ‚àû ‚àò œÑ‚àû"
-  ; htpy-map-hom-standard-sequential-colimit-htpy-hom-sequential-diagram -- "homotopy of natural transformations induces a homotopy"
-  ; equiv-equiv-standard-sequential-colimit -- "if œÑ is an equivalence, then œÑ‚àû is an equivalence"
-  )
-```
-
-**Lemma 3.6.** Dropping a head of a sequential diagram preserves the sequential
-colimit.
-
-**Lemma 3.7.** Dropping finitely many vertices from the beginning of a
-sequential diagram preserves the sequential colimit.
-
-Denoting by `A[k]` the sequence `A` with the first `k` vertices removed, we show
-that the type of cocones under `A[k]` is equivalent to the type of cocones under
-`A`, and conclude that any sequential colimit of `A[k]` also has the universal
-property of a colimit of `A`. Specializing to the standard sequential colimit,
-we get and equivalence `A[k]‚àû ‚âÉ A‚àû`.
-
-```agda
-open import synthetic-homotopy-theory.shifts-sequential-diagrams using
-  ( compute-sequential-colimit-shift-sequential-diagram -- "A[k]‚àû ‚âÉ A‚àû"
-  )
-compute-sequential-colimit-shift-sequential-diagram-once =
-  Œª l (A : sequential-diagram l) ‚Üí
-    compute-sequential-colimit-shift-sequential-diagram A 1
-```
-
-## 4 Fibered Sequences
-
-The fourth section defines fibered sequences, which we call _dependenct
-sequential diagrams_ in the library. It introduces the "Œ£ of a sequence", which
-we call the _total sequential diagram_, and asks the main question about the
-interplay between Œ£ and taking the colimit.
-
-The paper defines fibered sequences as a family over the total space
-`B : Œ£ ‚Ñï A ‚Üí ùí∞`, but we use the curried definition `B : (n : ‚Ñï) ‚Üí A(n) ‚Üí ùí∞`.
-
-**Definition 4.1.** Fibered sequences. Equifibered sequences.
-
-```agda
-open import synthetic-homotopy-theory.dependent-sequential-diagrams using
-  ( dependent-sequential-diagram -- "A sequence (B, b) fibered over (A, a)"
-  )
-```
-
-**Lemma 4.2.** The type of families over a colimit is equivalent to the type of
-equifibered sequences.
-
-This property is also called the _descent property of sequential colimits_,
-because it characterizes families over a sequential colimit.
-
-```agda
--- TODO
-```
-
-**Definition 4.3.** Œ£ of a fibered sequence.
-
-```agda
-open import synthetic-homotopy-theory.total-sequential-diagrams using
-  ( total-sequential-diagram -- "Œ£ (A, a) (B, b)"
-  ; pr1-total-sequential-diagram -- "the canonical projection"
-  )
-```
-
-**Construction.** The equifibered family associated to a fibered sequence.
-
-```agda
--- TODO
-```
-
-## 5 Colimits and Sums
-
-**Theorem 5.1.** Interaction between `colim` and `Œ£`.
-
-```agda
--- TODO
-```
-
-## 6 Induction on the Sum of Sequential Colimits
-
-```agda
--- TODO
-```
-
-## 7 Applications of the Main Theorem
-
-**Lemma 7.1.** TODO description.
-
-```agda
--- TODO
-```
-
-**Lemma 7.2.** Colimit of the terminal sequential diagram is contractible.
-
-```agda
--- TODO
-```
-
-**Lemma 7.3.** Encode-decode.
-
-This principle is called the _Fundamental theorem of identity types_ in the
-library.
-
-```agda
-open import foundation.fundamental-theorem-of-identity-types using
-  ( fundamental-theorem-id)
-```
-
-**Lemma 7.4.** Characterization of path spaces of images of the canonical maps
-into the sequential colimit.
-
-```agda
--- TODO
-```
-
-**Corollary 7.5.** The loop space of a sequential colimit is the sequential
-colimit of loop spaces.
-
-```agda
--- TODO
-```
-
-**Corollary 7.6.** For a morphism of sequential diagrams, the fibers of the
-induced map between sequential colimits are characterized as sequential colimits
-of the fibers.
-
-```agda
--- TODO
-```
-
-**Corollary 7.7.1.** If each type in a sequential diagram is `k`-truncated, then
-the colimit is `k`-truncated.
-
-```agda
--- TODO
-```
-
-**Corollary 7.7.2.** The `k`-truncation of a sequential colimit is the
-sequential colimit of `k`-truncations.
-
-```agda
--- TODO
-```
-
-**Corollary 7.7.3.** If each type in a sequential diagram is `k`-connected, then
-the colimit is `k`-connected.
-
-```agda
--- TODO
-```
-
-**Corollary 7.7.4.** If each component of a morphism between sequential diagrams
-is `k`-truncated/`k`-connected, then the induced map of sequential colimits is
-`k`-truncated/`k`-connected.
-
-```agda
--- TODO
-```
-
-**Corollary 7.7.5.** If each map in a sequential diagram is
-`k`-truncated/`k`-connected, then the first injection into the colimit is
-`k`-truncated/`k`-connected.
-
-```agda
--- TODO
-```

From be78eb4da47d5823d12c642988ae2d9e9a193938 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Sun, 7 Apr 2024 00:47:33 +0200
Subject: [PATCH 14/14] Prose feedback

---
 .../shifts-sequential-diagrams.lagda.md       | 27 +++++++++++++------
 .../total-sequential-diagrams.lagda.md        |  3 ++-
 2 files changed, 21 insertions(+), 9 deletions(-)

diff --git a/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
index 7cb80f94a4..66cb304593 100644
--- a/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/shifts-sequential-diagrams.lagda.md
@@ -196,7 +196,7 @@ Given a cocone `c`
           X
 ```
 
-under `A`, we may forget the first injection and homotopy to get the cocone
+under `A`, we may forget the first inclusion and homotopy to get the cocone
 
 ```text
          a‚ÇÅ
@@ -320,10 +320,22 @@ module _
 
 ### Shifts of homotopies of cocones under sequential diagrams
 
-Given cocones `c` and `c'` under `A`, and a homotopy `H : c ~ c'` between them,
-which I'm not sufficiently artistically equipped to put into an ASCII diagram,
-we can again forget the first homotopy of maps and coherence to get the homotopy
-`H[1] : c[1] ~ c'[1]`. Inductively, we define `H[k + 1] ‚âê H[k][1]`.
+Given cocones `c` and `c'` under `A`
+
+```text
+     a‚ÇÄ      a‚ÇÅ                   a‚ÇÄ      a‚ÇÅ
+ A‚ÇÄ ---> A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ    A‚ÇÄ ---> A‚ÇÅ ---> A‚ÇÇ ---> ‚ãØ
+  \      |      /              \      |      /
+   \     | i‚ÇÅ  /                \     | i'‚ÇÅ /
+ i‚ÇÄ \    |    / i‚ÇÇ     ~     i'‚ÇÄ \    |    / i'‚ÇÇ
+     \   |   /                    \   |   /
+      ‚à®  ‚à®  ‚à®                      ‚à®  ‚à®  ‚à®
+         X                            X
+```
+
+and a homotopy `H : c ~ c'` between them, we can again forget the first homotopy
+of maps and coherence to get the homotopy `H[1] : c[1] ~ c'[1]`. Inductively, we
+define `H[k + 1] ‚âê H[k][1]`.
 
 ```agda
 module _
@@ -363,9 +375,8 @@ module _
 
 ### Unshifts of homotopies of cocones under sequential diagrams
 
-Similarly to unshifting cocones, we can synthesize the first homotopy and
-coherence to unshift a homotopy of cocones. Given two cocones `c`, `c'` under
-`A[1]`
+Similarly to unshifting cocones, we can recover the first homotopy and coherence
+to unshift a homotopy of cocones. Given two cocones `c`, `c'` under `A[1]`
 
 ```text
          a‚ÇÅ                     a‚ÇÅ
diff --git a/src/synthetic-homotopy-theory/total-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/total-sequential-diagrams.lagda.md
index ffd1a3935d..70bd318d5a 100644
--- a/src/synthetic-homotopy-theory/total-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/total-sequential-diagrams.lagda.md
@@ -33,7 +33,8 @@ of a
 [dependent sequential diagram](synthetic-homotopy-theory.dependent-sequential-diagrams.md)
 `B : (A, a) ‚Üí ùí∞` is the
 [sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md)
-consisting of [total spaces](foundation.dependent-pair-types.md) `Œ£ A‚Çô B‚Çô`.
+consisting of [total spaces](foundation.dependent-pair-types.md) `Œ£ A‚Çô B‚Çô` and
+total maps.
 
 ## Definitions
 
