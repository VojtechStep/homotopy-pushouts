diff --git a/src/foundation/commuting-squares-of-maps.lagda.md b/src/foundation/commuting-squares-of-maps.lagda.md
index 3df33693bc..93688a63b5 100644
--- a/src/foundation/commuting-squares-of-maps.lagda.md
+++ b/src/foundation/commuting-squares-of-maps.lagda.md
@@ -590,7 +590,7 @@ newly created rectangles, or by first horizontally composing the squares, and
 then vertically composing the rectangles.
 
 The following lemma states that the big squares obtained by these two
-compositions are again homotopic. Diagramatically, we have
+compositions are again homotopic. Diagrammatically, we have
 
 ```text
  H | K   H | K
diff --git a/src/foundation/functoriality-dependent-pair-types.lagda.md b/src/foundation/functoriality-dependent-pair-types.lagda.md
index 929bf7f24c..cdf87ea21b 100644
--- a/src/foundation/functoriality-dependent-pair-types.lagda.md
+++ b/src/foundation/functoriality-dependent-pair-types.lagda.md
@@ -11,6 +11,7 @@ open import foundation-core.functoriality-dependent-pair-types public
 ```agda
 open import foundation.action-on-identifications-functions
 open import foundation.cones-over-cospans
+open import foundation.dependent-homotopies
 open import foundation.dependent-pair-types
 open import foundation.type-arithmetic-dependent-pair-types
 open import foundation.universe-levels
@@ -38,6 +39,101 @@ open import foundation-core.truncation-levels
 
 ## Properties
 
+### The map `htpy-map-Σ` preserves homotopies
+
+Given a [homotopy](foundation.homotopies.md) `H : f ~ f'` and a family of
+[dependent homotopies](foundation.dependent-homotopies.md) `K a : g a ~ g' a`
+over `H`, expressed as
+[commuting triangles](foundation.commuting-triangles-of-maps.md)
+
+```text
+        g a
+   C a -----> D (f a)
+      \      /
+  g' a \    / tr D (H a)
+        V  V
+      D (f' a)         ,
+```
+
+we get a homotopy `htpy-map-Σ H K : map-Σ f g ~ map-Σ f' g'`.
+
+This assignment itself preserves homotopies: given `H` and `K` as above,
+`H' : f ~ f'` with `K' a : g a ~ g' a` over `H'`, we would like to express
+coherences between the pairs `H, H'` and `K, K'` which would ensure
+`htpy-map-Σ H K ~ htpy-map-Σ H' K'`. Because `H` and `H'` have the same type, we
+may require a homotopy `α : H ~ H'`, but `K` and `K'` are families of dependent
+homotopies over different homotopies, so their coherence is provided as a family
+of
+[commuting triangles of identifications](foundation.commuting-triangles-of-identifications.md)
+
+```text
+                      ap (λ p → tr D p (g a c)) (α a)
+  tr D (H a) (g a c) --------------------------------- tr D (H' a) (g a c)
+                     \                               /
+                        \                         /
+                           \                   /
+                      K a c   \             /   K' a c
+                                 \       /
+                                    \ /
+                                  g' a c        .
+```
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {C : A → UU l3} (D : B → UU l4)
+  {f f' : A → B} {H H' : f ~ f'}
+  {g : (a : A) → C a → D (f a)}
+  {g' : (a : A) → C a → D (f' a)}
+  {K : (a : A) → dependent-homotopy (λ _ → D) (λ _ → H a) (g a) (g' a)}
+  {K' : (a : A) → dependent-homotopy (λ _ → D) (λ _ → H' a) (g a) (g' a)}
+  where
+
+  abstract
+    htpy-htpy-map-Σ :
+      (α : H ~ H') →
+      (β :
+        (a : A) (c : C a) →
+        K a c ＝ ap (λ p → tr D p (g a c)) (α a) ∙ K' a c) →
+      htpy-map-Σ D H g K ~ htpy-map-Σ D H' g K'
+    htpy-htpy-map-Σ α β (a , c) =
+      ap
+        ( eq-pair-Σ')
+        ( eq-pair-Σ
+          ( α a)
+          ( map-compute-dependent-identification-eq-value-function
+            ( λ p → tr D p (g a c))
+            ( λ _ → g' a c)
+            ( α a)
+            ( K a c)
+            ( K' a c)
+            ( inv
+              ( ( ap
+                  ( K a c ∙_)
+                  ( ap-const (g' a c) (α a))) ∙
+                ( right-unit) ∙
+                ( β a c)))))
+```
+
+As a corollary of the above statement, we can provide a condition which
+guarantees that `htpy-map-Σ` is homotopic to the trivial homotopy.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {C : A → UU l3} (D : B → UU l4)
+  {f : A → B} {H : f ~ f}
+  {g : (a : A) → C a → D (f a)}
+  {K : (a : A) → tr D (H a) ∘ g a ~ g a}
+  where
+
+  abstract
+    htpy-htpy-map-Σ-refl-htpy :
+      (α : H ~ refl-htpy) →
+      (β : (a : A) (c : C a) → K a c ＝ ap (λ p → tr D p (g a c)) (α a)) →
+      htpy-map-Σ D H g K ~ refl-htpy
+    htpy-htpy-map-Σ-refl-htpy α β =
+      htpy-htpy-map-Σ D α (λ a c → β a c ∙ inv right-unit)
+```
+
 ### The map on total spaces induced by a family of truncated maps is truncated
 
 ```agda
diff --git a/src/foundation/precomposition-type-families.lagda.md b/src/foundation/precomposition-type-families.lagda.md
index fea1ef916a..c257e0b17c 100644
--- a/src/foundation/precomposition-type-families.lagda.md
+++ b/src/foundation/precomposition-type-families.lagda.md
@@ -7,9 +7,14 @@ module foundation.precomposition-type-families where
 <details><summary>Imports</summary>
 
 ```agda
+open import foundation.homotopy-induction
+open import foundation.transport-along-homotopies
 open import foundation.universe-levels
 
 open import foundation-core.function-types
+open import foundation-core.homotopies
+open import foundation-core.identity-types
+open import foundation-core.whiskering-homotopies
 ```
 
 </details>
@@ -35,6 +40,50 @@ module _
   {l1 l2 : Level} {A : UU l1} {B : UU l2} (f : A → B)
   where
 
-  precomp-family : (l : Level) → (B → UU l) → (A → UU l)
-  precomp-family l Q = Q ∘ f
+  precomp-family : {l : Level} → (B → UU l) → (A → UU l)
+  precomp-family Q = Q ∘ f
+```
+
+## Properties
+
+### Transport along homotopies in precomposed type families
+
+[Transporting](foundation.transport-along-homotopies.md) along a
+[homotopy](foundation.homotopies.md) `H : g ~ h` in the family `Q ∘ f` gives us
+a map of families of elements
+
+```text
+  ((a : A) → Q (f (g a))) → ((a : A) → Q (f (h a))) .
+```
+
+We show that this map is homotopic to transporting along
+`f ·l H : f ∘ g ~ f ∘ h` in the family `Q`.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} (f : A → B) (Q : B → UU l3)
+  {X : UU l4} {g : X → A}
+  where
+
+  statement-tr-htpy-precomp-family :
+    {h : X → A} (H : g ~ h) → UU (l3 ⊔ l4)
+  statement-tr-htpy-precomp-family H =
+    tr-htpy (λ _ → precomp-family f Q) H ~ tr-htpy (λ _ → Q) (f ·l H)
+
+  abstract
+    tr-htpy-precomp-family :
+      {h : X → A} (H : g ~ h) →
+      statement-tr-htpy-precomp-family H
+    tr-htpy-precomp-family =
+      ind-htpy g
+        ( λ h → statement-tr-htpy-precomp-family)
+        ( refl-htpy)
+
+    compute-tr-htpy-precomp-family :
+      tr-htpy-precomp-family refl-htpy ＝
+      refl-htpy
+    compute-tr-htpy-precomp-family =
+      compute-ind-htpy g
+        ( λ h → statement-tr-htpy-precomp-family)
+        ( refl-htpy)
 ```
diff --git a/src/foundation/type-theoretic-principle-of-choice.lagda.md b/src/foundation/type-theoretic-principle-of-choice.lagda.md
index 031a9289b0..605aec74bc 100644
--- a/src/foundation/type-theoretic-principle-of-choice.lagda.md
+++ b/src/foundation/type-theoretic-principle-of-choice.lagda.md
@@ -37,6 +37,10 @@ In this file we record some further facts about the
 [structures](foundation.structure.md) introduced in
 [`foundation-core.type-theoretic-principle-of-choice`](foundation-core.type-theoretic-principle-of-choice.md).
 
+We relate precomposition of maps into a dependent pair type by a function with
+precomposition in dependent pair types of functions in the file
+[`orthogonal-factorization-systems.precomposition-lifts-families-of-elements`](orthogonal-factorization-systems.precomposition-lifts-families-of-elements.md).
+
 ## Lemma
 
 ### Characterizing the identity type of `universally-structured-Π`
diff --git a/src/foundation/whiskering-homotopies.lagda.md b/src/foundation/whiskering-homotopies.lagda.md
index bfe1cc284d..07ce4de860 100644
--- a/src/foundation/whiskering-homotopies.lagda.md
+++ b/src/foundation/whiskering-homotopies.lagda.md
@@ -115,7 +115,7 @@ may be whiskered by a homotopy `L` on the left or right, which results in a
 commuting square of homotopies with `L` appended or prepended to the two ways of
 going around the square.
 
-Diagramatically, we may turn the pasting diagram
+Diagrammatically, we may turn the pasting diagram
 
 ```text
         H
diff --git a/src/orthogonal-factorization-systems.lagda.md b/src/orthogonal-factorization-systems.lagda.md
index 528701370e..44d745a65d 100644
--- a/src/orthogonal-factorization-systems.lagda.md
+++ b/src/orthogonal-factorization-systems.lagda.md
@@ -46,6 +46,7 @@ open import orthogonal-factorization-systems.null-types public
 open import orthogonal-factorization-systems.open-modalities public
 open import orthogonal-factorization-systems.orthogonal-factorization-systems public
 open import orthogonal-factorization-systems.orthogonal-maps public
+open import orthogonal-factorization-systems.precomposition-lifts-families-of-elements public
 open import orthogonal-factorization-systems.pullback-hom public
 open import orthogonal-factorization-systems.raise-modalities public
 open import orthogonal-factorization-systems.reflective-modalities public
diff --git a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
index 6155ddf59e..c0e5399585 100644
--- a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
@@ -7,6 +7,15 @@ module orthogonal-factorization-systems.lifts-families-of-elements where
 <details><summary>Imports</summary>
 
 ```agda
+open import foundation.action-on-identifications-functions
+open import foundation.dependent-pair-types
+open import foundation.homotopies
+open import foundation.homotopy-induction
+open import foundation.identity-types
+open import foundation.precomposition-functions
+open import foundation.precomposition-type-families
+open import foundation.transport-along-homotopies
+open import foundation.transport-along-identifications
 open import foundation.universe-levels
 ```
 
@@ -38,6 +47,42 @@ elements `a` is a family of elements
   (i : I) → B (a i).
 ```
 
+A family of elements equipped with a dependent lift is a
+{{#concept "dependent lifted family of elements"}}, and analogously a family of
+elements equipped with a lift is a {{#concept "lifted family of elements"}}.
+
+To see how these families relate to
+[lifts of maps](orthogonal-factorization-systems.lifts-of-maps.md), consider the
+lifting diagram
+
+```text
+      Σ (x : A) (B x)
+            |
+            | pr1
+            |
+            v
+  I ------> A         .
+       a
+```
+
+Then a lift of the map `a` against `pr1` is a map `b : I → Σ A B`, such that the
+triangle commutes. Invoking the
+[type theoretic principle of choice](foundation.type-theoretic-principle-of-choice.md),
+we can show that this type is equivalent to the type of families of elements
+`(i : I) → B (a i)`:
+
+```text
+  Σ (b : I → Σ A B) ((i : I) → a i ＝ pr1 (b i))
+    ≃ (i : I) → Σ ((x , b) : Σ A B) (a i ＝ x)
+    ≃ (i : I) → Σ (x : A) (a i ＝ x × B x)
+    ≃ (i : I) → B (a i) .
+```
+
+The first equivalence is the principle of choice, the second is associativity of
+dependent pair types, and the third is the left unit law of dependent pair
+types, since `Σ (x : A) (a i ＝ x)` is
+[contractible](foundation.contractible-types.md).
+
 ## Definitions
 
 ### Dependent lifts of families of elements
@@ -63,6 +108,31 @@ module _
   lift-family-of-elements = dependent-lift-family-of-elements (λ _ → B) a
 ```
 
+### Dependent lifted families of elements
+
+```agda
+module _
+  {l1 l2 l3 : Level} {I : UU l1} (A : I → UU l2) (B : (i : I) → A i → UU l3)
+  where
+
+  dependent-lifted-family-of-elements : UU (l1 ⊔ l2 ⊔ l3)
+  dependent-lifted-family-of-elements =
+    Σ ( (i : I) → A i)
+      ( dependent-lift-family-of-elements B)
+```
+
+### Lifted families of elements
+
+```agda
+module _
+  {l1 l2 l3 : Level} (I : UU l1) {A : UU l2} (B : A → UU l3)
+  where
+
+  lifted-family-of-elements : UU (l1 ⊔ l2 ⊔ l3)
+  lifted-family-of-elements =
+    dependent-lifted-family-of-elements (λ (_ : I) → A) (λ _ → B)
+```
+
 ### Dependent lifts of binary families of elements
 
 ```agda
@@ -89,6 +159,58 @@ module _
     dependent-lift-binary-family-of-elements (λ _ → C) a
 ```
 
+## Properties
+
+### Transport in lifts of families of elements along homotopies of precompositions
+
+Given a map `a : I → A`, and a homotopy `H : f ~ g`, where `f, g : J → I`, we
+know that there is an identification `a ∘ f ＝ a ∘ g`. Transporting along this
+identification in the type of lifts of families of elements into a type family
+`B : A → 𝓤`, we get a map
+
+```text
+  ((j : J) → B (a (f j))) → ((j : J) → B (a (g j))) .
+```
+
+We show that this map is homotopic to transporting along `H` in the type family
+`B ∘ a : I → 𝓤`.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) (a : I → A)
+  {J : UU l4} {f : J → I}
+  where
+
+  statement-tr-lift-family-of-elements-precomp :
+    {g : J → I} (H : f ~ g) → UU (l3 ⊔ l4)
+  statement-tr-lift-family-of-elements-precomp H =
+    tr (lift-family-of-elements B) (htpy-precomp H A a) ~
+    tr-htpy (λ _ → precomp-family a B) H
+
+  tr-lift-family-of-elements-precomp-refl-htpy :
+    statement-tr-lift-family-of-elements-precomp refl-htpy
+  tr-lift-family-of-elements-precomp-refl-htpy b =
+    ap
+      ( λ p → tr (lift-family-of-elements B) p b)
+      ( compute-htpy-precomp-refl-htpy f A a)
+
+  abstract
+    tr-lift-family-of-elements-precomp :
+      {g : J → I} (H : f ~ g) → statement-tr-lift-family-of-elements-precomp H
+    tr-lift-family-of-elements-precomp =
+      ind-htpy f
+        ( λ g → statement-tr-lift-family-of-elements-precomp)
+        ( tr-lift-family-of-elements-precomp-refl-htpy)
+
+    compute-tr-lift-family-of-elements-precomp :
+      tr-lift-family-of-elements-precomp refl-htpy ＝
+      tr-lift-family-of-elements-precomp-refl-htpy
+    compute-tr-lift-family-of-elements-precomp =
+      compute-ind-htpy f
+        ( λ g → statement-tr-lift-family-of-elements-precomp)
+        ( tr-lift-family-of-elements-precomp-refl-htpy)
+```
+
 ## See also
 
 - [Double lifts of families of elements](orthogonal-factorization-systems.double-lifts-families-of-elements.md)
diff --git a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
new file mode 100644
index 0000000000..1cc89a4539
--- /dev/null
+++ b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
@@ -0,0 +1,357 @@
+# Precomposition of lifts of families of elements by maps
+
+```agda
+module orthogonal-factorization-systems.precomposition-lifts-families-of-elements where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.action-on-identifications-dependent-functions
+open import foundation.commuting-squares-of-homotopies
+open import foundation.commuting-squares-of-maps
+open import foundation.commuting-triangles-of-maps
+open import foundation.dependent-pair-types
+open import foundation.function-extensionality
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.homotopies
+open import foundation.homotopy-induction
+open import foundation.identity-types
+open import foundation.path-algebra
+open import foundation.precomposition-functions
+open import foundation.transport-along-identifications
+open import foundation.type-theoretic-principle-of-choice
+open import foundation.universe-levels
+open import foundation.whiskering-homotopies
+
+open import orthogonal-factorization-systems.lifts-families-of-elements
+```
+
+</details>
+
+## Idea
+
+Consider a type family `B : A → 𝓤` and a map `a : I → A`. Then, given a map
+`f : J → I`, we may pull back a
+[lift](orthogonal-factorization-systems.lifts-families-of-elements.md) of `a` to
+a lift of `a ∘ f`.
+
+In other words, given a diagram
+
+```text
+                Σ (x : A) (B x)
+                      |
+                      | pr1
+                      |
+                      v
+  J ------> I ------> A         ,
+       f         a
+```
+
+we get a map of lifts of families of elements
+
+```text
+  ((i : I) → B (a i)) → ((j : J) → B (a (f j))) .
+```
+
+This map of lifts induces a map from lifted families of elements indexed by `I`
+to lifted families of elements indexed by `J`.
+
+## Definitions
+
+### Precomposition of lifts of families of elements by functions
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) {J : UU l4}
+  (f : J → I)
+  where
+
+  precomp-lift-family-of-elements :
+    (a : I → A) →
+    lift-family-of-elements B a → lift-family-of-elements B (a ∘ f)
+  precomp-lift-family-of-elements a b i = b (f i)
+```
+
+### Precomposition in lifted families of elements
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) {J : UU l4}
+  (f : J → I)
+  where
+
+  precomp-lifted-family-of-elements :
+    lifted-family-of-elements I B → lifted-family-of-elements J B
+  precomp-lifted-family-of-elements =
+    map-Σ
+      ( lift-family-of-elements B)
+      ( precomp f A)
+      ( precomp-lift-family-of-elements B f)
+```
+
+## Properties
+
+### Homotopies between maps induce commuting triangles of precompositions of lifts of families of elements
+
+Consider two maps `f, g : J → I` and a homotopy `H : f ~ g` between them. The
+precomposition functions they induce on lifts of families of elements have
+different codomains, namely `lift-family-of-elements B (a ∘ f)` and
+`lift-family-of-elements B (a ∘ g)`, but they fit into a
+[commuting triangle](foundation.commuting-triangles-of-maps.md) with
+[transport](foundation.transport-along-identifications.md) in the type of lifts:
+
+```text
+                              precomp-lift B f a
+  lift-family-of-elements B a ------------------> lift-family-of-elements B (a ∘ f)
+                      \                                /
+                         \                          /
+                            \                    /
+           precomp-lift B g a  \              / tr (lift-family-of-elements B) (htpy-precomp H A a)
+                                  \        /
+                                     V  V
+                       lift-family-of-elements B (a ∘ g)
+```
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) (a : I → A)
+  {J : UU l4} {f : J → I}
+  where
+
+  statement-triangle-precomp-lift-family-of-elements-htpy :
+    {g : J → I} (H : f ~ g) → UU (l1 ⊔ l3 ⊔ l4)
+  statement-triangle-precomp-lift-family-of-elements-htpy {g} H =
+    coherence-triangle-maps'
+      ( precomp-lift-family-of-elements B g a)
+      ( tr (lift-family-of-elements B) (htpy-precomp H A a))
+      ( precomp-lift-family-of-elements B f a)
+
+  triangle-precomp-lift-family-of-elements-htpy-refl-htpy :
+    statement-triangle-precomp-lift-family-of-elements-htpy refl-htpy
+  triangle-precomp-lift-family-of-elements-htpy-refl-htpy b =
+    tr-lift-family-of-elements-precomp B a refl-htpy (b ∘ f)
+
+  abstract
+    triangle-precomp-lift-family-of-elements-htpy :
+      {g : J → I} (H : f ~ g) →
+      statement-triangle-precomp-lift-family-of-elements-htpy H
+    triangle-precomp-lift-family-of-elements-htpy =
+      ind-htpy f
+        ( λ g → statement-triangle-precomp-lift-family-of-elements-htpy)
+        ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
+
+    compute-triangle-precomp-lift-family-of-elements-htpy :
+      triangle-precomp-lift-family-of-elements-htpy refl-htpy ＝
+      triangle-precomp-lift-family-of-elements-htpy-refl-htpy
+    compute-triangle-precomp-lift-family-of-elements-htpy =
+      compute-ind-htpy f
+        ( λ g → statement-triangle-precomp-lift-family-of-elements-htpy)
+        ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
+```
+
+### `triangle-precomp-lift-family-of-elements-htpy` factors through transport along a homotopy in the famiy `B ∘ a`
+
+Instead of defining the homotopy `triangle-precomp-lift-family-of-elements-htpy`
+by homotopy induction, we could have defined it manually using the
+characterization of transport in the type of lifts of a family of elements.
+
+We show that these two definitions are homotopic.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) (a : I → A)
+  {J : UU l4} {f : J → I}
+  where
+
+  statement-coherence-triangle-precomp-lift-family-of-elements :
+    {g : J → I} (H : f ~ g) → UU (l1 ⊔ l3 ⊔ l4)
+  statement-coherence-triangle-precomp-lift-family-of-elements H =
+    ( triangle-precomp-lift-family-of-elements-htpy B a H) ~
+    ( ( ( tr-lift-family-of-elements-precomp B a H) ·r
+        ( precomp-lift-family-of-elements B f a)) ∙h
+      ( λ b → eq-htpy (λ j → apd b (H j))))
+
+  coherence-triangle-precomp-lift-family-of-elements-refl-htpy :
+    statement-coherence-triangle-precomp-lift-family-of-elements
+      ( refl-htpy)
+  coherence-triangle-precomp-lift-family-of-elements-refl-htpy b =
+    ( htpy-eq (compute-triangle-precomp-lift-family-of-elements-htpy B a) b) ∙
+    ( inv right-unit) ∙
+    ( identification-left-whisk
+      ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy B a b)
+      ( inv (eq-htpy-refl-htpy (b ∘ f))))
+
+  abstract
+    coherence-triangle-precomp-lift-family-of-elements :
+      {g : J → I} (H : f ~ g) →
+      statement-coherence-triangle-precomp-lift-family-of-elements H
+    coherence-triangle-precomp-lift-family-of-elements =
+      ind-htpy f
+        ( λ g →
+          statement-coherence-triangle-precomp-lift-family-of-elements)
+        ( coherence-triangle-precomp-lift-family-of-elements-refl-htpy)
+
+    compute-coherence-triangle-precomp-lift-family-of-elements :
+      coherence-triangle-precomp-lift-family-of-elements refl-htpy ＝
+      coherence-triangle-precomp-lift-family-of-elements-refl-htpy
+    compute-coherence-triangle-precomp-lift-family-of-elements =
+      compute-ind-htpy f
+        ( λ g →
+          statement-coherence-triangle-precomp-lift-family-of-elements)
+        ( coherence-triangle-precomp-lift-family-of-elements-refl-htpy)
+```
+
+### `precomp-lifted-family-of-elements` is homotopic to the precomposition map on functions up to equivalence
+
+We have a [commuting square](foundation.commuting-squares-of-maps.md) like this:
+
+```text
+                                     precomp-lifted-family f
+  Σ (a : I → A) ((i : I) → B (a i)) ------------------------> Σ (a : J → A) ((j : J) → B (a j))
+                  |                                                           |
+                  |                                                           |
+                  | map-inv-distributive-Π-Σ    ⇗    map-inv-distributive-Π-Σ |
+                  |                                                           |
+                  V                                                           V
+              I → Σ A B ------------------------------------------------> J → Σ A B ,
+                                               - ∘ f
+```
+
+which shows that `precomp-lifted-family-of-elements f` is a good choice for a
+precomposition map in the type of lifted families of elements, since it's
+homotopic to the regular precomposition map up to equivalence.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) {J : UU l4}
+  (f : J → I)
+  where
+
+  coherence-square-precomp-map-inv-distributive-Π-Σ :
+    coherence-square-maps
+      ( precomp-lifted-family-of-elements B f)
+      ( map-inv-distributive-Π-Σ)
+      ( map-inv-distributive-Π-Σ)
+      ( precomp f (Σ A B))
+  coherence-square-precomp-map-inv-distributive-Π-Σ = refl-htpy
+```
+
+### Precomposition of lifted families of elements preserves homotopies
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) {J : UU l4}
+  {f : J → I}
+  where
+
+  htpy-precomp-lifted-family-of-elements :
+    {g : J → I} (H : f ~ g) →
+    ( precomp-lifted-family-of-elements B f) ~
+    ( precomp-lifted-family-of-elements B g)
+  htpy-precomp-lifted-family-of-elements H =
+    htpy-map-Σ
+      ( lift-family-of-elements B)
+      ( htpy-precomp H A)
+      ( precomp-lift-family-of-elements B f)
+      ( λ a → triangle-precomp-lift-family-of-elements-htpy B a H)
+
+  abstract
+    compute-htpy-precomp-lifted-family-of-elements :
+      htpy-precomp-lifted-family-of-elements refl-htpy ~
+      refl-htpy
+    compute-htpy-precomp-lifted-family-of-elements =
+      htpy-htpy-map-Σ-refl-htpy
+        ( lift-family-of-elements B)
+        ( compute-htpy-precomp-refl-htpy f A)
+        ( λ a →
+          ( htpy-eq
+            ( compute-triangle-precomp-lift-family-of-elements-htpy B a)) ∙h
+          ( λ b →
+            htpy-eq (compute-tr-lift-family-of-elements-precomp B a) (b ∘ f)))
+```
+
+### `coherence-square-precomp-map-inv-distributive-Π-Σ` commutes with induced homotopies between precompositions maps
+
+Diagrammatically, we have two ways of composing homotopies to connect `- ∘ f`
+and `precomp-lifted-family-of-elements g`. One factors through
+`precomp-lifted-family-of-elements f`:
+
+```text
+                                     precomp-lifted-family g
+                               -----------------------------------
+                             /                                     \
+                           /     ⇗ htpy-precomp-lifted-family H      \
+                         /                                             V
+  Σ (a : I → A) ((i : I) → B (a i)) ------------------------> Σ (a : J → A) ((j : J) → B (a j))
+                  |                  precomp-lifted-family f                  |
+                  |                                                           |
+                  |                             ⇗                             |
+                  | map-inv-distributive-Π-Σ         map-inv-distributive-Π-Σ |
+                  V                                                           V
+              I → Σ A B ------------------------------------------------> J → Σ A B ,
+                                              - ∘ f
+```
+
+while the other factors through `- ∘ g`:
+
+```text
+                                     precomp-lifted-family g
+  Σ (a : I → A) ((i : I) → B (a i)) ------------------------> Σ (a : J → A) ((j : J) → B (a j))
+                  |                                                           |
+                  |                                                           |
+                  | map-inv-distributive-Π-Σ    ⇗    map-inv-distributive-Π-Σ |
+                  |                                                           |
+                  V                           - ∘ g                           V
+              I → Σ A B ------------------------------------------------> J → Σ A B .
+                        \                                               >
+                          \             ⇗  htpy-precomp H             /
+                            \                                       /
+                              -------------------------------------
+                                              - ∘ f
+```
+
+We show that these homotopies are themselves homotopic, filling the cylinder.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) {J : UU l4}
+  {f : J → I}
+  where
+
+  statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ :
+    {g : J → I} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
+  statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ
+    {g} H =
+    coherence-square-homotopies
+      ( htpy-precomp H (Σ A B) ·r map-inv-distributive-Π-Σ)
+      ( coherence-square-precomp-map-inv-distributive-Π-Σ B f)
+      ( coherence-square-precomp-map-inv-distributive-Π-Σ B g)
+      ( ( map-inv-distributive-Π-Σ) ·l
+        ( htpy-precomp-lifted-family-of-elements B H))
+
+  coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ-refl-htpy :
+    statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ
+      ( refl-htpy)
+  coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ-refl-htpy =
+    ( ap-left-whisk-htpy
+      ( map-inv-distributive-Π-Σ)
+      ( compute-htpy-precomp-lifted-family-of-elements B)) ∙h
+    ( inv-htpy
+      ( λ h →
+        compute-htpy-precomp-refl-htpy f
+          ( Σ A B)
+          ( map-inv-distributive-Π-Σ h))) ∙h
+    ( inv-htpy-right-unit-htpy)
+
+  coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ :
+    {g : J → I} (H : f ~ g) →
+    statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ
+      ( H)
+  coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ =
+    ind-htpy f
+      ( λ g →
+        statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ)
+      ( coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ-refl-htpy)
+```
diff --git a/src/synthetic-homotopy-theory/26-descent.lagda.md b/src/synthetic-homotopy-theory/26-descent.lagda.md
index dc40055258..79e084feb2 100644
--- a/src/synthetic-homotopy-theory/26-descent.lagda.md
+++ b/src/synthetic-homotopy-theory/26-descent.lagda.md
@@ -47,456 +47,6 @@ open import synthetic-homotopy-theory.universal-property-pushouts
 
 </details>
 
-### Remark 18.1.3 Computation of the identity type of `dependent-cocone`
-
-Before we state the main theorem of this section, we also state a dependent
-version of the pullback property of pushouts.
-
-## Theorem 18.1.4
-
-    The following properties are all equivalent:
-
-    1. universal-property-pushout
-    2. pullback-property-pushout
-    3. dependent-pullback-property-pushout
-    4. dependent-universal-property-pushout
-    5. Ind-pushout
-
-We have already shown (1) ↔ (2). Therefore we will first show (3) ↔ (4) ↔ (5).
-Finally, we will show (2) ↔ (3). Here are the precise references to the proofs
-of those parts:
-
-- Proof of (1) → (2): `pullback-property-pushout-universal-property-pushout`
-- Proof of (2) → (1): `universal-property-pushout-pullback-property-pushout`
-- Proof of (2) → (3): `dependent-pullback-property-pullback-property-pushout`
-- Proof of (3) → (2): `pullback-property-dependent-pullback-property-pushout`
-- Proof of (3) → (4):
-  `dependent-universal-property-dependent-pullback-property-pushout`
-- Proof of (4) → (3):
-  `dependent-pullback-property-dependent-universal-property-pushout`
-- Proof of (4) → (5): `Ind-pushout-dependent-universal-property-pushout`
-- Proof of (5) → (4): `dependent-universal-property-pushout-Ind-pushout`
-
-### Proof of Theorem 18.1.4, (3) implies (2)
-
-```agda
-pullback-property-dependent-pullback-property-pushout :
-  {l1 l2 l3 l4 : Level} (l : Level) {S : UU l1} {A : UU l2} {B : UU l3}
-  (f : S → A) (g : S → B) {X : UU l4} (c : cocone f g X) →
-  dependent-pullback-property-pushout l f g c →
-  pullback-property-pushout l f g c
-pullback-property-dependent-pullback-property-pushout
-  l f g (pair i (pair j H)) dpb Y =
-  is-pullback-htpy
-    -- ( λ h s → tr (λ x → Y) (H s) (h (f s)))
-    ( λ h → eq-htpy (λ s → inv (tr-constant-type-family (H s) (h (f s)))))
-    -- ( _∘ g)
-    ( refl-htpy)
-    { c = pair
-      ( _∘ i)
-      ( pair (_∘ j) (λ h → eq-htpy (h ·l H)))}
-    ( cone-dependent-pullback-property-pushout
-      f g (pair i (pair j H)) (λ x → Y))
-    ( pair
-      ( λ h → refl)
-      ( pair
-        ( λ h → refl)
-        ( λ h → right-unit ∙
-          ( ( ap eq-htpy
-              ( eq-htpy (λ s →
-                left-transpose-eq-concat
-                  ( tr-constant-type-family (H s) (h (i (f s))))
-                  ( ap h (H s))
-                  ( apd h (H s))
-                  ( inv (apd-constant-type-family h (H s)))))) ∙
-            ( eq-htpy-concat-htpy
-              ( λ s → inv (tr-constant-type-family (H s) (h (i (f s)))))
-              ( λ s → apd h (H s)))))))
-    ( dpb (λ x → Y))
-```
-
-### Proof of Theorem 18.1.4, (2) implies (3)
-
-We first define the family of lifts, which is indexed by maps $Y → X$.
-
-```agda
-fam-lifts :
-  {l1 l2 l3 : Level} (Y : UU l1) {X : UU l2} (P : X → UU l3) →
-  (Y → X) → UU (l1 ⊔ l3)
-fam-lifts Y P h = (y : Y) → P (h y)
-
-tr-fam-lifts' :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
-  (h : B → X) {f g : A → B} (H : f ~ g) →
-  fam-lifts A P (h ∘ f) → fam-lifts A P (h ∘ g)
-tr-fam-lifts' P h {f} {g} H k s = tr (P ∘ h) (H s) (k s)
-
-TR-EQ-HTPY-FAM-LIFTS :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
-  (h : B → X) {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l4)
-TR-EQ-HTPY-FAM-LIFTS {A = A} P h H =
-  tr (fam-lifts A P) (eq-htpy (h ·l H)) ~ (tr-fam-lifts' P h H)
-
-tr-eq-htpy-fam-lifts-refl-htpy :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
-  (h : B → X) (f : A → B) → TR-EQ-HTPY-FAM-LIFTS P h (refl-htpy' f)
-tr-eq-htpy-fam-lifts-refl-htpy P h f k =
-  ap (λ t → tr (fam-lifts _ P) t k) (eq-htpy-refl-htpy (h ∘ f))
-
-abstract
-  tr-eq-htpy-fam-lifts :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
-    (h : B → X) {f g : A → B} (H : f ~ g) →
-    TR-EQ-HTPY-FAM-LIFTS P h H
-  tr-eq-htpy-fam-lifts P h {f} =
-    ind-htpy f
-      ( λ g H → TR-EQ-HTPY-FAM-LIFTS P h H)
-      ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
-
-  compute-tr-eq-htpy-fam-lifts :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
-    (h : B → X) (f : A → B) →
-    Id ( tr-eq-htpy-fam-lifts P h (refl-htpy' f))
-        ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
-  compute-tr-eq-htpy-fam-lifts P h f =
-    compute-ind-htpy f
-      ( λ g H → TR-EQ-HTPY-FAM-LIFTS P h H)
-      ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
-```
-
-One of the basic operations on lifts is precomposition by an ordinary function.
-
-```agda
-precompose-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) → (f : A → B) → (h : B → X) →
-  (fam-lifts B P h) → (fam-lifts A P (h ∘ f))
-precompose-lifts P f h h' a = h' (f a)
-```
-
-Given two homotopic maps, their precomposition functions have different
-codomains. However, there is a commuting triangle. We obtain this triangle by
-homotopy induction.
-
-```agda
-TRIANGLE-PRECOMPOSE-LIFTS :
-  { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  ( P : X → UU l4) {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
-TRIANGLE-PRECOMPOSE-LIFTS {A = A} {B} {X} P {f} {g} H =
-  (h : B → X) →
-    ( (tr (fam-lifts A P) (eq-htpy (h ·l H))) ∘ (precompose-lifts P f h)) ~
-    ( precompose-lifts P g h)
-
-triangle-precompose-lifts-refl-htpy :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) (f : A → B) → TRIANGLE-PRECOMPOSE-LIFTS P (refl-htpy' f)
-triangle-precompose-lifts-refl-htpy {A = A} P f h h' =
-  tr-eq-htpy-fam-lifts-refl-htpy P h f (λ a → h' (f a))
-
-triangle-precompose-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) {f g : A → B} (H : f ~ g) →
-  TRIANGLE-PRECOMPOSE-LIFTS P H
-triangle-precompose-lifts {A = A} P {f} =
-  ind-htpy f
-    ( λ g H → TRIANGLE-PRECOMPOSE-LIFTS P H)
-    ( triangle-precompose-lifts-refl-htpy P f)
-
-compute-triangle-precompose-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) (f : A → B) →
-  Id
-    ( triangle-precompose-lifts P (refl-htpy' f))
-    ( triangle-precompose-lifts-refl-htpy P f)
-compute-triangle-precompose-lifts P f =
-  compute-ind-htpy f
-    ( λ g → TRIANGLE-PRECOMPOSE-LIFTS P)
-    ( triangle-precompose-lifts-refl-htpy P f)
-```
-
-There is a similar commuting triangle with the computed transport function. This
-time we don't use homotopy induction to construct the homotopy. We give an
-explicit definition instead.
-
-```agda
-triangle-precompose-lifts' :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) {f g : A → B} (H : f ~ g) → (h : B → X) →
-  ( (tr-fam-lifts' P h H) ∘ (precompose-lifts P f h)) ~
-  ( precompose-lifts P g h)
-triangle-precompose-lifts' P H h k = eq-htpy (λ a → apd k (H a))
-
-compute-triangle-precompose-lifts' :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) (f : A → B) → (h : B → X) →
-  ( triangle-precompose-lifts' P (refl-htpy' f) h) ~
-  ( refl-htpy' ( precompose-lifts P f h))
-compute-triangle-precompose-lifts' P f h k = eq-htpy-refl-htpy _
-```
-
-There is a coherence between the two commuting triangles. This coherence is
-again constructed by homotopy induction.
-
-```agda
-COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-  {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
-COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS {A = A} {B} {X} P {f} {g} H =
-  (h : B → X) →
-    ( triangle-precompose-lifts P H h) ~
-    ( ( ( tr-eq-htpy-fam-lifts P h H) ·r (precompose-lifts P f h)) ∙h
-      ( triangle-precompose-lifts' P H h))
-
-coherence-triangle-precompose-lifts-refl-htpy :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-  (f : A → B) → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P (refl-htpy' f)
-coherence-triangle-precompose-lifts-refl-htpy P f h =
-  ( htpy-eq (htpy-eq (compute-triangle-precompose-lifts P f) h)) ∙h
-  ( ( ( inv-htpy-right-unit-htpy) ∙h
-      ( ap-concat-htpy
-        ( λ h' → tr-eq-htpy-fam-lifts-refl-htpy P h f (λ a → h' (f a)))
-        ( inv-htpy (compute-triangle-precompose-lifts' P f h)))) ∙h
-    ( htpy-eq
-      ( ap
-        ( λ t →
-          ( t ·r (precompose-lifts P f h)) ∙h
-          ( triangle-precompose-lifts' P refl-htpy h))
-        ( inv (compute-tr-eq-htpy-fam-lifts P h f)))))
-
-abstract
-  coherence-triangle-precompose-lifts :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-    {f g : A → B} (H : f ~ g) → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H
-  coherence-triangle-precompose-lifts P {f} =
-    ind-htpy f
-      ( λ g H → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H)
-      ( coherence-triangle-precompose-lifts-refl-htpy P f)
-
-  compute-coherence-triangle-precompose-lifts :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-    (f : A → B) →
-      Id ( coherence-triangle-precompose-lifts P (refl-htpy' f))
-          ( coherence-triangle-precompose-lifts-refl-htpy P f)
-  compute-coherence-triangle-precompose-lifts P f =
-    compute-ind-htpy f
-      ( λ g H → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H)
-      ( coherence-triangle-precompose-lifts-refl-htpy P f)
-
-total-lifts :
-  {l1 l2 l3 : Level} (A : UU l1) {X : UU l2} (P : X → UU l3) →
-  UU (l1 ⊔ l2 ⊔ l3)
-total-lifts A {X} P = universally-structured-Π {A = A} {B = λ a → X} (λ a → P)
-
-precompose-total-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) → (A → B) →
-  total-lifts B P → total-lifts A P
-precompose-total-lifts {A = A} P f =
-  map-Σ
-    ( λ h → (a : A) → P (h a))
-    ( λ h → h ∘ f)
-    ( precompose-lifts P f)
-
-coherence-square-map-inv-distributive-Π-Σ :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) (f : A → B) →
-  coherence-square-maps
-    ( precompose-total-lifts P f)
-    ( map-inv-distributive-Π-Σ {A = B} {B = λ x → X} {C = λ x y → P y})
-    ( map-inv-distributive-Π-Σ)
-    ( λ h → h ∘ f)
-coherence-square-map-inv-distributive-Π-Σ P f = refl-htpy
-```
-
-Our goal is now to produce a homotopy between `precompose-total-lifts P f` and
-`precompose-total-lifts P g` for homotopic maps `f` and `g`, and a coherence
-filling a cylinder.
-
-```agda
-HTPY-PRECOMPOSE-TOTAL-LIFTS :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) {f g : A → B} (H : f ~ g) →
-  UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
-HTPY-PRECOMPOSE-TOTAL-LIFTS P {f} {g} H =
-  (precompose-total-lifts P f) ~ (precompose-total-lifts P g)
-
-htpy-precompose-total-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-  {f g : A → B} (H : f ~ g) → HTPY-PRECOMPOSE-TOTAL-LIFTS P H
-htpy-precompose-total-lifts {A = A} {B} P {f} {g} H =
-  htpy-map-Σ
-    ( fam-lifts A P)
-    ( λ h → eq-htpy (h ·l H))
-    ( precompose-lifts P f)
-    ( triangle-precompose-lifts P H)
-```
-
-We show that when `htpy-precompose-total-lifts` is applied to `refl-htpy`, it
-computes to `refl-htpy`.
-
-```agda
-tr-id-left-subst :
-  {l1 l2 : Level} {A : UU l1} {B : UU l2} {f : A → B} {x y : A}
-  (p : Id x y) (b : B) → (q : Id (f x) b) →
-  Id (tr (λ (a : A) → Id (f a) b) p q) ((inv (ap f p)) ∙ q)
-tr-id-left-subst refl b q = refl
-
-compute-htpy-precompose-total-lifts :
-  { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-  ( f : A → B) →
-  ( htpy-precompose-total-lifts P (refl-htpy {f = f})) ~
-  ( refl-htpy' (map-Σ (fam-lifts A P) (λ h → h ∘ f) (precompose-lifts P f)))
-compute-htpy-precompose-total-lifts {A = A} P f (pair h h') =
-  let α = λ (t : Id (h ∘ f) (h ∘ f)) → tr (fam-lifts A P) t (λ a → h' (f a))
-  in
-  ap eq-pair-Σ'
-    ( eq-pair-Σ
-      ( eq-htpy-refl-htpy (h ∘ f))
-      ( ( tr-id-left-subst
-          { f = α}
-          ( eq-htpy-refl-htpy (h ∘ f))
-          ( λ a → h' (f a))
-          ( triangle-precompose-lifts P refl-htpy h h')) ∙
-        ( ( ap
-            ( λ t → inv (ap α (eq-htpy-refl-htpy (λ a → h (f a)))) ∙ t)
-            ( htpy-eq
-              ( htpy-eq (compute-triangle-precompose-lifts P f) h) h')) ∙
-          ( left-inv (triangle-precompose-lifts-refl-htpy P f h h')))))
-
-COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-  {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
-COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P {f} {g} H =
-  ( ( coherence-square-map-inv-distributive-Π-Σ P f) ∙h
-    ( map-inv-distributive-Π-Σ ·l ( htpy-precompose-total-lifts P H))) ~
-  ( ( ( λ h → eq-htpy (h ·l H)) ·r map-inv-distributive-Π-Σ) ∙h
-    ( coherence-square-map-inv-distributive-Π-Σ P g))
-
-coherence-inv-htpy-distributive-Π-Σ-refl-htpy :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-  (f : A → B) → COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P (refl-htpy' f)
-coherence-inv-htpy-distributive-Π-Σ-refl-htpy {X = X} P f =
-  ( ap-concat-htpy
-    ( coherence-square-map-inv-distributive-Π-Σ P f)
-    ( λ h →
-      ap
-        ( ap map-inv-distributive-Π-Σ)
-        ( compute-htpy-precompose-total-lifts P f h))) ∙h
-  ( ap-concat-htpy'
-    ( refl-htpy)
-    ( inv-htpy
-      ( λ h →
-        compute-htpy-precomp-refl-htpy f (Σ X P) (map-inv-distributive-Π-Σ h))))
-
-abstract
-  coherence-inv-htpy-distributive-Π-Σ :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-    {f g : A → B} (H : f ~ g) → COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P H
-  coherence-inv-htpy-distributive-Π-Σ P {f} =
-    ind-htpy f
-      ( λ g H → COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P H)
-      ( coherence-inv-htpy-distributive-Π-Σ-refl-htpy P f)
-
-cone-family-dependent-pullback-property :
-  {l1 l2 l3 l4 l : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S → A) (g : S → B) (c : cocone f g X) (P : X → UU l) →
-  cone-family
-    ( fam-lifts S P)
-    ( precompose-lifts P f)
-    ( precompose-lifts P g)
-    ( cone-pullback-property-pushout f g c X)
-    ( fam-lifts X P)
-cone-family-dependent-pullback-property f g c P γ =
-  pair
-    ( precompose-lifts P (pr1 c) γ)
-    ( pair
-      ( precompose-lifts P (pr1 (pr2 c)) γ)
-      ( triangle-precompose-lifts P (pr2 (pr2 c)) γ))
-
-is-pullback-cone-family-dependent-pullback-property :
-  {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S → A) (g : S → B) (c : cocone f g X) →
-  ({l : Level} → pullback-property-pushout l f g c) →
-  {l : Level} (P : X → UU l) (γ : X → X) →
-  is-pullback
-    ( ( tr (fam-lifts S P) (eq-htpy (γ ·l (pr2 (pr2 c))))) ∘
-      ( precompose-lifts P f (γ ∘ (pr1 c))))
-    ( precompose-lifts P g (γ ∘ (pr1 (pr2 c))))
-    ( cone-family-dependent-pullback-property f g c P γ)
-is-pullback-cone-family-dependent-pullback-property {S = S} {A} {B} {X}
-  f g (pair i (pair j H)) pb-c P =
-  let c = pair i (pair j H) in
-  is-pullback-family-is-pullback-tot
-    ( fam-lifts S P)
-    ( precompose-lifts P f)
-    ( precompose-lifts P g)
-    ( cone-pullback-property-pushout f g c X)
-    ( cone-family-dependent-pullback-property f g c P)
-    ( pb-c X)
-    ( is-pullback-top-is-pullback-bottom-cube-is-equiv
-      ( precomp i (Σ X P))
-      ( precomp j (Σ X P))
-      ( precomp f (Σ X P))
-      ( precomp g (Σ X P))
-      ( map-Σ (fam-lifts A P) (precomp i X) (precompose-lifts P i))
-      ( map-Σ (fam-lifts B P) (precomp j X) (precompose-lifts P j))
-      ( map-Σ (fam-lifts S P) (precomp f X) (precompose-lifts P f))
-      ( map-Σ (fam-lifts S P) (precomp g X) (precompose-lifts P g))
-      ( map-inv-distributive-Π-Σ)
-      ( map-inv-distributive-Π-Σ)
-      ( map-inv-distributive-Π-Σ)
-      ( map-inv-distributive-Π-Σ)
-      ( htpy-precompose-total-lifts P H)
-      ( refl-htpy)
-      ( refl-htpy)
-      ( refl-htpy)
-      ( refl-htpy)
-      ( htpy-precomp H (Σ X P))
-      ( coherence-inv-htpy-distributive-Π-Σ P H)
-      ( is-equiv-map-inv-distributive-Π-Σ)
-      ( is-equiv-map-inv-distributive-Π-Σ)
-      ( is-equiv-map-inv-distributive-Π-Σ)
-      ( is-equiv-map-inv-distributive-Π-Σ)
-      ( pb-c (Σ X P)))
-
-dependent-pullback-property-pullback-property-pushout :
-  {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S → A) (g : S → B) (c : cocone f g X) →
-  ({l : Level} → pullback-property-pushout l f g c) →
-  ({l : Level} → dependent-pullback-property-pushout l f g c)
-dependent-pullback-property-pullback-property-pushout
-  {S = S} {A} {B} {X}
-  f g (pair i (pair j H)) pullback-c P =
-  let c = pair i (pair j H) in
-  is-pullback-htpy'
-    -- ( (tr (fam-lifts S P) (eq-htpy (id ·l H))) ∘ (precompose-lifts P f i))
-    ( (tr-eq-htpy-fam-lifts P id H) ·r (precompose-lifts P f i))
-    -- ( precompose-lifts P g j)
-    ( refl-htpy)
-    ( cone-family-dependent-pullback-property f g c P id)
-    { c' = cone-dependent-pullback-property-pushout f g c P}
-    ( pair refl-htpy
-      ( pair refl-htpy
-        ( right-unit-htpy ∙h (coherence-triangle-precompose-lifts P H id))))
-    ( is-pullback-cone-family-dependent-pullback-property f g c pullback-c P id)
-```
-
-This concludes the proof of Theorem 18.1.4.
-
-We give some further useful implications.
-
-```agda
-dependent-universal-property-universal-property-pushout :
-  { l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  ( f : S → A) (g : S → B) (c : cocone f g X) →
-  ( {l : Level} → universal-property-pushout l f g c) →
-  ( {l : Level} → dependent-universal-property-pushout l f g c)
-dependent-universal-property-universal-property-pushout f g c up-X =
-  dependent-universal-property-dependent-pullback-property-pushout f g c
-    ( dependent-pullback-property-pullback-property-pushout f g c
-      ( pullback-property-pushout-universal-property-pushout f g c up-X))
-```
-
 ## Section 16.2 Families over pushouts
 
 ### Definition 18.2.1
@@ -757,163 +307,3 @@ compute-path-fam-Fam-pushout :
 compute-path-fam-Fam-pushout {f = f} {g} c up-X P =
   pr2 (pr2 (pr2 (center (uniqueness-Fam-pushout f g c up-X P))))
 ```
-
-## Section 18.3 The Flattening lemma for pushouts
-
-### Definition 18.3.1
-
-```agda
-{-
-cocone-flattening-pushout :
-  { l1 l2 l3 l4 l5 : Level}
-  { S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  ( f : S → A) (g : S → B) (c : cocone f g X)
-  ( P : Fam-pushout l5 f g)
-  ( Q : X → UU l5)
-  ( e : equiv-Fam-pushout P (desc-fam f g c Q)) →
-  cocone
-    ( map-Σ (pr1 P) f (λ s → id))
-    ( map-Σ (pr1 (pr2 P)) g (λ s → map-equiv (pr2 (pr2 P) s)))
-    ( Σ X Q)
-cocone-flattening-pushout f g c P Q e =
-  pair
-    ( map-Σ Q
-      ( pr1 c)
-      ( λ a → map-equiv (pr1 e a)))
-    ( pair
-      ( map-Σ Q
-        ( pr1 (pr2 c))
-        ( λ b → map-equiv (pr1 (pr2 e) b)))
-      ( htpy-map-Σ Q
-        ( pr2 (pr2 c))
-        ( λ s → map-equiv (pr1 e (f s)))
-        ( λ s → inv-htpy (pr2 (pr2 e) s))))
--}
-```
-
-### Theorem 18.3.2 The flattening lemma
-
-```agda
-{-
-coherence-bottom-flattening-lemma' :
-  {l1 l2 l3 : Level} {B : UU l1} {Q : B → UU l2} {T : UU l3}
-  {b b' : B} (α : Id b b') {y : Q b} {y' : Q b'} (β : Id (tr Q α y) y')
-  (h : (b : B) → Q b → T) → Id (h b y) (h b' y')
-coherence-bottom-flattening-lemma' refl refl h = refl
-
-coherence-bottom-flattening-lemma :
-  {l1 l2 l3 l4 l5 : Level}
-  {A : UU l1} {B : UU l2} {P : A → UU l3} {Q : B → UU l4} {T : UU l5}
-  {f f' : A → B} (H : f ~ f')
-  {g : (a : A) → P a → Q (f a)}
-  {g' : (a : A) → P a → Q (f' a)}
-  (K : (a : A) → ((tr Q (H a)) ∘ (g a)) ~ (g' a))
-  (h : (b : B) → Q b → T) → (a : A) (p : P a) →
-  Id (h (f a) (g a p)) (h (f' a) (g' a p))
-coherence-bottom-flattening-lemma H K h a p =
-  coherence-bottom-flattening-lemma' (H a) (K a p) h
-coherence-cube-flattening-lemma :
-  {l1 l2 l3 l4 l5 : Level}
-  {A : UU l1} {B : UU l2} {P : A → UU l3} {Q : B → UU l4} {T : UU l5}
-  {f f' : A → B} (H : f ~ f')
-  {g : (a : A) → P a → Q (f a)}
-  {g' : (a : A) → P a → Q (f' a)}
-  (K : (a : A) → ((tr Q (H a)) ∘ (g a)) ~ (g' a))
-  (h : Σ B Q → T) →
-  Id ( eq-htpy
-       ( λ a → eq-htpy
-         ( coherence-bottom-flattening-lemma H K (ev-pair h) a)))
-     ( ap ev-pair
-       ( htpy-precomp (htpy-map-Σ Q H g K) T h))
-coherence-cube-flattening-lemma
-  {A = A} {B} {P} {Q} {T} {f = f} {f'} H {g} {g'} K =
-  ind-htpy f
-    ( λ f' H' →
-      (g : (a : A) → P a → Q (f a)) (g' : (a : A) → P a → Q (f' a))
-      (K : (a : A) → ((tr Q (H' a)) ∘ (g a)) ~ (g' a)) (h : Σ B Q → T) →
-      Id ( eq-htpy
-           ( λ a → eq-htpy
-             ( coherence-bottom-flattening-lemma H' K (ev-pair h) a)))
-         ( ap ev-pair
-           ( htpy-precomp (htpy-map-Σ Q H' g K) T h)))
-    ( λ g g' K h → {!ind-htpy g (λ g' K' → (h : Σ B Q → T) →
-      Id ( eq-htpy
-           ( λ a → eq-htpy
-             ( coherence-bottom-flattening-lemma
-                refl-htpy (λ a → htpy-eq (K' a)) (ev-pair h) a)))
-         ( ap ev-pair
-           ( htpy-precomp
-              ( htpy-map-Σ Q refl-htpy g
-                (λ a → htpy-eq (K' a))) T h))) ? (λ a → eq-htpy (K a)) h!})
-    H g g' K
-
-flattening-pushout' :
-  {l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S → A) (g : S → B) (c : cocone f g X) →
-  ( P : Fam-pushout l5 f g)
-  ( Q : X → UU l5)
-  ( e : equiv-Fam-pushout P (desc-fam f g c Q)) →
-  (l : Level) →
-  pullback-property-pushout l
-    ( map-Σ (pr1 P) f (λ s → id))
-    ( map-Σ (pr1 (pr2 P)) g (λ s → map-equiv (pr2 (pr2 P) s)))
-    ( cocone-flattening-pushout f g c P Q e)
-flattening-pushout' f g c P Q e l T =
-  is-pullback-top-is-pullback-bottom-cube-is-equiv
-    ( ( map-Π (λ x → precomp-Π (map-equiv (pr1 e x)) (λ q → T))) ∘
-      ( precomp-Π (pr1 c) (λ x → (Q x) → T)))
-    ( ( map-Π (λ x → precomp-Π (map-equiv (pr1 (pr2 e) x)) (λ q → T))) ∘
-      ( precomp-Π (pr1 (pr2 c)) (λ x → (Q x) → T)))
-    ( precomp-Π f (λ a → (pr1 P a) → T))
-    ( ( map-Π (λ s → precomp (map-equiv (pr2 (pr2 P) s)) T)) ∘
-      ( precomp-Π g (λ b → (pr1 (pr2 P) b) → T)))
-    ( precomp (map-Σ Q (pr1 c) (λ a → map-equiv (pr1 e a))) T)
-    ( precomp (map-Σ Q (pr1 (pr2 c)) (λ b → map-equiv (pr1 (pr2 e) b))) T)
-    ( precomp (map-Σ (pr1 P) f (λ s → id)) T)
-    ( precomp (map-Σ (pr1 (pr2 P)) g (λ s → map-equiv (pr2 (pr2 P) s))) T)
-    ev-pair
-    ev-pair
-    ev-pair
-    ev-pair
-    ( htpy-precomp
-      ( htpy-map-Σ Q
-        ( pr2 (pr2 c))
-        ( λ s → map-equiv (pr1 e (f s)))
-        ( λ s → inv-htpy (pr2 (pr2 e) s)))
-      ( T))
-    refl-htpy
-    refl-htpy
-    refl-htpy
-    refl-htpy
-    ( λ h → eq-htpy (λ s → eq-htpy
-      ( coherence-bottom-flattening-lemma
-        ( pr2 (pr2 c))
-        ( λ s → inv-htpy (pr2 (pr2 e) s))
-        ( h)
-        ( s))))
-    {!!}
-    is-equiv-ev-pair
-    is-equiv-ev-pair
-    is-equiv-ev-pair
-    is-equiv-ev-pair
-    {!!}
-
-flattening-pushout :
-  {l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S → A) (g : S → B) (c : cocone f g X) →
-  ( P : Fam-pushout l5 f g)
-  ( Q : X → UU l5)
-  ( e : equiv-Fam-pushout P (desc-fam f g c Q)) →
-  (l : Level) →
-  universal-property-pushout l
-    ( map-Σ (pr1 P) f (λ s → id))
-    ( map-Σ (pr1 (pr2 P)) g (λ s → map-equiv (pr2 (pr2 P) s)))
-    ( cocone-flattening-pushout f g c P Q e)
-flattening-pushout f g c P Q e l =
-  universal-property-pushout-pullback-property-pushout l
-    ( map-Σ (pr1 P) f (λ s → id))
-    ( map-Σ (pr1 (pr2 P)) g (λ s → map-equiv (pr2 (pr2 P) s)))
-    ( cocone-flattening-pushout f g c P Q e)
-    ( flattening-pushout' f g c P Q e l)
--}
-```
diff --git a/src/synthetic-homotopy-theory/26-id-pushout.lagda.md b/src/synthetic-homotopy-theory/26-id-pushout.lagda.md
index 6871fd856e..9666c7a2e3 100644
--- a/src/synthetic-homotopy-theory/26-id-pushout.lagda.md
+++ b/src/synthetic-homotopy-theory/26-id-pushout.lagda.md
@@ -33,6 +33,7 @@ open import foundation.whiskering-homotopies
 open import synthetic-homotopy-theory.26-descent
 open import synthetic-homotopy-theory.cocones-under-spans
 open import synthetic-homotopy-theory.dependent-cocones-under-spans
+open import synthetic-homotopy-theory.dependent-universal-property-pushouts
 open import synthetic-homotopy-theory.universal-property-pushouts
 ```
 
diff --git a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
index 1f55709c41..2ff8d22e32 100644
--- a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
@@ -8,14 +8,27 @@ module synthetic-homotopy-theory.dependent-pullback-property-pushouts where
 
 ```agda
 open import foundation.action-on-identifications-dependent-functions
+open import foundation.action-on-identifications-functions
 open import foundation.cones-over-cospans
+open import foundation.constant-type-families
 open import foundation.dependent-pair-types
 open import foundation.function-extensionality
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.homotopies
+open import foundation.identity-types
+open import foundation.precomposition-functions
 open import foundation.pullbacks
 open import foundation.transport-along-identifications
+open import foundation.type-theoretic-principle-of-choice
 open import foundation.universe-levels
+open import foundation.whiskering-homotopies
+
+open import orthogonal-factorization-systems.lifts-families-of-elements
+open import orthogonal-factorization-systems.precomposition-lifts-families-of-elements
 
 open import synthetic-homotopy-theory.cocones-under-spans
+open import synthetic-homotopy-theory.pullback-property-pushouts
 ```
 
 </details>
@@ -65,3 +78,213 @@ dependent-pullback-property-pushout l {S} {A} {B} f g {X} (i , j , H) =
     ( λ (h : (b : B) → P (j b)) → λ s → h (g s))
     ( cone-dependent-pullback-property-pushout f g (i , j , H) P)
 ```
+
+## Properties
+
+### The dependent pullback property is logically equivalent to the pullback property
+
+Consider a [cocone](synthetic-homotopy-theory.cocones-under-spans.md)
+
+```text
+        g
+    S -----> B
+    |        |
+  f |        | j
+    V        V
+    A -----> X  .
+        i
+```
+
+The non-dependent pullback property follows from the dependent one by applying
+the dependent pullback property to the constant type family `λ _ → Y`.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
+  (f : S → A) (g : S → B) {X : UU l4} (c : cocone f g X)
+  where
+
+  pullback-property-dependent-pullback-property-pushout :
+    ({l : Level} → dependent-pullback-property-pushout l f g c) →
+    ({l : Level} → pullback-property-pushout l f g c)
+  pullback-property-dependent-pullback-property-pushout dpp-c Y =
+    is-pullback-htpy
+      ( λ h →
+        eq-htpy
+          ( λ s →
+            inv
+              ( tr-constant-type-family
+                ( coherence-square-cocone f g c s)
+                ( h (f s)))))
+      ( refl-htpy)
+      ( cone-dependent-pullback-property-pushout f g c (λ _ → Y))
+      ( ( refl-htpy) ,
+        ( refl-htpy) ,
+        ( λ h →
+          ( right-unit) ∙
+          ( ap
+            ( eq-htpy)
+            ( eq-htpy
+              ( λ s →
+                left-transpose-eq-concat _ _ _
+                  ( inv
+                    ( apd-constant-type-family h
+                      ( coherence-square-cocone f g c s))))) ∙
+          ( eq-htpy-concat-htpy _ _))))
+      ( dpp-c (λ _ → Y))
+```
+
+In the converse direction, we use the fact that by the
+[type theoretic principle of choice](foundation.type-theoretic-principle-of-choice.md),
+dependent functions distribute over Σ-types. That, and a handful of technical
+lemmas about [transport](foundation.transport-along-identifications.md) in
+[precomposed type families](foundation.precomposition-type-families.md) and
+[precomposition](orthogonal-factorization-systems.precomposition-lifts-families-of-elements.md)
+in
+[lifts of families of elements](orthogonal-factorization-systems.lifts-families-of-elements.md),
+allow us to construct the following
+[commuting cube](foundation.commuting-cubes-of-maps.md):
+
+```text
+                                Σ (h : X → X) ((x : X) → P (h x))
+                                       /        |        \
+                                     /          |          \
+                                   /            |            \
+                                 /              |              \
+                               /                |                \
+                             /                  |                  \
+                           /                    |                    \
+                         V                      V                      V
+  Σ (h : A → X) ((a : A) → P (h a))    X → Σ (x : X) (P x)    Σ (h : B → X) ((b : B) → P (h b))
+                         |\             /               \             /|
+                         |  \         /                   \         /  |
+                         |    \     /                       \     /    |
+                         |      \ /                           \ /      |
+                         |      / \                           / \      |
+                         |    /     \                       /     \    |
+                         |  /         \                   /         \  |
+                         VV             V               V             VV
+         A → Σ (x : X) (P x)    Σ (h : S → X) ((s : S) → P (h s))    B → Σ (x : X) (P x)
+                           \                    |                    /
+                             \                  |                  /
+                               \                |                /
+                                 \              |              /
+                                   \            |            /
+                                     \          |          /
+                                       \        |        /
+                                         V      V      V
+                                       S → Σ (x : X) (P x) .
+```
+
+The bottom square is the induced precomposition square for our fixed cocone, so
+by the assumed pullback property, instantiated at the type `Σ (x : X) (P x)`,
+it's a pullback. The top square is constructed by precomposition of maps on the
+first component, and by precomposition of lifts of families of elements on the
+second component. Since vertical maps are equivalences, by the principle of
+choice, and the bottom square is a pullback, we conclude that the top square is
+a pullback.
+
+Observe that restricting the top square to its first component, we again get the
+induced precomposition square, this time instantiated at `X`, so that is also a
+pullback. Hence the top square is a pullback of total spaces over a pullback
+square, which implies that we get a family of pullback squares of the fibers,
+i.e. for every `h : X → X` we have a pullback
+
+```text
+    (x : X) → P (h x) ---------> (b : B) → P (h (j b))
+            | ⌟                           |
+            |                             |
+            |                             |
+            |                             |
+            V                             V
+  (a : A) → P (h (i a)) -----> (s : S) → P (h (j (g s))) ,
+```
+
+and instantiating for `id : X → X` gives us exactly a proof of the dependent
+pullback property.
+
+```agda
+  cone-family-dependent-pullback-property :
+    {l : Level} (P : X → UU l) →
+    cone-family
+      ( lift-family-of-elements P)
+      ( precomp-lift-family-of-elements P f)
+      ( precomp-lift-family-of-elements P g)
+      ( cone-pullback-property-pushout f g c X)
+      ( lift-family-of-elements P)
+  pr1 (cone-family-dependent-pullback-property P γ) h =
+    h ∘ horizontal-map-cocone f g c
+  pr1 (pr2 (cone-family-dependent-pullback-property P γ)) h =
+    h ∘ vertical-map-cocone f g c
+  pr2 (pr2 (cone-family-dependent-pullback-property P γ)) =
+    triangle-precomp-lift-family-of-elements-htpy P γ
+      ( coherence-square-cocone f g c)
+
+  is-pullback-cone-family-dependent-pullback-family :
+    {l : Level} (P : X → UU l) →
+    ({l : Level} → pullback-property-pushout l f g c) →
+    (γ : X → X) →
+    is-pullback
+      ( ( tr
+          ( lift-family-of-elements P)
+          ( htpy-precomp (coherence-square-cocone f g c) X γ)) ∘
+        ( precomp-lift-family-of-elements P f
+          ( γ ∘ horizontal-map-cocone f g c)))
+      ( precomp-lift-family-of-elements P g
+        ( γ ∘ vertical-map-cocone f g c))
+      ( cone-family-dependent-pullback-property P γ)
+  is-pullback-cone-family-dependent-pullback-family P pp-c =
+    is-pullback-family-is-pullback-tot
+      ( lift-family-of-elements P)
+      ( precomp-lift-family-of-elements P f)
+      ( precomp-lift-family-of-elements P g)
+      ( cone-pullback-property-pushout f g c X)
+      ( cone-family-dependent-pullback-property P)
+      ( pp-c X)
+      ( is-pullback-top-is-pullback-bottom-cube-is-equiv
+        ( precomp (horizontal-map-cocone f g c) (Σ X P))
+        ( precomp (vertical-map-cocone f g c) (Σ X P))
+        ( precomp f (Σ X P))
+        ( precomp g (Σ X P))
+        ( precomp-lifted-family-of-elements P (horizontal-map-cocone f g c))
+        ( precomp-lifted-family-of-elements P (vertical-map-cocone f g c))
+        ( precomp-lifted-family-of-elements P f)
+        ( precomp-lifted-family-of-elements P g)
+        ( map-inv-distributive-Π-Σ)
+        ( map-inv-distributive-Π-Σ)
+        ( map-inv-distributive-Π-Σ)
+        ( map-inv-distributive-Π-Σ)
+        ( htpy-precomp-lifted-family-of-elements P
+          ( coherence-square-cocone f g c))
+        ( refl-htpy)
+        ( refl-htpy)
+        ( refl-htpy)
+        ( refl-htpy)
+        ( htpy-precomp (coherence-square-cocone f g c) (Σ X P))
+        ( coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ
+          ( P)
+          ( coherence-square-cocone f g c))
+        ( is-equiv-map-inv-distributive-Π-Σ)
+        ( is-equiv-map-inv-distributive-Π-Σ)
+        ( is-equiv-map-inv-distributive-Π-Σ)
+        ( is-equiv-map-inv-distributive-Π-Σ)
+        ( pp-c (Σ X P)))
+
+  dependent-pullback-property-pullback-property-pushout :
+    ({l : Level} → pullback-property-pushout l f g c) →
+    ({l : Level} → dependent-pullback-property-pushout l f g c)
+  dependent-pullback-property-pullback-property-pushout pp-c P =
+    is-pullback-htpy'
+      ( ( tr-lift-family-of-elements-precomp P id
+          ( coherence-square-cocone f g c)) ·r
+        ( precomp-lift-family-of-elements P f (horizontal-map-cocone f g c)))
+      ( refl-htpy)
+      ( cone-family-dependent-pullback-property P id)
+      { c' = cone-dependent-pullback-property-pushout f g c P}
+      ( ( refl-htpy) ,
+        ( refl-htpy) ,
+        ( ( right-unit-htpy) ∙h
+          ( coherence-triangle-precomp-lift-family-of-elements P id
+            ( coherence-square-cocone f g c))))
+      ( is-pullback-cone-family-dependent-pullback-family P pp-c id)
+```
diff --git a/src/synthetic-homotopy-theory/dependent-universal-property-coequalizers.lagda.md b/src/synthetic-homotopy-theory/dependent-universal-property-coequalizers.lagda.md
index b47ea42d6e..37e4f6b39a 100644
--- a/src/synthetic-homotopy-theory/dependent-universal-property-coequalizers.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-universal-property-coequalizers.lagda.md
@@ -15,7 +15,6 @@ open import foundation.fibers-of-maps
 open import foundation.functoriality-dependent-pair-types
 open import foundation.universe-levels
 
-open import synthetic-homotopy-theory.26-descent
 open import synthetic-homotopy-theory.coforks
 open import synthetic-homotopy-theory.dependent-cocones-under-spans
 open import synthetic-homotopy-theory.dependent-coforks
diff --git a/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
index 0278952857..23a340bb74 100644
--- a/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
@@ -27,6 +27,7 @@ open import synthetic-homotopy-theory.cocones-under-spans
 open import synthetic-homotopy-theory.dependent-cocones-under-spans
 open import synthetic-homotopy-theory.dependent-pullback-property-pushouts
 open import synthetic-homotopy-theory.induction-principle-pushouts
+open import synthetic-homotopy-theory.universal-property-pushouts
 ```
 
 </details>
@@ -128,23 +129,23 @@ htpy-eq-dependent-cocone-map f g c ind-c {P} h h' p =
 dependent-universal-property-pushout-induction-principle-pushout :
   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
   (f : S → A) (g : S → B) {X : UU l4} (c : cocone f g X) →
-  ((l : Level) → induction-principle-pushout l f g c) →
-  ((l : Level) → dependent-universal-property-pushout l f g c)
+  ({l : Level} → induction-principle-pushout l f g c) →
+  ({l : Level} → dependent-universal-property-pushout l f g c)
 dependent-universal-property-pushout-induction-principle-pushout
-  f g c ind-c l P =
+  f g c ind-c P =
   is-equiv-is-invertible
-    ( ind-induction-principle-pushout f g c (ind-c l) P)
-    ( pr2 (ind-c l P))
+    ( ind-induction-principle-pushout f g c ind-c P)
+    ( pr2 (ind-c P))
     ( λ h →
       eq-htpy
         ( htpy-eq-dependent-cocone-map f g c
-          ( ind-c l)
+          ( ind-c)
           ( ind-induction-principle-pushout f g c
-            ( ind-c l)
+            ( ind-c)
             ( P)
             ( dependent-cocone-map f g c P h))
           ( h)
-          ( pr2 (ind-c l P) (dependent-cocone-map f g c P h))))
+          ( pr2 (ind-c P) (dependent-cocone-map f g c P h))))
 ```
 
 #### The dependent universal property of pushouts implies the induction principle of pushouts
@@ -153,11 +154,10 @@ dependent-universal-property-pushout-induction-principle-pushout
 induction-principle-pushout-dependent-universal-property-pushout :
   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
   (f : S → A) (g : S → B) {X : UU l4} (c : cocone f g X) →
-  ((l : Level) → dependent-universal-property-pushout l f g c) →
-  ((l : Level) → induction-principle-pushout l f g c)
+  ({l : Level} → dependent-universal-property-pushout l f g c) →
+  ({l : Level} → induction-principle-pushout l f g c)
 induction-principle-pushout-dependent-universal-property-pushout
-  f g c dup-c l P =
-  pr1 (dup-c l P)
+  f g c dup-c P = pr1 (dup-c P)
 ```
 
 ### The dependent pullback property of pushouts is equivalent to the dependent universal property of pushouts
@@ -184,10 +184,10 @@ triangle-dependent-pullback-property-pushout f g (pair i (pair j H)) P h =
 dependent-pullback-property-dependent-universal-property-pushout :
   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
   (f : S → A) (g : S → B) {X : UU l4} (c : cocone f g X) →
-  ((l : Level) → dependent-universal-property-pushout l f g c) →
-  ((l : Level) → dependent-pullback-property-pushout l f g c)
+  ({l : Level} → dependent-universal-property-pushout l f g c) →
+  ({l : Level} → dependent-pullback-property-pushout l f g c)
 dependent-pullback-property-dependent-universal-property-pushout
-  f g (pair i (pair j H)) I l P =
+  f g (pair i (pair j H)) I P =
   let c = (pair i (pair j H)) in
   is-equiv-top-map-triangle
     ( dependent-cocone-map f g c P)
@@ -201,7 +201,7 @@ dependent-pullback-property-dependent-universal-property-pushout
       ( λ h →
         is-equiv-tot-is-fiberwise-equiv
           ( λ h' → funext (λ x → tr P (H x) (h (f x))) (h' ∘ g))))
-    ( I l P)
+    ( I P)
 ```
 
 #### The dependent pullback property of pushouts implies the dependent universal property of pushouts
@@ -229,3 +229,34 @@ dependent-universal-property-dependent-pullback-property-pushout
         is-equiv-tot-is-fiberwise-equiv
           ( λ h' → funext (λ x → tr P (H x) (h (f x))) (h' ∘ g))))
 ```
+
+### The non-dependent and dependent universal property of pushouts are logically equivalent
+
+This follows from the fact that the
+[dependent pullback property of pushouts](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md)
+is logically equivalent to the
+[pullback property of pushouts](synthetic-homotopy-theory.pullback-property-pushouts.md).
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
+  (f : S → A) (g : S → B) (c : cocone f g X)
+  where
+
+  universal-property-dependent-universal-property-pushout :
+    ({l : Level} → dependent-universal-property-pushout l f g c) →
+    ({l : Level} → universal-property-pushout l f g c)
+  universal-property-dependent-universal-property-pushout dup-c {l} =
+    universal-property-pushout-pullback-property-pushout l f g c
+      ( pullback-property-dependent-pullback-property-pushout f g c
+        ( dependent-pullback-property-dependent-universal-property-pushout f g c
+          ( dup-c)))
+
+  dependent-universal-property-universal-property-pushout :
+    ({l : Level} → universal-property-pushout l f g c) →
+    ({l : Level} → dependent-universal-property-pushout l f g c)
+  dependent-universal-property-universal-property-pushout up-c =
+    dependent-universal-property-dependent-pullback-property-pushout f g c
+      ( dependent-pullback-property-pullback-property-pushout f g c
+        ( pullback-property-pushout-universal-property-pushout f g c up-c))
+```
diff --git a/src/synthetic-homotopy-theory/pushouts.lagda.md b/src/synthetic-homotopy-theory/pushouts.lagda.md
index 599d95be59..bb55f0d156 100644
--- a/src/synthetic-homotopy-theory/pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/pushouts.lagda.md
@@ -21,7 +21,6 @@ open import foundation.retractions
 open import foundation.sections
 open import foundation.universe-levels
 
-open import synthetic-homotopy-theory.26-descent
 open import synthetic-homotopy-theory.cocones-under-spans
 open import synthetic-homotopy-theory.dependent-cocones-under-spans
 open import synthetic-homotopy-theory.dependent-universal-property-pushouts
diff --git a/src/synthetic-homotopy-theory/universal-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/universal-property-pushouts.lagda.md
index 5c419dde39..61273f1b7b 100644
--- a/src/synthetic-homotopy-theory/universal-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/universal-property-pushouts.lagda.md
@@ -59,24 +59,10 @@ map is an equivalence:
 ```
 
 There are several ways of asserting a condition equivalent to the universal
-property of pushouts:
-
-1. The universal property of pushouts
-2. The
-   [pullback property of pushouts](synthetic-homotopy-theory.pullback-property-pushouts.md).
-   This is a restatement of the universal property of pushouts in terms of
-   pullbacks.
-3. The
-   [dependent universal property of pushouts](synthetic-homotopy-theory.dependent-universal-property-pushouts.md).
-   This property characterizes _dependent_ functions out of a pushout
-4. The
-   [dependent pullback property of pushouts](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md).
-   This is a restatement of the dependent universal property of pushouts in
-   terms of pullbacks
-5. The
-   [induction principle of pushouts](synthetic-homotopy-theory.induction-principle-pushouts.md).
-   This weaker form of the dependent universal property of pushouts expresses
-   the induction principle of pushouts seen as higher inductive types.
+property of pushouts. The statements and proofs of mutual equivalence may be
+found in the following table:
+
+{{#include tables/pushouts.md}}
 
 ## Definition
 
diff --git a/tables/pushouts.md b/tables/pushouts.md
new file mode 100644
index 0000000000..f397b801f5
--- /dev/null
+++ b/tables/pushouts.md
@@ -0,0 +1,17 @@
+| Concept                                                                                                          | Location                                                                                                                                 |
+| ---------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
+| (1) **Universal property of pushouts**<br>characterizes functions out of a pushout                               | [`synthetic-homotopy-theory.universal-property-pushouts`](synthetic-homotopy-theory.universal-property-pushouts.md)                      |
+| (2) **Dependent universal property of pushouts**<br>characterizes dependent functions out of a pushout           | [`synthetic-homotopy-theory.dependent-universal-property-pushouts`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md)  |
+| (3) **Pullback property of pushouts**<br>states the universal property in terms of pullbacks                     | [`synthetic-homotopy-theory.pullback-property-pushouts`](synthetic-homotopy-theory.pullback-property-pushouts.md)                        |
+| (4) **Dependent pullback property of pushouts**<br>states the dependent universal property in terms of pullbacks | [`synthetic-homotopy-theory.dependent-pullback-property-pushouts`](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md)    |
+| (5) **Induction principle of pushouts**<br>is the induction principle of pushouts seen as higher inductive types | [`synthetic-homotopy-theory.induction-principle-pushouts`](synthetic-homotopy-theory.induction-principle-pushouts.md)                    |
+| (1) → (2)                                                                                                        | [`dependent-universal-property-universal-property-pushouts`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md)         |
+| (2) → (1)                                                                                                        | [`universal-property-dependent-universal-property-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md)          |
+| (1) → (3)                                                                                                        | [`pullback-property-pushout-universal-property-pushout`](synthetic-homotopy-theory.universal-property-pushouts.md)                       |
+| (3) → (1)                                                                                                        | [`universal-property-pushout-pullback-property-pushout`](synthetic-homotopy-theory.universal-property-pushouts.md)                       |
+| (2) → (4)                                                                                                        | [`dependent-pullback-property-dependent-universal-property-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md) |
+| (4) → (2)                                                                                                        | [`dependent-universal-property-dependent-pullback-property-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md) |
+| (3) → (4)                                                                                                        | [`dependent-pullback-property-pullback-property-pushout`](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md)             |
+| (4) → (3)                                                                                                        | [`pullback-property-dependent-pullback-property-pushout`](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md)             |
+| (2) → (5)                                                                                                        | [`induction-principle-pushout-dependent-universal-property-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md) |
+| (5) → (2)                                                                                                        | [`dependent-universal-property-pushout-induction-principle-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md) |
