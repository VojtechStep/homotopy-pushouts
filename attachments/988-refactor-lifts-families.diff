diff --git a/src/foundation/commuting-squares-of-maps.lagda.md b/src/foundation/commuting-squares-of-maps.lagda.md
index 3df33693bc..93688a63b5 100644
--- a/src/foundation/commuting-squares-of-maps.lagda.md
+++ b/src/foundation/commuting-squares-of-maps.lagda.md
@@ -590,7 +590,7 @@ newly created rectangles, or by first horizontally composing the squares, and
 then vertically composing the rectangles.
 
 The following lemma states that the big squares obtained by these two
-compositions are again homotopic. Diagramatically, we have
+compositions are again homotopic. Diagrammatically, we have
 
 ```text
  H | K   H | K
diff --git a/src/foundation/functoriality-dependent-pair-types.lagda.md b/src/foundation/functoriality-dependent-pair-types.lagda.md
index 929bf7f24c..cdf87ea21b 100644
--- a/src/foundation/functoriality-dependent-pair-types.lagda.md
+++ b/src/foundation/functoriality-dependent-pair-types.lagda.md
@@ -11,6 +11,7 @@ open import foundation-core.functoriality-dependent-pair-types public
 ```agda
 open import foundation.action-on-identifications-functions
 open import foundation.cones-over-cospans
+open import foundation.dependent-homotopies
 open import foundation.dependent-pair-types
 open import foundation.type-arithmetic-dependent-pair-types
 open import foundation.universe-levels
@@ -38,6 +39,101 @@ open import foundation-core.truncation-levels
 
 ## Properties
 
+### The map `htpy-map-Œ£` preserves homotopies
+
+Given a [homotopy](foundation.homotopies.md) `H : f ~ f'` and a family of
+[dependent homotopies](foundation.dependent-homotopies.md) `K a : g a ~ g' a`
+over `H`, expressed as
+[commuting triangles](foundation.commuting-triangles-of-maps.md)
+
+```text
+        g a
+   C a -----> D (f a)
+      \      /
+  g' a \    / tr D (H a)
+        V  V
+      D (f' a)         ,
+```
+
+we get a homotopy `htpy-map-Œ£ H K : map-Œ£ f g ~ map-Œ£ f' g'`.
+
+This assignment itself preserves homotopies: given `H` and `K` as above,
+`H' : f ~ f'` with `K' a : g a ~ g' a` over `H'`, we would like to express
+coherences between the pairs `H, H'` and `K, K'` which would ensure
+`htpy-map-Œ£ H K ~ htpy-map-Œ£ H' K'`. Because `H` and `H'` have the same type, we
+may require a homotopy `Œ± : H ~ H'`, but `K` and `K'` are families of dependent
+homotopies over different homotopies, so their coherence is provided as a family
+of
+[commuting triangles of identifications](foundation.commuting-triangles-of-identifications.md)
+
+```text
+                      ap (Œª p ‚Üí tr D p (g a c)) (Œ± a)
+  tr D (H a) (g a c) --------------------------------- tr D (H' a) (g a c)
+                     \                               /
+                        \                         /
+                           \                   /
+                      K a c   \             /   K' a c
+                                 \       /
+                                    \ /
+                                  g' a c        .
+```
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {C : A ‚Üí UU l3} (D : B ‚Üí UU l4)
+  {f f' : A ‚Üí B} {H H' : f ~ f'}
+  {g : (a : A) ‚Üí C a ‚Üí D (f a)}
+  {g' : (a : A) ‚Üí C a ‚Üí D (f' a)}
+  {K : (a : A) ‚Üí dependent-homotopy (Œª _ ‚Üí D) (Œª _ ‚Üí H a) (g a) (g' a)}
+  {K' : (a : A) ‚Üí dependent-homotopy (Œª _ ‚Üí D) (Œª _ ‚Üí H' a) (g a) (g' a)}
+  where
+
+  abstract
+    htpy-htpy-map-Œ£ :
+      (Œ± : H ~ H') ‚Üí
+      (Œ≤ :
+        (a : A) (c : C a) ‚Üí
+        K a c Ôºù ap (Œª p ‚Üí tr D p (g a c)) (Œ± a) ‚àô K' a c) ‚Üí
+      htpy-map-Œ£ D H g K ~ htpy-map-Œ£ D H' g K'
+    htpy-htpy-map-Œ£ Œ± Œ≤ (a , c) =
+      ap
+        ( eq-pair-Œ£')
+        ( eq-pair-Œ£
+          ( Œ± a)
+          ( map-compute-dependent-identification-eq-value-function
+            ( Œª p ‚Üí tr D p (g a c))
+            ( Œª _ ‚Üí g' a c)
+            ( Œ± a)
+            ( K a c)
+            ( K' a c)
+            ( inv
+              ( ( ap
+                  ( K a c ‚àô_)
+                  ( ap-const (g' a c) (Œ± a))) ‚àô
+                ( right-unit) ‚àô
+                ( Œ≤ a c)))))
+```
+
+As a corollary of the above statement, we can provide a condition which
+guarantees that `htpy-map-Œ£` is homotopic to the trivial homotopy.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {C : A ‚Üí UU l3} (D : B ‚Üí UU l4)
+  {f : A ‚Üí B} {H : f ~ f}
+  {g : (a : A) ‚Üí C a ‚Üí D (f a)}
+  {K : (a : A) ‚Üí tr D (H a) ‚àò g a ~ g a}
+  where
+
+  abstract
+    htpy-htpy-map-Œ£-refl-htpy :
+      (Œ± : H ~ refl-htpy) ‚Üí
+      (Œ≤ : (a : A) (c : C a) ‚Üí K a c Ôºù ap (Œª p ‚Üí tr D p (g a c)) (Œ± a)) ‚Üí
+      htpy-map-Œ£ D H g K ~ refl-htpy
+    htpy-htpy-map-Œ£-refl-htpy Œ± Œ≤ =
+      htpy-htpy-map-Œ£ D Œ± (Œª a c ‚Üí Œ≤ a c ‚àô inv right-unit)
+```
+
 ### The map on total spaces induced by a family of truncated maps is truncated
 
 ```agda
diff --git a/src/foundation/precomposition-type-families.lagda.md b/src/foundation/precomposition-type-families.lagda.md
index fea1ef916a..c257e0b17c 100644
--- a/src/foundation/precomposition-type-families.lagda.md
+++ b/src/foundation/precomposition-type-families.lagda.md
@@ -7,9 +7,14 @@ module foundation.precomposition-type-families where
 <details><summary>Imports</summary>
 
 ```agda
+open import foundation.homotopy-induction
+open import foundation.transport-along-homotopies
 open import foundation.universe-levels
 
 open import foundation-core.function-types
+open import foundation-core.homotopies
+open import foundation-core.identity-types
+open import foundation-core.whiskering-homotopies
 ```
 
 </details>
@@ -35,6 +40,50 @@ module _
   {l1 l2 : Level} {A : UU l1} {B : UU l2} (f : A ‚Üí B)
   where
 
-  precomp-family : (l : Level) ‚Üí (B ‚Üí UU l) ‚Üí (A ‚Üí UU l)
-  precomp-family l Q = Q ‚àò f
+  precomp-family : {l : Level} ‚Üí (B ‚Üí UU l) ‚Üí (A ‚Üí UU l)
+  precomp-family Q = Q ‚àò f
+```
+
+## Properties
+
+### Transport along homotopies in precomposed type families
+
+[Transporting](foundation.transport-along-homotopies.md) along a
+[homotopy](foundation.homotopies.md) `H : g ~ h` in the family `Q ‚àò f` gives us
+a map of families of elements
+
+```text
+  ((a : A) ‚Üí Q (f (g a))) ‚Üí ((a : A) ‚Üí Q (f (h a))) .
+```
+
+We show that this map is homotopic to transporting along
+`f ¬∑l H : f ‚àò g ~ f ‚àò h` in the family `Q`.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} (f : A ‚Üí B) (Q : B ‚Üí UU l3)
+  {X : UU l4} {g : X ‚Üí A}
+  where
+
+  statement-tr-htpy-precomp-family :
+    {h : X ‚Üí A} (H : g ~ h) ‚Üí UU (l3 ‚äî l4)
+  statement-tr-htpy-precomp-family H =
+    tr-htpy (Œª _ ‚Üí precomp-family f Q) H ~ tr-htpy (Œª _ ‚Üí Q) (f ¬∑l H)
+
+  abstract
+    tr-htpy-precomp-family :
+      {h : X ‚Üí A} (H : g ~ h) ‚Üí
+      statement-tr-htpy-precomp-family H
+    tr-htpy-precomp-family =
+      ind-htpy g
+        ( Œª h ‚Üí statement-tr-htpy-precomp-family)
+        ( refl-htpy)
+
+    compute-tr-htpy-precomp-family :
+      tr-htpy-precomp-family refl-htpy Ôºù
+      refl-htpy
+    compute-tr-htpy-precomp-family =
+      compute-ind-htpy g
+        ( Œª h ‚Üí statement-tr-htpy-precomp-family)
+        ( refl-htpy)
 ```
diff --git a/src/foundation/type-theoretic-principle-of-choice.lagda.md b/src/foundation/type-theoretic-principle-of-choice.lagda.md
index 031a9289b0..605aec74bc 100644
--- a/src/foundation/type-theoretic-principle-of-choice.lagda.md
+++ b/src/foundation/type-theoretic-principle-of-choice.lagda.md
@@ -37,6 +37,10 @@ In this file we record some further facts about the
 [structures](foundation.structure.md) introduced in
 [`foundation-core.type-theoretic-principle-of-choice`](foundation-core.type-theoretic-principle-of-choice.md).
 
+We relate precomposition of maps into a dependent pair type by a function with
+precomposition in dependent pair types of functions in the file
+[`orthogonal-factorization-systems.precomposition-lifts-families-of-elements`](orthogonal-factorization-systems.precomposition-lifts-families-of-elements.md).
+
 ## Lemma
 
 ### Characterizing the identity type of `universally-structured-Œ†`
diff --git a/src/foundation/whiskering-homotopies.lagda.md b/src/foundation/whiskering-homotopies.lagda.md
index bfe1cc284d..07ce4de860 100644
--- a/src/foundation/whiskering-homotopies.lagda.md
+++ b/src/foundation/whiskering-homotopies.lagda.md
@@ -115,7 +115,7 @@ may be whiskered by a homotopy `L` on the left or right, which results in a
 commuting square of homotopies with `L` appended or prepended to the two ways of
 going around the square.
 
-Diagramatically, we may turn the pasting diagram
+Diagrammatically, we may turn the pasting diagram
 
 ```text
         H
diff --git a/src/orthogonal-factorization-systems.lagda.md b/src/orthogonal-factorization-systems.lagda.md
index 528701370e..44d745a65d 100644
--- a/src/orthogonal-factorization-systems.lagda.md
+++ b/src/orthogonal-factorization-systems.lagda.md
@@ -46,6 +46,7 @@ open import orthogonal-factorization-systems.null-types public
 open import orthogonal-factorization-systems.open-modalities public
 open import orthogonal-factorization-systems.orthogonal-factorization-systems public
 open import orthogonal-factorization-systems.orthogonal-maps public
+open import orthogonal-factorization-systems.precomposition-lifts-families-of-elements public
 open import orthogonal-factorization-systems.pullback-hom public
 open import orthogonal-factorization-systems.raise-modalities public
 open import orthogonal-factorization-systems.reflective-modalities public
diff --git a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
index 6155ddf59e..c0e5399585 100644
--- a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
@@ -7,6 +7,15 @@ module orthogonal-factorization-systems.lifts-families-of-elements where
 <details><summary>Imports</summary>
 
 ```agda
+open import foundation.action-on-identifications-functions
+open import foundation.dependent-pair-types
+open import foundation.homotopies
+open import foundation.homotopy-induction
+open import foundation.identity-types
+open import foundation.precomposition-functions
+open import foundation.precomposition-type-families
+open import foundation.transport-along-homotopies
+open import foundation.transport-along-identifications
 open import foundation.universe-levels
 ```
 
@@ -38,6 +47,42 @@ elements `a` is a family of elements
   (i : I) ‚Üí B (a i).
 ```
 
+A family of elements equipped with a dependent lift is a
+{{#concept "dependent lifted family of elements"}}, and analogously a family of
+elements equipped with a lift is a {{#concept "lifted family of elements"}}.
+
+To see how these families relate to
+[lifts of maps](orthogonal-factorization-systems.lifts-of-maps.md), consider the
+lifting diagram
+
+```text
+      Œ£ (x : A) (B x)
+            |
+            | pr1
+            |
+            v
+  I ------> A         .
+       a
+```
+
+Then a lift of the map `a` against `pr1` is a map `b : I ‚Üí Œ£ A B`, such that the
+triangle commutes. Invoking the
+[type theoretic principle of choice](foundation.type-theoretic-principle-of-choice.md),
+we can show that this type is equivalent to the type of families of elements
+`(i : I) ‚Üí B (a i)`:
+
+```text
+  Œ£ (b : I ‚Üí Œ£ A B) ((i : I) ‚Üí a i Ôºù pr1 (b i))
+    ‚âÉ (i : I) ‚Üí Œ£ ((x , b) : Œ£ A B) (a i Ôºù x)
+    ‚âÉ (i : I) ‚Üí Œ£ (x : A) (a i Ôºù x √ó B x)
+    ‚âÉ (i : I) ‚Üí B (a i) .
+```
+
+The first equivalence is the principle of choice, the second is associativity of
+dependent pair types, and the third is the left unit law of dependent pair
+types, since `Œ£ (x : A) (a i Ôºù x)` is
+[contractible](foundation.contractible-types.md).
+
 ## Definitions
 
 ### Dependent lifts of families of elements
@@ -63,6 +108,31 @@ module _
   lift-family-of-elements = dependent-lift-family-of-elements (Œª _ ‚Üí B) a
 ```
 
+### Dependent lifted families of elements
+
+```agda
+module _
+  {l1 l2 l3 : Level} {I : UU l1} (A : I ‚Üí UU l2) (B : (i : I) ‚Üí A i ‚Üí UU l3)
+  where
+
+  dependent-lifted-family-of-elements : UU (l1 ‚äî l2 ‚äî l3)
+  dependent-lifted-family-of-elements =
+    Œ£ ( (i : I) ‚Üí A i)
+      ( dependent-lift-family-of-elements B)
+```
+
+### Lifted families of elements
+
+```agda
+module _
+  {l1 l2 l3 : Level} (I : UU l1) {A : UU l2} (B : A ‚Üí UU l3)
+  where
+
+  lifted-family-of-elements : UU (l1 ‚äî l2 ‚äî l3)
+  lifted-family-of-elements =
+    dependent-lifted-family-of-elements (Œª (_ : I) ‚Üí A) (Œª _ ‚Üí B)
+```
+
 ### Dependent lifts of binary families of elements
 
 ```agda
@@ -89,6 +159,58 @@ module _
     dependent-lift-binary-family-of-elements (Œª _ ‚Üí C) a
 ```
 
+## Properties
+
+### Transport in lifts of families of elements along homotopies of precompositions
+
+Given a map `a : I ‚Üí A`, and a homotopy `H : f ~ g`, where `f, g : J ‚Üí I`, we
+know that there is an identification `a ‚àò f Ôºù a ‚àò g`. Transporting along this
+identification in the type of lifts of families of elements into a type family
+`B : A ‚Üí ùì§`, we get a map
+
+```text
+  ((j : J) ‚Üí B (a (f j))) ‚Üí ((j : J) ‚Üí B (a (g j))) .
+```
+
+We show that this map is homotopic to transporting along `H` in the type family
+`B ‚àò a : I ‚Üí ùì§`.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A ‚Üí UU l3) (a : I ‚Üí A)
+  {J : UU l4} {f : J ‚Üí I}
+  where
+
+  statement-tr-lift-family-of-elements-precomp :
+    {g : J ‚Üí I} (H : f ~ g) ‚Üí UU (l3 ‚äî l4)
+  statement-tr-lift-family-of-elements-precomp H =
+    tr (lift-family-of-elements B) (htpy-precomp H A a) ~
+    tr-htpy (Œª _ ‚Üí precomp-family a B) H
+
+  tr-lift-family-of-elements-precomp-refl-htpy :
+    statement-tr-lift-family-of-elements-precomp refl-htpy
+  tr-lift-family-of-elements-precomp-refl-htpy b =
+    ap
+      ( Œª p ‚Üí tr (lift-family-of-elements B) p b)
+      ( compute-htpy-precomp-refl-htpy f A a)
+
+  abstract
+    tr-lift-family-of-elements-precomp :
+      {g : J ‚Üí I} (H : f ~ g) ‚Üí statement-tr-lift-family-of-elements-precomp H
+    tr-lift-family-of-elements-precomp =
+      ind-htpy f
+        ( Œª g ‚Üí statement-tr-lift-family-of-elements-precomp)
+        ( tr-lift-family-of-elements-precomp-refl-htpy)
+
+    compute-tr-lift-family-of-elements-precomp :
+      tr-lift-family-of-elements-precomp refl-htpy Ôºù
+      tr-lift-family-of-elements-precomp-refl-htpy
+    compute-tr-lift-family-of-elements-precomp =
+      compute-ind-htpy f
+        ( Œª g ‚Üí statement-tr-lift-family-of-elements-precomp)
+        ( tr-lift-family-of-elements-precomp-refl-htpy)
+```
+
 ## See also
 
 - [Double lifts of families of elements](orthogonal-factorization-systems.double-lifts-families-of-elements.md)
diff --git a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
new file mode 100644
index 0000000000..1cc89a4539
--- /dev/null
+++ b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
@@ -0,0 +1,357 @@
+# Precomposition of lifts of families of elements by maps
+
+```agda
+module orthogonal-factorization-systems.precomposition-lifts-families-of-elements where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.action-on-identifications-dependent-functions
+open import foundation.commuting-squares-of-homotopies
+open import foundation.commuting-squares-of-maps
+open import foundation.commuting-triangles-of-maps
+open import foundation.dependent-pair-types
+open import foundation.function-extensionality
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.homotopies
+open import foundation.homotopy-induction
+open import foundation.identity-types
+open import foundation.path-algebra
+open import foundation.precomposition-functions
+open import foundation.transport-along-identifications
+open import foundation.type-theoretic-principle-of-choice
+open import foundation.universe-levels
+open import foundation.whiskering-homotopies
+
+open import orthogonal-factorization-systems.lifts-families-of-elements
+```
+
+</details>
+
+## Idea
+
+Consider a type family `B : A ‚Üí ùì§` and a map `a : I ‚Üí A`. Then, given a map
+`f : J ‚Üí I`, we may pull back a
+[lift](orthogonal-factorization-systems.lifts-families-of-elements.md) of `a` to
+a lift of `a ‚àò f`.
+
+In other words, given a diagram
+
+```text
+                Œ£ (x : A) (B x)
+                      |
+                      | pr1
+                      |
+                      v
+  J ------> I ------> A         ,
+       f         a
+```
+
+we get a map of lifts of families of elements
+
+```text
+  ((i : I) ‚Üí B (a i)) ‚Üí ((j : J) ‚Üí B (a (f j))) .
+```
+
+This map of lifts induces a map from lifted families of elements indexed by `I`
+to lifted families of elements indexed by `J`.
+
+## Definitions
+
+### Precomposition of lifts of families of elements by functions
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A ‚Üí UU l3) {J : UU l4}
+  (f : J ‚Üí I)
+  where
+
+  precomp-lift-family-of-elements :
+    (a : I ‚Üí A) ‚Üí
+    lift-family-of-elements B a ‚Üí lift-family-of-elements B (a ‚àò f)
+  precomp-lift-family-of-elements a b i = b (f i)
+```
+
+### Precomposition in lifted families of elements
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A ‚Üí UU l3) {J : UU l4}
+  (f : J ‚Üí I)
+  where
+
+  precomp-lifted-family-of-elements :
+    lifted-family-of-elements I B ‚Üí lifted-family-of-elements J B
+  precomp-lifted-family-of-elements =
+    map-Œ£
+      ( lift-family-of-elements B)
+      ( precomp f A)
+      ( precomp-lift-family-of-elements B f)
+```
+
+## Properties
+
+### Homotopies between maps induce commuting triangles of precompositions of lifts of families of elements
+
+Consider two maps `f, g : J ‚Üí I` and a homotopy `H : f ~ g` between them. The
+precomposition functions they induce on lifts of families of elements have
+different codomains, namely `lift-family-of-elements B (a ‚àò f)` and
+`lift-family-of-elements B (a ‚àò g)`, but they fit into a
+[commuting triangle](foundation.commuting-triangles-of-maps.md) with
+[transport](foundation.transport-along-identifications.md) in the type of lifts:
+
+```text
+                              precomp-lift B f a
+  lift-family-of-elements B a ------------------> lift-family-of-elements B (a ‚àò f)
+                      \                                /
+                         \                          /
+                            \                    /
+           precomp-lift B g a  \              / tr (lift-family-of-elements B) (htpy-precomp H A a)
+                                  \        /
+                                     V  V
+                       lift-family-of-elements B (a ‚àò g)
+```
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A ‚Üí UU l3) (a : I ‚Üí A)
+  {J : UU l4} {f : J ‚Üí I}
+  where
+
+  statement-triangle-precomp-lift-family-of-elements-htpy :
+    {g : J ‚Üí I} (H : f ~ g) ‚Üí UU (l1 ‚äî l3 ‚äî l4)
+  statement-triangle-precomp-lift-family-of-elements-htpy {g} H =
+    coherence-triangle-maps'
+      ( precomp-lift-family-of-elements B g a)
+      ( tr (lift-family-of-elements B) (htpy-precomp H A a))
+      ( precomp-lift-family-of-elements B f a)
+
+  triangle-precomp-lift-family-of-elements-htpy-refl-htpy :
+    statement-triangle-precomp-lift-family-of-elements-htpy refl-htpy
+  triangle-precomp-lift-family-of-elements-htpy-refl-htpy b =
+    tr-lift-family-of-elements-precomp B a refl-htpy (b ‚àò f)
+
+  abstract
+    triangle-precomp-lift-family-of-elements-htpy :
+      {g : J ‚Üí I} (H : f ~ g) ‚Üí
+      statement-triangle-precomp-lift-family-of-elements-htpy H
+    triangle-precomp-lift-family-of-elements-htpy =
+      ind-htpy f
+        ( Œª g ‚Üí statement-triangle-precomp-lift-family-of-elements-htpy)
+        ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
+
+    compute-triangle-precomp-lift-family-of-elements-htpy :
+      triangle-precomp-lift-family-of-elements-htpy refl-htpy Ôºù
+      triangle-precomp-lift-family-of-elements-htpy-refl-htpy
+    compute-triangle-precomp-lift-family-of-elements-htpy =
+      compute-ind-htpy f
+        ( Œª g ‚Üí statement-triangle-precomp-lift-family-of-elements-htpy)
+        ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
+```
+
+### `triangle-precomp-lift-family-of-elements-htpy` factors through transport along a homotopy in the famiy `B ‚àò a`
+
+Instead of defining the homotopy `triangle-precomp-lift-family-of-elements-htpy`
+by homotopy induction, we could have defined it manually using the
+characterization of transport in the type of lifts of a family of elements.
+
+We show that these two definitions are homotopic.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A ‚Üí UU l3) (a : I ‚Üí A)
+  {J : UU l4} {f : J ‚Üí I}
+  where
+
+  statement-coherence-triangle-precomp-lift-family-of-elements :
+    {g : J ‚Üí I} (H : f ~ g) ‚Üí UU (l1 ‚äî l3 ‚äî l4)
+  statement-coherence-triangle-precomp-lift-family-of-elements H =
+    ( triangle-precomp-lift-family-of-elements-htpy B a H) ~
+    ( ( ( tr-lift-family-of-elements-precomp B a H) ¬∑r
+        ( precomp-lift-family-of-elements B f a)) ‚àôh
+      ( Œª b ‚Üí eq-htpy (Œª j ‚Üí apd b (H j))))
+
+  coherence-triangle-precomp-lift-family-of-elements-refl-htpy :
+    statement-coherence-triangle-precomp-lift-family-of-elements
+      ( refl-htpy)
+  coherence-triangle-precomp-lift-family-of-elements-refl-htpy b =
+    ( htpy-eq (compute-triangle-precomp-lift-family-of-elements-htpy B a) b) ‚àô
+    ( inv right-unit) ‚àô
+    ( identification-left-whisk
+      ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy B a b)
+      ( inv (eq-htpy-refl-htpy (b ‚àò f))))
+
+  abstract
+    coherence-triangle-precomp-lift-family-of-elements :
+      {g : J ‚Üí I} (H : f ~ g) ‚Üí
+      statement-coherence-triangle-precomp-lift-family-of-elements H
+    coherence-triangle-precomp-lift-family-of-elements =
+      ind-htpy f
+        ( Œª g ‚Üí
+          statement-coherence-triangle-precomp-lift-family-of-elements)
+        ( coherence-triangle-precomp-lift-family-of-elements-refl-htpy)
+
+    compute-coherence-triangle-precomp-lift-family-of-elements :
+      coherence-triangle-precomp-lift-family-of-elements refl-htpy Ôºù
+      coherence-triangle-precomp-lift-family-of-elements-refl-htpy
+    compute-coherence-triangle-precomp-lift-family-of-elements =
+      compute-ind-htpy f
+        ( Œª g ‚Üí
+          statement-coherence-triangle-precomp-lift-family-of-elements)
+        ( coherence-triangle-precomp-lift-family-of-elements-refl-htpy)
+```
+
+### `precomp-lifted-family-of-elements` is homotopic to the precomposition map on functions up to equivalence
+
+We have a [commuting square](foundation.commuting-squares-of-maps.md) like this:
+
+```text
+                                     precomp-lifted-family f
+  Œ£ (a : I ‚Üí A) ((i : I) ‚Üí B (a i)) ------------------------> Œ£ (a : J ‚Üí A) ((j : J) ‚Üí B (a j))
+                  |                                                           |
+                  |                                                           |
+                  | map-inv-distributive-Œ†-Œ£    ‚áó    map-inv-distributive-Œ†-Œ£ |
+                  |                                                           |
+                  V                                                           V
+              I ‚Üí Œ£ A B ------------------------------------------------> J ‚Üí Œ£ A B ,
+                                               - ‚àò f
+```
+
+which shows that `precomp-lifted-family-of-elements f` is a good choice for a
+precomposition map in the type of lifted families of elements, since it's
+homotopic to the regular precomposition map up to equivalence.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A ‚Üí UU l3) {J : UU l4}
+  (f : J ‚Üí I)
+  where
+
+  coherence-square-precomp-map-inv-distributive-Œ†-Œ£ :
+    coherence-square-maps
+      ( precomp-lifted-family-of-elements B f)
+      ( map-inv-distributive-Œ†-Œ£)
+      ( map-inv-distributive-Œ†-Œ£)
+      ( precomp f (Œ£ A B))
+  coherence-square-precomp-map-inv-distributive-Œ†-Œ£ = refl-htpy
+```
+
+### Precomposition of lifted families of elements preserves homotopies
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A ‚Üí UU l3) {J : UU l4}
+  {f : J ‚Üí I}
+  where
+
+  htpy-precomp-lifted-family-of-elements :
+    {g : J ‚Üí I} (H : f ~ g) ‚Üí
+    ( precomp-lifted-family-of-elements B f) ~
+    ( precomp-lifted-family-of-elements B g)
+  htpy-precomp-lifted-family-of-elements H =
+    htpy-map-Œ£
+      ( lift-family-of-elements B)
+      ( htpy-precomp H A)
+      ( precomp-lift-family-of-elements B f)
+      ( Œª a ‚Üí triangle-precomp-lift-family-of-elements-htpy B a H)
+
+  abstract
+    compute-htpy-precomp-lifted-family-of-elements :
+      htpy-precomp-lifted-family-of-elements refl-htpy ~
+      refl-htpy
+    compute-htpy-precomp-lifted-family-of-elements =
+      htpy-htpy-map-Œ£-refl-htpy
+        ( lift-family-of-elements B)
+        ( compute-htpy-precomp-refl-htpy f A)
+        ( Œª a ‚Üí
+          ( htpy-eq
+            ( compute-triangle-precomp-lift-family-of-elements-htpy B a)) ‚àôh
+          ( Œª b ‚Üí
+            htpy-eq (compute-tr-lift-family-of-elements-precomp B a) (b ‚àò f)))
+```
+
+### `coherence-square-precomp-map-inv-distributive-Œ†-Œ£` commutes with induced homotopies between precompositions maps
+
+Diagrammatically, we have two ways of composing homotopies to connect `- ‚àò f`
+and `precomp-lifted-family-of-elements g`. One factors through
+`precomp-lifted-family-of-elements f`:
+
+```text
+                                     precomp-lifted-family g
+                               -----------------------------------
+                             /                                     \
+                           /     ‚áó htpy-precomp-lifted-family H      \
+                         /                                             V
+  Œ£ (a : I ‚Üí A) ((i : I) ‚Üí B (a i)) ------------------------> Œ£ (a : J ‚Üí A) ((j : J) ‚Üí B (a j))
+                  |                  precomp-lifted-family f                  |
+                  |                                                           |
+                  |                             ‚áó                             |
+                  | map-inv-distributive-Œ†-Œ£         map-inv-distributive-Œ†-Œ£ |
+                  V                                                           V
+              I ‚Üí Œ£ A B ------------------------------------------------> J ‚Üí Œ£ A B ,
+                                              - ‚àò f
+```
+
+while the other factors through `- ‚àò g`:
+
+```text
+                                     precomp-lifted-family g
+  Œ£ (a : I ‚Üí A) ((i : I) ‚Üí B (a i)) ------------------------> Œ£ (a : J ‚Üí A) ((j : J) ‚Üí B (a j))
+                  |                                                           |
+                  |                                                           |
+                  | map-inv-distributive-Œ†-Œ£    ‚áó    map-inv-distributive-Œ†-Œ£ |
+                  |                                                           |
+                  V                           - ‚àò g                           V
+              I ‚Üí Œ£ A B ------------------------------------------------> J ‚Üí Œ£ A B .
+                        \                                               >
+                          \             ‚áó  htpy-precomp H             /
+                            \                                       /
+                              -------------------------------------
+                                              - ‚àò f
+```
+
+We show that these homotopies are themselves homotopic, filling the cylinder.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A ‚Üí UU l3) {J : UU l4}
+  {f : J ‚Üí I}
+  where
+
+  statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Œ†-Œ£ :
+    {g : J ‚Üí I} (H : f ~ g) ‚Üí UU (l1 ‚äî l2 ‚äî l3 ‚äî l4)
+  statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Œ†-Œ£
+    {g} H =
+    coherence-square-homotopies
+      ( htpy-precomp H (Œ£ A B) ¬∑r map-inv-distributive-Œ†-Œ£)
+      ( coherence-square-precomp-map-inv-distributive-Œ†-Œ£ B f)
+      ( coherence-square-precomp-map-inv-distributive-Œ†-Œ£ B g)
+      ( ( map-inv-distributive-Œ†-Œ£) ¬∑l
+        ( htpy-precomp-lifted-family-of-elements B H))
+
+  coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Œ†-Œ£-refl-htpy :
+    statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Œ†-Œ£
+      ( refl-htpy)
+  coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Œ†-Œ£-refl-htpy =
+    ( ap-left-whisk-htpy
+      ( map-inv-distributive-Œ†-Œ£)
+      ( compute-htpy-precomp-lifted-family-of-elements B)) ‚àôh
+    ( inv-htpy
+      ( Œª h ‚Üí
+        compute-htpy-precomp-refl-htpy f
+          ( Œ£ A B)
+          ( map-inv-distributive-Œ†-Œ£ h))) ‚àôh
+    ( inv-htpy-right-unit-htpy)
+
+  coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Œ†-Œ£ :
+    {g : J ‚Üí I} (H : f ~ g) ‚Üí
+    statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Œ†-Œ£
+      ( H)
+  coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Œ†-Œ£ =
+    ind-htpy f
+      ( Œª g ‚Üí
+        statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Œ†-Œ£)
+      ( coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Œ†-Œ£-refl-htpy)
+```
diff --git a/src/synthetic-homotopy-theory/26-descent.lagda.md b/src/synthetic-homotopy-theory/26-descent.lagda.md
index dc40055258..79e084feb2 100644
--- a/src/synthetic-homotopy-theory/26-descent.lagda.md
+++ b/src/synthetic-homotopy-theory/26-descent.lagda.md
@@ -47,456 +47,6 @@ open import synthetic-homotopy-theory.universal-property-pushouts
 
 </details>
 
-### Remark 18.1.3 Computation of the identity type of `dependent-cocone`
-
-Before we state the main theorem of this section, we also state a dependent
-version of the pullback property of pushouts.
-
-## Theorem 18.1.4
-
-    The following properties are all equivalent:
-
-    1. universal-property-pushout
-    2. pullback-property-pushout
-    3. dependent-pullback-property-pushout
-    4. dependent-universal-property-pushout
-    5. Ind-pushout
-
-We have already shown (1) ‚Üî (2). Therefore we will first show (3) ‚Üî (4) ‚Üî (5).
-Finally, we will show (2) ‚Üî (3). Here are the precise references to the proofs
-of those parts:
-
-- Proof of (1) ‚Üí (2): `pullback-property-pushout-universal-property-pushout`
-- Proof of (2) ‚Üí (1): `universal-property-pushout-pullback-property-pushout`
-- Proof of (2) ‚Üí (3): `dependent-pullback-property-pullback-property-pushout`
-- Proof of (3) ‚Üí (2): `pullback-property-dependent-pullback-property-pushout`
-- Proof of (3) ‚Üí (4):
-  `dependent-universal-property-dependent-pullback-property-pushout`
-- Proof of (4) ‚Üí (3):
-  `dependent-pullback-property-dependent-universal-property-pushout`
-- Proof of (4) ‚Üí (5): `Ind-pushout-dependent-universal-property-pushout`
-- Proof of (5) ‚Üí (4): `dependent-universal-property-pushout-Ind-pushout`
-
-### Proof of Theorem 18.1.4, (3) implies (2)
-
-```agda
-pullback-property-dependent-pullback-property-pushout :
-  {l1 l2 l3 l4 : Level} (l : Level) {S : UU l1} {A : UU l2} {B : UU l3}
-  (f : S ‚Üí A) (g : S ‚Üí B) {X : UU l4} (c : cocone f g X) ‚Üí
-  dependent-pullback-property-pushout l f g c ‚Üí
-  pullback-property-pushout l f g c
-pullback-property-dependent-pullback-property-pushout
-  l f g (pair i (pair j H)) dpb Y =
-  is-pullback-htpy
-    -- ( Œª h s ‚Üí tr (Œª x ‚Üí Y) (H s) (h (f s)))
-    ( Œª h ‚Üí eq-htpy (Œª s ‚Üí inv (tr-constant-type-family (H s) (h (f s)))))
-    -- ( _‚àò g)
-    ( refl-htpy)
-    { c = pair
-      ( _‚àò i)
-      ( pair (_‚àò j) (Œª h ‚Üí eq-htpy (h ¬∑l H)))}
-    ( cone-dependent-pullback-property-pushout
-      f g (pair i (pair j H)) (Œª x ‚Üí Y))
-    ( pair
-      ( Œª h ‚Üí refl)
-      ( pair
-        ( Œª h ‚Üí refl)
-        ( Œª h ‚Üí right-unit ‚àô
-          ( ( ap eq-htpy
-              ( eq-htpy (Œª s ‚Üí
-                left-transpose-eq-concat
-                  ( tr-constant-type-family (H s) (h (i (f s))))
-                  ( ap h (H s))
-                  ( apd h (H s))
-                  ( inv (apd-constant-type-family h (H s)))))) ‚àô
-            ( eq-htpy-concat-htpy
-              ( Œª s ‚Üí inv (tr-constant-type-family (H s) (h (i (f s)))))
-              ( Œª s ‚Üí apd h (H s)))))))
-    ( dpb (Œª x ‚Üí Y))
-```
-
-### Proof of Theorem 18.1.4, (2) implies (3)
-
-We first define the family of lifts, which is indexed by maps $Y ‚Üí X$.
-
-```agda
-fam-lifts :
-  {l1 l2 l3 : Level} (Y : UU l1) {X : UU l2} (P : X ‚Üí UU l3) ‚Üí
-  (Y ‚Üí X) ‚Üí UU (l1 ‚äî l3)
-fam-lifts Y P h = (y : Y) ‚Üí P (h y)
-
-tr-fam-lifts' :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4) ‚Üí
-  (h : B ‚Üí X) {f g : A ‚Üí B} (H : f ~ g) ‚Üí
-  fam-lifts A P (h ‚àò f) ‚Üí fam-lifts A P (h ‚àò g)
-tr-fam-lifts' P h {f} {g} H k s = tr (P ‚àò h) (H s) (k s)
-
-TR-EQ-HTPY-FAM-LIFTS :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4) ‚Üí
-  (h : B ‚Üí X) {f g : A ‚Üí B} (H : f ~ g) ‚Üí UU (l1 ‚äî l4)
-TR-EQ-HTPY-FAM-LIFTS {A = A} P h H =
-  tr (fam-lifts A P) (eq-htpy (h ¬∑l H)) ~ (tr-fam-lifts' P h H)
-
-tr-eq-htpy-fam-lifts-refl-htpy :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4) ‚Üí
-  (h : B ‚Üí X) (f : A ‚Üí B) ‚Üí TR-EQ-HTPY-FAM-LIFTS P h (refl-htpy' f)
-tr-eq-htpy-fam-lifts-refl-htpy P h f k =
-  ap (Œª t ‚Üí tr (fam-lifts _ P) t k) (eq-htpy-refl-htpy (h ‚àò f))
-
-abstract
-  tr-eq-htpy-fam-lifts :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4) ‚Üí
-    (h : B ‚Üí X) {f g : A ‚Üí B} (H : f ~ g) ‚Üí
-    TR-EQ-HTPY-FAM-LIFTS P h H
-  tr-eq-htpy-fam-lifts P h {f} =
-    ind-htpy f
-      ( Œª g H ‚Üí TR-EQ-HTPY-FAM-LIFTS P h H)
-      ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
-
-  compute-tr-eq-htpy-fam-lifts :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4) ‚Üí
-    (h : B ‚Üí X) (f : A ‚Üí B) ‚Üí
-    Id ( tr-eq-htpy-fam-lifts P h (refl-htpy' f))
-        ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
-  compute-tr-eq-htpy-fam-lifts P h f =
-    compute-ind-htpy f
-      ( Œª g H ‚Üí TR-EQ-HTPY-FAM-LIFTS P h H)
-      ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
-```
-
-One of the basic operations on lifts is precomposition by an ordinary function.
-
-```agda
-precompose-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X ‚Üí UU l4) ‚Üí (f : A ‚Üí B) ‚Üí (h : B ‚Üí X) ‚Üí
-  (fam-lifts B P h) ‚Üí (fam-lifts A P (h ‚àò f))
-precompose-lifts P f h h' a = h' (f a)
-```
-
-Given two homotopic maps, their precomposition functions have different
-codomains. However, there is a commuting triangle. We obtain this triangle by
-homotopy induction.
-
-```agda
-TRIANGLE-PRECOMPOSE-LIFTS :
-  { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  ( P : X ‚Üí UU l4) {f g : A ‚Üí B} (H : f ~ g) ‚Üí UU (l1 ‚äî l2 ‚äî l3 ‚äî l4)
-TRIANGLE-PRECOMPOSE-LIFTS {A = A} {B} {X} P {f} {g} H =
-  (h : B ‚Üí X) ‚Üí
-    ( (tr (fam-lifts A P) (eq-htpy (h ¬∑l H))) ‚àò (precompose-lifts P f h)) ~
-    ( precompose-lifts P g h)
-
-triangle-precompose-lifts-refl-htpy :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X ‚Üí UU l4) (f : A ‚Üí B) ‚Üí TRIANGLE-PRECOMPOSE-LIFTS P (refl-htpy' f)
-triangle-precompose-lifts-refl-htpy {A = A} P f h h' =
-  tr-eq-htpy-fam-lifts-refl-htpy P h f (Œª a ‚Üí h' (f a))
-
-triangle-precompose-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X ‚Üí UU l4) {f g : A ‚Üí B} (H : f ~ g) ‚Üí
-  TRIANGLE-PRECOMPOSE-LIFTS P H
-triangle-precompose-lifts {A = A} P {f} =
-  ind-htpy f
-    ( Œª g H ‚Üí TRIANGLE-PRECOMPOSE-LIFTS P H)
-    ( triangle-precompose-lifts-refl-htpy P f)
-
-compute-triangle-precompose-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X ‚Üí UU l4) (f : A ‚Üí B) ‚Üí
-  Id
-    ( triangle-precompose-lifts P (refl-htpy' f))
-    ( triangle-precompose-lifts-refl-htpy P f)
-compute-triangle-precompose-lifts P f =
-  compute-ind-htpy f
-    ( Œª g ‚Üí TRIANGLE-PRECOMPOSE-LIFTS P)
-    ( triangle-precompose-lifts-refl-htpy P f)
-```
-
-There is a similar commuting triangle with the computed transport function. This
-time we don't use homotopy induction to construct the homotopy. We give an
-explicit definition instead.
-
-```agda
-triangle-precompose-lifts' :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X ‚Üí UU l4) {f g : A ‚Üí B} (H : f ~ g) ‚Üí (h : B ‚Üí X) ‚Üí
-  ( (tr-fam-lifts' P h H) ‚àò (precompose-lifts P f h)) ~
-  ( precompose-lifts P g h)
-triangle-precompose-lifts' P H h k = eq-htpy (Œª a ‚Üí apd k (H a))
-
-compute-triangle-precompose-lifts' :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X ‚Üí UU l4) (f : A ‚Üí B) ‚Üí (h : B ‚Üí X) ‚Üí
-  ( triangle-precompose-lifts' P (refl-htpy' f) h) ~
-  ( refl-htpy' ( precompose-lifts P f h))
-compute-triangle-precompose-lifts' P f h k = eq-htpy-refl-htpy _
-```
-
-There is a coherence between the two commuting triangles. This coherence is
-again constructed by homotopy induction.
-
-```agda
-COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4)
-  {f g : A ‚Üí B} (H : f ~ g) ‚Üí UU (l1 ‚äî l2 ‚äî l3 ‚äî l4)
-COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS {A = A} {B} {X} P {f} {g} H =
-  (h : B ‚Üí X) ‚Üí
-    ( triangle-precompose-lifts P H h) ~
-    ( ( ( tr-eq-htpy-fam-lifts P h H) ¬∑r (precompose-lifts P f h)) ‚àôh
-      ( triangle-precompose-lifts' P H h))
-
-coherence-triangle-precompose-lifts-refl-htpy :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4)
-  (f : A ‚Üí B) ‚Üí COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P (refl-htpy' f)
-coherence-triangle-precompose-lifts-refl-htpy P f h =
-  ( htpy-eq (htpy-eq (compute-triangle-precompose-lifts P f) h)) ‚àôh
-  ( ( ( inv-htpy-right-unit-htpy) ‚àôh
-      ( ap-concat-htpy
-        ( Œª h' ‚Üí tr-eq-htpy-fam-lifts-refl-htpy P h f (Œª a ‚Üí h' (f a)))
-        ( inv-htpy (compute-triangle-precompose-lifts' P f h)))) ‚àôh
-    ( htpy-eq
-      ( ap
-        ( Œª t ‚Üí
-          ( t ¬∑r (precompose-lifts P f h)) ‚àôh
-          ( triangle-precompose-lifts' P refl-htpy h))
-        ( inv (compute-tr-eq-htpy-fam-lifts P h f)))))
-
-abstract
-  coherence-triangle-precompose-lifts :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4)
-    {f g : A ‚Üí B} (H : f ~ g) ‚Üí COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H
-  coherence-triangle-precompose-lifts P {f} =
-    ind-htpy f
-      ( Œª g H ‚Üí COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H)
-      ( coherence-triangle-precompose-lifts-refl-htpy P f)
-
-  compute-coherence-triangle-precompose-lifts :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4)
-    (f : A ‚Üí B) ‚Üí
-      Id ( coherence-triangle-precompose-lifts P (refl-htpy' f))
-          ( coherence-triangle-precompose-lifts-refl-htpy P f)
-  compute-coherence-triangle-precompose-lifts P f =
-    compute-ind-htpy f
-      ( Œª g H ‚Üí COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H)
-      ( coherence-triangle-precompose-lifts-refl-htpy P f)
-
-total-lifts :
-  {l1 l2 l3 : Level} (A : UU l1) {X : UU l2} (P : X ‚Üí UU l3) ‚Üí
-  UU (l1 ‚äî l2 ‚äî l3)
-total-lifts A {X} P = universally-structured-Œ† {A = A} {B = Œª a ‚Üí X} (Œª a ‚Üí P)
-
-precompose-total-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X ‚Üí UU l4) ‚Üí (A ‚Üí B) ‚Üí
-  total-lifts B P ‚Üí total-lifts A P
-precompose-total-lifts {A = A} P f =
-  map-Œ£
-    ( Œª h ‚Üí (a : A) ‚Üí P (h a))
-    ( Œª h ‚Üí h ‚àò f)
-    ( precompose-lifts P f)
-
-coherence-square-map-inv-distributive-Œ†-Œ£ :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X ‚Üí UU l4) (f : A ‚Üí B) ‚Üí
-  coherence-square-maps
-    ( precompose-total-lifts P f)
-    ( map-inv-distributive-Œ†-Œ£ {A = B} {B = Œª x ‚Üí X} {C = Œª x y ‚Üí P y})
-    ( map-inv-distributive-Œ†-Œ£)
-    ( Œª h ‚Üí h ‚àò f)
-coherence-square-map-inv-distributive-Œ†-Œ£ P f = refl-htpy
-```
-
-Our goal is now to produce a homotopy between `precompose-total-lifts P f` and
-`precompose-total-lifts P g` for homotopic maps `f` and `g`, and a coherence
-filling a cylinder.
-
-```agda
-HTPY-PRECOMPOSE-TOTAL-LIFTS :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X ‚Üí UU l4) {f g : A ‚Üí B} (H : f ~ g) ‚Üí
-  UU (l1 ‚äî l2 ‚äî l3 ‚äî l4)
-HTPY-PRECOMPOSE-TOTAL-LIFTS P {f} {g} H =
-  (precompose-total-lifts P f) ~ (precompose-total-lifts P g)
-
-htpy-precompose-total-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4)
-  {f g : A ‚Üí B} (H : f ~ g) ‚Üí HTPY-PRECOMPOSE-TOTAL-LIFTS P H
-htpy-precompose-total-lifts {A = A} {B} P {f} {g} H =
-  htpy-map-Œ£
-    ( fam-lifts A P)
-    ( Œª h ‚Üí eq-htpy (h ¬∑l H))
-    ( precompose-lifts P f)
-    ( triangle-precompose-lifts P H)
-```
-
-We show that when `htpy-precompose-total-lifts` is applied to `refl-htpy`, it
-computes to `refl-htpy`.
-
-```agda
-tr-id-left-subst :
-  {l1 l2 : Level} {A : UU l1} {B : UU l2} {f : A ‚Üí B} {x y : A}
-  (p : Id x y) (b : B) ‚Üí (q : Id (f x) b) ‚Üí
-  Id (tr (Œª (a : A) ‚Üí Id (f a) b) p q) ((inv (ap f p)) ‚àô q)
-tr-id-left-subst refl b q = refl
-
-compute-htpy-precompose-total-lifts :
-  { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4)
-  ( f : A ‚Üí B) ‚Üí
-  ( htpy-precompose-total-lifts P (refl-htpy {f = f})) ~
-  ( refl-htpy' (map-Œ£ (fam-lifts A P) (Œª h ‚Üí h ‚àò f) (precompose-lifts P f)))
-compute-htpy-precompose-total-lifts {A = A} P f (pair h h') =
-  let Œ± = Œª (t : Id (h ‚àò f) (h ‚àò f)) ‚Üí tr (fam-lifts A P) t (Œª a ‚Üí h' (f a))
-  in
-  ap eq-pair-Œ£'
-    ( eq-pair-Œ£
-      ( eq-htpy-refl-htpy (h ‚àò f))
-      ( ( tr-id-left-subst
-          { f = Œ±}
-          ( eq-htpy-refl-htpy (h ‚àò f))
-          ( Œª a ‚Üí h' (f a))
-          ( triangle-precompose-lifts P refl-htpy h h')) ‚àô
-        ( ( ap
-            ( Œª t ‚Üí inv (ap Œ± (eq-htpy-refl-htpy (Œª a ‚Üí h (f a)))) ‚àô t)
-            ( htpy-eq
-              ( htpy-eq (compute-triangle-precompose-lifts P f) h) h')) ‚àô
-          ( left-inv (triangle-precompose-lifts-refl-htpy P f h h')))))
-
-COHERENCE-INV-HTPY-DISTRIBUTIVE-Œ†-Œ£ :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4)
-  {f g : A ‚Üí B} (H : f ~ g) ‚Üí UU (l1 ‚äî l2 ‚äî l3 ‚äî l4)
-COHERENCE-INV-HTPY-DISTRIBUTIVE-Œ†-Œ£ P {f} {g} H =
-  ( ( coherence-square-map-inv-distributive-Œ†-Œ£ P f) ‚àôh
-    ( map-inv-distributive-Œ†-Œ£ ¬∑l ( htpy-precompose-total-lifts P H))) ~
-  ( ( ( Œª h ‚Üí eq-htpy (h ¬∑l H)) ¬∑r map-inv-distributive-Œ†-Œ£) ‚àôh
-    ( coherence-square-map-inv-distributive-Œ†-Œ£ P g))
-
-coherence-inv-htpy-distributive-Œ†-Œ£-refl-htpy :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4)
-  (f : A ‚Üí B) ‚Üí COHERENCE-INV-HTPY-DISTRIBUTIVE-Œ†-Œ£ P (refl-htpy' f)
-coherence-inv-htpy-distributive-Œ†-Œ£-refl-htpy {X = X} P f =
-  ( ap-concat-htpy
-    ( coherence-square-map-inv-distributive-Œ†-Œ£ P f)
-    ( Œª h ‚Üí
-      ap
-        ( ap map-inv-distributive-Œ†-Œ£)
-        ( compute-htpy-precompose-total-lifts P f h))) ‚àôh
-  ( ap-concat-htpy'
-    ( refl-htpy)
-    ( inv-htpy
-      ( Œª h ‚Üí
-        compute-htpy-precomp-refl-htpy f (Œ£ X P) (map-inv-distributive-Œ†-Œ£ h))))
-
-abstract
-  coherence-inv-htpy-distributive-Œ†-Œ£ :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X ‚Üí UU l4)
-    {f g : A ‚Üí B} (H : f ~ g) ‚Üí COHERENCE-INV-HTPY-DISTRIBUTIVE-Œ†-Œ£ P H
-  coherence-inv-htpy-distributive-Œ†-Œ£ P {f} =
-    ind-htpy f
-      ( Œª g H ‚Üí COHERENCE-INV-HTPY-DISTRIBUTIVE-Œ†-Œ£ P H)
-      ( coherence-inv-htpy-distributive-Œ†-Œ£-refl-htpy P f)
-
-cone-family-dependent-pullback-property :
-  {l1 l2 l3 l4 l : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S ‚Üí A) (g : S ‚Üí B) (c : cocone f g X) (P : X ‚Üí UU l) ‚Üí
-  cone-family
-    ( fam-lifts S P)
-    ( precompose-lifts P f)
-    ( precompose-lifts P g)
-    ( cone-pullback-property-pushout f g c X)
-    ( fam-lifts X P)
-cone-family-dependent-pullback-property f g c P Œ≥ =
-  pair
-    ( precompose-lifts P (pr1 c) Œ≥)
-    ( pair
-      ( precompose-lifts P (pr1 (pr2 c)) Œ≥)
-      ( triangle-precompose-lifts P (pr2 (pr2 c)) Œ≥))
-
-is-pullback-cone-family-dependent-pullback-property :
-  {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S ‚Üí A) (g : S ‚Üí B) (c : cocone f g X) ‚Üí
-  ({l : Level} ‚Üí pullback-property-pushout l f g c) ‚Üí
-  {l : Level} (P : X ‚Üí UU l) (Œ≥ : X ‚Üí X) ‚Üí
-  is-pullback
-    ( ( tr (fam-lifts S P) (eq-htpy (Œ≥ ¬∑l (pr2 (pr2 c))))) ‚àò
-      ( precompose-lifts P f (Œ≥ ‚àò (pr1 c))))
-    ( precompose-lifts P g (Œ≥ ‚àò (pr1 (pr2 c))))
-    ( cone-family-dependent-pullback-property f g c P Œ≥)
-is-pullback-cone-family-dependent-pullback-property {S = S} {A} {B} {X}
-  f g (pair i (pair j H)) pb-c P =
-  let c = pair i (pair j H) in
-  is-pullback-family-is-pullback-tot
-    ( fam-lifts S P)
-    ( precompose-lifts P f)
-    ( precompose-lifts P g)
-    ( cone-pullback-property-pushout f g c X)
-    ( cone-family-dependent-pullback-property f g c P)
-    ( pb-c X)
-    ( is-pullback-top-is-pullback-bottom-cube-is-equiv
-      ( precomp i (Œ£ X P))
-      ( precomp j (Œ£ X P))
-      ( precomp f (Œ£ X P))
-      ( precomp g (Œ£ X P))
-      ( map-Œ£ (fam-lifts A P) (precomp i X) (precompose-lifts P i))
-      ( map-Œ£ (fam-lifts B P) (precomp j X) (precompose-lifts P j))
-      ( map-Œ£ (fam-lifts S P) (precomp f X) (precompose-lifts P f))
-      ( map-Œ£ (fam-lifts S P) (precomp g X) (precompose-lifts P g))
-      ( map-inv-distributive-Œ†-Œ£)
-      ( map-inv-distributive-Œ†-Œ£)
-      ( map-inv-distributive-Œ†-Œ£)
-      ( map-inv-distributive-Œ†-Œ£)
-      ( htpy-precompose-total-lifts P H)
-      ( refl-htpy)
-      ( refl-htpy)
-      ( refl-htpy)
-      ( refl-htpy)
-      ( htpy-precomp H (Œ£ X P))
-      ( coherence-inv-htpy-distributive-Œ†-Œ£ P H)
-      ( is-equiv-map-inv-distributive-Œ†-Œ£)
-      ( is-equiv-map-inv-distributive-Œ†-Œ£)
-      ( is-equiv-map-inv-distributive-Œ†-Œ£)
-      ( is-equiv-map-inv-distributive-Œ†-Œ£)
-      ( pb-c (Œ£ X P)))
-
-dependent-pullback-property-pullback-property-pushout :
-  {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S ‚Üí A) (g : S ‚Üí B) (c : cocone f g X) ‚Üí
-  ({l : Level} ‚Üí pullback-property-pushout l f g c) ‚Üí
-  ({l : Level} ‚Üí dependent-pullback-property-pushout l f g c)
-dependent-pullback-property-pullback-property-pushout
-  {S = S} {A} {B} {X}
-  f g (pair i (pair j H)) pullback-c P =
-  let c = pair i (pair j H) in
-  is-pullback-htpy'
-    -- ( (tr (fam-lifts S P) (eq-htpy (id ¬∑l H))) ‚àò (precompose-lifts P f i))
-    ( (tr-eq-htpy-fam-lifts P id H) ¬∑r (precompose-lifts P f i))
-    -- ( precompose-lifts P g j)
-    ( refl-htpy)
-    ( cone-family-dependent-pullback-property f g c P id)
-    { c' = cone-dependent-pullback-property-pushout f g c P}
-    ( pair refl-htpy
-      ( pair refl-htpy
-        ( right-unit-htpy ‚àôh (coherence-triangle-precompose-lifts P H id))))
-    ( is-pullback-cone-family-dependent-pullback-property f g c pullback-c P id)
-```
-
-This concludes the proof of Theorem 18.1.4.
-
-We give some further useful implications.
-
-```agda
-dependent-universal-property-universal-property-pushout :
-  { l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  ( f : S ‚Üí A) (g : S ‚Üí B) (c : cocone f g X) ‚Üí
-  ( {l : Level} ‚Üí universal-property-pushout l f g c) ‚Üí
-  ( {l : Level} ‚Üí dependent-universal-property-pushout l f g c)
-dependent-universal-property-universal-property-pushout f g c up-X =
-  dependent-universal-property-dependent-pullback-property-pushout f g c
-    ( dependent-pullback-property-pullback-property-pushout f g c
-      ( pullback-property-pushout-universal-property-pushout f g c up-X))
-```
-
 ## Section 16.2 Families over pushouts
 
 ### Definition 18.2.1
@@ -757,163 +307,3 @@ compute-path-fam-Fam-pushout :
 compute-path-fam-Fam-pushout {f = f} {g} c up-X P =
   pr2 (pr2 (pr2 (center (uniqueness-Fam-pushout f g c up-X P))))
 ```
-
-## Section 18.3 The Flattening lemma for pushouts
-
-### Definition 18.3.1
-
-```agda
-{-
-cocone-flattening-pushout :
-  { l1 l2 l3 l4 l5 : Level}
-  { S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  ( f : S ‚Üí A) (g : S ‚Üí B) (c : cocone f g X)
-  ( P : Fam-pushout l5 f g)
-  ( Q : X ‚Üí UU l5)
-  ( e : equiv-Fam-pushout P (desc-fam f g c Q)) ‚Üí
-  cocone
-    ( map-Œ£ (pr1 P) f (Œª s ‚Üí id))
-    ( map-Œ£ (pr1 (pr2 P)) g (Œª s ‚Üí map-equiv (pr2 (pr2 P) s)))
-    ( Œ£ X Q)
-cocone-flattening-pushout f g c P Q e =
-  pair
-    ( map-Œ£ Q
-      ( pr1 c)
-      ( Œª a ‚Üí map-equiv (pr1 e a)))
-    ( pair
-      ( map-Œ£ Q
-        ( pr1 (pr2 c))
-        ( Œª b ‚Üí map-equiv (pr1 (pr2 e) b)))
-      ( htpy-map-Œ£ Q
-        ( pr2 (pr2 c))
-        ( Œª s ‚Üí map-equiv (pr1 e (f s)))
-        ( Œª s ‚Üí inv-htpy (pr2 (pr2 e) s))))
--}
-```
-
-### Theorem 18.3.2 The flattening lemma
-
-```agda
-{-
-coherence-bottom-flattening-lemma' :
-  {l1 l2 l3 : Level} {B : UU l1} {Q : B ‚Üí UU l2} {T : UU l3}
-  {b b' : B} (Œ± : Id b b') {y : Q b} {y' : Q b'} (Œ≤ : Id (tr Q Œ± y) y')
-  (h : (b : B) ‚Üí Q b ‚Üí T) ‚Üí Id (h b y) (h b' y')
-coherence-bottom-flattening-lemma' refl refl h = refl
-
-coherence-bottom-flattening-lemma :
-  {l1 l2 l3 l4 l5 : Level}
-  {A : UU l1} {B : UU l2} {P : A ‚Üí UU l3} {Q : B ‚Üí UU l4} {T : UU l5}
-  {f f' : A ‚Üí B} (H : f ~ f')
-  {g : (a : A) ‚Üí P a ‚Üí Q (f a)}
-  {g' : (a : A) ‚Üí P a ‚Üí Q (f' a)}
-  (K : (a : A) ‚Üí ((tr Q (H a)) ‚àò (g a)) ~ (g' a))
-  (h : (b : B) ‚Üí Q b ‚Üí T) ‚Üí (a : A) (p : P a) ‚Üí
-  Id (h (f a) (g a p)) (h (f' a) (g' a p))
-coherence-bottom-flattening-lemma H K h a p =
-  coherence-bottom-flattening-lemma' (H a) (K a p) h
-coherence-cube-flattening-lemma :
-  {l1 l2 l3 l4 l5 : Level}
-  {A : UU l1} {B : UU l2} {P : A ‚Üí UU l3} {Q : B ‚Üí UU l4} {T : UU l5}
-  {f f' : A ‚Üí B} (H : f ~ f')
-  {g : (a : A) ‚Üí P a ‚Üí Q (f a)}
-  {g' : (a : A) ‚Üí P a ‚Üí Q (f' a)}
-  (K : (a : A) ‚Üí ((tr Q (H a)) ‚àò (g a)) ~ (g' a))
-  (h : Œ£ B Q ‚Üí T) ‚Üí
-  Id ( eq-htpy
-       ( Œª a ‚Üí eq-htpy
-         ( coherence-bottom-flattening-lemma H K (ev-pair h) a)))
-     ( ap ev-pair
-       ( htpy-precomp (htpy-map-Œ£ Q H g K) T h))
-coherence-cube-flattening-lemma
-  {A = A} {B} {P} {Q} {T} {f = f} {f'} H {g} {g'} K =
-  ind-htpy f
-    ( Œª f' H' ‚Üí
-      (g : (a : A) ‚Üí P a ‚Üí Q (f a)) (g' : (a : A) ‚Üí P a ‚Üí Q (f' a))
-      (K : (a : A) ‚Üí ((tr Q (H' a)) ‚àò (g a)) ~ (g' a)) (h : Œ£ B Q ‚Üí T) ‚Üí
-      Id ( eq-htpy
-           ( Œª a ‚Üí eq-htpy
-             ( coherence-bottom-flattening-lemma H' K (ev-pair h) a)))
-         ( ap ev-pair
-           ( htpy-precomp (htpy-map-Œ£ Q H' g K) T h)))
-    ( Œª g g' K h ‚Üí {!ind-htpy g (Œª g' K' ‚Üí (h : Œ£ B Q ‚Üí T) ‚Üí
-      Id ( eq-htpy
-           ( Œª a ‚Üí eq-htpy
-             ( coherence-bottom-flattening-lemma
-                refl-htpy (Œª a ‚Üí htpy-eq (K' a)) (ev-pair h) a)))
-         ( ap ev-pair
-           ( htpy-precomp
-              ( htpy-map-Œ£ Q refl-htpy g
-                (Œª a ‚Üí htpy-eq (K' a))) T h))) ? (Œª a ‚Üí eq-htpy (K a)) h!})
-    H g g' K
-
-flattening-pushout' :
-  {l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S ‚Üí A) (g : S ‚Üí B) (c : cocone f g X) ‚Üí
-  ( P : Fam-pushout l5 f g)
-  ( Q : X ‚Üí UU l5)
-  ( e : equiv-Fam-pushout P (desc-fam f g c Q)) ‚Üí
-  (l : Level) ‚Üí
-  pullback-property-pushout l
-    ( map-Œ£ (pr1 P) f (Œª s ‚Üí id))
-    ( map-Œ£ (pr1 (pr2 P)) g (Œª s ‚Üí map-equiv (pr2 (pr2 P) s)))
-    ( cocone-flattening-pushout f g c P Q e)
-flattening-pushout' f g c P Q e l T =
-  is-pullback-top-is-pullback-bottom-cube-is-equiv
-    ( ( map-Œ† (Œª x ‚Üí precomp-Œ† (map-equiv (pr1 e x)) (Œª q ‚Üí T))) ‚àò
-      ( precomp-Œ† (pr1 c) (Œª x ‚Üí (Q x) ‚Üí T)))
-    ( ( map-Œ† (Œª x ‚Üí precomp-Œ† (map-equiv (pr1 (pr2 e) x)) (Œª q ‚Üí T))) ‚àò
-      ( precomp-Œ† (pr1 (pr2 c)) (Œª x ‚Üí (Q x) ‚Üí T)))
-    ( precomp-Œ† f (Œª a ‚Üí (pr1 P a) ‚Üí T))
-    ( ( map-Œ† (Œª s ‚Üí precomp (map-equiv (pr2 (pr2 P) s)) T)) ‚àò
-      ( precomp-Œ† g (Œª b ‚Üí (pr1 (pr2 P) b) ‚Üí T)))
-    ( precomp (map-Œ£ Q (pr1 c) (Œª a ‚Üí map-equiv (pr1 e a))) T)
-    ( precomp (map-Œ£ Q (pr1 (pr2 c)) (Œª b ‚Üí map-equiv (pr1 (pr2 e) b))) T)
-    ( precomp (map-Œ£ (pr1 P) f (Œª s ‚Üí id)) T)
-    ( precomp (map-Œ£ (pr1 (pr2 P)) g (Œª s ‚Üí map-equiv (pr2 (pr2 P) s))) T)
-    ev-pair
-    ev-pair
-    ev-pair
-    ev-pair
-    ( htpy-precomp
-      ( htpy-map-Œ£ Q
-        ( pr2 (pr2 c))
-        ( Œª s ‚Üí map-equiv (pr1 e (f s)))
-        ( Œª s ‚Üí inv-htpy (pr2 (pr2 e) s)))
-      ( T))
-    refl-htpy
-    refl-htpy
-    refl-htpy
-    refl-htpy
-    ( Œª h ‚Üí eq-htpy (Œª s ‚Üí eq-htpy
-      ( coherence-bottom-flattening-lemma
-        ( pr2 (pr2 c))
-        ( Œª s ‚Üí inv-htpy (pr2 (pr2 e) s))
-        ( h)
-        ( s))))
-    {!!}
-    is-equiv-ev-pair
-    is-equiv-ev-pair
-    is-equiv-ev-pair
-    is-equiv-ev-pair
-    {!!}
-
-flattening-pushout :
-  {l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S ‚Üí A) (g : S ‚Üí B) (c : cocone f g X) ‚Üí
-  ( P : Fam-pushout l5 f g)
-  ( Q : X ‚Üí UU l5)
-  ( e : equiv-Fam-pushout P (desc-fam f g c Q)) ‚Üí
-  (l : Level) ‚Üí
-  universal-property-pushout l
-    ( map-Œ£ (pr1 P) f (Œª s ‚Üí id))
-    ( map-Œ£ (pr1 (pr2 P)) g (Œª s ‚Üí map-equiv (pr2 (pr2 P) s)))
-    ( cocone-flattening-pushout f g c P Q e)
-flattening-pushout f g c P Q e l =
-  universal-property-pushout-pullback-property-pushout l
-    ( map-Œ£ (pr1 P) f (Œª s ‚Üí id))
-    ( map-Œ£ (pr1 (pr2 P)) g (Œª s ‚Üí map-equiv (pr2 (pr2 P) s)))
-    ( cocone-flattening-pushout f g c P Q e)
-    ( flattening-pushout' f g c P Q e l)
--}
-```
diff --git a/src/synthetic-homotopy-theory/26-id-pushout.lagda.md b/src/synthetic-homotopy-theory/26-id-pushout.lagda.md
index 6871fd856e..9666c7a2e3 100644
--- a/src/synthetic-homotopy-theory/26-id-pushout.lagda.md
+++ b/src/synthetic-homotopy-theory/26-id-pushout.lagda.md
@@ -33,6 +33,7 @@ open import foundation.whiskering-homotopies
 open import synthetic-homotopy-theory.26-descent
 open import synthetic-homotopy-theory.cocones-under-spans
 open import synthetic-homotopy-theory.dependent-cocones-under-spans
+open import synthetic-homotopy-theory.dependent-universal-property-pushouts
 open import synthetic-homotopy-theory.universal-property-pushouts
 ```
 
diff --git a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
index 1f55709c41..2ff8d22e32 100644
--- a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
@@ -8,14 +8,27 @@ module synthetic-homotopy-theory.dependent-pullback-property-pushouts where
 
 ```agda
 open import foundation.action-on-identifications-dependent-functions
+open import foundation.action-on-identifications-functions
 open import foundation.cones-over-cospans
+open import foundation.constant-type-families
 open import foundation.dependent-pair-types
 open import foundation.function-extensionality
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.homotopies
+open import foundation.identity-types
+open import foundation.precomposition-functions
 open import foundation.pullbacks
 open import foundation.transport-along-identifications
+open import foundation.type-theoretic-principle-of-choice
 open import foundation.universe-levels
+open import foundation.whiskering-homotopies
+
+open import orthogonal-factorization-systems.lifts-families-of-elements
+open import orthogonal-factorization-systems.precomposition-lifts-families-of-elements
 
 open import synthetic-homotopy-theory.cocones-under-spans
+open import synthetic-homotopy-theory.pullback-property-pushouts
 ```
 
 </details>
@@ -65,3 +78,213 @@ dependent-pullback-property-pushout l {S} {A} {B} f g {X} (i , j , H) =
     ( Œª (h : (b : B) ‚Üí P (j b)) ‚Üí Œª s ‚Üí h (g s))
     ( cone-dependent-pullback-property-pushout f g (i , j , H) P)
 ```
+
+## Properties
+
+### The dependent pullback property is logically equivalent to the pullback property
+
+Consider a [cocone](synthetic-homotopy-theory.cocones-under-spans.md)
+
+```text
+        g
+    S -----> B
+    |        |
+  f |        | j
+    V        V
+    A -----> X  .
+        i
+```
+
+The non-dependent pullback property follows from the dependent one by applying
+the dependent pullback property to the constant type family `Œª _ ‚Üí Y`.
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
+  (f : S ‚Üí A) (g : S ‚Üí B) {X : UU l4} (c : cocone f g X)
+  where
+
+  pullback-property-dependent-pullback-property-pushout :
+    ({l : Level} ‚Üí dependent-pullback-property-pushout l f g c) ‚Üí
+    ({l : Level} ‚Üí pullback-property-pushout l f g c)
+  pullback-property-dependent-pullback-property-pushout dpp-c Y =
+    is-pullback-htpy
+      ( Œª h ‚Üí
+        eq-htpy
+          ( Œª s ‚Üí
+            inv
+              ( tr-constant-type-family
+                ( coherence-square-cocone f g c s)
+                ( h (f s)))))
+      ( refl-htpy)
+      ( cone-dependent-pullback-property-pushout f g c (Œª _ ‚Üí Y))
+      ( ( refl-htpy) ,
+        ( refl-htpy) ,
+        ( Œª h ‚Üí
+          ( right-unit) ‚àô
+          ( ap
+            ( eq-htpy)
+            ( eq-htpy
+              ( Œª s ‚Üí
+                left-transpose-eq-concat _ _ _
+                  ( inv
+                    ( apd-constant-type-family h
+                      ( coherence-square-cocone f g c s))))) ‚àô
+          ( eq-htpy-concat-htpy _ _))))
+      ( dpp-c (Œª _ ‚Üí Y))
+```
+
+In the converse direction, we use the fact that by the
+[type theoretic principle of choice](foundation.type-theoretic-principle-of-choice.md),
+dependent functions distribute over Œ£-types. That, and a handful of technical
+lemmas about [transport](foundation.transport-along-identifications.md) in
+[precomposed type families](foundation.precomposition-type-families.md) and
+[precomposition](orthogonal-factorization-systems.precomposition-lifts-families-of-elements.md)
+in
+[lifts of families of elements](orthogonal-factorization-systems.lifts-families-of-elements.md),
+allow us to construct the following
+[commuting cube](foundation.commuting-cubes-of-maps.md):
+
+```text
+                                Œ£ (h : X ‚Üí X) ((x : X) ‚Üí P (h x))
+                                       /        |        \
+                                     /          |          \
+                                   /            |            \
+                                 /              |              \
+                               /                |                \
+                             /                  |                  \
+                           /                    |                    \
+                         V                      V                      V
+  Œ£ (h : A ‚Üí X) ((a : A) ‚Üí P (h a))    X ‚Üí Œ£ (x : X) (P x)    Œ£ (h : B ‚Üí X) ((b : B) ‚Üí P (h b))
+                         |\             /               \             /|
+                         |  \         /                   \         /  |
+                         |    \     /                       \     /    |
+                         |      \ /                           \ /      |
+                         |      / \                           / \      |
+                         |    /     \                       /     \    |
+                         |  /         \                   /         \  |
+                         VV             V               V             VV
+         A ‚Üí Œ£ (x : X) (P x)    Œ£ (h : S ‚Üí X) ((s : S) ‚Üí P (h s))    B ‚Üí Œ£ (x : X) (P x)
+                           \                    |                    /
+                             \                  |                  /
+                               \                |                /
+                                 \              |              /
+                                   \            |            /
+                                     \          |          /
+                                       \        |        /
+                                         V      V      V
+                                       S ‚Üí Œ£ (x : X) (P x) .
+```
+
+The bottom square is the induced precomposition square for our fixed cocone, so
+by the assumed pullback property, instantiated at the type `Œ£ (x : X) (P x)`,
+it's a pullback. The top square is constructed by precomposition of maps on the
+first component, and by precomposition of lifts of families of elements on the
+second component. Since vertical maps are equivalences, by the principle of
+choice, and the bottom square is a pullback, we conclude that the top square is
+a pullback.
+
+Observe that restricting the top square to its first component, we again get the
+induced precomposition square, this time instantiated at `X`, so that is also a
+pullback. Hence the top square is a pullback of total spaces over a pullback
+square, which implies that we get a family of pullback squares of the fibers,
+i.e. for every `h : X ‚Üí X` we have a pullback
+
+```text
+    (x : X) ‚Üí P (h x) ---------> (b : B) ‚Üí P (h (j b))
+            | ‚åü                           |
+            |                             |
+            |                             |
+            |                             |
+            V                             V
+  (a : A) ‚Üí P (h (i a)) -----> (s : S) ‚Üí P (h (j (g s))) ,
+```
+
+and instantiating for `id : X ‚Üí X` gives us exactly a proof of the dependent
+pullback property.
+
+```agda
+  cone-family-dependent-pullback-property :
+    {l : Level} (P : X ‚Üí UU l) ‚Üí
+    cone-family
+      ( lift-family-of-elements P)
+      ( precomp-lift-family-of-elements P f)
+      ( precomp-lift-family-of-elements P g)
+      ( cone-pullback-property-pushout f g c X)
+      ( lift-family-of-elements P)
+  pr1 (cone-family-dependent-pullback-property P Œ≥) h =
+    h ‚àò horizontal-map-cocone f g c
+  pr1 (pr2 (cone-family-dependent-pullback-property P Œ≥)) h =
+    h ‚àò vertical-map-cocone f g c
+  pr2 (pr2 (cone-family-dependent-pullback-property P Œ≥)) =
+    triangle-precomp-lift-family-of-elements-htpy P Œ≥
+      ( coherence-square-cocone f g c)
+
+  is-pullback-cone-family-dependent-pullback-family :
+    {l : Level} (P : X ‚Üí UU l) ‚Üí
+    ({l : Level} ‚Üí pullback-property-pushout l f g c) ‚Üí
+    (Œ≥ : X ‚Üí X) ‚Üí
+    is-pullback
+      ( ( tr
+          ( lift-family-of-elements P)
+          ( htpy-precomp (coherence-square-cocone f g c) X Œ≥)) ‚àò
+        ( precomp-lift-family-of-elements P f
+          ( Œ≥ ‚àò horizontal-map-cocone f g c)))
+      ( precomp-lift-family-of-elements P g
+        ( Œ≥ ‚àò vertical-map-cocone f g c))
+      ( cone-family-dependent-pullback-property P Œ≥)
+  is-pullback-cone-family-dependent-pullback-family P pp-c =
+    is-pullback-family-is-pullback-tot
+      ( lift-family-of-elements P)
+      ( precomp-lift-family-of-elements P f)
+      ( precomp-lift-family-of-elements P g)
+      ( cone-pullback-property-pushout f g c X)
+      ( cone-family-dependent-pullback-property P)
+      ( pp-c X)
+      ( is-pullback-top-is-pullback-bottom-cube-is-equiv
+        ( precomp (horizontal-map-cocone f g c) (Œ£ X P))
+        ( precomp (vertical-map-cocone f g c) (Œ£ X P))
+        ( precomp f (Œ£ X P))
+        ( precomp g (Œ£ X P))
+        ( precomp-lifted-family-of-elements P (horizontal-map-cocone f g c))
+        ( precomp-lifted-family-of-elements P (vertical-map-cocone f g c))
+        ( precomp-lifted-family-of-elements P f)
+        ( precomp-lifted-family-of-elements P g)
+        ( map-inv-distributive-Œ†-Œ£)
+        ( map-inv-distributive-Œ†-Œ£)
+        ( map-inv-distributive-Œ†-Œ£)
+        ( map-inv-distributive-Œ†-Œ£)
+        ( htpy-precomp-lifted-family-of-elements P
+          ( coherence-square-cocone f g c))
+        ( refl-htpy)
+        ( refl-htpy)
+        ( refl-htpy)
+        ( refl-htpy)
+        ( htpy-precomp (coherence-square-cocone f g c) (Œ£ X P))
+        ( coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Œ†-Œ£
+          ( P)
+          ( coherence-square-cocone f g c))
+        ( is-equiv-map-inv-distributive-Œ†-Œ£)
+        ( is-equiv-map-inv-distributive-Œ†-Œ£)
+        ( is-equiv-map-inv-distributive-Œ†-Œ£)
+        ( is-equiv-map-inv-distributive-Œ†-Œ£)
+        ( pp-c (Œ£ X P)))
+
+  dependent-pullback-property-pullback-property-pushout :
+    ({l : Level} ‚Üí pullback-property-pushout l f g c) ‚Üí
+    ({l : Level} ‚Üí dependent-pullback-property-pushout l f g c)
+  dependent-pullback-property-pullback-property-pushout pp-c P =
+    is-pullback-htpy'
+      ( ( tr-lift-family-of-elements-precomp P id
+          ( coherence-square-cocone f g c)) ¬∑r
+        ( precomp-lift-family-of-elements P f (horizontal-map-cocone f g c)))
+      ( refl-htpy)
+      ( cone-family-dependent-pullback-property P id)
+      { c' = cone-dependent-pullback-property-pushout f g c P}
+      ( ( refl-htpy) ,
+        ( refl-htpy) ,
+        ( ( right-unit-htpy) ‚àôh
+          ( coherence-triangle-precomp-lift-family-of-elements P id
+            ( coherence-square-cocone f g c))))
+      ( is-pullback-cone-family-dependent-pullback-family P pp-c id)
+```
diff --git a/src/synthetic-homotopy-theory/dependent-universal-property-coequalizers.lagda.md b/src/synthetic-homotopy-theory/dependent-universal-property-coequalizers.lagda.md
index b47ea42d6e..37e4f6b39a 100644
--- a/src/synthetic-homotopy-theory/dependent-universal-property-coequalizers.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-universal-property-coequalizers.lagda.md
@@ -15,7 +15,6 @@ open import foundation.fibers-of-maps
 open import foundation.functoriality-dependent-pair-types
 open import foundation.universe-levels
 
-open import synthetic-homotopy-theory.26-descent
 open import synthetic-homotopy-theory.coforks
 open import synthetic-homotopy-theory.dependent-cocones-under-spans
 open import synthetic-homotopy-theory.dependent-coforks
diff --git a/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
index 0278952857..23a340bb74 100644
--- a/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
@@ -27,6 +27,7 @@ open import synthetic-homotopy-theory.cocones-under-spans
 open import synthetic-homotopy-theory.dependent-cocones-under-spans
 open import synthetic-homotopy-theory.dependent-pullback-property-pushouts
 open import synthetic-homotopy-theory.induction-principle-pushouts
+open import synthetic-homotopy-theory.universal-property-pushouts
 ```
 
 </details>
@@ -128,23 +129,23 @@ htpy-eq-dependent-cocone-map f g c ind-c {P} h h' p =
 dependent-universal-property-pushout-induction-principle-pushout :
   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
   (f : S ‚Üí A) (g : S ‚Üí B) {X : UU l4} (c : cocone f g X) ‚Üí
-  ((l : Level) ‚Üí induction-principle-pushout l f g c) ‚Üí
-  ((l : Level) ‚Üí dependent-universal-property-pushout l f g c)
+  ({l : Level} ‚Üí induction-principle-pushout l f g c) ‚Üí
+  ({l : Level} ‚Üí dependent-universal-property-pushout l f g c)
 dependent-universal-property-pushout-induction-principle-pushout
-  f g c ind-c l P =
+  f g c ind-c P =
   is-equiv-is-invertible
-    ( ind-induction-principle-pushout f g c (ind-c l) P)
-    ( pr2 (ind-c l P))
+    ( ind-induction-principle-pushout f g c ind-c P)
+    ( pr2 (ind-c P))
     ( Œª h ‚Üí
       eq-htpy
         ( htpy-eq-dependent-cocone-map f g c
-          ( ind-c l)
+          ( ind-c)
           ( ind-induction-principle-pushout f g c
-            ( ind-c l)
+            ( ind-c)
             ( P)
             ( dependent-cocone-map f g c P h))
           ( h)
-          ( pr2 (ind-c l P) (dependent-cocone-map f g c P h))))
+          ( pr2 (ind-c P) (dependent-cocone-map f g c P h))))
 ```
 
 #### The dependent universal property of pushouts implies the induction principle of pushouts
@@ -153,11 +154,10 @@ dependent-universal-property-pushout-induction-principle-pushout
 induction-principle-pushout-dependent-universal-property-pushout :
   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
   (f : S ‚Üí A) (g : S ‚Üí B) {X : UU l4} (c : cocone f g X) ‚Üí
-  ((l : Level) ‚Üí dependent-universal-property-pushout l f g c) ‚Üí
-  ((l : Level) ‚Üí induction-principle-pushout l f g c)
+  ({l : Level} ‚Üí dependent-universal-property-pushout l f g c) ‚Üí
+  ({l : Level} ‚Üí induction-principle-pushout l f g c)
 induction-principle-pushout-dependent-universal-property-pushout
-  f g c dup-c l P =
-  pr1 (dup-c l P)
+  f g c dup-c P = pr1 (dup-c P)
 ```
 
 ### The dependent pullback property of pushouts is equivalent to the dependent universal property of pushouts
@@ -184,10 +184,10 @@ triangle-dependent-pullback-property-pushout f g (pair i (pair j H)) P h =
 dependent-pullback-property-dependent-universal-property-pushout :
   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
   (f : S ‚Üí A) (g : S ‚Üí B) {X : UU l4} (c : cocone f g X) ‚Üí
-  ((l : Level) ‚Üí dependent-universal-property-pushout l f g c) ‚Üí
-  ((l : Level) ‚Üí dependent-pullback-property-pushout l f g c)
+  ({l : Level} ‚Üí dependent-universal-property-pushout l f g c) ‚Üí
+  ({l : Level} ‚Üí dependent-pullback-property-pushout l f g c)
 dependent-pullback-property-dependent-universal-property-pushout
-  f g (pair i (pair j H)) I l P =
+  f g (pair i (pair j H)) I P =
   let c = (pair i (pair j H)) in
   is-equiv-top-map-triangle
     ( dependent-cocone-map f g c P)
@@ -201,7 +201,7 @@ dependent-pullback-property-dependent-universal-property-pushout
       ( Œª h ‚Üí
         is-equiv-tot-is-fiberwise-equiv
           ( Œª h' ‚Üí funext (Œª x ‚Üí tr P (H x) (h (f x))) (h' ‚àò g))))
-    ( I l P)
+    ( I P)
 ```
 
 #### The dependent pullback property of pushouts implies the dependent universal property of pushouts
@@ -229,3 +229,34 @@ dependent-universal-property-dependent-pullback-property-pushout
         is-equiv-tot-is-fiberwise-equiv
           ( Œª h' ‚Üí funext (Œª x ‚Üí tr P (H x) (h (f x))) (h' ‚àò g))))
 ```
+
+### The non-dependent and dependent universal property of pushouts are logically equivalent
+
+This follows from the fact that the
+[dependent pullback property of pushouts](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md)
+is logically equivalent to the
+[pullback property of pushouts](synthetic-homotopy-theory.pullback-property-pushouts.md).
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
+  (f : S ‚Üí A) (g : S ‚Üí B) (c : cocone f g X)
+  where
+
+  universal-property-dependent-universal-property-pushout :
+    ({l : Level} ‚Üí dependent-universal-property-pushout l f g c) ‚Üí
+    ({l : Level} ‚Üí universal-property-pushout l f g c)
+  universal-property-dependent-universal-property-pushout dup-c {l} =
+    universal-property-pushout-pullback-property-pushout l f g c
+      ( pullback-property-dependent-pullback-property-pushout f g c
+        ( dependent-pullback-property-dependent-universal-property-pushout f g c
+          ( dup-c)))
+
+  dependent-universal-property-universal-property-pushout :
+    ({l : Level} ‚Üí universal-property-pushout l f g c) ‚Üí
+    ({l : Level} ‚Üí dependent-universal-property-pushout l f g c)
+  dependent-universal-property-universal-property-pushout up-c =
+    dependent-universal-property-dependent-pullback-property-pushout f g c
+      ( dependent-pullback-property-pullback-property-pushout f g c
+        ( pullback-property-pushout-universal-property-pushout f g c up-c))
+```
diff --git a/src/synthetic-homotopy-theory/pushouts.lagda.md b/src/synthetic-homotopy-theory/pushouts.lagda.md
index 599d95be59..bb55f0d156 100644
--- a/src/synthetic-homotopy-theory/pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/pushouts.lagda.md
@@ -21,7 +21,6 @@ open import foundation.retractions
 open import foundation.sections
 open import foundation.universe-levels
 
-open import synthetic-homotopy-theory.26-descent
 open import synthetic-homotopy-theory.cocones-under-spans
 open import synthetic-homotopy-theory.dependent-cocones-under-spans
 open import synthetic-homotopy-theory.dependent-universal-property-pushouts
diff --git a/src/synthetic-homotopy-theory/universal-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/universal-property-pushouts.lagda.md
index 5c419dde39..61273f1b7b 100644
--- a/src/synthetic-homotopy-theory/universal-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/universal-property-pushouts.lagda.md
@@ -59,24 +59,10 @@ map is an equivalence:
 ```
 
 There are several ways of asserting a condition equivalent to the universal
-property of pushouts:
-
-1. The universal property of pushouts
-2. The
-   [pullback property of pushouts](synthetic-homotopy-theory.pullback-property-pushouts.md).
-   This is a restatement of the universal property of pushouts in terms of
-   pullbacks.
-3. The
-   [dependent universal property of pushouts](synthetic-homotopy-theory.dependent-universal-property-pushouts.md).
-   This property characterizes _dependent_ functions out of a pushout
-4. The
-   [dependent pullback property of pushouts](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md).
-   This is a restatement of the dependent universal property of pushouts in
-   terms of pullbacks
-5. The
-   [induction principle of pushouts](synthetic-homotopy-theory.induction-principle-pushouts.md).
-   This weaker form of the dependent universal property of pushouts expresses
-   the induction principle of pushouts seen as higher inductive types.
+property of pushouts. The statements and proofs of mutual equivalence may be
+found in the following table:
+
+{{#include tables/pushouts.md}}
 
 ## Definition
 
diff --git a/tables/pushouts.md b/tables/pushouts.md
new file mode 100644
index 0000000000..f397b801f5
--- /dev/null
+++ b/tables/pushouts.md
@@ -0,0 +1,17 @@
+| Concept                                                                                                          | Location                                                                                                                                 |
+| ---------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
+| (1) **Universal property of pushouts**<br>characterizes functions out of a pushout                               | [`synthetic-homotopy-theory.universal-property-pushouts`](synthetic-homotopy-theory.universal-property-pushouts.md)                      |
+| (2) **Dependent universal property of pushouts**<br>characterizes dependent functions out of a pushout           | [`synthetic-homotopy-theory.dependent-universal-property-pushouts`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md)  |
+| (3) **Pullback property of pushouts**<br>states the universal property in terms of pullbacks                     | [`synthetic-homotopy-theory.pullback-property-pushouts`](synthetic-homotopy-theory.pullback-property-pushouts.md)                        |
+| (4) **Dependent pullback property of pushouts**<br>states the dependent universal property in terms of pullbacks | [`synthetic-homotopy-theory.dependent-pullback-property-pushouts`](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md)    |
+| (5) **Induction principle of pushouts**<br>is the induction principle of pushouts seen as higher inductive types | [`synthetic-homotopy-theory.induction-principle-pushouts`](synthetic-homotopy-theory.induction-principle-pushouts.md)                    |
+| (1) ‚Üí (2)                                                                                                        | [`dependent-universal-property-universal-property-pushouts`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md)         |
+| (2) ‚Üí (1)                                                                                                        | [`universal-property-dependent-universal-property-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md)          |
+| (1) ‚Üí (3)                                                                                                        | [`pullback-property-pushout-universal-property-pushout`](synthetic-homotopy-theory.universal-property-pushouts.md)                       |
+| (3) ‚Üí (1)                                                                                                        | [`universal-property-pushout-pullback-property-pushout`](synthetic-homotopy-theory.universal-property-pushouts.md)                       |
+| (2) ‚Üí (4)                                                                                                        | [`dependent-pullback-property-dependent-universal-property-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md) |
+| (4) ‚Üí (2)                                                                                                        | [`dependent-universal-property-dependent-pullback-property-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md) |
+| (3) ‚Üí (4)                                                                                                        | [`dependent-pullback-property-pullback-property-pushout`](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md)             |
+| (4) ‚Üí (3)                                                                                                        | [`pullback-property-dependent-pullback-property-pushout`](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md)             |
+| (2) ‚Üí (5)                                                                                                        | [`induction-principle-pushout-dependent-universal-property-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md) |
+| (5) ‚Üí (2)                                                                                                        | [`dependent-universal-property-pushout-induction-principle-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md) |
