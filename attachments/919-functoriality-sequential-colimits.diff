diff --git a/src/foundation-core.lagda.md b/src/foundation-core.lagda.md
index 3607d4a3f7..0d74036950 100644
--- a/src/foundation-core.lagda.md
+++ b/src/foundation-core.lagda.md
@@ -8,6 +8,7 @@ module foundation-core where
 open import foundation-core.1-types public
 open import foundation-core.cartesian-product-types public
 open import foundation-core.coherently-invertible-maps public
+open import foundation-core.commuting-prisms-of-maps public
 open import foundation-core.commuting-squares-of-maps public
 open import foundation-core.commuting-triangles-of-maps public
 open import foundation-core.constant-maps public
diff --git a/src/foundation-core/commuting-prisms-of-maps.lagda.md b/src/foundation-core/commuting-prisms-of-maps.lagda.md
new file mode 100644
index 0000000000..375fd37989
--- /dev/null
+++ b/src/foundation-core/commuting-prisms-of-maps.lagda.md
@@ -0,0 +1,150 @@
+# Commuting prisms of maps
+
+```agda
+module foundation-core.commuting-prisms-of-maps where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.universe-levels
+
+open import foundation-core.commuting-squares-of-maps
+open import foundation-core.commuting-triangles-of-maps
+open import foundation-core.homotopies
+open import foundation-core.whiskering-homotopies
+```
+
+</details>
+
+## Idea
+
+Consider an arrangment of maps composable into a diagram as follows:
+
+```text
+         hA
+   A ---------> A'
+   |\           |\
+   | \ h   ⇗    | \ h'
+   |  \      f' |  \
+   |   V        |   V
+ f | ⇐ B ------ | -> B'
+   |   /   hB   | ⇐ /
+   |  / g       |  / g'
+   | /     ⇗    | /
+   VV           VV
+   C ---------> C' ,
+         hC
+```
+
+and [homotopies](foundation-core.homotopies.md) filling its faces. Then a
+{{#concept "horizontal commuting prism of maps" Agda=horizontal-coherence-prism-maps}}
+is a homotopy filling the shape. In other words, we may choose two homotopies
+from the composition `hC ∘ g ∘ h` to `f' ∘ hA`, namely following 1) the left
+[triangle](foundation-core.commuting-triangles-of-maps.md) and then the front
+[square](foundation-core.commuting-squares-of-maps.md), or 2) the two back
+squares and then the right triangle; the prism is then a homotopy between these
+two homotopies. In this way, a commuting prism may be viewed as a homotopy
+between a pasting of squares and their composite — that is the motivation for
+having the triangles go the unconventional way, from the composition to the
+composite.
+
+We may also arrange the maps into a more vertical shape, like so:
+
+```text
+          B
+      h  ^| \  g
+       /  |   \
+     /  f | ⇑   V
+    A ---------> C
+    |     | hB   |
+    | ⇗   V   ⇗  |
+ hA |     B'     | hC
+    | h' ^  \ g' |
+    |  /  ⇑   \  |
+    V/          VV
+    A' --------> C' .
+          f'
+```
+
+Then, given homotopies for the faces, we call a homotopy filling this shape a
+{{#concept "vertical commuting prism of maps" Agda=vertical-coherence-prism-maps Agda=vertical-coherence-prism-maps'}}.
+This rotation of a prism may be viewed as a homotopy between two triangles with
+different but related sides.
+
+It remains to be formalized that the type of vertical prisms is
+[equivalent](foundation-core.equivalences.md) to the type of horizontal prisms.
+
+## Definitions
+
+### Horizontal commuting prisms of maps
+
+```agda
+module _
+  { l1 l2 l3 l1' l2' l3' : Level}
+  { A : UU l1} {B : UU l2} {C : UU l3} {A' : UU l1'} {B' : UU l2'} {C' : UU l3'}
+  ( hA : A → A') (h : A → B) (h' : A' → B')
+  ( hB : B → B') (g : B → C) (g' : B' → C')
+  ( hC : C → C') (f : A → C) (f' : A' → C')
+  ( left : coherence-triangle-maps' f g h)
+  ( sq-top : coherence-square-maps hA h h' hB)
+  ( sq-bottom : coherence-square-maps hB g g' hC)
+  ( sq-front : coherence-square-maps hA f f' hC)
+  ( right : coherence-triangle-maps' f' g' h')
+  where
+
+  horizontal-coherence-prism-maps : UU (l1 ⊔ l3')
+  horizontal-coherence-prism-maps =
+    ( ( hC ·l left) ∙h sq-front) ~
+    ( ( pasting-vertical-coherence-square-maps hA h h' hB g g' hC
+        ( sq-top)
+        ( sq-bottom)) ∙h
+      ( right ·r hA))
+```
+
+### Vertical commuting prisms of maps
+
+Because triangular prisms are less symmetric than, say, cubes, we have more than
+one natural formulation for where to draw the "seams" for the filler. Here, we
+present two choices, and show that they are equivalent in
+[`foundation.commuting-prisms-of-maps`](foundation.commuting-prisms-of-maps.md).
+
+```agda
+module _
+  { l1 l2 l3 l1' l2' l3' : Level}
+  { A : UU l1} {B : UU l2} {C : UU l3}
+  ( f : A → C) (g : B → C) (h : A → B)
+  { A' : UU l1'} {B' : UU l2'} {C' : UU l3'}
+  ( f' : A' → C') (g' : B' → C') (h' : A' → B')
+  ( hA : A → A') (hB : B → B') (hC : C → C')
+  where
+
+  module _
+    ( top : coherence-triangle-maps f g h)
+    ( front : coherence-square-maps f hA hC f')
+    ( right : coherence-square-maps g hB hC g')
+    ( left : coherence-square-maps h hA hB h')
+    ( bottom : coherence-triangle-maps f' g' h')
+    where
+
+    vertical-coherence-prism-maps : UU (l1 ⊔ l3')
+    vertical-coherence-prism-maps =
+      ( ( bottom ·r hA) ∙h
+        ( pasting-horizontal-coherence-square-maps h g hA hB hC h' g'
+          ( left)
+          ( right))) ~
+      ( front ∙h (hC ·l top))
+
+  module _
+    ( top : coherence-triangle-maps f g h)
+    ( inv-front : coherence-square-maps hA f f' hC)
+    ( inv-right : coherence-square-maps hB g g' hC)
+    ( left : coherence-square-maps h hA hB h')
+    ( bottom : coherence-triangle-maps f' g' h')
+    where
+
+    vertical-coherence-prism-maps' : UU (l1 ⊔ l3')
+    vertical-coherence-prism-maps' =
+      ( inv-front ∙h ((bottom ·r hA) ∙h (g' ·l left))) ~
+      ( (hC ·l top) ∙h (inv-right ·r h))
+```
diff --git a/src/foundation-core/homotopies.lagda.md b/src/foundation-core/homotopies.lagda.md
index 42205ec1a9..29a5233dca 100644
--- a/src/foundation-core/homotopies.lagda.md
+++ b/src/foundation-core/homotopies.lagda.md
@@ -281,13 +281,13 @@ module _
   where
 
   ap-concat-htpy :
-    (H : f ~ g) (K K' : g ~ h) → K ~ K' → (H ∙h K) ~ (H ∙h K')
-  ap-concat-htpy H K K' L x = ap (concat (H x) (h x)) (L x)
+    (H : f ~ g) {K K' : g ~ h} → K ~ K' → (H ∙h K) ~ (H ∙h K')
+  ap-concat-htpy H L x = ap (concat (H x) (h x)) (L x)
 
   ap-concat-htpy' :
-    (H H' : f ~ g) (K : g ~ h) → H ~ H' → (H ∙h K) ~ (H' ∙h K)
-  ap-concat-htpy' H H' K L x =
-    ap (concat' _ (K x)) (L x)
+    {H H' : f ~ g} (K : g ~ h) → H ~ H' → (H ∙h K) ~ (H' ∙h K)
+  ap-concat-htpy' K L x =
+    ap (concat' (f x) (K x)) (L x)
 
 module _
   {l1 l2 : Level} {A : UU l1} {B : A → UU l2} {f g : (x : A) → B x}
diff --git a/src/foundation-core/whiskering-homotopies.lagda.md b/src/foundation-core/whiskering-homotopies.lagda.md
index 547b27dfc3..e79337e4b3 100644
--- a/src/foundation-core/whiskering-homotopies.lagda.md
+++ b/src/foundation-core/whiskering-homotopies.lagda.md
@@ -88,6 +88,34 @@ module _
 
 ## Properties
 
+### Unit laws for whiskering homotopies
+
+The identity map is the identity element for whiskerings from the function side,
+and the reflexivity homotopy is the identity element for whiskerings from the
+homotopy side.
+
+```agda
+module _
+  { l1 l2 : Level} {A : UU l1} {B : UU l2}
+  where
+
+  left-unit-law-left-whisk-htpy : {f f' : A → B} → (H : f ~ f') → id ·l H ~ H
+  left-unit-law-left-whisk-htpy H x = ap-id (H x)
+
+  right-unit-law-left-whisk-htpy :
+    { l3 : Level} {C : UU l3} {f : A → B} (g : B → C) →
+    g ·l refl-htpy {f = f} ~ refl-htpy
+  right-unit-law-left-whisk-htpy g = refl-htpy
+
+  left-unit-law-right-whisk-htpy :
+    {l3 : Level} {C : UU l3} {g : B → C} (f : A → B) →
+    refl-htpy {f = g} ·r f ~ refl-htpy
+  left-unit-law-right-whisk-htpy f = refl-htpy
+
+  right-unit-law-right-whisk-htpy : {f f' : A → B} → (H : f ~ f') → H ·r id ~ H
+  right-unit-law-right-whisk-htpy H = refl-htpy
+```
+
 ### Laws for whiskering an inverted homotopy
 
 ```agda
@@ -172,3 +200,20 @@ module _
   inv-htpy-coh-htpy-id : (f ·l H) ~ (H ·r f)
   inv-htpy-coh-htpy-id = inv-htpy coh-htpy-id
 ```
+
+### Whiskering whiskerings
+
+```agda
+module _
+  { l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {C : UU l3}
+  { f g : A → B}
+  where
+
+  ap-left-whisk-htpy :
+    ( h : B → C) {H H' : f ~ g} (α : H ~ H') → h ·l H ~ h ·l H'
+  ap-left-whisk-htpy h α x = ap (ap h) (α x)
+
+  ap-right-whisk-htpy :
+    { H H' : f ~ g} (α : H ~ H') (h : C → A) → H ·r h ~ H' ·r h
+  ap-right-whisk-htpy α h = α ·r h
+```
diff --git a/src/foundation.lagda.md b/src/foundation.lagda.md
index ec3a8ee545..0ce657f8ec 100644
--- a/src/foundation.lagda.md
+++ b/src/foundation.lagda.md
@@ -47,6 +47,7 @@ open import foundation.commuting-3-simplices-of-maps public
 open import foundation.commuting-cubes-of-maps public
 open import foundation.commuting-hexagons-of-identifications public
 open import foundation.commuting-pentagons-of-identifications public
+open import foundation.commuting-prisms-of-maps public
 open import foundation.commuting-squares-of-homotopies public
 open import foundation.commuting-squares-of-identifications public
 open import foundation.commuting-squares-of-maps public
diff --git a/src/foundation/action-on-identifications-functions.lagda.md b/src/foundation/action-on-identifications-functions.lagda.md
index d8627e45ac..e59fb9db53 100644
--- a/src/foundation/action-on-identifications-functions.lagda.md
+++ b/src/foundation/action-on-identifications-functions.lagda.md
@@ -52,6 +52,12 @@ ap-comp :
   {l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {C : UU l3} (g : B → C)
   (f : A → B) {x y : A} (p : x ＝ y) → (ap (g ∘ f) p) ＝ ((ap g ∘ ap f) p)
 ap-comp g f refl = refl
+
+ap-comp-assoc :
+  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {C : UU l3} {D : UU l4}
+  (h : C → D) (g : B → C) (f : A → B) {x y : A} (p : x ＝ y) →
+  ap (h ∘ g) (ap f p) ＝ ap h (ap (g ∘ f) p)
+ap-comp-assoc h g f refl = refl
 ```
 
 ### The action on identifications of any map preserves `refl`
diff --git a/src/foundation/commuting-cubes-of-maps.lagda.md b/src/foundation/commuting-cubes-of-maps.lagda.md
index 8e60f145ab..edb2d434b6 100644
--- a/src/foundation/commuting-cubes-of-maps.lagda.md
+++ b/src/foundation/commuting-cubes-of-maps.lagda.md
@@ -38,7 +38,7 @@ that the cube is presented as a lattice
        |\ /   \ /|
        | \     / |
        |/ \   / \|
-       B    D'   C'
+       B    D'   C
         \   |   /
          \  |  /
           \ | /
@@ -360,8 +360,6 @@ module _
       ( bottom ·r hA)
       ( (k ·l back-right) ∙h (refl-htpy' (k ∘ (hC ∘ g'))))) ∙h
     ( ( ap-concat-htpy'
-        ( h ·l (inv-htpy back-left))
-        ( inv-htpy (h ·l back-left))
         ( _)
         ( left-whisk-inv-htpy h back-left)) ∙h
       ( inv-htpy-left-transpose-htpy-concat (h ·l back-left) _ _
@@ -372,7 +370,7 @@ module _
                 ( (inv-htpy front-right) ·r g')) ∙h
               ( inv-htpy-right-transpose-htpy-concat _ (front-right ·r g') _
                 ( (assoc-htpy (bottom ·r hA) _ _) ∙h (inv-htpy c))))) ∙h
-          ( ap-concat-htpy (bottom ·r hA) _ _ inv-htpy-right-unit-htpy))))
+          ( ap-concat-htpy (bottom ·r hA) inv-htpy-right-unit-htpy))))
 ```
 
 ### Any commuting cube of maps induces a commuting cube of function spaces
diff --git a/src/foundation/commuting-prisms-of-maps.lagda.md b/src/foundation/commuting-prisms-of-maps.lagda.md
new file mode 100644
index 0000000000..c173d81aa3
--- /dev/null
+++ b/src/foundation/commuting-prisms-of-maps.lagda.md
@@ -0,0 +1,181 @@
+# Commuting prisms of maps
+
+```agda
+module foundation.commuting-prisms-of-maps where
+
+open import foundation-core.commuting-prisms-of-maps public
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.action-on-identifications-functions
+open import foundation.commuting-squares-of-maps
+open import foundation.identity-types
+open import foundation.path-algebra
+open import foundation.universe-levels
+open import foundation.whiskering-homotopies
+
+open import foundation-core.commuting-triangles-of-maps
+open import foundation-core.equivalences
+open import foundation-core.function-types
+open import foundation-core.functoriality-dependent-function-types
+open import foundation-core.homotopies
+```
+
+</details>
+
+## Definitions
+
+### Vertical pasting of vertical prisms of maps
+
+```agda
+module _
+  { l1 l2 l3 l1' l2' l3' l1'' l2'' l3'' : Level}
+  { A : UU l1} {B : UU l2} {C : UU l3}
+  ( f : A → C) (g : B → C) (h : A → B)
+  { A' : UU l1'} {B' : UU l2'} {C' : UU l3'}
+  ( f' : A' → C') (g' : B' → C') (h' : A' → B')
+  ( hA : A → A') (hB : B → B') (hC : C → C')
+  { A'' : UU l1''} {B'' : UU l2''} {C'' : UU l3''}
+  ( f'' : A'' → C'') (g'' : B'' → C'') (h'' : A'' → B'')
+  ( hA' : A' → A'') (hB' : B' → B'') (hC' : C' → C'')
+  ( top : coherence-triangle-maps f g h)
+  ( front-top : coherence-square-maps f hA hC f')
+  ( right-top : coherence-square-maps g hB hC g')
+  ( left-top : coherence-square-maps h hA hB h')
+  ( mid : coherence-triangle-maps f' g' h')
+  ( front-bottom : coherence-square-maps f' hA' hC' f'')
+  ( right-bottom : coherence-square-maps g' hB' hC' g'')
+  ( left-bottom : coherence-square-maps h' hA' hB' h'')
+  ( bottom : coherence-triangle-maps f'' g'' h'')
+  where
+
+  pasting-vertical-coherence-prism-maps :
+    vertical-coherence-prism-maps f g h f' g' h' hA hB hC
+      ( top)
+      ( front-top)
+      ( right-top)
+      ( left-top)
+      ( mid) →
+    vertical-coherence-prism-maps f' g' h' f'' g'' h'' hA' hB' hC'
+      ( mid)
+      ( front-bottom)
+      ( right-bottom)
+      ( left-bottom)
+      ( bottom) →
+    vertical-coherence-prism-maps f g h f'' g'' h''
+      ( hA' ∘ hA)
+      ( hB' ∘ hB)
+      ( hC' ∘ hC)
+      ( top)
+      ( pasting-vertical-coherence-square-maps f hA hC f' hA' hC' f''
+        ( front-top)
+        ( front-bottom))
+      ( pasting-vertical-coherence-square-maps g hB hC g' hB' hC' g''
+        ( right-top)
+        ( right-bottom))
+      ( pasting-vertical-coherence-square-maps h hA hB h' hA' hB' h''
+        ( left-top)
+        ( left-bottom))
+      ( bottom)
+  pasting-vertical-coherence-prism-maps prism-top prism-bottom =
+    ( ap-concat-htpy
+      ( bottom ·r hA' ·r hA)
+      ( commutative-pasting-vertical-pasting-horizontal-coherence-square-maps
+        h g hA hB hC h' g' hA' hB' hC' h'' g''
+        ( left-top)
+        ( right-top)
+        ( left-bottom)
+        ( right-bottom))) ∙h
+    ( right-whisk-square-htpy
+      ( front-bottom ·r hA)
+      ( bottom ·r hA' ·r hA)
+      ( hC' ·l ((g' ·l left-top) ∙h (right-top ·r h)))
+      ( prism-bottom ·r hA)) ∙h
+    ( ap-concat-htpy
+      ( front-bottom ·r hA)
+      ( ( ap-left-whisk-coherence-square-homotopies hC'
+          ( front-top)
+          ( mid ·r hA)
+          ( prism-top)) ∙h
+        ( ap-concat-htpy
+          ( hC' ·l front-top)
+          ( associative-left-whisk-comp
+            ( hC')
+            ( hC)
+            ( top))))) ∙h
+    ( inv-htpy-assoc-htpy
+      ( front-bottom ·r hA)
+      ( hC' ·l front-top)
+      ( ( hC' ∘ hC) ·l top))
+```
+
+## Properties
+
+### The two definitions of vertical prisms are equivalent
+
+```agda
+module _
+  { l1 l2 l3 l1' l2' l3' : Level}
+  { A : UU l1} {B : UU l2} {C : UU l3}
+  ( f : A → C) (g : B → C) (h : A → B)
+  { A' : UU l1'} {B' : UU l2'} {C' : UU l3'}
+  ( f' : A' → C') (g' : B' → C') (h' : A' → B')
+  ( hA : A → A') (hB : B → B') (hC : C → C')
+  ( top : coherence-triangle-maps f g h)
+  ( inv-front : coherence-square-maps hA f f' hC)
+  ( inv-right : coherence-square-maps hB g g' hC)
+  ( left : coherence-square-maps h hA hB h')
+  ( bottom : coherence-triangle-maps f' g' h')
+  where
+
+  equiv-rotate-vertical-coherence-prism-maps :
+    vertical-coherence-prism-maps' f g h f' g' h' hA hB hC
+      ( top)
+      ( inv-front)
+      ( inv-right)
+      ( left)
+      ( bottom) ≃
+    vertical-coherence-prism-maps f g h f' g' h' hA hB hC
+      ( top)
+      ( inv-htpy inv-front)
+      ( inv-htpy inv-right)
+      ( left)
+      ( bottom)
+  equiv-rotate-vertical-coherence-prism-maps =
+    equiv-Π-equiv-family
+      ( λ a →
+        ( equiv-concat-assoc
+          ( bottom (hA a))
+          ( ap g' (left a))
+          ( inv (inv-right (h a))) _) ∘e
+        ( equiv-right-transpose-eq-concat' _
+          ( inv (inv-front a) ∙ ap hC (top a))
+          ( inv-right (h a))) ∘e
+        ( inv-equiv
+          ( equiv-concat-assoc' _
+            ( inv (inv-front a))
+            ( ap hC (top a))
+            ( inv-right (h a)))) ∘e
+        ( equiv-left-transpose-eq-concat
+          ( inv-front a)
+          ( bottom (hA a) ∙ ap g' (left a))
+          ( _)))
+
+  rotate-vertical-coherence-prism-maps :
+    vertical-coherence-prism-maps' f g h f' g' h' hA hB hC
+      ( top)
+      ( inv-front)
+      ( inv-right)
+      ( left)
+      ( bottom) →
+    vertical-coherence-prism-maps f g h f' g' h' hA hB hC
+      ( top)
+      ( inv-htpy inv-front)
+      ( inv-htpy inv-right)
+      ( left)
+      ( bottom)
+  rotate-vertical-coherence-prism-maps =
+    map-equiv equiv-rotate-vertical-coherence-prism-maps
+```
diff --git a/src/foundation/commuting-squares-of-maps.lagda.md b/src/foundation/commuting-squares-of-maps.lagda.md
index d20b430b0c..878c10e3e5 100644
--- a/src/foundation/commuting-squares-of-maps.lagda.md
+++ b/src/foundation/commuting-squares-of-maps.lagda.md
@@ -11,12 +11,16 @@ open import foundation-core.commuting-squares-of-maps public
 ```agda
 open import foundation.action-on-identifications-binary-functions
 open import foundation.action-on-identifications-functions
+open import foundation.commuting-squares-of-homotopies
+open import foundation.commuting-squares-of-identifications
 open import foundation.equivalences
 open import foundation.function-extensionality
+open import foundation.path-algebra
 open import foundation.precomposition-functions
 open import foundation.universe-levels
 open import foundation.whiskering-homotopies
 
+open import foundation-core.commuting-prisms-of-maps
 open import foundation-core.commuting-triangles-of-maps
 open import foundation-core.function-types
 open import foundation-core.functoriality-function-types
@@ -30,7 +34,7 @@ open import foundation-core.identity-types
 
 ### Pasting commuting triangles into commuting squares along homotopic diagonals
 
-Two commuting triangles
+Two [commuting triangles](foundation-core.commuting-triangles-of-maps.md)
 
 ```text
    A         A --> X
@@ -41,7 +45,8 @@ Two commuting triangles
   B --> Y         Y
 ```
 
-with a homotopic diagonal may be pasted into a commuting square
+with a [homotopic](foundation-core.homotopies.md) diagonal may be pasted into a
+commuting square
 
 ```text
   A -----> X
@@ -92,8 +97,9 @@ module _
 
 ### Inverting squares horizontally and vertically
 
-If the horizontal/vertical maps in a commuting square are both equivalences,
-then the square remains commuting if we invert those equivalences.
+If the horizontal/vertical maps in a commuting square are both
+[equivalences](foundation-core.equivalences.md), then the square remains
+commuting if we invert those equivalences.
 
 ```agda
 coherence-square-inv-horizontal :
@@ -102,7 +108,8 @@ coherence-square-inv-horizontal :
   coherence-square-maps (map-equiv top) left right (map-equiv bottom) →
   coherence-square-maps (map-inv-equiv top) right left (map-inv-equiv bottom)
 coherence-square-inv-horizontal top left right bottom H b =
-  map-eq-transpose-equiv' bottom
+  map-eq-transpose-equiv-inv
+    ( bottom)
     ( ( ap right (inv (is-section-map-inv-equiv top b))) ∙
       ( inv (H (map-inv-equiv top b))))
 
@@ -112,7 +119,8 @@ coherence-square-inv-vertical :
   coherence-square-maps top (map-equiv left) (map-equiv right) bottom →
   coherence-square-maps bottom (map-inv-equiv left) (map-inv-equiv right) top
 coherence-square-inv-vertical top left right bottom H x =
-  map-eq-transpose-equiv right
+  map-eq-transpose-equiv
+    ( right)
     ( ( inv (H (map-inv-equiv left x))) ∙
       ( ap bottom (is-section-map-inv-equiv left x)))
 
@@ -162,11 +170,440 @@ precomp-coherence-square-maps top left right bottom H X =
 
 ## Properties
 
+### Taking vertical inversions of squares is an inverse operation
+
+Vertical composition of a square with the square obtained by inverting the
+vertical maps fits into a [prism](foundation.commuting-prisms-of-maps.md) with
+the reflexivity square.
+
+The analogous result for horizontal composition remains to be formalized.
+
+```agda
+module _
+  { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} {Y : UU l4}
+  ( top : A → X) (left : A ≃ B) (right : X ≃ Y) (bottom : B → Y)
+  where
+
+  left-inverse-law-pasting-vertical-coherence-square-maps :
+    ( H : coherence-square-maps top (map-equiv left) (map-equiv right) bottom) →
+    horizontal-coherence-prism-maps
+      ( top)
+      ( map-equiv left)
+      ( map-equiv right)
+      ( bottom)
+      ( map-inv-equiv left)
+      ( map-inv-equiv right)
+      ( top)
+      ( id)
+      ( id)
+      ( is-retraction-map-inv-equiv left)
+      ( H)
+      ( coherence-square-inv-vertical top left right bottom H)
+      ( refl-htpy)
+      ( is-retraction-map-inv-equiv right)
+  left-inverse-law-pasting-vertical-coherence-square-maps H a =
+    ( right-unit) ∙
+    ( inv
+      ( ( ap
+          ( λ q →
+            ( q ∙ ap (map-inv-equiv right) (H a)) ∙
+            ( is-retraction-map-inv-equiv right (top a)))
+          ( triangle-eq-transpose-equiv-concat
+            ( right)
+            ( inv (H (map-inv-equiv left (map-equiv left a))))
+            ( ap bottom (is-section-map-inv-equiv left (map-equiv left a))))) ∙
+        ( assoc
+          ( ( map-eq-transpose-equiv
+              ( right)
+              ( inv (H (map-inv-equiv left (map-equiv left a))))) ∙
+            ( ap
+              ( map-inv-equiv right)
+              ( ap bottom (is-section-map-inv-equiv left (map-equiv left a)))))
+          ( ap (map-inv-equiv right) (H a))
+          ( is-retraction-map-inv-equiv right (top a))) ∙
+        ( left-whisk-square-identification
+          ( map-eq-transpose-equiv
+            ( right)
+            ( inv (H (map-inv-equiv left (map-equiv left a)))))
+          ( inv
+            ( coherence-square-identifications-comp-vertical
+              { p-left =
+                  ap
+                    ( map-inv-equiv right)
+                    ( H (map-inv-equiv left (map-equiv left a)))}
+              { p-top =
+                  ap
+                    ( map-inv-equiv right)
+                    ( ap
+                      ( bottom)
+                      ( is-section-map-inv-equiv left (map-equiv left a)))}
+              { q-bottom = ap top (is-retraction-map-inv-equiv left a)}
+              ( coherence-square-identifications-top-paste
+                ( ap
+                  ( map-inv-equiv right)
+                  ( H (map-inv-equiv left (map-equiv left a))))
+                ( _)
+                ( _)
+                ( _)
+                ( inv
+                  ( ap
+                    ( ap (map-inv-equiv right))
+                    ( ( ap (ap bottom) (coherence-map-inv-equiv left a)) ∙
+                      ( inv
+                        ( ap-comp
+                          ( bottom)
+                          ( map-equiv left)
+                          ( is-retraction-map-inv-equiv left a))))))
+                ( coherence-square-identifications-ap
+                  ( map-inv-equiv right)
+                  ( ap
+                    ( bottom ∘ map-equiv left)
+                    ( is-retraction-map-inv-equiv left a))
+                  ( H (map-inv-equiv left (map-equiv left a)))
+                  ( H a)
+                  ( ap
+                    ( map-equiv right ∘ top)
+                    ( is-retraction-map-inv-equiv left a))
+                  ( nat-htpy H (is-retraction-map-inv-equiv left a))))
+              ( coherence-square-identifications-top-paste _
+                ( ap top (is-retraction-map-inv-equiv left a))
+                ( _)
+                ( _)
+                ( ap-comp
+                  ( map-inv-equiv right)
+                  ( map-equiv right ∘ top)
+                  ( is-retraction-map-inv-equiv left a))
+                ( nat-htpy
+                  ( is-retraction-map-inv-equiv right ·r top)
+                  ( is-retraction-map-inv-equiv left a)))))) ∙
+        ( ap
+          ( _∙ ap top (is-retraction-map-inv-equiv left a))
+          ( right-inverse-eq-transpose-equiv
+            ( right)
+            ( H (map-inv-equiv left (map-equiv left a)))))))
+
+  right-inverse-law-pasting-vertical-coherence-square-maps :
+    ( H : coherence-square-maps top (map-equiv left) (map-equiv right) bottom) →
+    horizontal-coherence-prism-maps
+      ( bottom)
+      ( map-inv-equiv left)
+      ( map-inv-equiv right)
+      ( top)
+      ( map-equiv left)
+      ( map-equiv right)
+      ( bottom)
+      ( id)
+      ( id)
+      ( is-section-map-inv-equiv left)
+      ( coherence-square-inv-vertical top left right bottom H)
+      ( H)
+      ( refl-htpy)
+      ( is-section-map-inv-equiv right)
+  right-inverse-law-pasting-vertical-coherence-square-maps H a =
+    ( right-unit) ∙
+    ( inv
+      ( ( assoc
+          ( H (map-inv-equiv left a))
+          ( ap
+            ( map-equiv right)
+            ( coherence-square-inv-vertical top left right bottom H a))
+          ( is-section-map-inv-equiv right (bottom a))) ∙
+        ( ap
+          ( H (map-inv-equiv left a) ∙_)
+          ( triangle-eq-transpose-equiv
+            ( right)
+            ( ( inv (H (map-inv-equiv left a))) ∙
+              ( ap bottom (is-section-map-inv-equiv left a))))) ∙
+        ( is-retraction-left-concat-inv
+          ( H (map-inv-equiv left a))
+          ( ap bottom (is-section-map-inv-equiv left a)))))
+```
+
+### Associativity of vertical pasting
+
+The proof of associativity of horizontal pasting may be found in
+[`foundation-core.commuting-squares-of-maps`](foundation-core.commuting-squares-of-maps.md).
+
+```agda
+module _
+  { l1 l2 l3 l4 l5 l6 l7 l8 : Level}
+  { A : UU l1} {B : UU l2} {C : UU l3} {D : UU l4}
+  { X : UU l5} {Y : UU l6} {Z : UU l7} {W : UU l8}
+  ( top : A → X) (top-left : A → B) (top-right : X → Y)
+  ( mid-top : B → Y) (mid-left : B → C) (mid-right : Y → Z) (mid-bottom : C → Z)
+  ( bottom-left : C → D) (bottom-right : Z → W) (bottom : D → W)
+  ( sq-top : coherence-square-maps top top-left top-right mid-top)
+  ( sq-mid : coherence-square-maps mid-top mid-left mid-right mid-bottom)
+  ( sq-bottom :
+      coherence-square-maps mid-bottom bottom-left bottom-right bottom)
+  where
+
+  assoc-pasting-vertical-coherence-square-maps :
+    pasting-vertical-coherence-square-maps
+      ( top)
+      ( mid-left ∘ top-left)
+      ( mid-right ∘ top-right)
+      ( mid-bottom)
+      ( bottom-left)
+      ( bottom-right)
+      ( bottom)
+      ( pasting-vertical-coherence-square-maps
+        ( top)
+        ( top-left)
+        ( top-right)
+        ( mid-top)
+        ( mid-left)
+        ( mid-right)
+        ( mid-bottom)
+        ( sq-top)
+        ( sq-mid))
+      ( sq-bottom) ~
+    pasting-vertical-coherence-square-maps
+      ( top)
+      ( top-left)
+      ( top-right)
+      ( mid-top)
+      ( bottom-left ∘ mid-left)
+      ( bottom-right ∘ mid-right)
+      ( bottom)
+      ( sq-top)
+      ( pasting-vertical-coherence-square-maps
+        ( mid-top)
+        ( mid-left)
+        ( mid-right)
+        ( mid-bottom)
+        ( bottom-left)
+        ( bottom-right)
+        ( bottom)
+        ( sq-mid)
+        ( sq-bottom))
+  assoc-pasting-vertical-coherence-square-maps =
+    ( ap-concat-htpy
+      ( sq-bottom ·r mid-left ·r top-left)
+      ( ( distributive-left-whisk-concat-htpy
+          ( bottom-right)
+          ( sq-mid ·r top-left)
+          ( mid-right ·l sq-top)) ∙h
+        ( ap-concat-htpy
+          ( bottom-right ·l (sq-mid ·r top-left))
+          ( associative-left-whisk-comp bottom-right mid-right sq-top)))) ∙h
+    ( inv-htpy-assoc-htpy
+      ( sq-bottom ·r mid-left ·r top-left)
+      ( bottom-right ·l (sq-mid ·r top-left))
+      ( ( bottom-right ∘ mid-right) ·l sq-top))
+```
+
+### Naturality of commuting squares of maps with respect to identifications
+
+Similarly to the naturality square of homotopies and
+[identifications](foundation-core.identity-types.md), we have a naturality
+square of coherence squares of maps and identifications:
+
+```text
+           ap f (ap g p)
+  f (g x) =============== f (g y)
+     ‖                       ‖
+ H x ‖                       ‖ H y
+     ‖                       ‖
+  h (k x) =============== h (k y)
+           ap h (ap k p)           .
+```
+
+```agda
+module _
+  { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {C : UU l3} {D : UU l4}
+  ( top : A → B) (left : A → C) (right : B → D) (bottom : C → D)
+  ( H : coherence-square-maps top left right bottom)
+  where
+
+  nat-coherence-square-maps :
+    { x y : A} (p : x ＝ y) →
+    coherence-square-identifications
+      ( ap bottom (ap left p))
+      ( H x)
+      ( H y)
+      ( ap right (ap top p))
+  nat-coherence-square-maps refl = right-unit
+```
+
+As a corollary, whenever we have two coherence squares touching at a vertex:
+
+```text
+  A -----> B
+  |        |
+  |   H ⇗  |
+  V        V
+  C -----> D -----> X
+           |        |
+           |   K ⇗  |
+           V        V
+           Y -----> Z ,
+```
+
+there is a homotopy between first applying `H`, then `K`, and first applying
+`K`, then `H`.
+
+```agda
+module _
+  { l1 l2 l3 l4 l5 l6 l7 : Level}
+  { A : UU l1} {B : UU l2} {C : UU l3} {D : UU l4}
+  { X : UU l5} {Y : UU l6} {Z : UU l7}
+  ( top : A → B) (left : A → C) (mid-top : B → D) (mid-left : C → D)
+  ( mid-right : D → X) (mid-bottom : D → Y) (right : X → Z) (bottom : Y → Z)
+  ( H : coherence-square-maps top left mid-top mid-left)
+  ( K : coherence-square-maps mid-right mid-bottom right bottom)
+  where
+
+  swap-nat-coherence-square-maps :
+    coherence-square-homotopies
+      ( bottom ·l mid-bottom ·l H)
+      ( K ·r mid-left ·r left)
+      ( K ·r mid-top ·r top)
+      ( right ·l mid-right ·l H)
+  swap-nat-coherence-square-maps x =
+    nat-coherence-square-maps mid-right mid-bottom right bottom K (H x)
+```
+
+### Commutativity of horizontal and vertical pasting
+
+Given a square of commuting squares, like so:
+
+```text
+  A -----> B -----> C
+  |        |        |
+  |    ⇗   |    ⇗   |
+  V        V        V
+  X -----> Y -----> Z
+  |        |        |
+  |    ⇗   |    ⇗   |
+  V        V        V
+  M -----> N -----> O ,
+```
+
+we have two choices for obtaining the outer commuting square — either by first
+vertically composing the smaller squares, and then horizontally composing the
+newly created rectangles, or by first horizontally composing the squares, and
+then vertically composing the rectangles.
+
+The following lemma states that the big squares obtained by these two
+compositions are again homotopic. Diagramatically, we have
+
+```text
+ H | K   H | K
+ ----- ~ --|--
+ L | T   L | T .
+```
+
+```agda
+module _
+  { l1 l2 l3 l4 l5 l6 l7 l8 l9 : Level}
+  { A : UU l1} {B : UU l2} {C : UU l3} {X : UU l4} {Y : UU l5} {Z : UU l6}
+  { M : UU l7} {N : UU l8} {O : UU l9}
+  ( top-left : A → B) (top-right : B → C)
+  ( left-top : A → X) (mid-top : B → Y) (right-top : C → Z)
+  ( mid-left : X → Y) (mid-right : Y → Z)
+  ( left-bottom : X → M) (mid-bottom : Y → N) (right-bottom : Z → O)
+  ( bottom-left : M → N) (bottom-right : N → O)
+  ( sq-left-top : coherence-square-maps top-left left-top mid-top mid-left)
+  ( sq-right-top : coherence-square-maps top-right mid-top right-top mid-right)
+  ( sq-left-bottom :
+      coherence-square-maps mid-left left-bottom mid-bottom bottom-left)
+  ( sq-right-bottom :
+      coherence-square-maps mid-right mid-bottom right-bottom bottom-right)
+  where
+
+  commutative-pasting-vertical-pasting-horizontal-coherence-square-maps :
+    ( pasting-horizontal-coherence-square-maps
+      ( top-left)
+      ( top-right)
+      ( left-bottom ∘ left-top)
+      ( mid-bottom ∘ mid-top)
+      ( right-bottom ∘ right-top)
+      ( bottom-left)
+      ( bottom-right)
+      ( pasting-vertical-coherence-square-maps
+        ( top-left)
+        ( left-top)
+        ( mid-top)
+        ( mid-left)
+        ( left-bottom)
+        ( mid-bottom)
+        ( bottom-left)
+        ( sq-left-top)
+        ( sq-left-bottom))
+      ( pasting-vertical-coherence-square-maps
+        ( top-right)
+        ( mid-top)
+        ( right-top)
+        ( mid-right)
+        ( mid-bottom)
+        ( right-bottom)
+        ( bottom-right)
+        ( sq-right-top)
+        ( sq-right-bottom))) ~
+    ( pasting-vertical-coherence-square-maps
+      ( top-right ∘ top-left)
+      ( left-top)
+      ( right-top)
+      ( mid-right ∘ mid-left)
+      ( left-bottom)
+      ( right-bottom)
+      ( bottom-right ∘ bottom-left)
+      ( pasting-horizontal-coherence-square-maps
+        ( top-left)
+        ( top-right)
+        ( left-top)
+        ( mid-top)
+        ( right-top)
+        ( mid-left)
+        ( mid-right)
+        ( sq-left-top)
+        ( sq-right-top))
+      ( pasting-horizontal-coherence-square-maps
+        ( mid-left)
+        ( mid-right)
+        ( left-bottom)
+        ( mid-bottom)
+        ( right-bottom)
+        ( bottom-left)
+        ( bottom-right)
+        ( sq-left-bottom)
+        ( sq-right-bottom)))
+  commutative-pasting-vertical-pasting-horizontal-coherence-square-maps =
+    ( ap-concat-htpy' _
+      ( distributive-left-whisk-concat-htpy
+        ( bottom-right)
+        ( sq-left-bottom ·r left-top)
+        ( mid-bottom ·l sq-left-top)) ∙h
+      ( both-whisk-square-htpy
+        ( bottom-right ·l (sq-left-bottom ·r left-top))
+        ( right-bottom ·l (sq-right-top ·r top-left))
+        ( inv-htpy
+          ( swap-nat-coherence-square-maps
+            ( top-left)
+            ( left-top)
+            ( mid-top)
+            ( mid-left)
+            ( mid-right)
+            ( mid-bottom)
+            ( right-bottom)
+            ( bottom-right)
+            ( sq-left-top)
+            ( sq-right-bottom))))) ∙h
+      ( ap-concat-htpy _
+        ( inv-htpy
+          ( distributive-left-whisk-concat-htpy
+            ( right-bottom)
+            ( mid-right ·l sq-left-top)
+            ( sq-right-top ·r top-left))))
+```
+
 ### Distributivity of pasting squares and transposing by precomposition
 
 Given two commuting squares which can be composed horizontally (vertically), we
-know that composing them and then transposing them by precomposition gives the
-same homotopies as first transposing the squares and then composing them.
+know that composing them and then transposing them by precomposition gives a
+homotopy that is homotopic to first transposing the squares and then composing
+them.
 
 ```text
       tl       tr                tr ∘ tl
diff --git a/src/foundation/equivalences.lagda.md b/src/foundation/equivalences.lagda.md
index 2265899cee..38b3006946 100644
--- a/src/foundation/equivalences.lagda.md
+++ b/src/foundation/equivalences.lagda.md
@@ -16,6 +16,7 @@ open import foundation.equivalence-extensionality
 open import foundation.function-extensionality
 open import foundation.functoriality-fibers-of-maps
 open import foundation.identity-types
+open import foundation.path-algebra
 open import foundation.truncated-maps
 open import foundation.universal-property-equivalences
 open import foundation.universe-levels
@@ -59,9 +60,26 @@ module _
 
 ### Transposing equalities along equivalences
 
-The fact that equivalences are embeddings has many important consequences, we
-will use some of these consequences in order to derive basic properties of
-embeddings.
+We have two ways of showing that an application of an equivalence may be
+transposed to the other side of an
+[identification](foundation-core.identity-types.md), i.e. that the type
+`e x ＝ y` is equivalent to the type `x ＝ e⁻¹ y` — one uses the fact that `e⁻¹`
+is a [section](foundation-core.sections.md) of `e`, from which it follows that
+
+```text
+ (e x ＝ y) ≃ (e x ＝ e e⁻¹ y) ≃ (x ＝ e⁻¹ y) ,
+```
+
+and the other using the fact that `e⁻¹` is a
+[retraction](foundation-core.retractions.md) of `e`, resulting in the
+equivalence
+
+```text
+ (e x ＝ y) ≃ (e⁻¹ e x ＝ e⁻¹ y) ≃ (x ＝ e⁻¹ y) .
+```
+
+These two equivalences are [homotopic](foundation-core.homotopies.md), as is
+shown below.
 
 ```agda
 module _
@@ -84,9 +102,79 @@ module _
     {x : A} {y : B} → x ＝ map-inv-equiv e y → map-equiv e x ＝ y
   inv-map-eq-transpose-equiv {x} {y} = map-inv-equiv (eq-transpose-equiv x y)
 
+  eq-transpose-equiv' :
+    (x : A) (y : B) → (map-equiv e x ＝ y) ≃ (x ＝ map-inv-equiv e y)
+  eq-transpose-equiv' x y =
+    ( equiv-concat
+      ( inv (is-retraction-map-inv-equiv e x))
+      ( map-inv-equiv e y)) ∘e
+    ( equiv-ap (inv-equiv e) (map-equiv e x) y)
+
+  map-eq-transpose-equiv' :
+    {x : A} {y : B} → map-equiv e x ＝ y → x ＝ map-inv-equiv e y
+  map-eq-transpose-equiv' {x} {y} = map-equiv (eq-transpose-equiv' x y)
+```
+
+It is sometimes useful to consider identifications `y ＝ e x` instead of
+`e x ＝ y`, so we include an inverted equivalence for that as well.
+
+```agda
+  eq-transpose-equiv-inv :
+    (x : A) (y : B) → (y ＝ map-equiv e x) ≃ (map-inv-equiv e y ＝ x)
+  eq-transpose-equiv-inv x y =
+    ( equiv-inv x (map-inv-equiv e y)) ∘e
+    ( eq-transpose-equiv x y) ∘e
+    ( equiv-inv y (map-equiv e x))
+
+  map-eq-transpose-equiv-inv :
+    {a : A} {b : B} → b ＝ map-equiv e a → map-inv-equiv e b ＝ a
+  map-eq-transpose-equiv-inv {a} {b} = map-equiv (eq-transpose-equiv-inv a b)
+
+  inv-map-eq-transpose-equiv-inv :
+    {a : A} {b : B} → map-inv-equiv e b ＝ a → b ＝ map-equiv e a
+  inv-map-eq-transpose-equiv-inv {a} {b} =
+    map-inv-equiv (eq-transpose-equiv-inv a b)
+```
+
+#### Computation rules for transposing equivalences
+
+We begin by showing that the two equivalences stated above are homotopic.
+
+```agda
+module _
+  {l1 l2 : Level} {A : UU l1} {B : UU l2} (e : A ≃ B)
+  where
+
+  htpy-map-eq-transpose-equiv :
+    {x : A} {y : B} →
+    map-eq-transpose-equiv e {x} {y} ~ map-eq-transpose-equiv' e
+  htpy-map-eq-transpose-equiv {x} refl =
+    ( map-eq-transpose-equiv-inv
+      ( equiv-ap e x _)
+      ( ( ap inv (coherence-map-inv-equiv e x)) ∙
+        ( inv (ap-inv (map-equiv e) (is-retraction-map-inv-equiv e x))))) ∙
+    ( inv right-unit)
+```
+
+Transposing a composition of paths fits into a triangle with a transpose of the
+left factor.
+
+```agda
+  triangle-eq-transpose-equiv-concat :
+    {x : A} {y z : B} (p : map-equiv e x ＝ y) (q : y ＝ z) →
+    ( map-eq-transpose-equiv e (p ∙ q)) ＝
+    ( map-eq-transpose-equiv e p ∙ ap (map-inv-equiv e) q)
+  triangle-eq-transpose-equiv-concat refl refl = inv right-unit
+```
+
+Transposed identifications fit in
+[commuting triangles](foundation.commuting-triangles-of-identifications.md) with
+the original identifications.
+
+```agda
   triangle-eq-transpose-equiv :
     {x : A} {y : B} (p : map-equiv e x ＝ y) →
-    ( ( ap (map-equiv e) (map-eq-transpose-equiv p)) ∙
+    ( ( ap (map-equiv e) (map-eq-transpose-equiv e p)) ∙
       ( is-section-map-inv-equiv e y)) ＝
     ( p)
   triangle-eq-transpose-equiv {x} {y} p =
@@ -102,29 +190,20 @@ module _
       ( ( ap (concat p y) (left-inv (is-section-map-inv-equiv e y))) ∙
         ( right-unit)))
 
-  map-eq-transpose-equiv' :
-    {a : A} {b : B} → b ＝ map-equiv e a → map-inv-equiv e b ＝ a
-  map-eq-transpose-equiv' p = inv (map-eq-transpose-equiv (inv p))
-
-  inv-map-eq-transpose-equiv' :
-    {a : A} {b : B} → map-inv-equiv e b ＝ a → b ＝ map-equiv e a
-  inv-map-eq-transpose-equiv' p =
-    inv (inv-map-eq-transpose-equiv (inv p))
-
-  triangle-eq-transpose-equiv' :
+  triangle-eq-transpose-equiv-inv :
     {x : A} {y : B} (p : y ＝ map-equiv e x) →
     ( (is-section-map-inv-equiv e y) ∙ p) ＝
-    ( ap (map-equiv e) (map-eq-transpose-equiv' p))
-  triangle-eq-transpose-equiv' {x} {y} p =
+    ( ap (map-equiv e) (map-eq-transpose-equiv-inv e p))
+  triangle-eq-transpose-equiv-inv {x} {y} p =
     map-inv-equiv
       ( equiv-ap
         ( equiv-inv (map-equiv e (map-inv-equiv e y)) (map-equiv e x))
         ( (is-section-map-inv-equiv e y) ∙ p)
-        ( ap (map-equiv e) (map-eq-transpose-equiv' p)))
+        ( ap (map-equiv e) (map-eq-transpose-equiv-inv e p)))
       ( ( distributive-inv-concat (is-section-map-inv-equiv e y) p) ∙
         ( ( inv
             ( right-transpose-eq-concat
-              ( ap (map-equiv e) (inv (map-eq-transpose-equiv' p)))
+              ( ap (map-equiv e) (inv (map-eq-transpose-equiv-inv e p)))
               ( is-section-map-inv-equiv e y)
               ( inv p)
               ( ( ap
@@ -137,7 +216,43 @@ module _
                         ( ( inv p) ∙
                           ( inv (is-section-map-inv-equiv e y))))))) ∙
                 ( triangle-eq-transpose-equiv (inv p))))) ∙
-          ( ap-inv (map-equiv e) (map-eq-transpose-equiv' p))))
+          ( ap-inv (map-equiv e) (map-eq-transpose-equiv-inv e p))))
+
+  triangle-eq-transpose-equiv' :
+    {x : A} {y : B} (p : map-equiv e x ＝ y) →
+    ( is-retraction-map-inv-equiv e x ∙ map-eq-transpose-equiv e p) ＝
+    ( ap (map-inv-equiv e) p)
+  triangle-eq-transpose-equiv' {x} refl =
+    ( ap
+      ( is-retraction-map-inv-equiv e x ∙_)
+      ( htpy-map-eq-transpose-equiv refl)) ∙
+    ( is-retraction-left-concat-inv (is-retraction-map-inv-equiv e x) refl)
+
+  triangle-eq-transpose-equiv-inv' :
+    {x : A} {y : B} (p : y ＝ map-equiv e x) →
+    ( map-eq-transpose-equiv-inv e p) ＝
+    ( ap (map-inv-equiv e) p ∙ is-retraction-map-inv-equiv e x)
+  triangle-eq-transpose-equiv-inv' {x} refl =
+    inv
+      ( right-transpose-eq-concat
+        ( is-retraction-map-inv-equiv e x)
+        ( map-eq-transpose-equiv e refl)
+        ( refl)
+        ( triangle-eq-transpose-equiv' refl))
+
+  right-inverse-eq-transpose-equiv :
+    {x : A} {y : B} (p : y ＝ map-equiv e x) →
+    ( ( map-eq-transpose-equiv e (inv p)) ∙
+      ( ap (map-inv-equiv e) p ∙ is-retraction-map-inv-equiv e x)) ＝
+    ( refl)
+  right-inverse-eq-transpose-equiv {x} p =
+    inv
+      ( map-inv-equiv
+        ( equiv-left-transpose-eq-concat'
+          ( refl)
+          ( map-eq-transpose-equiv e (inv p))
+          ( ap (map-inv-equiv e) p ∙ is-retraction-map-inv-equiv e x))
+        ( right-unit ∙ triangle-eq-transpose-equiv-inv' p))
 ```
 
 ### Equivalences have a contractible type of sections
@@ -551,7 +666,7 @@ module _
   distributive-inv-comp-equiv e f =
     eq-htpy-equiv
       ( λ x →
-        map-eq-transpose-equiv'
+        map-eq-transpose-equiv-inv
           ( f ∘e e)
           ( ( ap (λ g → map-equiv g x) (inv (right-inverse-law-equiv f))) ∙
             ( ap
diff --git a/src/foundation/identity-types.lagda.md b/src/foundation/identity-types.lagda.md
index b15cec9771..75089c9cf7 100644
--- a/src/foundation/identity-types.lagda.md
+++ b/src/foundation/identity-types.lagda.md
@@ -233,6 +233,18 @@ module _
   pr2 (equiv-left-transpose-eq-concat p q r) =
     is-equiv-left-transpose-eq-concat p q r
 
+  equiv-left-transpose-eq-concat' :
+    (p : x ＝ z) (q : x ＝ y) (r : y ＝ z) →
+    (p ＝ q ∙ r) ≃ (inv q ∙ p ＝ r)
+  equiv-left-transpose-eq-concat' p q r =
+    equiv-inv _ _ ∘e equiv-left-transpose-eq-concat q r p ∘e equiv-inv _ _
+
+  left-transpose-eq-concat' :
+    (p : x ＝ z) (q : x ＝ y) (r : y ＝ z) →
+    (p ＝ q ∙ r) → (inv q ∙ p ＝ r)
+  left-transpose-eq-concat' p q r =
+    map-equiv (equiv-left-transpose-eq-concat' p q r)
+
   abstract
     is-equiv-right-transpose-eq-concat :
       (p : x ＝ y) (q : y ＝ z) (r : x ＝ z) →
@@ -250,6 +262,18 @@ module _
   pr1 (equiv-right-transpose-eq-concat p q r) = right-transpose-eq-concat p q r
   pr2 (equiv-right-transpose-eq-concat p q r) =
     is-equiv-right-transpose-eq-concat p q r
+
+  equiv-right-transpose-eq-concat' :
+    (p : x ＝ z) (q : x ＝ y) (r : y ＝ z) →
+    (p ＝ q ∙ r) ≃ (p ∙ inv r ＝ q)
+  equiv-right-transpose-eq-concat' p q r =
+    equiv-inv _ _ ∘e equiv-right-transpose-eq-concat q r p ∘e equiv-inv _ _
+
+  right-transpose-eq-concat' :
+    (p : x ＝ z) (q : x ＝ y) (r : y ＝ z) →
+    (p ＝ q ∙ r) → (p ∙ inv r ＝ q)
+  right-transpose-eq-concat' p q r =
+    map-equiv (equiv-right-transpose-eq-concat' p q r)
 ```
 
 ### Computation of fibers of families of maps out of the identity type
diff --git a/src/foundation/path-algebra.lagda.md b/src/foundation/path-algebra.lagda.md
index 4bf44f330e..11f7e9d7f8 100644
--- a/src/foundation/path-algebra.lagda.md
+++ b/src/foundation/path-algebra.lagda.md
@@ -12,10 +12,12 @@ open import foundation.action-on-identifications-functions
 open import foundation.binary-embeddings
 open import foundation.binary-equivalences
 open import foundation.commuting-squares-of-identifications
+open import foundation.dependent-pair-types
 open import foundation.identity-types
 open import foundation.universe-levels
 
 open import foundation-core.constant-maps
+open import foundation-core.equivalences
 open import foundation-core.function-types
 open import foundation-core.homotopies
 ```
@@ -249,6 +251,124 @@ module _
   htpy-identification-left-whisk β p = identification-left-whisk p β
 ```
 
+### Whiskerings of identifications are equivalences
+
+```agda
+module _
+  {l : Level} {A : UU l} {x y z : A}
+  where
+
+  is-equiv-identification-left-whisk :
+    (p : x ＝ y) {q q' : y ＝ z} →
+    is-equiv (identification-left-whisk p {q} {q'})
+  is-equiv-identification-left-whisk p {q} {q'} =
+    is-emb-is-equiv (is-equiv-concat p z) q q'
+
+  equiv-identification-left-whisk :
+    (p : x ＝ y) {q q' : y ＝ z} →
+    (q ＝ q') ≃ (p ∙ q ＝ p ∙ q')
+  pr1 (equiv-identification-left-whisk p) = identification-left-whisk p
+  pr2 (equiv-identification-left-whisk p) = is-equiv-identification-left-whisk p
+
+  is-equiv-identification-right-whisk :
+    {p p' : x ＝ y} → (q : y ＝ z) →
+    is-equiv (λ (α : p ＝ p') → identification-right-whisk α q)
+  is-equiv-identification-right-whisk {p} {p'} q =
+    is-emb-is-equiv (is-equiv-concat' x q) p p'
+
+  equiv-identification-right-whisk :
+    {p p' : x ＝ y} → (q : y ＝ z) →
+    (p ＝ p') ≃ (p ∙ q ＝ p' ∙ q)
+  pr1 (equiv-identification-right-whisk q) α = identification-right-whisk α q
+  pr2 (equiv-identification-right-whisk q) =
+    is-equiv-identification-right-whisk q
+```
+
+### Reassociating one side of a higher identification is an equivalence
+
+```agda
+module _
+  {l : Level} {A : UU l} {x y z u : A}
+  where
+
+  equiv-concat-assoc :
+    (p : x ＝ y) (q : y ＝ z) (r : z ＝ u) (s : x ＝ u) →
+    ((p ∙ q) ∙ r ＝ s) ≃ (p ∙ (q ∙ r) ＝ s)
+  equiv-concat-assoc p q r = equiv-concat (inv (assoc p q r))
+
+  equiv-concat-assoc' :
+    (s : x ＝ u) (p : x ＝ y) (q : y ＝ z) (r : z ＝ u) →
+    (s ＝ (p ∙ q) ∙ r) ≃ (s ＝ p ∙ (q ∙ r))
+  equiv-concat-assoc' s p q r = equiv-concat' s (assoc p q r)
+```
+
+### Whiskering of squares of identifications
+
+```agda
+module _
+  {l : Level} {A : UU l} {x y z u v : A}
+  (p : x ＝ y) (p' : x ＝ z) {q : y ＝ u} {q' : z ＝ u} (r : u ＝ v)
+  where
+
+  equiv-right-whisk-square-identification :
+    ( coherence-square-identifications p p' q q') ≃
+    ( coherence-square-identifications p p' (q ∙ r) (q' ∙ r))
+  equiv-right-whisk-square-identification =
+    ( equiv-concat-assoc' (p' ∙ (q' ∙ r)) p q r) ∘e
+    ( equiv-concat-assoc p' q' r (p ∙ q ∙ r)) ∘e
+    ( equiv-identification-right-whisk r)
+
+  right-whisk-square-identification :
+    coherence-square-identifications p p' q q' →
+    coherence-square-identifications p p' (q ∙ r) (q' ∙ r)
+  right-whisk-square-identification =
+    map-equiv equiv-right-whisk-square-identification
+
+  right-unwhisk-square-identifications :
+    coherence-square-identifications p p' (q ∙ r) (q' ∙ r) →
+    coherence-square-identifications p p' q q'
+  right-unwhisk-square-identifications =
+    map-inv-equiv equiv-right-whisk-square-identification
+
+module _
+  {l : Level} {A : UU l} {x y z u v : A}
+  (p : v ＝ x) {q : x ＝ y} {q' : x ＝ z} {r : y ＝ u} {r' : z ＝ u}
+  where
+
+  equiv-left-whisk-square-identification :
+    ( coherence-square-identifications q q' r r') ≃
+    ( coherence-square-identifications (p ∙ q) (p ∙ q') r r')
+  equiv-left-whisk-square-identification =
+    ( inv-equiv (equiv-concat-assoc p q' r' (p ∙ q ∙ r))) ∘e
+    ( inv-equiv (equiv-concat-assoc' (p ∙ (q' ∙ r')) p q r)) ∘e
+    ( equiv-identification-left-whisk p)
+
+  left-whisk-square-identification :
+    coherence-square-identifications q q' r r' →
+    coherence-square-identifications (p ∙ q) (p ∙ q') r r'
+  left-whisk-square-identification =
+    map-equiv equiv-left-whisk-square-identification
+
+  left-unwhisk-square-identification :
+    coherence-square-identifications (p ∙ q) (p ∙ q') r r' →
+    coherence-square-identifications q q' r r'
+  left-unwhisk-square-identification =
+    map-inv-equiv equiv-left-whisk-square-identification
+
+module _
+  {l : Level} {A : UU l} {x y z u v w : A}
+  where
+
+  equiv-both-whisk-square-identifications :
+    (p : x ＝ y) {q : y ＝ z} {q' : y ＝ u} {r : z ＝ v} {r' : u ＝ v} →
+    (s : v ＝ w) →
+    ( coherence-square-identifications q q' r r') ≃
+    ( coherence-square-identifications (p ∙ q) (p ∙ q') (r ∙ s) (r' ∙ s))
+  equiv-both-whisk-square-identifications p {q} {q'} s =
+    ( equiv-left-whisk-square-identification p) ∘e
+    ( equiv-right-whisk-square-identification q q' s)
+```
+
 ### Both horizontal and vertical concatenation of 2-paths are binary equivalences
 
 ```agda
diff --git a/src/foundation/pullbacks.lagda.md b/src/foundation/pullbacks.lagda.md
index 2319877033..7ec58e0b2a 100644
--- a/src/foundation/pullbacks.lagda.md
+++ b/src/foundation/pullbacks.lagda.md
@@ -341,8 +341,8 @@ htpy-parallel-cone-refl-htpy-htpy-cone f g (p , q , H) (p' , q' , H') =
   tot
     ( λ K → tot
       ( λ L M →
-        ( ap-concat-htpy H _ _ right-unit-htpy) ∙h
-        ( M ∙h ap-concat-htpy' _ _ H' inv-htpy-right-unit-htpy)))
+        ( ap-concat-htpy H right-unit-htpy) ∙h
+        ( M ∙h ap-concat-htpy' H' inv-htpy-right-unit-htpy)))
 
 abstract
   is-equiv-htpy-parallel-cone-refl-htpy-htpy-cone :
@@ -356,11 +356,11 @@ abstract
       ( λ K → is-equiv-tot-is-fiberwise-equiv
         ( λ L → is-equiv-comp
           ( concat-htpy
-            ( ap-concat-htpy H _ _ right-unit-htpy)
+            ( ap-concat-htpy H right-unit-htpy)
             ( (f ·l K) ∙h refl-htpy ∙h H'))
           ( concat-htpy'
             ( H ∙h (g ·l L))
-            ( ap-concat-htpy' _ _ H' inv-htpy-right-unit-htpy))
+            ( ap-concat-htpy' H' inv-htpy-right-unit-htpy))
           ( is-equiv-concat-htpy'
             ( H ∙h (g ·l L))
             ( λ x → ap (λ z → z ∙ H' x) (inv right-unit)))
@@ -897,10 +897,8 @@ is-pullback-top-is-pullback-bottom-cube-is-equiv
           ( inv-htpy c) ∙h
           ( assoc-htpy (h ·l back-left) (front-left ·r f') (hD ·l top)) ∙h
           ( ap-concat-htpy'
-            ( h ·l back-left)
-            ( (h ·l back-left) ∙h refl-htpy)
             ( (front-left ·r f') ∙h (hD ·l top))
-            ( inv-htpy-right-unit-htpy))))
+            ( inv-htpy-right-unit-htpy {H = h ·l back-left}))))
       ( is-pullback-rectangle-is-pullback-top h k hC
         ( f , g , bottom)
         ( hA , g' , back-right)
diff --git a/src/foundation/retractions.lagda.md b/src/foundation/retractions.lagda.md
index 05c481994e..f248c0ad92 100644
--- a/src/foundation/retractions.lagda.md
+++ b/src/foundation/retractions.lagda.md
@@ -74,11 +74,7 @@ is-retraction-retraction-left-map-triangle f g h H (l , L) (k , K) =
         ( inv-htpy ((k ∘ l) ·l H))
         ( (k ∘ l) ·l H)
         ( (k ·l (L ·r h)) ∙h K)) ∙h
-      ( ap-concat-htpy'
-        ( (inv-htpy ((k ∘ l) ·l H)) ∙h ((k ∘ l) ·l H))
-        ( refl-htpy)
-        ( (k ·l (L ·r h)) ∙h K)
-        ( left-inv-htpy ((k ∘ l) ·l H))))
+      ( ap-concat-htpy' ((k ·l (L ·r h)) ∙h K) (left-inv-htpy ((k ∘ l) ·l H))))
 
 retraction-right-factor-retract-of-retraction-left-factor :
   {l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
diff --git a/src/foundation/sections.lagda.md b/src/foundation/sections.lagda.md
index 79c19570a0..a623ca0673 100644
--- a/src/foundation/sections.lagda.md
+++ b/src/foundation/sections.lagda.md
@@ -111,11 +111,7 @@ is-retraction-section-left-map-triangle f g h H (k , K) (l , L) =
         ( inv-htpy (H ·r (k ∘ l)))
         ( H ·r (k ∘ l))
         ( (g ·l (K ·r l)) ∙h L)) ∙h
-      ( ap-concat-htpy'
-        ( (inv-htpy (H ·r (k ∘ l))) ∙h (H ·r (k ∘ l)))
-        ( refl-htpy)
-        ( (g ·l (K ·r l)) ∙h L)
-        ( left-inv-htpy (H ·r (k ∘ l)))))
+      ( ap-concat-htpy' ((g ·l (K ·r l)) ∙h L) (left-inv-htpy (H ·r (k ∘ l)))))
 
 section-left-factor-retract-of-section-composition :
   {l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
diff --git a/src/foundation/symmetric-cores-binary-relations.lagda.md b/src/foundation/symmetric-cores-binary-relations.lagda.md
index 1aac9ce702..d0fac4272b 100644
--- a/src/foundation/symmetric-cores-binary-relations.lagda.md
+++ b/src/foundation/symmetric-cores-binary-relations.lagda.md
@@ -1,8 +1,6 @@
 # Symmetric cores of binary relations
 
 ```agda
-{-# OPTIONS --allow-unsolved-metas #-}
-
 module foundation.symmetric-cores-binary-relations where
 ```
 
diff --git a/src/foundation/whiskering-homotopies.lagda.md b/src/foundation/whiskering-homotopies.lagda.md
index c1e49b47be..7249cf1307 100644
--- a/src/foundation/whiskering-homotopies.lagda.md
+++ b/src/foundation/whiskering-homotopies.lagda.md
@@ -10,11 +10,16 @@ open import foundation-core.whiskering-homotopies public
 
 ```agda
 open import foundation.action-on-identifications-functions
+open import foundation.commuting-squares-of-homotopies
+open import foundation.commuting-squares-of-identifications
 open import foundation.function-extensionality
+open import foundation.path-algebra
 open import foundation.postcomposition-functions
 open import foundation.universe-levels
 
+open import foundation-core.equivalences
 open import foundation-core.function-types
+open import foundation-core.functoriality-dependent-function-types
 open import foundation-core.homotopies
 open import foundation-core.identity-types
 open import foundation-core.precomposition-functions
@@ -100,3 +105,163 @@ module _
       ( inv (is-section-eq-htpy H))) ∙
     ( compute-eq-htpy-htpy-eq-left-whisk (eq-htpy H))
 ```
+
+### Whiskering a square of homotopies by a homotopy is an equivalence
+
+A
+[commuting square of homotopies](foundation.commuting-squares-of-homotopies.md)
+may be whiskered by a homotopy `L` on the left or right, which results in a
+commuting square of homotopies with `L` appended or prepended to the two ways of
+going around the square.
+
+Diagramatically, we may turn the pasting diagram
+
+```text
+        H
+    f ~~~~~ g
+    ︴      ︴
+ H' ︴  ⇗   ︴ K
+    ︴      ︴
+   g' ~~~~~ h ~~~~~ k
+       K'       L
+```
+
+into a commmuting square
+
+```text
+        H
+    f ~~~~~ g
+    ︴      ︴
+ H' ︴  ⇗   ︴K ∙h L
+    ︴      ︴
+   g' ~~~~~ k
+     K' ∙h L   ,
+```
+
+and similarly for the other side.
+
+```agda
+module _
+  { l1 l2 : Level} {A : UU l1} {B : UU l2}
+  { f g g' h k : A → B}
+  where
+
+  module _
+    ( H : f ~ g) (H' : f ~ g') {K : g ~ h} {K' : g' ~ h} (L : h ~ k)
+    where
+
+    equiv-right-whisk-square-htpy :
+      ( coherence-square-homotopies H H' K K') ≃
+      ( coherence-square-homotopies H H' (K ∙h L) (K' ∙h L))
+    equiv-right-whisk-square-htpy =
+      equiv-Π-equiv-family
+        ( λ a → equiv-right-whisk-square-identification (H a) (H' a) (L a))
+
+    right-whisk-square-htpy :
+      coherence-square-homotopies H H' K K' →
+      coherence-square-homotopies H H' (K ∙h L) (K' ∙h L)
+    right-whisk-square-htpy = map-equiv equiv-right-whisk-square-htpy
+
+    right-unwhisk-square-htpy :
+      coherence-square-homotopies H H' (K ∙h L) (K' ∙h L) →
+      coherence-square-homotopies H H' K K'
+    right-unwhisk-square-htpy = map-inv-equiv equiv-right-whisk-square-htpy
+
+  module _
+    ( L : k ~ f) {H : f ~ g} {H' : f ~ g'} {K : g ~ h} {K' : g' ~ h}
+    where
+
+    equiv-left-whisk-square-htpy :
+      ( coherence-square-homotopies H H' K K') ≃
+      ( coherence-square-homotopies (L ∙h H) (L ∙h H') K K')
+    equiv-left-whisk-square-htpy =
+      equiv-Π-equiv-family
+        ( λ a → equiv-left-whisk-square-identification (L a))
+
+    left-whisk-square-htpy :
+      coherence-square-homotopies H H' K K' →
+      coherence-square-homotopies (L ∙h H) (L ∙h H') K K'
+    left-whisk-square-htpy = map-equiv equiv-left-whisk-square-htpy
+
+    left-unwhisk-square-htpy :
+      coherence-square-homotopies (L ∙h H) (L ∙h H') K K' →
+      coherence-square-homotopies H H' K K'
+    left-unwhisk-square-htpy = map-inv-equiv equiv-left-whisk-square-htpy
+
+module _
+  { l1 l2 : Level} {A : UU l1} {B : UU l2}
+  { f g h h' k m : A → B}
+  ( H : f ~ g) {K : g ~ h} {K' : g ~ h'} {L : h ~ k} {L' : h' ~ k} (M : k ~ m)
+  where
+
+  equiv-both-whisk-square-htpy :
+    ( coherence-square-homotopies K K' L L') ≃
+    ( coherence-square-homotopies (H ∙h K) (H ∙h K') (L ∙h M) (L' ∙h M))
+  equiv-both-whisk-square-htpy =
+    equiv-Π-equiv-family
+      ( λ a → equiv-both-whisk-square-identifications (H a) (M a))
+
+  both-whisk-square-htpy :
+    ( coherence-square-homotopies K K' L L') →
+    ( coherence-square-homotopies (H ∙h K) (H ∙h K') (L ∙h M) (L' ∙h M))
+  both-whisk-square-htpy = map-equiv equiv-both-whisk-square-htpy
+
+  both-unwhisk-square-htpy :
+    ( coherence-square-homotopies (H ∙h K) (H ∙h K') (L ∙h M) (L' ∙h M)) →
+    ( coherence-square-homotopies K K' L L')
+  both-unwhisk-square-htpy = map-inv-equiv equiv-both-whisk-square-htpy
+```
+
+### Whiskering a square of homotopies by a map
+
+Given a square of homotopies
+
+```text
+        H
+    g ~~~~~ h
+    ︴      ︴
+ H' ︴  ⇗   ︴ K
+    ︴      ︴
+   h' ~~~~~ k
+       K'
+```
+
+and a map `f`, we may whisker it by a map on the left into a square of
+homotopies
+
+```text
+           f ·l H
+         fg ~~~~~ fh
+         ︴        ︴
+ f ·l H' ︴   ⇗    ︴f ·l K
+         ︴        ︴
+        fh' ~~~~~ fk
+           f ·l K' ,
+```
+
+and similarly we may whisker it on the right.
+
+```agda
+module _
+  { l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {C : UU l3}
+  ( f : B → C) {g h h' k : A → B}
+  ( H : g ~ h) (H' : g ~ h') {K : h ~ k} {K' : h' ~ k}
+  where
+
+  ap-left-whisk-coherence-square-homotopies :
+    coherence-square-homotopies H H' K K' →
+    coherence-square-homotopies (f ·l H) (f ·l H') (f ·l K) (f ·l K')
+  ap-left-whisk-coherence-square-homotopies α a =
+    coherence-square-identifications-ap f (H a) (H' a) (K a) (K' a) (α a)
+
+module _
+  { l1 l2 l3 : Level} {A : UU l1} {B : UU l2} {C : UU l3}
+  { g h h' k : B → C} (H : g ~ h) (H' : g ~ h') {K : h ~ k} {K' : h' ~ k}
+  ( f : A → B)
+  where
+
+  ap-right-whisk-coherence-square-homotopies :
+    coherence-square-homotopies H H' K K' →
+    coherence-square-homotopies (H ·r f) (H' ·r f) (K ·r f) (K' ·r f)
+  ap-right-whisk-coherence-square-homotopies α = α ·r f
+```
diff --git a/src/graph-theory/equivalences-directed-graphs.lagda.md b/src/graph-theory/equivalences-directed-graphs.lagda.md
index 30f51a8e45..765064f512 100644
--- a/src/graph-theory/equivalences-directed-graphs.lagda.md
+++ b/src/graph-theory/equivalences-directed-graphs.lagda.md
@@ -492,7 +492,7 @@ module _
       ( edge-Directed-Graph G)
       ( vertex-is-retraction-inv-equiv-Directed-Graph x)
       ( vertex-is-retraction-inv-equiv-Directed-Graph y)
-      ( map-eq-transpose-equiv'
+      ( map-eq-transpose-equiv-inv
         ( equiv-edge-equiv-Directed-Graph G H f
           ( vertex-inv-equiv-Directed-Graph
             ( vertex-equiv-Directed-Graph G H f x))
diff --git a/src/structured-types/initial-pointed-type-equipped-with-automorphism.lagda.md b/src/structured-types/initial-pointed-type-equipped-with-automorphism.lagda.md
index 647e14bdea..f42f2e522e 100644
--- a/src/structured-types/initial-pointed-type-equipped-with-automorphism.lagda.md
+++ b/src/structured-types/initial-pointed-type-equipped-with-automorphism.lagda.md
@@ -90,7 +90,7 @@ htpy-map-ℤ-Pointed-Type-With-Aut :
   map-ℤ-Pointed-Type-With-Aut X ~
   map-hom-Pointed-Type-With-Aut ℤ-Pointed-Type-With-Aut X h
 htpy-map-ℤ-Pointed-Type-With-Aut X h (inl zero-ℕ) =
-  map-eq-transpose-equiv'
+  map-eq-transpose-equiv-inv
     ( aut-Pointed-Type-With-Aut X)
     ( ( inv
         ( preserves-point-map-hom-Pointed-Type-With-Aut ℤ-Pointed-Type-With-Aut
@@ -98,7 +98,7 @@ htpy-map-ℤ-Pointed-Type-With-Aut X h (inl zero-ℕ) =
       ( preserves-aut-map-hom-Pointed-Type-With-Aut ℤ-Pointed-Type-With-Aut
         X h neg-one-ℤ))
 htpy-map-ℤ-Pointed-Type-With-Aut X h (inl (succ-ℕ k)) =
-  map-eq-transpose-equiv'
+  map-eq-transpose-equiv-inv
     ( aut-Pointed-Type-With-Aut X)
     ( ( htpy-map-ℤ-Pointed-Type-With-Aut X h (inl k)) ∙
       ( preserves-aut-map-hom-Pointed-Type-With-Aut ℤ-Pointed-Type-With-Aut
@@ -157,7 +157,7 @@ coh-aut-htpy-map-ℤ-Pointed-Type-With-Aut X h (inl zero-ℕ) =
       ( ap
         ( map-equiv (aut-Pointed-Type-With-Aut X))
         ( htpy-map-ℤ-Pointed-Type-With-Aut X h neg-one-ℤ))
-      ( triangle-eq-transpose-equiv'
+      ( triangle-eq-transpose-equiv-inv
         ( aut-Pointed-Type-With-Aut X)
         ( ( inv
             ( preserves-point-map-hom-Pointed-Type-With-Aut
@@ -176,7 +176,7 @@ coh-aut-htpy-map-ℤ-Pointed-Type-With-Aut X h (inl (succ-ℕ k)) =
       ( ap
         ( map-equiv (aut-Pointed-Type-With-Aut X))
         ( htpy-map-ℤ-Pointed-Type-With-Aut X h (inl (succ-ℕ k))))
-      ( triangle-eq-transpose-equiv'
+      ( triangle-eq-transpose-equiv-inv
         ( aut-Pointed-Type-With-Aut X)
         ( ( htpy-map-ℤ-Pointed-Type-With-Aut X h (inl k)) ∙
           ( preserves-aut-map-hom-Pointed-Type-With-Aut
diff --git a/src/synthetic-homotopy-theory.lagda.md b/src/synthetic-homotopy-theory.lagda.md
index 5503aa9cba..c86b59ed51 100644
--- a/src/synthetic-homotopy-theory.lagda.md
+++ b/src/synthetic-homotopy-theory.lagda.md
@@ -50,6 +50,7 @@ open import synthetic-homotopy-theory.flattening-lemma-coequalizers public
 open import synthetic-homotopy-theory.flattening-lemma-pushouts public
 open import synthetic-homotopy-theory.free-loops public
 open import synthetic-homotopy-theory.functoriality-loop-spaces public
+open import synthetic-homotopy-theory.functoriality-sequential-colimits public
 open import synthetic-homotopy-theory.functoriality-suspensions public
 open import synthetic-homotopy-theory.groups-of-loops-in-1-types public
 open import synthetic-homotopy-theory.hatchers-acyclic-type public
@@ -77,6 +78,7 @@ open import synthetic-homotopy-theory.pushout-products public
 open import synthetic-homotopy-theory.pushouts public
 open import synthetic-homotopy-theory.pushouts-of-pointed-types public
 open import synthetic-homotopy-theory.sections-descent-circle public
+open import synthetic-homotopy-theory.sequential-colimits public
 open import synthetic-homotopy-theory.sequential-diagrams public
 open import synthetic-homotopy-theory.sequentially-compact-types public
 open import synthetic-homotopy-theory.smash-products-of-pointed-types public
diff --git a/src/synthetic-homotopy-theory/26-descent.lagda.md b/src/synthetic-homotopy-theory/26-descent.lagda.md
index e20d23cfa6..05dbd423e7 100644
--- a/src/synthetic-homotopy-theory/26-descent.lagda.md
+++ b/src/synthetic-homotopy-theory/26-descent.lagda.md
@@ -255,8 +255,6 @@ coherence-triangle-precompose-lifts-refl-htpy P f h =
   ( ( ( inv-htpy-right-unit-htpy) ∙h
       ( ap-concat-htpy
         ( λ h' → tr-eq-htpy-fam-lifts-refl-htpy P h f (λ a → h' (f a)))
-        ( refl-htpy)
-        ( triangle-precompose-lifts' P refl-htpy h)
         ( inv-htpy (compute-triangle-precompose-lifts' P f h)))) ∙h
     ( htpy-eq
       ( ap
@@ -380,15 +378,11 @@ coherence-inv-htpy-distributive-Π-Σ-refl-htpy :
 coherence-inv-htpy-distributive-Π-Σ-refl-htpy {X = X} P f =
   ( ap-concat-htpy
     ( coherence-square-map-inv-distributive-Π-Σ P f)
-    ( map-inv-distributive-Π-Σ ·l ( htpy-precompose-total-lifts P refl-htpy))
-    ( refl-htpy)
     ( λ h →
       ap
         ( ap map-inv-distributive-Π-Σ)
         ( compute-htpy-precompose-total-lifts P f h))) ∙h
   ( ap-concat-htpy'
-    ( refl-htpy)
-    ( ( htpy-precomp refl-htpy (Σ X P)) ·r map-inv-distributive-Π-Σ)
     ( refl-htpy)
     ( inv-htpy
       ( λ h →
diff --git a/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md
index 340867351c..4fd328dce7 100644
--- a/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/cocones-under-sequential-diagrams.lagda.md
@@ -101,8 +101,9 @@ filling the "pinched cylinder" with the faces `Kₙ`, `Hₙ`, `Lₙ` and `Kₙ
 
 The coherence datum may be better understood by viewing a cocone as a
 [morphism](synthetic-homotopy-theory.morphisms-sequential-diagrams.md) from
-`(A, a)` to the constant cocone `(n ↦ X, n ↦ id)`. Then a homotopy of cocones is
-a regular homotopy of morphisms of sequential diagrams.
+`(A, a)` to the constant cocone `(n ↦ X, n ↦ id)` — the two types are
+definitionally equal. Then a homotopy of cocones is a regular homotopy of
+morphisms of sequential diagrams.
 
 ```agda
 module _
@@ -137,7 +138,7 @@ module _
 ```agda
 module _
   { l1 l2 : Level} (A : sequential-diagram l1) {X : UU l2}
-  ( c c' : cocone-sequential-diagram A X)
+  { c c' : cocone-sequential-diagram A X}
   ( H : htpy-cocone-sequential-diagram A c c')
   where
 
diff --git a/src/synthetic-homotopy-theory/dependent-universal-property-sequential-colimits.lagda.md b/src/synthetic-homotopy-theory/dependent-universal-property-sequential-colimits.lagda.md
index 123a8fa98a..7da1b9e746 100644
--- a/src/synthetic-homotopy-theory/dependent-universal-property-sequential-colimits.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-universal-property-sequential-colimits.lagda.md
@@ -46,13 +46,14 @@ is an [equivalence](foundation.equivalences.md).
 
 ```agda
 module _
-  { l1 l2 : Level} (l : Level) (A : sequential-diagram l1) {X : UU l2}
+  { l1 l2 : Level} (A : sequential-diagram l1) {X : UU l2}
   ( c : cocone-sequential-diagram A X)
   where
 
-  dependent-universal-property-sequential-colimit : UU (l1 ⊔ l2 ⊔ lsuc l)
+  dependent-universal-property-sequential-colimit : UUω
   dependent-universal-property-sequential-colimit =
-    ( P : X → UU l) → is-equiv (dependent-cocone-map-sequential-diagram A c P)
+    { l : Level} → (P : X → UU l) →
+    is-equiv (dependent-cocone-map-sequential-diagram A c P)
 ```
 
 ### The map induced by the dependent universal property of sequential colimits
@@ -62,7 +63,7 @@ module _
   { l1 l2 l3 : Level} (A : sequential-diagram l1) {X : UU l2}
   ( c : cocone-sequential-diagram A X) {P : X → UU l3}
   ( dup-sequential-colimit :
-    dependent-universal-property-sequential-colimit l3 A c)
+    dependent-universal-property-sequential-colimit A c)
   where
 
   map-dependent-universal-property-sequential-colimit :
@@ -81,7 +82,7 @@ module _
   { l1 l2 l3 : Level} (A : sequential-diagram l1) {X : UU l2}
   ( c : cocone-sequential-diagram A X) {P : X → UU l3}
   ( dup-sequential-colimit :
-    dependent-universal-property-sequential-colimit l3 A c)
+    dependent-universal-property-sequential-colimit A c)
   ( d : dependent-cocone-sequential-diagram A c P)
   where
 
@@ -138,8 +139,7 @@ module _
         ( bottom-map-cofork-cocone-sequential-diagram A)
         ( top-map-cofork-cocone-sequential-diagram A)
         ( cofork-cocone-sequential-diagram A c)) →
-    ( {l : Level} →
-      dependent-universal-property-sequential-colimit l A c)
+    dependent-universal-property-sequential-colimit A c
   dependent-universal-property-sequential-colimit-dependent-universal-property-coequalizer
     ( dup-coequalizer)
     ( P) =
@@ -155,8 +155,7 @@ module _
       ( is-equiv-dependent-cocone-sequential-diagram-dependent-cofork A c P)
 
   dependent-universal-property-coequalizer-dependent-universal-property-sequential-colimit :
-    ( {l : Level} →
-      dependent-universal-property-sequential-colimit l A c) →
+    dependent-universal-property-sequential-colimit A c →
     ( {l : Level} →
       dependent-universal-property-coequalizer l
         ( bottom-map-cofork-cocone-sequential-diagram A)
@@ -186,8 +185,8 @@ module _
   where
 
   universal-property-dependent-universal-property-sequential-colimit :
-    ( {l : Level} → dependent-universal-property-sequential-colimit l A c) →
-    ( {l : Level} → universal-property-sequential-colimit l A c)
+    dependent-universal-property-sequential-colimit A c →
+    universal-property-sequential-colimit A c
   universal-property-dependent-universal-property-sequential-colimit
     ( dup-sequential-colimit)
     ( Y) =
@@ -202,8 +201,8 @@ module _
         ( compute-dependent-cocone-sequential-diagram-constant-family A c Y))
 
   dependent-universal-property-universal-property-sequential-colimit :
-    ( {l : Level} → universal-property-sequential-colimit l A c) →
-    ( {l : Level} → dependent-universal-property-sequential-colimit l A c)
+    universal-property-sequential-colimit A c →
+    dependent-universal-property-sequential-colimit A c
   dependent-universal-property-universal-property-sequential-colimit
     ( up-sequential-diagram) =
     dependent-universal-property-sequential-colimit-dependent-universal-property-coequalizer
diff --git a/src/synthetic-homotopy-theory/equivalences-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/equivalences-sequential-diagrams.lagda.md
index 0ef1c1a4a2..580992c4d5 100644
--- a/src/synthetic-homotopy-theory/equivalences-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/equivalences-sequential-diagrams.lagda.md
@@ -9,6 +9,7 @@ module synthetic-homotopy-theory.equivalences-sequential-diagrams where
 ```agda
 open import elementary-number-theory.natural-numbers
 
+open import foundation.commuting-squares-of-maps
 open import foundation.dependent-pair-types
 open import foundation.equality-dependent-function-types
 open import foundation.equivalences
@@ -56,6 +57,11 @@ module _
 
 ### Components of equivalences of sequential diagrams
 
+_Implementation note:_ As mentioned in
+[`morphisms-sequential-diagrams`](synthetic-homotopy-theory.morphisms-sequential-diagrams.md),
+Agda can't infer both the domain and the codomain when we use accessors for the
+equivalences, and the codomain needs to be provided explicitly.
+
 ```agda
 module _
   { l1 l2 : Level} {A : sequential-diagram l1} (B : sequential-diagram l2)
@@ -67,16 +73,19 @@ module _
     family-sequential-diagram A n ≃ family-sequential-diagram B n
   equiv-equiv-sequential-diagram = pr1 e
 
-  hom-equiv-sequential-diagram : hom-sequential-diagram A B
-  pr1 hom-equiv-sequential-diagram n =
-    map-equiv (equiv-equiv-sequential-diagram n)
-  pr2 hom-equiv-sequential-diagram = pr2 e
-
   map-equiv-sequential-diagram :
     ( n : ℕ) →
     family-sequential-diagram A n → family-sequential-diagram B n
   map-equiv-sequential-diagram n = map-equiv (equiv-equiv-sequential-diagram n)
 
+  naturality-equiv-sequential-diagram :
+    naturality-hom-sequential-diagram A B map-equiv-sequential-diagram
+  naturality-equiv-sequential-diagram = pr2 e
+
+  hom-equiv-sequential-diagram : hom-sequential-diagram A B
+  pr1 hom-equiv-sequential-diagram = map-equiv-sequential-diagram
+  pr2 hom-equiv-sequential-diagram = naturality-equiv-sequential-diagram
+
   is-equiv-map-equiv-sequential-diagram :
     ( n : ℕ) →
     is-equiv (map-equiv-sequential-diagram n)
@@ -118,6 +127,38 @@ module _
         ( hom-equiv-sequential-diagram B e'))
 ```
 
+### Inverses of equivalences of sequential diagrams
+
+```agda
+module _
+  { l1 l2 : Level} {A : sequential-diagram l1} (B : sequential-diagram l2)
+  ( e : equiv-sequential-diagram A B)
+  where
+
+  inv-equiv-sequential-diagram : equiv-sequential-diagram B A
+  pr1 inv-equiv-sequential-diagram n =
+    inv-equiv (equiv-equiv-sequential-diagram B e n)
+  pr2 inv-equiv-sequential-diagram n =
+    coherence-square-inv-vertical
+      ( map-sequential-diagram A n)
+      ( equiv-equiv-sequential-diagram B e n)
+      ( equiv-equiv-sequential-diagram B e (succ-ℕ n))
+      ( map-sequential-diagram B n)
+      ( naturality-map-hom-sequential-diagram B
+        ( hom-equiv-sequential-diagram B e)
+        ( n))
+
+  map-inv-equiv-sequential-diagram :
+    ( n : ℕ) →
+    family-sequential-diagram B n → family-sequential-diagram A n
+  map-inv-equiv-sequential-diagram =
+    map-equiv-sequential-diagram A inv-equiv-sequential-diagram
+
+  hom-inv-equiv-sequential-diagram : hom-sequential-diagram B A
+  hom-inv-equiv-sequential-diagram =
+    hom-equiv-sequential-diagram A inv-equiv-sequential-diagram
+```
+
 ## Properties
 
 ### Characterization of equality of sequential diagrams
@@ -166,3 +207,46 @@ eq-equiv-sequential-diagram :
 eq-equiv-sequential-diagram A B =
   map-inv-equiv (extensionality-sequential-diagram A B)
 ```
+
+### Inverses of equivalences are inverses with respect to composition of morphisms of sequential diagrams
+
+```agda
+module _
+  { l1 l2 : Level} {A : sequential-diagram l1} (B : sequential-diagram l2)
+  ( e : equiv-sequential-diagram A B)
+  where
+
+  is-section-inv-equiv-sequential-diagram :
+    htpy-hom-sequential-diagram B
+      ( comp-hom-sequential-diagram B A B
+        ( hom-equiv-sequential-diagram B e)
+        ( hom-inv-equiv-sequential-diagram B e))
+      ( id-hom-sequential-diagram B)
+  pr1 is-section-inv-equiv-sequential-diagram n =
+    is-section-map-inv-equiv (equiv-equiv-sequential-diagram B e n)
+  pr2 is-section-inv-equiv-sequential-diagram n =
+    inv-htpy
+      ( right-inverse-law-pasting-vertical-coherence-square-maps
+        ( map-sequential-diagram A n)
+        ( equiv-equiv-sequential-diagram B e n)
+        ( equiv-equiv-sequential-diagram B e (succ-ℕ n))
+        ( map-sequential-diagram B n)
+        ( naturality-equiv-sequential-diagram B e n))
+
+  is-retraction-inv-equiv-sequential-diagram :
+    htpy-hom-sequential-diagram A
+      ( comp-hom-sequential-diagram A B A
+        ( hom-inv-equiv-sequential-diagram B e)
+        ( hom-equiv-sequential-diagram B e))
+      ( id-hom-sequential-diagram A)
+  pr1 is-retraction-inv-equiv-sequential-diagram n =
+    is-retraction-map-inv-equiv (equiv-equiv-sequential-diagram B e n)
+  pr2 is-retraction-inv-equiv-sequential-diagram n =
+    inv-htpy
+      ( left-inverse-law-pasting-vertical-coherence-square-maps
+        ( map-sequential-diagram A n)
+        ( equiv-equiv-sequential-diagram B e n)
+        ( equiv-equiv-sequential-diagram B e (succ-ℕ n))
+        ( map-sequential-diagram B n)
+        ( naturality-equiv-sequential-diagram B e n))
+```
diff --git a/src/synthetic-homotopy-theory/functoriality-sequential-colimits.lagda.md b/src/synthetic-homotopy-theory/functoriality-sequential-colimits.lagda.md
new file mode 100644
index 0000000000..cbace8a721
--- /dev/null
+++ b/src/synthetic-homotopy-theory/functoriality-sequential-colimits.lagda.md
@@ -0,0 +1,450 @@
+# Functoriality of sequential colimits
+
+```agda
+module synthetic-homotopy-theory.functoriality-sequential-colimits where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import elementary-number-theory.natural-numbers
+
+open import foundation.action-on-identifications-functions
+open import foundation.commuting-prisms-of-maps
+open import foundation.commuting-squares-of-homotopies
+open import foundation.commuting-squares-of-maps
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.function-extensionality
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.homotopies
+open import foundation.universe-levels
+open import foundation.whiskering-homotopies
+
+open import synthetic-homotopy-theory.cocones-under-sequential-diagrams
+open import synthetic-homotopy-theory.equivalences-sequential-diagrams
+open import synthetic-homotopy-theory.morphisms-sequential-diagrams
+open import synthetic-homotopy-theory.sequential-colimits
+open import synthetic-homotopy-theory.sequential-diagrams
+open import synthetic-homotopy-theory.universal-property-sequential-colimits
+```
+
+</details>
+
+## Idea
+
+Taking the
+[sequential colimit](synthetic-homotopy-theory.sequential-colimits.md) of a
+[sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md) is a
+functorial action `(A, a) ↦ A∞`.
+
+In other words, a
+[morphism of sequential diagrams](synthetic-homotopy-theory.morphisms-sequential-diagrams.md)
+`f : (A, a) → (B, b)` induces a map `f∞ : A∞ → B∞` between the
+[standard sequential colimits](synthetic-homotopy-theory.sequential-colimits.md)
+of the diagrams, and this action preserves the identity morphism and morphism
+composition.
+
+Furthermore, an
+[equivalence of sequential diagrams](synthetic-homotopy-theory.equivalences-sequential-diagrams.md)
+`e : (A, a) ≃ (B, b)` induces an equivalence `e∞ : A∞ ≃ B∞`.
+
+The development in this file is a formalization of Lemma 3.5 in Sequential
+Colimits in Homotopy Type Theory.
+
+## Properties
+
+### A morphism of sequential diagrams induces a map of cocones
+
+```agda
+module _
+  { l1 l2 l3 : Level} {A : sequential-diagram l1} {B : sequential-diagram l2}
+  ( f : hom-sequential-diagram A B) {X : UU l3}
+  where
+
+  map-cocone-hom-sequential-diagram :
+    cocone-sequential-diagram B X → cocone-sequential-diagram A X
+  map-cocone-hom-sequential-diagram c =
+    comp-hom-sequential-diagram A B (constant-sequential-diagram X) c f
+```
+
+### A morphism of sequential diagrams induces a map of sequential colimits
+
+The induced map
+
+```text
+        a₀      a₁      a₂
+    A₀ ---> A₁ ---> A₂ ---> ⋯ ---> A∞
+    |       |       |              |
+ f₀ |       | f₁    | f₂           | f∞
+    V       V       V              V
+    B₀ ---> B₁ ---> B₂ ---> ⋯ ---> B∞
+        b₀      b₁      b₂
+```
+
+then induces a
+[cocone](synthetic-homotopy-theory.cocones-under-sequential-diagrams.md) under
+`(A, a)` with codomain `B∞`, which is homotopic to the standard cocone under
+`(B, b)` precomposed by `f`.
+
+This homotopy of cocones provides
+[vertical commuting prisms of maps](foundation.commuting-prisms-of-maps.md),
+
+```text
+          Aₙ₊₁
+         ^ | \
+       /   |   \
+     /     |fₙ₊₁ V
+    Aₙ ---------> A∞
+    |      |      |
+    |      V      |
+ fₙ |     Bₙ₊₁    | f∞
+    |    ^   \    |
+    |  /       \  |
+    V/           VV
+    Bₙ ---------> B∞ ,
+```
+
+where the [triangles](foundation-core.commuting-triangles-of-maps.md) are
+coherences of the cocones of the standard sequential colimits, the back left
+[square](foundation-core.commuting-triangles-of-maps.md) is coherence of `f`,
+and the front and back right squares are provided by uniqueness of `f∞`.
+
+```agda
+module _
+  { l1 l2 : Level} {A : sequential-diagram l1} (B : sequential-diagram l2)
+  ( f : hom-sequential-diagram A B)
+  where
+
+  map-hom-standard-sequential-colimit :
+    standard-sequential-colimit A → standard-sequential-colimit B
+  map-hom-standard-sequential-colimit =
+    cogap-standard-sequential-colimit
+      ( map-cocone-hom-sequential-diagram f
+        ( cocone-standard-sequential-colimit B))
+
+  htpy-cocone-map-hom-standard-sequential-colimit :
+    htpy-cocone-sequential-diagram A
+      ( cocone-map-sequential-diagram A
+        ( cocone-standard-sequential-colimit A)
+        ( map-hom-standard-sequential-colimit))
+      ( map-cocone-hom-sequential-diagram f
+        ( cocone-standard-sequential-colimit B))
+  htpy-cocone-map-hom-standard-sequential-colimit =
+    htpy-cocone-universal-property-sequential-colimit A
+      ( cocone-standard-sequential-colimit A)
+      ( up-standard-sequential-colimit)
+      ( map-cocone-hom-sequential-diagram f
+        ( cocone-standard-sequential-colimit B))
+
+  htpy-htpy-cocone-map-hom-standard-sequential-colimit :
+    ( n : ℕ) →
+    coherence-square-maps
+      ( map-hom-sequential-diagram B f n)
+      ( map-cocone-standard-sequential-colimit n)
+      ( map-cocone-standard-sequential-colimit n)
+      ( map-hom-standard-sequential-colimit)
+  htpy-htpy-cocone-map-hom-standard-sequential-colimit =
+    htpy-htpy-cocone-sequential-diagram A
+      ( htpy-cocone-map-hom-standard-sequential-colimit)
+
+  coherence-htpy-cocone-map-hom-standard-sequential-colimit :
+    ( n : ℕ) →
+    coherence-square-homotopies
+      ( htpy-htpy-cocone-map-hom-standard-sequential-colimit n)
+      ( ( map-hom-standard-sequential-colimit) ·l
+        ( coherence-triangle-cocone-standard-sequential-colimit n))
+      ( coherence-triangle-cocone-sequential-diagram A
+          ( map-cocone-hom-sequential-diagram f
+            ( cocone-standard-sequential-colimit B))
+          ( n))
+      ( ( htpy-htpy-cocone-map-hom-standard-sequential-colimit (succ-ℕ n)) ·r
+        ( map-sequential-diagram A n))
+  coherence-htpy-cocone-map-hom-standard-sequential-colimit =
+    coherence-htpy-htpy-cocone-sequential-diagram A
+      ( htpy-cocone-map-hom-standard-sequential-colimit)
+
+  prism-htpy-cocone-map-hom-standard-sequential-colimit :
+    ( n : ℕ) →
+    vertical-coherence-prism-maps
+      ( map-cocone-standard-sequential-colimit n)
+      ( map-cocone-standard-sequential-colimit (succ-ℕ n))
+      ( map-sequential-diagram A n)
+      ( map-cocone-standard-sequential-colimit n)
+      ( map-cocone-standard-sequential-colimit (succ-ℕ n))
+      ( map-sequential-diagram B n)
+      ( map-hom-sequential-diagram B f n)
+      ( map-hom-sequential-diagram B f (succ-ℕ n))
+      ( map-hom-standard-sequential-colimit)
+      ( coherence-triangle-cocone-standard-sequential-colimit n)
+      ( inv-htpy (htpy-htpy-cocone-map-hom-standard-sequential-colimit n))
+      ( inv-htpy
+        ( htpy-htpy-cocone-map-hom-standard-sequential-colimit (succ-ℕ n)))
+      ( naturality-map-hom-sequential-diagram B f n)
+      ( coherence-triangle-cocone-standard-sequential-colimit n)
+  prism-htpy-cocone-map-hom-standard-sequential-colimit n =
+    rotate-vertical-coherence-prism-maps
+      ( map-cocone-standard-sequential-colimit n)
+      ( map-cocone-standard-sequential-colimit (succ-ℕ n))
+      ( map-sequential-diagram A n)
+      ( map-cocone-standard-sequential-colimit n)
+      ( map-cocone-standard-sequential-colimit (succ-ℕ n))
+      ( map-sequential-diagram B n)
+      ( map-hom-sequential-diagram B f n)
+      ( map-hom-sequential-diagram B f (succ-ℕ n))
+      ( map-hom-standard-sequential-colimit)
+      ( coherence-triangle-cocone-standard-sequential-colimit n)
+      ( htpy-htpy-cocone-map-hom-standard-sequential-colimit n)
+      ( htpy-htpy-cocone-map-hom-standard-sequential-colimit (succ-ℕ n))
+      ( naturality-map-hom-sequential-diagram B f n)
+      ( coherence-triangle-cocone-standard-sequential-colimit n)
+      ( inv-htpy (coherence-htpy-cocone-map-hom-standard-sequential-colimit n))
+```
+
+### Homotopies between morphisms of sequential diagrams induce homotopies of maps of sequential colimits
+
+```agda
+module _
+  { l1 l2 : Level} {A : sequential-diagram l1} {B : sequential-diagram l2}
+  { f g : hom-sequential-diagram A B} (H : htpy-hom-sequential-diagram B f g)
+  where
+
+  htpy-map-hom-standard-sequential-colimit-htpy-hom-sequential-diagram :
+    map-hom-standard-sequential-colimit B f ~
+    map-hom-standard-sequential-colimit B g
+  htpy-map-hom-standard-sequential-colimit-htpy-hom-sequential-diagram =
+    htpy-eq
+      ( ap
+        ( map-hom-standard-sequential-colimit B)
+        ( eq-htpy-sequential-diagram A B f g H))
+```
+
+### The identity morphism induces the identity map
+
+We have `id∞ ~ id : A∞ → A∞`.
+
+```agda
+module _
+  { l1 : Level} {A : sequential-diagram l1}
+  where
+
+  htpy-preserves-id-map-hom-standard-sequential-colimit :
+    htpy-out-of-standard-sequential-colimit A
+      ( map-hom-standard-sequential-colimit A
+        ( id-hom-sequential-diagram A))
+      ( id)
+  pr1 htpy-preserves-id-map-hom-standard-sequential-colimit =
+    htpy-htpy-cocone-map-hom-standard-sequential-colimit A
+      ( id-hom-sequential-diagram A)
+  pr2 htpy-preserves-id-map-hom-standard-sequential-colimit n =
+    ( coherence-htpy-cocone-map-hom-standard-sequential-colimit A
+      ( id-hom-sequential-diagram A) n) ∙h
+    ( ap-concat-htpy _
+      ( ( right-unit-htpy) ∙h
+        ( inv-htpy
+          ( left-unit-law-left-whisk-htpy
+            ( coherence-triangle-cocone-standard-sequential-colimit n)))))
+
+  preserves-id-map-hom-standard-sequential-colimit :
+    map-hom-standard-sequential-colimit A
+      ( id-hom-sequential-diagram A) ~
+    id
+  preserves-id-map-hom-standard-sequential-colimit =
+    htpy-htpy-out-of-standard-sequential-colimit A
+      ( htpy-preserves-id-map-hom-standard-sequential-colimit)
+```
+
+### Forming sequential colimits preserves composition of morphisms of sequential diagrams
+
+We have `(f ∘ g)∞ ~ (f∞ ∘ g∞) : A∞ → C∞`.
+
+```agda
+module _
+  { l1 l2 l3 : Level} {A : sequential-diagram l1} {B : sequential-diagram l2}
+  { C : sequential-diagram l3}
+  ( g : hom-sequential-diagram B C) (f : hom-sequential-diagram A B)
+  where
+
+  htpy-preserves-comp-map-hom-standard-sequential-colimit :
+    htpy-out-of-standard-sequential-colimit A
+      ( map-hom-standard-sequential-colimit C
+        ( comp-hom-sequential-diagram A B C g f))
+      ( ( map-hom-standard-sequential-colimit C g) ∘
+        ( map-hom-standard-sequential-colimit B f))
+  pr1 htpy-preserves-comp-map-hom-standard-sequential-colimit n =
+    ( htpy-htpy-cocone-map-hom-standard-sequential-colimit C
+      ( comp-hom-sequential-diagram A B C g f) n) ∙h
+    ( pasting-vertical-coherence-square-maps
+      ( map-cocone-standard-sequential-colimit n)
+      ( map-hom-sequential-diagram B f n)
+      ( map-hom-standard-sequential-colimit B f)
+      ( map-cocone-standard-sequential-colimit n)
+      ( map-hom-sequential-diagram C g n)
+      ( map-hom-standard-sequential-colimit C g)
+      ( map-cocone-standard-sequential-colimit n)
+      ( inv-htpy
+        ( htpy-htpy-cocone-map-hom-standard-sequential-colimit B f n))
+      ( inv-htpy
+        ( htpy-htpy-cocone-map-hom-standard-sequential-colimit C g n)))
+  pr2 htpy-preserves-comp-map-hom-standard-sequential-colimit n =
+    ( inv-htpy-assoc-htpy
+      ( ( map-hom-standard-sequential-colimit C
+          ( comp-hom-sequential-diagram A B C g f)) ·l
+        ( coherence-triangle-cocone-standard-sequential-colimit n))
+      ( ( htpy-htpy-cocone-map-hom-standard-sequential-colimit C
+          ( comp-hom-sequential-diagram A B C g f)
+          ( succ-ℕ n)) ·r
+        ( map-sequential-diagram A n))
+      ( _)) ∙h
+    ( ap-concat-htpy' _
+      ( coherence-htpy-cocone-map-hom-standard-sequential-colimit C
+        ( comp-hom-sequential-diagram A B C g f)
+        ( n)) ∙h
+    ( assoc-htpy
+      ( htpy-htpy-cocone-map-hom-standard-sequential-colimit C
+        ( comp-hom-sequential-diagram A B C g f)
+        ( n))
+      ( coherence-triangle-cocone-sequential-diagram A
+        ( map-cocone-hom-sequential-diagram
+          ( comp-hom-sequential-diagram A B C g f)
+          ( cocone-standard-sequential-colimit C))
+        ( n))
+      ( _)) ∙h
+    ( ap-concat-htpy
+      ( htpy-htpy-cocone-map-hom-standard-sequential-colimit C
+        ( comp-hom-sequential-diagram A B C g f)
+        ( n))
+      ( ( assoc-htpy
+          ( ( coherence-triangle-cocone-standard-sequential-colimit n) ·r
+            ( ( map-hom-sequential-diagram C g n) ∘
+              ( map-hom-sequential-diagram B f n)))
+          ( map-cocone-standard-sequential-colimit (succ-ℕ n) ·l _)
+          ( _)) ∙h
+        ( pasting-vertical-coherence-prism-maps
+          ( map-cocone-standard-sequential-colimit n)
+          ( map-cocone-standard-sequential-colimit (succ-ℕ n))
+          ( map-sequential-diagram A n)
+          ( map-cocone-standard-sequential-colimit n)
+          ( map-cocone-standard-sequential-colimit (succ-ℕ n))
+          ( map-sequential-diagram B n)
+          ( map-hom-sequential-diagram B f n)
+          ( map-hom-sequential-diagram B f (succ-ℕ n))
+          ( map-hom-standard-sequential-colimit B f)
+          ( map-cocone-standard-sequential-colimit n)
+          ( map-cocone-standard-sequential-colimit (succ-ℕ n))
+          ( map-sequential-diagram C n)
+          ( map-hom-sequential-diagram C g n)
+          ( map-hom-sequential-diagram C g (succ-ℕ n))
+          ( map-hom-standard-sequential-colimit C g)
+          ( coherence-triangle-cocone-standard-sequential-colimit n)
+          ( inv-htpy
+            ( htpy-htpy-cocone-map-hom-standard-sequential-colimit B f n))
+          ( inv-htpy
+            ( htpy-htpy-cocone-map-hom-standard-sequential-colimit B f
+              ( succ-ℕ n)))
+          ( naturality-map-hom-sequential-diagram B f n)
+          ( coherence-triangle-cocone-standard-sequential-colimit n)
+          ( inv-htpy
+            ( htpy-htpy-cocone-map-hom-standard-sequential-colimit C g n))
+          ( inv-htpy
+            ( htpy-htpy-cocone-map-hom-standard-sequential-colimit C g
+              ( succ-ℕ n)))
+          ( naturality-map-hom-sequential-diagram C g n)
+          ( coherence-triangle-cocone-standard-sequential-colimit n)
+          ( prism-htpy-cocone-map-hom-standard-sequential-colimit B f n)
+          ( prism-htpy-cocone-map-hom-standard-sequential-colimit C g
+            ( n))))) ∙h
+    ( inv-htpy-assoc-htpy
+      ( htpy-htpy-cocone-map-hom-standard-sequential-colimit C
+        ( comp-hom-sequential-diagram A B C g f)
+        ( n))
+      ( _)
+      ( ( ( map-hom-standard-sequential-colimit C g) ∘
+          ( map-hom-standard-sequential-colimit B f)) ·l
+        ( coherence-triangle-cocone-standard-sequential-colimit n))))
+
+  preserves-comp-map-hom-standard-sequential-colimit :
+    ( map-hom-standard-sequential-colimit C
+      ( comp-hom-sequential-diagram A B C g f)) ~
+    ( ( map-hom-standard-sequential-colimit C g) ∘
+      ( map-hom-standard-sequential-colimit B f))
+  preserves-comp-map-hom-standard-sequential-colimit =
+    htpy-htpy-out-of-standard-sequential-colimit A
+      htpy-preserves-comp-map-hom-standard-sequential-colimit
+```
+
+### An equivalence of sequential diagrams induces an equivalence of cocones
+
+Additionally, the underlying map of the inverse equivalence is definitionally
+equal to the map induced by the inverse of the equivalence of sequential
+diagrams, i.e. `(e∞)⁻¹ = (e⁻¹)∞`.
+
+```agda
+module _
+  { l1 l2 : Level} {A : sequential-diagram l1} {B : sequential-diagram l2}
+  ( e : equiv-sequential-diagram A B)
+  where
+
+  map-equiv-standard-sequential-colimit :
+    standard-sequential-colimit A → standard-sequential-colimit B
+  map-equiv-standard-sequential-colimit =
+    map-hom-standard-sequential-colimit B
+      ( hom-equiv-sequential-diagram B e)
+
+  inv-map-equiv-standard-sequential-colimit :
+    standard-sequential-colimit B → standard-sequential-colimit A
+  inv-map-equiv-standard-sequential-colimit =
+    map-hom-standard-sequential-colimit A
+      ( hom-inv-equiv-sequential-diagram B e)
+
+  abstract
+    is-section-inv-map-equiv-standard-sequential-colimit :
+      ( ( map-equiv-standard-sequential-colimit) ∘
+        ( inv-map-equiv-standard-sequential-colimit)) ~
+      ( id)
+    is-section-inv-map-equiv-standard-sequential-colimit =
+      ( inv-htpy
+        ( preserves-comp-map-hom-standard-sequential-colimit
+          ( hom-equiv-sequential-diagram B e)
+          ( hom-inv-equiv-sequential-diagram B e))) ∙h
+      ( htpy-map-hom-standard-sequential-colimit-htpy-hom-sequential-diagram
+        ( is-section-inv-equiv-sequential-diagram B e)) ∙h
+      ( preserves-id-map-hom-standard-sequential-colimit)
+
+    is-retraction-inv-map-equiv-standard-sequential-colimit :
+      ( ( inv-map-equiv-standard-sequential-colimit) ∘
+        ( map-equiv-standard-sequential-colimit)) ~
+      ( id)
+    is-retraction-inv-map-equiv-standard-sequential-colimit =
+      ( inv-htpy
+        ( preserves-comp-map-hom-standard-sequential-colimit
+          ( hom-inv-equiv-sequential-diagram B e)
+          ( hom-equiv-sequential-diagram B e))) ∙h
+      ( htpy-map-hom-standard-sequential-colimit-htpy-hom-sequential-diagram
+        ( is-retraction-inv-equiv-sequential-diagram B e)) ∙h
+      ( preserves-id-map-hom-standard-sequential-colimit)
+
+  is-equiv-map-hom-standard-sequential-colimit :
+    is-equiv map-equiv-standard-sequential-colimit
+  is-equiv-map-hom-standard-sequential-colimit =
+    is-equiv-is-invertible
+      ( inv-map-equiv-standard-sequential-colimit)
+      ( is-section-inv-map-equiv-standard-sequential-colimit)
+      ( is-retraction-inv-map-equiv-standard-sequential-colimit)
+
+  equiv-equiv-standard-sequential-colimit :
+    standard-sequential-colimit A ≃ standard-sequential-colimit B
+  pr1 equiv-equiv-standard-sequential-colimit =
+    map-hom-standard-sequential-colimit B (hom-equiv-sequential-diagram B e)
+  pr2 equiv-equiv-standard-sequential-colimit =
+    is-equiv-map-hom-standard-sequential-colimit
+```
+
+## References
+
+1. Kristina Sojakova, Floris van Doorn, and Egbert Rijke. 2020. Sequential
+   Colimits in Homotopy Type Theory. In Proceedings of the 35th Annual ACM/IEEE
+   Symposium on Logic in Computer Science (LICS '20). Association for Computing
+   Machinery, New York, NY, USA, 845–858,
+   [DOI:10.1145](https://doi.org/10.1145/3373718.3394801)
diff --git a/src/synthetic-homotopy-theory/morphisms-sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/morphisms-sequential-diagrams.lagda.md
index 36b52d62a1..d906a3862b 100644
--- a/src/synthetic-homotopy-theory/morphisms-sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/morphisms-sequential-diagrams.lagda.md
@@ -77,6 +77,12 @@ module _
 
 ### Components of morphisms of sequential diagrams
 
+_Implementation note:_ Ideally we would have both the domain and codomain of a
+morphism of sequential diagrams inferred by Agda. Unfortunately that's not the
+case with the current implementation, and the codomain needs to be provided
+explicitly. This arises also in
+[equivalences of sequential diagrams](synthetic-homotopy-theory.equivalences-sequential-diagrams.md).
+
 ```agda
 module _
   { l1 l2 : Level} {A : sequential-diagram l1} (B : sequential-diagram l2)
diff --git a/src/synthetic-homotopy-theory/sequential-colimits.lagda.md b/src/synthetic-homotopy-theory/sequential-colimits.lagda.md
new file mode 100644
index 0000000000..7906598769
--- /dev/null
+++ b/src/synthetic-homotopy-theory/sequential-colimits.lagda.md
@@ -0,0 +1,213 @@
+# Sequential colimits
+
+```agda
+module synthetic-homotopy-theory.sequential-colimits where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import elementary-number-theory.natural-numbers
+
+open import foundation.commuting-triangles-of-maps
+open import foundation.dependent-pair-types
+open import foundation.equivalences
+open import foundation.function-types
+open import foundation.functoriality-dependent-function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.homotopies
+open import foundation.universe-levels
+
+open import synthetic-homotopy-theory.cocones-under-sequential-diagrams
+open import synthetic-homotopy-theory.coequalizers
+open import synthetic-homotopy-theory.dependent-cocones-under-sequential-diagrams
+open import synthetic-homotopy-theory.dependent-universal-property-sequential-colimits
+open import synthetic-homotopy-theory.sequential-diagrams
+open import synthetic-homotopy-theory.universal-property-sequential-colimits
+```
+
+</details>
+
+## Idea
+
+Given a [sequential diagram](synthetic-homotopy-theory.sequential-diagrams.md)
+`(A, a)`, we can construct its **standard sequential colimit** `A∞`, which is a
+[cocone under it](synthetic-homotopy-theory.cocones-under-sequential-diagrams.md)
+satisfying the
+[universal property of sequential colimits](synthetic-homotopy-theory.universal-property-sequential-colimits.md).
+
+In other words, the sequential colimit universally completes the diagram
+
+```text
+     a₀      a₁      a₂
+ A₀ ---> A₁ ---> A₂ ---> ⋯ ---> A∞ .
+```
+
+We often abuse notation and write `A∞` for just the codomain of the universal
+cocone. You may also see the colimit written as `colimₙ Aₙ`.
+
+## Properties
+
+### All sequential diagrams admit a standard colimit
+
+The standard colimit may be constructed from
+[coequalizers](synthetic-homotopy-theory.coequalizers.md), because we
+[have shown](synthetic-homotopy-theory.universal-property-sequential-colimits.md)
+that cocones of sequential diagrams correspond to a certain class of
+[coforks](synthetic-homotopy-theory.coforks.md), and the coequalizers correspond
+to sequential colimits. Since all coequalizers exist, we conclude that all
+sequential colimits exist.
+
+```agda
+abstract
+  standard-sequential-colimit : {l : Level} (A : sequential-diagram l) → UU l
+  standard-sequential-colimit A =
+    canonical-coequalizer
+      ( bottom-map-cofork-cocone-sequential-diagram A)
+      ( top-map-cofork-cocone-sequential-diagram A)
+
+  cocone-standard-sequential-colimit :
+    { l : Level} (A : sequential-diagram l) →
+    cocone-sequential-diagram A (standard-sequential-colimit A)
+  cocone-standard-sequential-colimit A =
+    cocone-sequential-diagram-cofork A
+      ( cofork-canonical-coequalizer
+        ( bottom-map-cofork-cocone-sequential-diagram A)
+        ( top-map-cofork-cocone-sequential-diagram A))
+
+  dup-standard-sequential-colimit :
+    { l : Level} {A : sequential-diagram l} →
+    dependent-universal-property-sequential-colimit A
+      ( cocone-standard-sequential-colimit A)
+  dup-standard-sequential-colimit {A = A} =
+    dependent-universal-property-sequential-colimit-dependent-universal-property-coequalizer
+      ( A)
+      ( cocone-standard-sequential-colimit A)
+      ( dup-canonical-coequalizer
+        ( bottom-map-cofork-cocone-sequential-diagram A)
+        ( top-map-cofork-cocone-sequential-diagram A))
+
+  up-standard-sequential-colimit :
+    { l : Level} {A : sequential-diagram l} →
+    universal-property-sequential-colimit A
+      (cocone-standard-sequential-colimit A)
+  up-standard-sequential-colimit {A = A} =
+    universal-property-dependent-universal-property-sequential-colimit A
+      ( cocone-standard-sequential-colimit A)
+      ( dup-standard-sequential-colimit)
+
+module _
+  { l : Level} {A : sequential-diagram l}
+  where
+
+  map-cocone-standard-sequential-colimit :
+    ( n : ℕ) → family-sequential-diagram A n → standard-sequential-colimit A
+  map-cocone-standard-sequential-colimit =
+    map-cocone-sequential-diagram A (cocone-standard-sequential-colimit A)
+
+  coherence-triangle-cocone-standard-sequential-colimit :
+    ( n : ℕ) →
+    coherence-triangle-maps
+      ( map-cocone-standard-sequential-colimit n)
+      ( map-cocone-standard-sequential-colimit (succ-ℕ n))
+      ( map-sequential-diagram A n)
+  coherence-triangle-cocone-standard-sequential-colimit =
+    coherence-triangle-cocone-sequential-diagram A
+      ( cocone-standard-sequential-colimit A)
+```
+
+### Corollaries of the universal property of sequential colimits
+
+```agda
+module _
+  { l1 l2 : Level} {A : sequential-diagram l1}
+  where
+
+  equiv-up-standard-sequential-colimit :
+    { X : UU l2} →
+    (standard-sequential-colimit A → X) ≃ (cocone-sequential-diagram A X)
+  pr1 equiv-up-standard-sequential-colimit =
+    cocone-map-sequential-diagram A (cocone-standard-sequential-colimit A)
+  pr2 (equiv-up-standard-sequential-colimit) =
+    up-standard-sequential-colimit _
+
+  cogap-standard-sequential-colimit :
+    { X : UU l2} →
+    cocone-sequential-diagram A X → standard-sequential-colimit A → X
+  cogap-standard-sequential-colimit =
+    map-inv-equiv equiv-up-standard-sequential-colimit
+
+  equiv-dup-standard-sequential-colimit :
+    { P : standard-sequential-colimit A → UU l2} →
+    ( (x : standard-sequential-colimit A) → P x) ≃
+    ( dependent-cocone-sequential-diagram A
+      ( cocone-standard-sequential-colimit A)
+      ( P))
+  pr1 equiv-dup-standard-sequential-colimit =
+    dependent-cocone-map-sequential-diagram A
+      ( cocone-standard-sequential-colimit A)
+      ( _)
+  pr2 equiv-dup-standard-sequential-colimit =
+    dup-standard-sequential-colimit _
+
+  dependent-cogap-standard-sequential-colimit :
+    { P : standard-sequential-colimit A → UU l2} →
+    dependent-cocone-sequential-diagram A
+      ( cocone-standard-sequential-colimit A)
+      ( P) →
+    ( x : standard-sequential-colimit A) → P x
+  dependent-cogap-standard-sequential-colimit =
+    map-inv-equiv equiv-dup-standard-sequential-colimit
+```
+
+### Homotopies between maps from the standard sequential colimit
+
+Maps from the standard sequential colimit induce cocones under the sequential
+diagrams, and a [homotopy](foundation-core.homotopies.md) between the maps is
+exactly a homotopy of the cocones.
+
+```agda
+module _
+  { l1 l2 : Level} (A : sequential-diagram l1) {X : UU l2}
+  ( f g : standard-sequential-colimit A → X)
+  where
+
+  htpy-out-of-standard-sequential-colimit : UU (l1 ⊔ l2)
+  htpy-out-of-standard-sequential-colimit =
+    htpy-cocone-sequential-diagram A
+      ( cocone-map-sequential-diagram A
+        ( cocone-standard-sequential-colimit A)
+        ( f))
+      ( cocone-map-sequential-diagram A
+        ( cocone-standard-sequential-colimit A)
+        ( g))
+
+  equiv-htpy-htpy-out-of-standard-sequential-colimit :
+    htpy-out-of-standard-sequential-colimit ≃ (f ~ g)
+  equiv-htpy-htpy-out-of-standard-sequential-colimit =
+    ( inv-equiv equiv-dup-standard-sequential-colimit) ∘e
+    ( equiv-tot
+      ( λ K →
+        equiv-Π-equiv-family
+          ( λ n →
+            equiv-Π-equiv-family
+              ( λ a →
+                compute-dependent-identification-eq-value-function f g
+                  ( coherence-triangle-cocone-standard-sequential-colimit n a)
+                  ( K n a)
+                  ( K (succ-ℕ n) (map-sequential-diagram A n a))))))
+```
+
+We may then obtain a homotopy of maps from a homotopy of their induced cocones.
+
+```agda
+module _
+  { l1 l2 : Level} (A : sequential-diagram l1) {X : UU l2}
+  { f g : standard-sequential-colimit A → X}
+  ( H : htpy-out-of-standard-sequential-colimit A f g)
+  where
+
+  htpy-htpy-out-of-standard-sequential-colimit : f ~ g
+  htpy-htpy-out-of-standard-sequential-colimit =
+    map-equiv (equiv-htpy-htpy-out-of-standard-sequential-colimit A f g) H
+```
diff --git a/src/synthetic-homotopy-theory/sequential-diagrams.lagda.md b/src/synthetic-homotopy-theory/sequential-diagrams.lagda.md
index 40e1709298..1aed088035 100644
--- a/src/synthetic-homotopy-theory/sequential-diagrams.lagda.md
+++ b/src/synthetic-homotopy-theory/sequential-diagrams.lagda.md
@@ -51,6 +51,16 @@ module _
   map-sequential-diagram = pr2 A
 ```
 
+```agda
+module _
+  { l : Level} (X : UU l)
+  where
+
+  constant-sequential-diagram : sequential-diagram l
+  pr1 constant-sequential-diagram _ = X
+  pr2 constant-sequential-diagram _ x = x
+```
+
 ## Properties
 
 The [identity type](foundation.identity-types.md) of sequential diagrams is
diff --git a/src/synthetic-homotopy-theory/sequentially-compact-types.lagda.md b/src/synthetic-homotopy-theory/sequentially-compact-types.lagda.md
index e7b02ffe9d..44aa440b30 100644
--- a/src/synthetic-homotopy-theory/sequentially-compact-types.lagda.md
+++ b/src/synthetic-homotopy-theory/sequentially-compact-types.lagda.md
@@ -42,9 +42,8 @@ module _
   is-sequentially-compact =
     {l2 l3 : Level} (A : sequential-diagram l2) {A∞ : UU l3}
     (c : cocone-sequential-diagram A A∞) →
-    ((l : Level) → universal-property-sequential-colimit l A c) →
-    (l : Level) →
-    universal-property-sequential-colimit l
+    universal-property-sequential-colimit A c →
+    universal-property-sequential-colimit
       ( postcomp-sequential-diagram X A)
       ( cocone-postcomp-sequential-diagram X A c)
 ```
diff --git a/src/synthetic-homotopy-theory/universal-property-sequential-colimits.lagda.md b/src/synthetic-homotopy-theory/universal-property-sequential-colimits.lagda.md
index 16383fc01e..911d82d7c3 100644
--- a/src/synthetic-homotopy-theory/universal-property-sequential-colimits.lagda.md
+++ b/src/synthetic-homotopy-theory/universal-property-sequential-colimits.lagda.md
@@ -58,13 +58,14 @@ diagram
 
 ```agda
 module _
-  { l1 l2 : Level} (l : Level) (A : sequential-diagram l1) {X : UU l2}
+  { l1 l2 : Level} (A : sequential-diagram l1) {X : UU l2}
   ( c : cocone-sequential-diagram A X)
   where
 
-  universal-property-sequential-colimit : UU (l1 ⊔ l2 ⊔ lsuc l)
+  universal-property-sequential-colimit : UUω
   universal-property-sequential-colimit =
-    ( Y : UU l) → is-equiv (cocone-map-sequential-diagram A c {Y = Y})
+    {l : Level} → (Y : UU l) →
+    is-equiv (cocone-map-sequential-diagram A c {Y = Y})
 ```
 
 ### The map induced by the universal property of sequential colimits
@@ -76,7 +77,7 @@ providing a cocone under the sequential diagram.
 module _
   { l1 l2 l3 : Level} (A : sequential-diagram l1) {X : UU l2}
   ( c : cocone-sequential-diagram A X) {Y : UU l3}
-  ( up-sequential-colimit : universal-property-sequential-colimit l3 A c)
+  ( up-sequential-colimit : universal-property-sequential-colimit A c)
   where
 
   map-universal-property-sequential-colimit :
@@ -93,7 +94,7 @@ module _
 module _
   { l1 l2 l3 : Level} (A : sequential-diagram l1) {X : UU l2}
   ( c : cocone-sequential-diagram A X) {Y : UU l3}
-  ( up-sequential-colimit : universal-property-sequential-colimit l3 A c)
+  ( up-sequential-colimit : universal-property-sequential-colimit A c)
   ( c' : cocone-sequential-diagram A Y)
   where
 
@@ -151,8 +152,7 @@ module _
         ( bottom-map-cofork-cocone-sequential-diagram A)
         ( top-map-cofork-cocone-sequential-diagram A)
         ( cofork-cocone-sequential-diagram A c)) →
-    ( {l : Level} →
-      universal-property-sequential-colimit l A c)
+    universal-property-sequential-colimit A c
   universal-property-sequential-colimit-universal-property-coequalizer
     ( up-cofork)
     ( Y) =
@@ -168,8 +168,7 @@ module _
       ( is-equiv-cocone-sequential-diagram-cofork A)
 
   universal-property-coequalizer-universal-property-sequential-colimit :
-    ( {l : Level} →
-      universal-property-sequential-colimit l A c) →
+    universal-property-sequential-colimit A c →
     ( {l : Level} →
       universal-property-coequalizer l
         ( bottom-map-cofork-cocone-sequential-diagram A)
@@ -233,8 +232,8 @@ module _
 
   abstract
     is-equiv-universal-property-sequential-colimit-universal-property-sequential-colimit :
-      ( {l : Level} → universal-property-sequential-colimit l A c) →
-      ( {l : Level} → universal-property-sequential-colimit l A c') →
+      universal-property-sequential-colimit A c →
+      universal-property-sequential-colimit A c' →
       is-equiv h
     is-equiv-universal-property-sequential-colimit-universal-property-sequential-colimit
       ( up-sequential-colimit)
@@ -250,9 +249,9 @@ module _
             ( up-sequential-colimit' Z))
 
     universal-property-sequential-colimit-is-equiv-universal-property-sequential-colomit :
-      ( {l : Level} → universal-property-sequential-colimit l A c) →
+      universal-property-sequential-colimit A c →
       is-equiv h →
-      ( {l : Level} → universal-property-sequential-colimit l A c')
+      universal-property-sequential-colimit A c'
     universal-property-sequential-colimit-is-equiv-universal-property-sequential-colomit
       ( up-sequential-colimit)
       ( is-equiv-h)
@@ -267,8 +266,8 @@ module _
 
     universal-property-sequential-colimit-universal-property-sequential-colimit-is-equiv :
       is-equiv h →
-      ( {l : Level} → universal-property-sequential-colimit l A c') →
-      ( {l : Level} → universal-property-sequential-colimit l A c)
+      universal-property-sequential-colimit A c' →
+      universal-property-sequential-colimit A c
     universal-property-sequential-colimit-universal-property-sequential-colimit-is-equiv
       ( is-equiv-h)
       ( up-sequential-colimit)
@@ -289,10 +288,8 @@ module _
   { l1 l2 l3 : Level} (A : sequential-diagram l1) {X : UU l2} {Y : UU l3}
   ( c : cocone-sequential-diagram A X)
   ( c' : cocone-sequential-diagram A Y)
-  ( up-sequential-diagram :
-    {l : Level} → universal-property-sequential-colimit l A c)
-  ( up-sequential-diagram' :
-    {l : Level} → universal-property-sequential-colimit l A c')
+  ( up-c : universal-property-sequential-colimit A c)
+  ( up-c' : universal-property-sequential-colimit A c')
   where
 
   abstract
@@ -305,26 +302,16 @@ module _
                 ( c')))
     uniquely-unique-sequential-colimit =
       is-torsorial-Eq-subtype
-        ( uniqueness-map-universal-property-sequential-colimit A c
-          ( up-sequential-diagram)
-          ( c'))
+        ( uniqueness-map-universal-property-sequential-colimit A c up-c c')
         ( is-property-is-equiv)
-        ( map-universal-property-sequential-colimit A c
-          ( up-sequential-diagram)
-          ( c'))
-        ( htpy-cocone-universal-property-sequential-colimit A c
-          ( up-sequential-diagram)
-          ( c'))
+        ( map-universal-property-sequential-colimit A c up-c c')
+        ( htpy-cocone-universal-property-sequential-colimit A c up-c c')
         ( is-equiv-universal-property-sequential-colimit-universal-property-sequential-colimit
           ( A)
           ( c)
           ( c')
-          ( map-universal-property-sequential-colimit A c
-            ( up-sequential-diagram)
-            ( c'))
-          ( htpy-cocone-universal-property-sequential-colimit A c
-            ( up-sequential-diagram)
-            ( c'))
-          ( up-sequential-diagram)
-          ( up-sequential-diagram'))
+          ( map-universal-property-sequential-colimit A c up-c c')
+          ( htpy-cocone-universal-property-sequential-colimit A c up-c c')
+          ( up-c)
+          ( up-c'))
 ```
