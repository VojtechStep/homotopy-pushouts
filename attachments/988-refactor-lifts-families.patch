From 299019d5454fdddefc242d7ba93236c02d2e6337 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Thu, 4 Jan 2024 13:47:16 +0100
Subject: [PATCH 01/18] =?UTF-8?q?WIP=20Refactor=20proof=20of=20dependent-p?=
 =?UTF-8?q?ullback-property=E2=86=94pullback-property?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Mostly moves stuff out of 26-descent to more appropriate locations
---
 ...unctoriality-dependent-pair-types.lagda.md |  48 +
 .../precomposition-type-families.lagda.md     |  44 +-
 src/orthogonal-factorization-systems.lagda.md |   1 +
 .../lifts-families-of-elements.lagda.md       |  73 ++
 ...sition-lifts-families-of-elements.lagda.md | 244 +++++
 .../26-descent.lagda.md                       | 886 +++++++-----------
 .../26-id-pushout.lagda.md                    |   1 +
 ...endent-pullback-property-pushouts.lagda.md | 134 +++
 ...t-universal-property-coequalizers.lagda.md |   1 -
 .../pushouts.lagda.md                         |   1 -
 10 files changed, 906 insertions(+), 527 deletions(-)
 create mode 100644 src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md

diff --git a/src/foundation/functoriality-dependent-pair-types.lagda.md b/src/foundation/functoriality-dependent-pair-types.lagda.md
index 929bf7f24c..068351c63a 100644
--- a/src/foundation/functoriality-dependent-pair-types.lagda.md
+++ b/src/foundation/functoriality-dependent-pair-types.lagda.md
@@ -11,6 +11,7 @@ open import foundation-core.functoriality-dependent-pair-types public
 ```agda
 open import foundation.action-on-identifications-functions
 open import foundation.cones-over-cospans
+open import foundation.dependent-homotopies
 open import foundation.dependent-pair-types
 open import foundation.type-arithmetic-dependent-pair-types
 open import foundation.universe-levels
@@ -38,6 +39,53 @@ open import foundation-core.truncation-levels
 
 ## Properties
 
+### TODO
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {C : A → UU l3}
+  (D : B → UU l4)
+  where
+
+  abstract
+    htpy-htpy-map-Σ :
+      {f f' : A → B} {H H' : f ~ f'} →
+      {g : (a : A) → C a → D (f a)} {g' : (a : A) → C a → D (f' a)} →
+      {K : (a : A) → dependent-homotopy (λ _ → D) (λ _ → H a) (g a) (g' a)} →
+      {K' : (a : A) → dependent-homotopy (λ _ → D) (λ _ → H' a) (g a) (g' a)} →
+      (α : H ~ H') →
+      (β :
+        (a : A) (c : C a) →
+        K a c ＝ ap (λ p → tr D p (g a c)) (α a) ∙ K' a c) →
+      htpy-map-Σ D H g K ~ htpy-map-Σ D H' g K'
+    htpy-htpy-map-Σ {g = g} {g'} {K} {K'} α β (a , c) =
+      ap
+        ( eq-pair-Σ')
+        ( eq-pair-Σ
+          ( α a)
+          ( map-compute-dependent-identification-eq-value-function
+            ( λ p → tr D p (g a c))
+            ( λ _ → g' a c)
+            ( α a)
+            ( K a c)
+            ( K' a c)
+            ( inv
+              ( ( ap
+                  ( K a c ∙_)
+                  ( ap-const (g' a c) (α a))) ∙
+                ( right-unit) ∙
+                ( β a c)))))
+
+    htpy-htpy-map-Σ-refl-htpy :
+      {f : A → B} {H : f ~ f} →
+      {g : (x : A) → C x → D (f x)} {K : (a : A) → tr D (H a) ∘ g a ~ g a} →
+      (α : H ~ refl-htpy) →
+      (β : (a : A) (c : C a) → K a c ＝ ap (λ p → tr D p (g a c)) (α a)) →
+      htpy-map-Σ D H g K ~ refl-htpy
+    htpy-htpy-map-Σ-refl-htpy α β =
+      htpy-htpy-map-Σ α (λ a c → β a c ∙ inv right-unit)
+```
+
 ### The map on total spaces induced by a family of truncated maps is truncated
 
 ```agda
diff --git a/src/foundation/precomposition-type-families.lagda.md b/src/foundation/precomposition-type-families.lagda.md
index fea1ef916a..bd58689295 100644
--- a/src/foundation/precomposition-type-families.lagda.md
+++ b/src/foundation/precomposition-type-families.lagda.md
@@ -7,9 +7,14 @@ module foundation.precomposition-type-families where
 <details><summary>Imports</summary>
 
 ```agda
+open import foundation.homotopy-induction
+open import foundation.transport-along-homotopies
 open import foundation.universe-levels
 
 open import foundation-core.function-types
+open import foundation-core.homotopies
+open import foundation-core.identity-types
+open import foundation-core.whiskering-homotopies
 ```
 
 </details>
@@ -35,6 +40,41 @@ module _
   {l1 l2 : Level} {A : UU l1} {B : UU l2} (f : A → B)
   where
 
-  precomp-family : (l : Level) → (B → UU l) → (A → UU l)
-  precomp-family l Q = Q ∘ f
+  precomp-family : {l : Level} → (B → UU l) → (A → UU l)
+  precomp-family Q = Q ∘ f
+```
+
+## Properties
+
+### Transport in precomposed type families
+
+TODO
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} (f : A → B) (Q : B → UU l3)
+  {X : UU l4} {g : X → A}
+  where
+
+  statement-tr-precomp-family :
+    {h : X → A} (H : g ~ h) → UU (l3 ⊔ l4)
+  statement-tr-precomp-family H =
+    tr-htpy (λ _ → precomp-family f Q) H ~ tr-htpy (λ _ → Q) (f ·l H)
+
+  tr-precomp-family :
+    {h : X → A} (H : g ~ h) →
+    statement-tr-precomp-family H
+  tr-precomp-family =
+    ind-htpy g
+      ( λ h → statement-tr-precomp-family)
+      ( refl-htpy)
+
+  abstract
+    compute-tr-precomp-family :
+      tr-precomp-family refl-htpy ＝
+      refl-htpy
+    compute-tr-precomp-family =
+      compute-ind-htpy g
+        ( λ h → statement-tr-precomp-family)
+        ( refl-htpy)
 ```
diff --git a/src/orthogonal-factorization-systems.lagda.md b/src/orthogonal-factorization-systems.lagda.md
index 528701370e..44d745a65d 100644
--- a/src/orthogonal-factorization-systems.lagda.md
+++ b/src/orthogonal-factorization-systems.lagda.md
@@ -46,6 +46,7 @@ open import orthogonal-factorization-systems.null-types public
 open import orthogonal-factorization-systems.open-modalities public
 open import orthogonal-factorization-systems.orthogonal-factorization-systems public
 open import orthogonal-factorization-systems.orthogonal-maps public
+open import orthogonal-factorization-systems.precomposition-lifts-families-of-elements public
 open import orthogonal-factorization-systems.pullback-hom public
 open import orthogonal-factorization-systems.raise-modalities public
 open import orthogonal-factorization-systems.reflective-modalities public
diff --git a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
index 6155ddf59e..fc79bb4650 100644
--- a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
@@ -7,6 +7,15 @@ module orthogonal-factorization-systems.lifts-families-of-elements where
 <details><summary>Imports</summary>
 
 ```agda
+open import foundation.action-on-identifications-functions
+open import foundation.dependent-pair-types
+open import foundation.homotopies
+open import foundation.homotopy-induction
+open import foundation.identity-types
+open import foundation.precomposition-functions
+open import foundation.precomposition-type-families
+open import foundation.transport-along-homotopies
+open import foundation.transport-along-identifications
 open import foundation.universe-levels
 ```
 
@@ -63,6 +72,31 @@ module _
   lift-family-of-elements = dependent-lift-family-of-elements (λ _ → B) a
 ```
 
+### Total space of dependent lifts of families of elements
+
+```agda
+module _
+  {l1 l2 l3 : Level} {I : UU l1} (A : I → UU l2) (B : (i : I) → A i → UU l3)
+  where
+
+  total-dependent-lift-family-of-elements : UU (l1 ⊔ l2 ⊔ l3)
+  total-dependent-lift-family-of-elements =
+    Σ ( (i : I) → A i)
+      ( dependent-lift-family-of-elements B)
+```
+
+### Total space of lifts of families of elements
+
+```agda
+module _
+  {l1 l2 l3 : Level} (I : UU l1) {A : UU l2} (B : A → UU l3)
+  where
+
+  total-lift-family-of-elements : UU (l1 ⊔ l2 ⊔ l3)
+  total-lift-family-of-elements =
+    total-dependent-lift-family-of-elements (λ (_ : I) → A) (λ _ → B)
+```
+
 ### Dependent lifts of binary families of elements
 
 ```agda
@@ -89,6 +123,45 @@ module _
     dependent-lift-binary-family-of-elements (λ _ → C) a
 ```
 
+## Properties
+
+### Transport in lifts of families of elements
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) (a : I → A)
+  {J : UU l4} {f : J → I}
+  where
+
+  statement-tr-lift-family-of-elements : {g : J → I} (H : f ~ g) → UU (l3 ⊔ l4)
+  statement-tr-lift-family-of-elements H =
+    tr (lift-family-of-elements B) (htpy-precomp H A a) ~
+    tr-htpy (λ _ → precomp-family a B) H
+
+  tr-lift-family-of-elements-refl-htpy :
+    statement-tr-lift-family-of-elements refl-htpy
+  tr-lift-family-of-elements-refl-htpy b =
+    ap
+      ( λ p → tr (lift-family-of-elements B) p b)
+      ( compute-htpy-precomp-refl-htpy f A a)
+
+  tr-lift-family-of-elements :
+    {g : J → I} (H : f ~ g) → statement-tr-lift-family-of-elements H
+  tr-lift-family-of-elements =
+    ind-htpy f
+      ( λ g → statement-tr-lift-family-of-elements)
+      ( tr-lift-family-of-elements-refl-htpy)
+
+  abstract
+    compute-tr-lift-family-of-elements :
+      tr-lift-family-of-elements refl-htpy ＝
+      tr-lift-family-of-elements-refl-htpy
+    compute-tr-lift-family-of-elements =
+      compute-ind-htpy f
+        ( λ g → statement-tr-lift-family-of-elements)
+        ( tr-lift-family-of-elements-refl-htpy)
+```
+
 ## See also
 
 - [Double lifts of families of elements](orthogonal-factorization-systems.double-lifts-families-of-elements.md)
diff --git a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
new file mode 100644
index 0000000000..07f2c826c0
--- /dev/null
+++ b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
@@ -0,0 +1,244 @@
+# Precomposition of lifts of families of elements by maps
+
+```agda
+module orthogonal-factorization-systems.precomposition-lifts-families-of-elements where
+```
+
+<details><summary>Imports</summary>
+
+```agda
+open import foundation.action-on-identifications-dependent-functions
+open import foundation.commuting-squares-of-homotopies
+open import foundation.commuting-squares-of-maps
+open import foundation.commuting-triangles-of-maps
+open import foundation.dependent-pair-types
+open import foundation.function-extensionality
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.homotopies
+open import foundation.homotopy-induction
+open import foundation.identity-types
+open import foundation.path-algebra
+open import foundation.precomposition-functions
+open import foundation.transport-along-identifications
+open import foundation.type-theoretic-principle-of-choice
+open import foundation.universe-levels
+open import foundation.whiskering-homotopies
+
+open import orthogonal-factorization-systems.lifts-families-of-elements
+```
+
+</details>
+
+## Definitions
+
+### Precomposition of lifts of families of elements by functions
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) {J : UU l4}
+  (f : I → J)
+  where
+
+  precomp-lift-family-of-elements :
+    (a : J → A) →
+    lift-family-of-elements B a → lift-family-of-elements B (a ∘ f)
+  precomp-lift-family-of-elements a b i = b (f i)
+```
+
+### Precomposition in total spaces of lifts of families of elements
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) {J : UU l4}
+  (f : I → J)
+  where
+
+  precomp-total-lift-family-of-elements :
+    total-lift-family-of-elements J B → total-lift-family-of-elements I B
+  precomp-total-lift-family-of-elements =
+    map-Σ
+      ( lift-family-of-elements B)
+      ( precomp f A)
+      ( precomp-lift-family-of-elements B f)
+```
+
+## Properties
+
+### Homotopies between maps induce commuting triangles of precompositions of lifts of families of elements
+
+We have a commuting triangle
+
+```text
+                              precomp-lift B f a
+  lift-family-of-elements B a ------------------> lift-family-of-elements B (a ∘ f)
+                      \                                /
+                         \                          /
+                            \                    /
+           precomp-lift B g a  \              / tr (lift-family-of-elements B) (htpy-precomp H A a)
+                                  \        /
+                                     V  V
+                       lift-family-of-elements B (a ∘ g)
+```
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) (a : I → A)
+  {J : UU l4} {f : J → I}
+  where
+
+  statement-triangle-precompose-lift-family-of-elements-htpy :
+    {g : J → I} (H : f ~ g) → UU (l1 ⊔ l3 ⊔ l4)
+  statement-triangle-precompose-lift-family-of-elements-htpy {g} H =
+    coherence-triangle-maps'
+      ( precomp-lift-family-of-elements B g a)
+      ( tr (lift-family-of-elements B) (htpy-precomp H A a))
+      ( precomp-lift-family-of-elements B f a)
+
+  triangle-precompose-lift-family-of-elements-htpy-refl-htpy :
+    statement-triangle-precompose-lift-family-of-elements-htpy refl-htpy
+  triangle-precompose-lift-family-of-elements-htpy-refl-htpy b =
+    tr-lift-family-of-elements B a refl-htpy (b ∘ f)
+
+  triangle-precompose-lift-family-of-elements-htpy :
+    {g : J → I} (H : f ~ g) →
+    statement-triangle-precompose-lift-family-of-elements-htpy H
+  triangle-precompose-lift-family-of-elements-htpy =
+    ind-htpy f
+      ( λ g → statement-triangle-precompose-lift-family-of-elements-htpy)
+      ( triangle-precompose-lift-family-of-elements-htpy-refl-htpy)
+
+  abstract
+    compute-triangle-precompose-lift-family-of-elements-htpy :
+      triangle-precompose-lift-family-of-elements-htpy refl-htpy ＝
+      triangle-precompose-lift-family-of-elements-htpy-refl-htpy
+    compute-triangle-precompose-lift-family-of-elements-htpy =
+      compute-ind-htpy f
+        ( λ g → statement-triangle-precompose-lift-family-of-elements-htpy)
+        ( triangle-precompose-lift-family-of-elements-htpy-refl-htpy)
+
+  statement-coherence-triangle-precompose-lift-family-of-elements-htpy :
+    {g : J → I} (H : f ~ g) → UU (l1 ⊔ l3 ⊔ l4)
+  statement-coherence-triangle-precompose-lift-family-of-elements-htpy H =
+    ( triangle-precompose-lift-family-of-elements-htpy H) ~
+    ( ( ( tr-lift-family-of-elements B a H) ·r
+        ( precomp-lift-family-of-elements B f a)) ∙h
+      ( λ b → eq-htpy (λ j → apd b (H j))))
+
+  coherence-triangle-precompose-lift-family-of-elements-htpy-refl-htpy :
+    statement-coherence-triangle-precompose-lift-family-of-elements-htpy
+      ( refl-htpy)
+  coherence-triangle-precompose-lift-family-of-elements-htpy-refl-htpy b =
+    ( htpy-eq (compute-triangle-precompose-lift-family-of-elements-htpy) b) ∙
+    ( inv right-unit) ∙
+    ( identification-left-whisk
+      ( triangle-precompose-lift-family-of-elements-htpy-refl-htpy b)
+      ( inv (eq-htpy-refl-htpy (b ∘ f))))
+
+  coherence-triangle-precompose-lift-family-of-elements-htpy :
+    {g : J → I} (H : f ~ g) →
+    statement-coherence-triangle-precompose-lift-family-of-elements-htpy H
+  coherence-triangle-precompose-lift-family-of-elements-htpy =
+    ind-htpy f
+      ( λ g →
+        statement-coherence-triangle-precompose-lift-family-of-elements-htpy)
+      ( coherence-triangle-precompose-lift-family-of-elements-htpy-refl-htpy)
+
+  abstract
+    compute-coherence-triangle-precompose-lift-family-of-elements-htpy :
+      coherence-triangle-precompose-lift-family-of-elements-htpy refl-htpy ＝
+      coherence-triangle-precompose-lift-family-of-elements-htpy-refl-htpy
+    compute-coherence-triangle-precompose-lift-family-of-elements-htpy =
+      compute-ind-htpy f
+        ( λ g →
+          statement-coherence-triangle-precompose-lift-family-of-elements-htpy)
+        ( coherence-triangle-precompose-lift-family-of-elements-htpy-refl-htpy)
+```
+
+### TODO
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) {J : UU l4}
+  (f : J → I)
+  where
+
+  coherence-square-precomp-map-inv-distributive-Π-Σ :
+    coherence-square-maps
+      ( precomp-total-lift-family-of-elements B f)
+      ( map-inv-distributive-Π-Σ)
+      ( map-inv-distributive-Π-Σ)
+      ( precomp f (Σ A B))
+  coherence-square-precomp-map-inv-distributive-Π-Σ = refl-htpy
+```
+
+### TODO
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) {J : UU l4}
+  {f : J → I}
+  where
+
+  htpy-precomp-total-lift-family-of-elements-htpy :
+    {g : J → I} (H : f ~ g) →
+    ( precomp-total-lift-family-of-elements B f) ~
+    ( precomp-total-lift-family-of-elements B g)
+  htpy-precomp-total-lift-family-of-elements-htpy H =
+    htpy-map-Σ
+      ( lift-family-of-elements B)
+      ( htpy-precomp H A)
+      ( precomp-lift-family-of-elements B f)
+      ( λ a → triangle-precompose-lift-family-of-elements-htpy B a H)
+
+  abstract
+    compute-htpy-precomp-total-lift-family-of-elements-htpy :
+      htpy-precomp-total-lift-family-of-elements-htpy refl-htpy ~
+      refl-htpy
+    compute-htpy-precomp-total-lift-family-of-elements-htpy =
+      htpy-htpy-map-Σ-refl-htpy
+        ( lift-family-of-elements B)
+        ( compute-htpy-precomp-refl-htpy f A)
+        ( λ a →
+          ( htpy-eq
+            ( compute-triangle-precompose-lift-family-of-elements-htpy B a)) ∙h
+          ( λ b → (htpy-eq (compute-tr-lift-family-of-elements B a) (b ∘ f))))
+```
+
+### TODO
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) {J : UU l4}
+  {f : J → I}
+  where
+
+  statement-coherence-blabla :
+    {g : J → I} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
+  statement-coherence-blabla {g} H =
+    coherence-square-homotopies
+      ( htpy-precomp H (Σ A B) ·r map-inv-distributive-Π-Σ)
+      ( coherence-square-precomp-map-inv-distributive-Π-Σ B f)
+      ( coherence-square-precomp-map-inv-distributive-Π-Σ B g)
+      ( ( map-inv-distributive-Π-Σ) ·l
+        ( htpy-precomp-total-lift-family-of-elements-htpy B H))
+
+  coherence-blabla-refl-htpy : statement-coherence-blabla refl-htpy
+  coherence-blabla-refl-htpy =
+    ( ap-left-whisk-htpy
+      ( map-inv-distributive-Π-Σ)
+      ( compute-htpy-precomp-total-lift-family-of-elements-htpy B)) ∙h
+    ( inv-htpy
+      ( λ h →
+        compute-htpy-precomp-refl-htpy f
+          ( Σ A B)
+          ( map-inv-distributive-Π-Σ h))) ∙h
+    ( inv-htpy-right-unit-htpy)
+
+  coherence-blabla :
+    {g : J → I} (H : f ~ g) → statement-coherence-blabla H
+  coherence-blabla =
+    ind-htpy f
+      ( λ g → statement-coherence-blabla)
+      ( coherence-blabla-refl-htpy)
+```
diff --git a/src/synthetic-homotopy-theory/26-descent.lagda.md b/src/synthetic-homotopy-theory/26-descent.lagda.md
index dc40055258..b4d5efd0e4 100644
--- a/src/synthetic-homotopy-theory/26-descent.lagda.md
+++ b/src/synthetic-homotopy-theory/26-descent.lagda.md
@@ -80,39 +80,39 @@ of those parts:
 ### Proof of Theorem 18.1.4, (3) implies (2)
 
 ```agda
-pullback-property-dependent-pullback-property-pushout :
-  {l1 l2 l3 l4 : Level} (l : Level) {S : UU l1} {A : UU l2} {B : UU l3}
-  (f : S → A) (g : S → B) {X : UU l4} (c : cocone f g X) →
-  dependent-pullback-property-pushout l f g c →
-  pullback-property-pushout l f g c
-pullback-property-dependent-pullback-property-pushout
-  l f g (pair i (pair j H)) dpb Y =
-  is-pullback-htpy
-    -- ( λ h s → tr (λ x → Y) (H s) (h (f s)))
-    ( λ h → eq-htpy (λ s → inv (tr-constant-type-family (H s) (h (f s)))))
-    -- ( _∘ g)
-    ( refl-htpy)
-    { c = pair
-      ( _∘ i)
-      ( pair (_∘ j) (λ h → eq-htpy (h ·l H)))}
-    ( cone-dependent-pullback-property-pushout
-      f g (pair i (pair j H)) (λ x → Y))
-    ( pair
-      ( λ h → refl)
-      ( pair
-        ( λ h → refl)
-        ( λ h → right-unit ∙
-          ( ( ap eq-htpy
-              ( eq-htpy (λ s →
-                left-transpose-eq-concat
-                  ( tr-constant-type-family (H s) (h (i (f s))))
-                  ( ap h (H s))
-                  ( apd h (H s))
-                  ( inv (apd-constant-type-family h (H s)))))) ∙
-            ( eq-htpy-concat-htpy
-              ( λ s → inv (tr-constant-type-family (H s) (h (i (f s)))))
-              ( λ s → apd h (H s)))))))
-    ( dpb (λ x → Y))
+-- pullback-property-dependent-pullback-property-pushout :
+--   {l1 l2 l3 l4 : Level} (l : Level) {S : UU l1} {A : UU l2} {B : UU l3}
+--   (f : S → A) (g : S → B) {X : UU l4} (c : cocone f g X) →
+--   dependent-pullback-property-pushout l f g c →
+--   pullback-property-pushout l f g c
+-- pullback-property-dependent-pullback-property-pushout
+--   l f g (pair i (pair j H)) dpb Y =
+--   is-pullback-htpy
+--     -- ( λ h s → tr (λ x → Y) (H s) (h (f s)))
+--     ( λ h → eq-htpy (λ s → inv (tr-constant-type-family (H s) (h (f s)))))
+--     -- ( _∘ g)
+--     ( refl-htpy)
+--     { c = pair
+--       ( _∘ i)
+--       ( pair (_∘ j) (λ h → eq-htpy (h ·l H)))}
+--     ( cone-dependent-pullback-property-pushout
+--       f g (pair i (pair j H)) (λ x → Y))
+--     ( pair
+--       ( λ h → refl)
+--       ( pair
+--         ( λ h → refl)
+--         ( λ h → right-unit ∙
+--           ( ( ap eq-htpy
+--               ( eq-htpy (λ s →
+--                 left-transpose-eq-concat
+--                   ( tr-constant-type-family (H s) (h (i (f s))))
+--                   ( ap h (H s))
+--                   ( apd h (H s))
+--                   ( inv (apd-constant-type-family h (H s)))))) ∙
+--             ( eq-htpy-concat-htpy
+--               ( λ s → inv (tr-constant-type-family (H s) (h (i (f s)))))
+--               ( λ s → apd h (H s)))))))
+--     ( dpb (λ x → Y))
 ```
 
 ### Proof of Theorem 18.1.4, (2) implies (3)
@@ -120,58 +120,58 @@ pullback-property-dependent-pullback-property-pushout
 We first define the family of lifts, which is indexed by maps $Y → X$.
 
 ```agda
-fam-lifts :
-  {l1 l2 l3 : Level} (Y : UU l1) {X : UU l2} (P : X → UU l3) →
-  (Y → X) → UU (l1 ⊔ l3)
-fam-lifts Y P h = (y : Y) → P (h y)
-
-tr-fam-lifts' :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
-  (h : B → X) {f g : A → B} (H : f ~ g) →
-  fam-lifts A P (h ∘ f) → fam-lifts A P (h ∘ g)
-tr-fam-lifts' P h {f} {g} H k s = tr (P ∘ h) (H s) (k s)
-
-TR-EQ-HTPY-FAM-LIFTS :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
-  (h : B → X) {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l4)
-TR-EQ-HTPY-FAM-LIFTS {A = A} P h H =
-  tr (fam-lifts A P) (eq-htpy (h ·l H)) ~ (tr-fam-lifts' P h H)
-
-tr-eq-htpy-fam-lifts-refl-htpy :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
-  (h : B → X) (f : A → B) → TR-EQ-HTPY-FAM-LIFTS P h (refl-htpy' f)
-tr-eq-htpy-fam-lifts-refl-htpy P h f k =
-  ap (λ t → tr (fam-lifts _ P) t k) (eq-htpy-refl-htpy (h ∘ f))
-
-abstract
-  tr-eq-htpy-fam-lifts :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
-    (h : B → X) {f g : A → B} (H : f ~ g) →
-    TR-EQ-HTPY-FAM-LIFTS P h H
-  tr-eq-htpy-fam-lifts P h {f} =
-    ind-htpy f
-      ( λ g H → TR-EQ-HTPY-FAM-LIFTS P h H)
-      ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
-
-  compute-tr-eq-htpy-fam-lifts :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
-    (h : B → X) (f : A → B) →
-    Id ( tr-eq-htpy-fam-lifts P h (refl-htpy' f))
-        ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
-  compute-tr-eq-htpy-fam-lifts P h f =
-    compute-ind-htpy f
-      ( λ g H → TR-EQ-HTPY-FAM-LIFTS P h H)
-      ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
+-- fam-lifts :
+--   {l1 l2 l3 : Level} (Y : UU l1) {X : UU l2} (P : X → UU l3) →
+--   (Y → X) → UU (l1 ⊔ l3)
+-- fam-lifts Y P h = (y : Y) → P (h y)
+
+-- tr-fam-lifts' :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
+--   (h : B → X) {f g : A → B} (H : f ~ g) →
+--   fam-lifts A P (h ∘ f) → fam-lifts A P (h ∘ g)
+-- tr-fam-lifts' P h {f} {g} H k s = tr (P ∘ h) (H s) (k s)
+
+-- TR-EQ-HTPY-FAM-LIFTS :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
+--   (h : B → X) {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l4)
+-- TR-EQ-HTPY-FAM-LIFTS {A = A} P h H =
+--   tr (fam-lifts A P) (eq-htpy (h ·l H)) ~ (tr-fam-lifts' P h H)
+
+-- tr-eq-htpy-fam-lifts-refl-htpy :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
+--   (h : B → X) (f : A → B) → TR-EQ-HTPY-FAM-LIFTS P h (refl-htpy' f)
+-- tr-eq-htpy-fam-lifts-refl-htpy P h f k =
+--   ap (λ t → tr (fam-lifts _ P) t k) (eq-htpy-refl-htpy (h ∘ f))
+
+-- abstract
+--   tr-eq-htpy-fam-lifts :
+--     {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
+--     (h : B → X) {f g : A → B} (H : f ~ g) →
+--     TR-EQ-HTPY-FAM-LIFTS P h H
+--   tr-eq-htpy-fam-lifts P h {f} =
+--     ind-htpy f
+--       ( λ g H → TR-EQ-HTPY-FAM-LIFTS P h H)
+--       ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
+
+--   compute-tr-eq-htpy-fam-lifts :
+--     {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
+--     (h : B → X) (f : A → B) →
+--     Id ( tr-eq-htpy-fam-lifts P h (refl-htpy' f))
+--         ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
+--   compute-tr-eq-htpy-fam-lifts P h f =
+--     compute-ind-htpy f
+--       ( λ g H → TR-EQ-HTPY-FAM-LIFTS P h H)
+--       ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
 ```
 
 One of the basic operations on lifts is precomposition by an ordinary function.
 
 ```agda
-precompose-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) → (f : A → B) → (h : B → X) →
-  (fam-lifts B P h) → (fam-lifts A P (h ∘ f))
-precompose-lifts P f h h' a = h' (f a)
+-- precompose-lifts :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
+--   (P : X → UU l4) → (f : A → B) → (h : B → X) →
+--   (fam-lifts B P h) → (fam-lifts A P (h ∘ f))
+-- precompose-lifts P f h h' a = h' (f a)
 ```
 
 Given two homotopic maps, their precomposition functions have different
@@ -179,39 +179,39 @@ codomains. However, there is a commuting triangle. We obtain this triangle by
 homotopy induction.
 
 ```agda
-TRIANGLE-PRECOMPOSE-LIFTS :
-  { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  ( P : X → UU l4) {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
-TRIANGLE-PRECOMPOSE-LIFTS {A = A} {B} {X} P {f} {g} H =
-  (h : B → X) →
-    ( (tr (fam-lifts A P) (eq-htpy (h ·l H))) ∘ (precompose-lifts P f h)) ~
-    ( precompose-lifts P g h)
-
-triangle-precompose-lifts-refl-htpy :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) (f : A → B) → TRIANGLE-PRECOMPOSE-LIFTS P (refl-htpy' f)
-triangle-precompose-lifts-refl-htpy {A = A} P f h h' =
-  tr-eq-htpy-fam-lifts-refl-htpy P h f (λ a → h' (f a))
-
-triangle-precompose-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) {f g : A → B} (H : f ~ g) →
-  TRIANGLE-PRECOMPOSE-LIFTS P H
-triangle-precompose-lifts {A = A} P {f} =
-  ind-htpy f
-    ( λ g H → TRIANGLE-PRECOMPOSE-LIFTS P H)
-    ( triangle-precompose-lifts-refl-htpy P f)
-
-compute-triangle-precompose-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) (f : A → B) →
-  Id
-    ( triangle-precompose-lifts P (refl-htpy' f))
-    ( triangle-precompose-lifts-refl-htpy P f)
-compute-triangle-precompose-lifts P f =
-  compute-ind-htpy f
-    ( λ g → TRIANGLE-PRECOMPOSE-LIFTS P)
-    ( triangle-precompose-lifts-refl-htpy P f)
+-- TRIANGLE-PRECOMPOSE-LIFTS :
+--   { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
+--   ( P : X → UU l4) {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
+-- TRIANGLE-PRECOMPOSE-LIFTS {A = A} {B} {X} P {f} {g} H =
+--   (h : B → X) →
+--     ( (tr (fam-lifts A P) (eq-htpy (h ·l H))) ∘ (precompose-lifts P f h)) ~
+--     ( precompose-lifts P g h)
+
+-- triangle-precompose-lifts-refl-htpy :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
+--   (P : X → UU l4) (f : A → B) → TRIANGLE-PRECOMPOSE-LIFTS P (refl-htpy' f)
+-- triangle-precompose-lifts-refl-htpy {A = A} P f h h' =
+--   tr-eq-htpy-fam-lifts-refl-htpy P h f (λ a → h' (f a))
+
+-- triangle-precompose-lifts :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
+--   (P : X → UU l4) {f g : A → B} (H : f ~ g) →
+--   TRIANGLE-PRECOMPOSE-LIFTS P H
+-- triangle-precompose-lifts {A = A} P {f} =
+--   ind-htpy f
+--     ( λ g H → TRIANGLE-PRECOMPOSE-LIFTS P H)
+--     ( triangle-precompose-lifts-refl-htpy P f)
+
+-- compute-triangle-precompose-lifts :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
+--   (P : X → UU l4) (f : A → B) →
+--   Id
+--     ( triangle-precompose-lifts P (refl-htpy' f))
+--     ( triangle-precompose-lifts-refl-htpy P f)
+-- compute-triangle-precompose-lifts P f =
+--   compute-ind-htpy f
+--     ( λ g → TRIANGLE-PRECOMPOSE-LIFTS P)
+--     ( triangle-precompose-lifts-refl-htpy P f)
 ```
 
 There is a similar commuting triangle with the computed transport function. This
@@ -219,93 +219,93 @@ time we don't use homotopy induction to construct the homotopy. We give an
 explicit definition instead.
 
 ```agda
-triangle-precompose-lifts' :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) {f g : A → B} (H : f ~ g) → (h : B → X) →
-  ( (tr-fam-lifts' P h H) ∘ (precompose-lifts P f h)) ~
-  ( precompose-lifts P g h)
-triangle-precompose-lifts' P H h k = eq-htpy (λ a → apd k (H a))
-
-compute-triangle-precompose-lifts' :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) (f : A → B) → (h : B → X) →
-  ( triangle-precompose-lifts' P (refl-htpy' f) h) ~
-  ( refl-htpy' ( precompose-lifts P f h))
-compute-triangle-precompose-lifts' P f h k = eq-htpy-refl-htpy _
+-- triangle-precompose-lifts' :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
+--   (P : X → UU l4) {f g : A → B} (H : f ~ g) → (h : B → X) →
+--   ( (tr-fam-lifts' P h H) ∘ (precompose-lifts P f h)) ~
+--   ( precompose-lifts P g h)
+-- triangle-precompose-lifts' P H h k = eq-htpy (λ a → apd k (H a))
+
+-- compute-triangle-precompose-lifts' :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
+--   (P : X → UU l4) (f : A → B) → (h : B → X) →
+--   ( triangle-precompose-lifts' P (refl-htpy' f) h) ~
+--   ( refl-htpy' ( precompose-lifts P f h))
+-- compute-triangle-precompose-lifts' P f h k = eq-htpy-refl-htpy _
 ```
 
 There is a coherence between the two commuting triangles. This coherence is
 again constructed by homotopy induction.
 
 ```agda
-COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-  {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
-COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS {A = A} {B} {X} P {f} {g} H =
-  (h : B → X) →
-    ( triangle-precompose-lifts P H h) ~
-    ( ( ( tr-eq-htpy-fam-lifts P h H) ·r (precompose-lifts P f h)) ∙h
-      ( triangle-precompose-lifts' P H h))
-
-coherence-triangle-precompose-lifts-refl-htpy :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-  (f : A → B) → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P (refl-htpy' f)
-coherence-triangle-precompose-lifts-refl-htpy P f h =
-  ( htpy-eq (htpy-eq (compute-triangle-precompose-lifts P f) h)) ∙h
-  ( ( ( inv-htpy-right-unit-htpy) ∙h
-      ( ap-concat-htpy
-        ( λ h' → tr-eq-htpy-fam-lifts-refl-htpy P h f (λ a → h' (f a)))
-        ( inv-htpy (compute-triangle-precompose-lifts' P f h)))) ∙h
-    ( htpy-eq
-      ( ap
-        ( λ t →
-          ( t ·r (precompose-lifts P f h)) ∙h
-          ( triangle-precompose-lifts' P refl-htpy h))
-        ( inv (compute-tr-eq-htpy-fam-lifts P h f)))))
-
-abstract
-  coherence-triangle-precompose-lifts :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-    {f g : A → B} (H : f ~ g) → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H
-  coherence-triangle-precompose-lifts P {f} =
-    ind-htpy f
-      ( λ g H → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H)
-      ( coherence-triangle-precompose-lifts-refl-htpy P f)
-
-  compute-coherence-triangle-precompose-lifts :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-    (f : A → B) →
-      Id ( coherence-triangle-precompose-lifts P (refl-htpy' f))
-          ( coherence-triangle-precompose-lifts-refl-htpy P f)
-  compute-coherence-triangle-precompose-lifts P f =
-    compute-ind-htpy f
-      ( λ g H → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H)
-      ( coherence-triangle-precompose-lifts-refl-htpy P f)
-
-total-lifts :
-  {l1 l2 l3 : Level} (A : UU l1) {X : UU l2} (P : X → UU l3) →
-  UU (l1 ⊔ l2 ⊔ l3)
-total-lifts A {X} P = universally-structured-Π {A = A} {B = λ a → X} (λ a → P)
-
-precompose-total-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) → (A → B) →
-  total-lifts B P → total-lifts A P
-precompose-total-lifts {A = A} P f =
-  map-Σ
-    ( λ h → (a : A) → P (h a))
-    ( λ h → h ∘ f)
-    ( precompose-lifts P f)
-
-coherence-square-map-inv-distributive-Π-Σ :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) (f : A → B) →
-  coherence-square-maps
-    ( precompose-total-lifts P f)
-    ( map-inv-distributive-Π-Σ {A = B} {B = λ x → X} {C = λ x y → P y})
-    ( map-inv-distributive-Π-Σ)
-    ( λ h → h ∘ f)
-coherence-square-map-inv-distributive-Π-Σ P f = refl-htpy
+-- COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
+--   {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
+-- COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS {A = A} {B} {X} P {f} {g} H =
+--   (h : B → X) →
+--     ( triangle-precompose-lifts P H h) ~
+--     ( ( ( tr-eq-htpy-fam-lifts P h H) ·r (precompose-lifts P f h)) ∙h
+--       ( triangle-precompose-lifts' P H h))
+
+-- coherence-triangle-precompose-lifts-refl-htpy :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
+--   (f : A → B) → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P (refl-htpy' f)
+-- coherence-triangle-precompose-lifts-refl-htpy P f h =
+--   ( htpy-eq (htpy-eq (compute-triangle-precompose-lifts P f) h)) ∙h
+--   ( ( ( inv-htpy-right-unit-htpy) ∙h
+--       ( ap-concat-htpy
+--         ( λ h' → tr-eq-htpy-fam-lifts-refl-htpy P h f (λ a → h' (f a)))
+--         ( inv-htpy (compute-triangle-precompose-lifts' P f h)))) ∙h
+--     ( htpy-eq
+--       ( ap
+--         ( λ t →
+--           ( t ·r (precompose-lifts P f h)) ∙h
+--           ( triangle-precompose-lifts' P refl-htpy h))
+--         ( inv (compute-tr-eq-htpy-fam-lifts P h f)))))
+
+-- abstract
+--   coherence-triangle-precompose-lifts :
+--     {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
+--     {f g : A → B} (H : f ~ g) → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H
+--   coherence-triangle-precompose-lifts P {f} =
+--     ind-htpy f
+--       ( λ g H → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H)
+--       ( coherence-triangle-precompose-lifts-refl-htpy P f)
+
+--   compute-coherence-triangle-precompose-lifts :
+--     {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
+--     (f : A → B) →
+--       Id ( coherence-triangle-precompose-lifts P (refl-htpy' f))
+--           ( coherence-triangle-precompose-lifts-refl-htpy P f)
+--   compute-coherence-triangle-precompose-lifts P f =
+--     compute-ind-htpy f
+--       ( λ g H → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H)
+--       ( coherence-triangle-precompose-lifts-refl-htpy P f)
+
+-- total-lifts :
+--   {l1 l2 l3 : Level} (A : UU l1) {X : UU l2} (P : X → UU l3) →
+--   UU (l1 ⊔ l2 ⊔ l3)
+-- total-lifts A {X} P = universally-structured-Π {A = A} {B = λ a → X} (λ a → P)
+
+-- precompose-total-lifts :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
+--   (P : X → UU l4) → (A → B) →
+--   total-lifts B P → total-lifts A P
+-- precompose-total-lifts {A = A} P f =
+--   map-Σ
+--     ( λ h → (a : A) → P (h a))
+--     ( λ h → h ∘ f)
+--     ( precompose-lifts P f)
+
+-- coherence-square-map-inv-distributive-Π-Σ :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
+--   (P : X → UU l4) (f : A → B) →
+--   coherence-square-maps
+--     ( precompose-total-lifts P f)
+--     ( map-inv-distributive-Π-Σ {A = B} {B = λ x → X} {C = λ x y → P y})
+--     ( map-inv-distributive-Π-Σ)
+--     ( λ h → h ∘ f)
+-- coherence-square-map-inv-distributive-Π-Σ P f = refl-htpy
 ```
 
 Our goal is now to produce a homotopy between `precompose-total-lifts P f` and
@@ -313,172 +313,172 @@ Our goal is now to produce a homotopy between `precompose-total-lifts P f` and
 filling a cylinder.
 
 ```agda
-HTPY-PRECOMPOSE-TOTAL-LIFTS :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
-  (P : X → UU l4) {f g : A → B} (H : f ~ g) →
-  UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
-HTPY-PRECOMPOSE-TOTAL-LIFTS P {f} {g} H =
-  (precompose-total-lifts P f) ~ (precompose-total-lifts P g)
-
-htpy-precompose-total-lifts :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-  {f g : A → B} (H : f ~ g) → HTPY-PRECOMPOSE-TOTAL-LIFTS P H
-htpy-precompose-total-lifts {A = A} {B} P {f} {g} H =
-  htpy-map-Σ
-    ( fam-lifts A P)
-    ( λ h → eq-htpy (h ·l H))
-    ( precompose-lifts P f)
-    ( triangle-precompose-lifts P H)
+-- HTPY-PRECOMPOSE-TOTAL-LIFTS :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
+--   (P : X → UU l4) {f g : A → B} (H : f ~ g) →
+--   UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
+-- HTPY-PRECOMPOSE-TOTAL-LIFTS P {f} {g} H =
+--   (precompose-total-lifts P f) ~ (precompose-total-lifts P g)
+
+-- htpy-precompose-total-lifts :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
+--   {f g : A → B} (H : f ~ g) → HTPY-PRECOMPOSE-TOTAL-LIFTS P H
+-- htpy-precompose-total-lifts {A = A} {B} P {f} {g} H =
+--   htpy-map-Σ
+--     ( fam-lifts A P)
+--     ( λ h → eq-htpy (h ·l H))
+--     ( precompose-lifts P f)
+--     ( triangle-precompose-lifts P H)
 ```
 
 We show that when `htpy-precompose-total-lifts` is applied to `refl-htpy`, it
 computes to `refl-htpy`.
 
 ```agda
-tr-id-left-subst :
-  {l1 l2 : Level} {A : UU l1} {B : UU l2} {f : A → B} {x y : A}
-  (p : Id x y) (b : B) → (q : Id (f x) b) →
-  Id (tr (λ (a : A) → Id (f a) b) p q) ((inv (ap f p)) ∙ q)
-tr-id-left-subst refl b q = refl
-
-compute-htpy-precompose-total-lifts :
-  { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-  ( f : A → B) →
-  ( htpy-precompose-total-lifts P (refl-htpy {f = f})) ~
-  ( refl-htpy' (map-Σ (fam-lifts A P) (λ h → h ∘ f) (precompose-lifts P f)))
-compute-htpy-precompose-total-lifts {A = A} P f (pair h h') =
-  let α = λ (t : Id (h ∘ f) (h ∘ f)) → tr (fam-lifts A P) t (λ a → h' (f a))
-  in
-  ap eq-pair-Σ'
-    ( eq-pair-Σ
-      ( eq-htpy-refl-htpy (h ∘ f))
-      ( ( tr-id-left-subst
-          { f = α}
-          ( eq-htpy-refl-htpy (h ∘ f))
-          ( λ a → h' (f a))
-          ( triangle-precompose-lifts P refl-htpy h h')) ∙
-        ( ( ap
-            ( λ t → inv (ap α (eq-htpy-refl-htpy (λ a → h (f a)))) ∙ t)
-            ( htpy-eq
-              ( htpy-eq (compute-triangle-precompose-lifts P f) h) h')) ∙
-          ( left-inv (triangle-precompose-lifts-refl-htpy P f h h')))))
-
-COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-  {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
-COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P {f} {g} H =
-  ( ( coherence-square-map-inv-distributive-Π-Σ P f) ∙h
-    ( map-inv-distributive-Π-Σ ·l ( htpy-precompose-total-lifts P H))) ~
-  ( ( ( λ h → eq-htpy (h ·l H)) ·r map-inv-distributive-Π-Σ) ∙h
-    ( coherence-square-map-inv-distributive-Π-Σ P g))
-
-coherence-inv-htpy-distributive-Π-Σ-refl-htpy :
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-  (f : A → B) → COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P (refl-htpy' f)
-coherence-inv-htpy-distributive-Π-Σ-refl-htpy {X = X} P f =
-  ( ap-concat-htpy
-    ( coherence-square-map-inv-distributive-Π-Σ P f)
-    ( λ h →
-      ap
-        ( ap map-inv-distributive-Π-Σ)
-        ( compute-htpy-precompose-total-lifts P f h))) ∙h
-  ( ap-concat-htpy'
-    ( refl-htpy)
-    ( inv-htpy
-      ( λ h →
-        compute-htpy-precomp-refl-htpy f (Σ X P) (map-inv-distributive-Π-Σ h))))
-
-abstract
-  coherence-inv-htpy-distributive-Π-Σ :
-    {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
-    {f g : A → B} (H : f ~ g) → COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P H
-  coherence-inv-htpy-distributive-Π-Σ P {f} =
-    ind-htpy f
-      ( λ g H → COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P H)
-      ( coherence-inv-htpy-distributive-Π-Σ-refl-htpy P f)
-
-cone-family-dependent-pullback-property :
-  {l1 l2 l3 l4 l : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S → A) (g : S → B) (c : cocone f g X) (P : X → UU l) →
-  cone-family
-    ( fam-lifts S P)
-    ( precompose-lifts P f)
-    ( precompose-lifts P g)
-    ( cone-pullback-property-pushout f g c X)
-    ( fam-lifts X P)
-cone-family-dependent-pullback-property f g c P γ =
-  pair
-    ( precompose-lifts P (pr1 c) γ)
-    ( pair
-      ( precompose-lifts P (pr1 (pr2 c)) γ)
-      ( triangle-precompose-lifts P (pr2 (pr2 c)) γ))
-
-is-pullback-cone-family-dependent-pullback-property :
-  {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S → A) (g : S → B) (c : cocone f g X) →
-  ({l : Level} → pullback-property-pushout l f g c) →
-  {l : Level} (P : X → UU l) (γ : X → X) →
-  is-pullback
-    ( ( tr (fam-lifts S P) (eq-htpy (γ ·l (pr2 (pr2 c))))) ∘
-      ( precompose-lifts P f (γ ∘ (pr1 c))))
-    ( precompose-lifts P g (γ ∘ (pr1 (pr2 c))))
-    ( cone-family-dependent-pullback-property f g c P γ)
-is-pullback-cone-family-dependent-pullback-property {S = S} {A} {B} {X}
-  f g (pair i (pair j H)) pb-c P =
-  let c = pair i (pair j H) in
-  is-pullback-family-is-pullback-tot
-    ( fam-lifts S P)
-    ( precompose-lifts P f)
-    ( precompose-lifts P g)
-    ( cone-pullback-property-pushout f g c X)
-    ( cone-family-dependent-pullback-property f g c P)
-    ( pb-c X)
-    ( is-pullback-top-is-pullback-bottom-cube-is-equiv
-      ( precomp i (Σ X P))
-      ( precomp j (Σ X P))
-      ( precomp f (Σ X P))
-      ( precomp g (Σ X P))
-      ( map-Σ (fam-lifts A P) (precomp i X) (precompose-lifts P i))
-      ( map-Σ (fam-lifts B P) (precomp j X) (precompose-lifts P j))
-      ( map-Σ (fam-lifts S P) (precomp f X) (precompose-lifts P f))
-      ( map-Σ (fam-lifts S P) (precomp g X) (precompose-lifts P g))
-      ( map-inv-distributive-Π-Σ)
-      ( map-inv-distributive-Π-Σ)
-      ( map-inv-distributive-Π-Σ)
-      ( map-inv-distributive-Π-Σ)
-      ( htpy-precompose-total-lifts P H)
-      ( refl-htpy)
-      ( refl-htpy)
-      ( refl-htpy)
-      ( refl-htpy)
-      ( htpy-precomp H (Σ X P))
-      ( coherence-inv-htpy-distributive-Π-Σ P H)
-      ( is-equiv-map-inv-distributive-Π-Σ)
-      ( is-equiv-map-inv-distributive-Π-Σ)
-      ( is-equiv-map-inv-distributive-Π-Σ)
-      ( is-equiv-map-inv-distributive-Π-Σ)
-      ( pb-c (Σ X P)))
-
-dependent-pullback-property-pullback-property-pushout :
-  {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S → A) (g : S → B) (c : cocone f g X) →
-  ({l : Level} → pullback-property-pushout l f g c) →
-  ({l : Level} → dependent-pullback-property-pushout l f g c)
-dependent-pullback-property-pullback-property-pushout
-  {S = S} {A} {B} {X}
-  f g (pair i (pair j H)) pullback-c P =
-  let c = pair i (pair j H) in
-  is-pullback-htpy'
-    -- ( (tr (fam-lifts S P) (eq-htpy (id ·l H))) ∘ (precompose-lifts P f i))
-    ( (tr-eq-htpy-fam-lifts P id H) ·r (precompose-lifts P f i))
-    -- ( precompose-lifts P g j)
-    ( refl-htpy)
-    ( cone-family-dependent-pullback-property f g c P id)
-    { c' = cone-dependent-pullback-property-pushout f g c P}
-    ( pair refl-htpy
-      ( pair refl-htpy
-        ( right-unit-htpy ∙h (coherence-triangle-precompose-lifts P H id))))
-    ( is-pullback-cone-family-dependent-pullback-property f g c pullback-c P id)
+-- tr-id-left-subst :
+--   {l1 l2 : Level} {A : UU l1} {B : UU l2} {f : A → B} {x y : A}
+--   (p : Id x y) (b : B) → (q : Id (f x) b) →
+--   Id (tr (λ (a : A) → Id (f a) b) p q) ((inv (ap f p)) ∙ q)
+-- tr-id-left-subst refl b q = refl
+
+-- compute-htpy-precompose-total-lifts :
+--   { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
+--   ( f : A → B) →
+--   ( htpy-precompose-total-lifts P (refl-htpy {f = f})) ~
+--   ( refl-htpy' (map-Σ (fam-lifts A P) (λ h → h ∘ f) (precompose-lifts P f)))
+-- compute-htpy-precompose-total-lifts {A = A} P f (pair h h') =
+--   let α = λ (t : Id (h ∘ f) (h ∘ f)) → tr (fam-lifts A P) t (λ a → h' (f a))
+--   in
+--   ap eq-pair-Σ'
+--     ( eq-pair-Σ
+--       ( eq-htpy-refl-htpy (h ∘ f))
+--       ( ( tr-id-left-subst
+--           { f = α}
+--           ( eq-htpy-refl-htpy (h ∘ f))
+--           ( λ a → h' (f a))
+--           ( triangle-precompose-lifts P refl-htpy h h')) ∙
+--         ( ( ap
+--             ( λ t → inv (ap α (eq-htpy-refl-htpy (λ a → h (f a)))) ∙ t)
+--             ( htpy-eq
+--               ( htpy-eq (compute-triangle-precompose-lifts P f) h) h')) ∙
+--           ( left-inv (triangle-precompose-lifts-refl-htpy P f h h')))))
+
+-- COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
+--   {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
+-- COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P {f} {g} H =
+--   ( ( coherence-square-map-inv-distributive-Π-Σ P f) ∙h
+--     ( map-inv-distributive-Π-Σ ·l ( htpy-precompose-total-lifts P H))) ~
+--   ( ( ( λ h → eq-htpy (h ·l H)) ·r map-inv-distributive-Π-Σ) ∙h
+--     ( coherence-square-map-inv-distributive-Π-Σ P g))
+
+-- coherence-inv-htpy-distributive-Π-Σ-refl-htpy :
+--   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
+--   (f : A → B) → COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P (refl-htpy' f)
+-- coherence-inv-htpy-distributive-Π-Σ-refl-htpy {X = X} P f =
+--   ( ap-concat-htpy
+--     ( coherence-square-map-inv-distributive-Π-Σ P f)
+--     ( λ h →
+--       ap
+--         ( ap map-inv-distributive-Π-Σ)
+--         ( compute-htpy-precompose-total-lifts P f h))) ∙h
+--   ( ap-concat-htpy'
+--     ( refl-htpy)
+--     ( inv-htpy
+--       ( λ h →
+--         compute-htpy-precomp-refl-htpy f (Σ X P) (map-inv-distributive-Π-Σ h))))
+
+-- abstract
+--   coherence-inv-htpy-distributive-Π-Σ :
+--     {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
+--     {f g : A → B} (H : f ~ g) → COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P H
+--   coherence-inv-htpy-distributive-Π-Σ P {f} =
+--     ind-htpy f
+--       ( λ g H → COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P H)
+--       ( coherence-inv-htpy-distributive-Π-Σ-refl-htpy P f)
+
+-- cone-family-dependent-pullback-property :
+--   {l1 l2 l3 l4 l : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
+--   (f : S → A) (g : S → B) (c : cocone f g X) (P : X → UU l) →
+--   cone-family
+--     ( fam-lifts S P)
+--     ( precompose-lifts P f)
+--     ( precompose-lifts P g)
+--     ( cone-pullback-property-pushout f g c X)
+--     ( fam-lifts X P)
+-- cone-family-dependent-pullback-property f g c P γ =
+--   pair
+--     ( precompose-lifts P (pr1 c) γ)
+--     ( pair
+--       ( precompose-lifts P (pr1 (pr2 c)) γ)
+--       ( triangle-precompose-lifts P (pr2 (pr2 c)) γ))
+
+-- is-pullback-cone-family-dependent-pullback-property :
+--   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
+--   (f : S → A) (g : S → B) (c : cocone f g X) →
+--   ({l : Level} → pullback-property-pushout l f g c) →
+--   {l : Level} (P : X → UU l) (γ : X → X) →
+--   is-pullback
+--     ( ( tr (fam-lifts S P) (eq-htpy (γ ·l (pr2 (pr2 c))))) ∘
+--       ( precompose-lifts P f (γ ∘ (pr1 c))))
+--     ( precompose-lifts P g (γ ∘ (pr1 (pr2 c))))
+--     ( cone-family-dependent-pullback-property f g c P γ)
+-- is-pullback-cone-family-dependent-pullback-property {S = S} {A} {B} {X}
+--   f g (pair i (pair j H)) pb-c P =
+--   let c = pair i (pair j H) in
+--   is-pullback-family-is-pullback-tot
+--     ( fam-lifts S P)
+--     ( precompose-lifts P f)
+--     ( precompose-lifts P g)
+--     ( cone-pullback-property-pushout f g c X)
+--     ( cone-family-dependent-pullback-property f g c P)
+--     ( pb-c X)
+--     ( is-pullback-top-is-pullback-bottom-cube-is-equiv
+--       ( precomp i (Σ X P))
+--       ( precomp j (Σ X P))
+--       ( precomp f (Σ X P))
+--       ( precomp g (Σ X P))
+--       ( map-Σ (fam-lifts A P) (precomp i X) (precompose-lifts P i))
+--       ( map-Σ (fam-lifts B P) (precomp j X) (precompose-lifts P j))
+--       ( map-Σ (fam-lifts S P) (precomp f X) (precompose-lifts P f))
+--       ( map-Σ (fam-lifts S P) (precomp g X) (precompose-lifts P g))
+--       ( map-inv-distributive-Π-Σ)
+--       ( map-inv-distributive-Π-Σ)
+--       ( map-inv-distributive-Π-Σ)
+--       ( map-inv-distributive-Π-Σ)
+--       ( htpy-precompose-total-lifts P H)
+--       ( refl-htpy)
+--       ( refl-htpy)
+--       ( refl-htpy)
+--       ( refl-htpy)
+--       ( htpy-precomp H (Σ X P))
+--       ( coherence-inv-htpy-distributive-Π-Σ P H)
+--       ( is-equiv-map-inv-distributive-Π-Σ)
+--       ( is-equiv-map-inv-distributive-Π-Σ)
+--       ( is-equiv-map-inv-distributive-Π-Σ)
+--       ( is-equiv-map-inv-distributive-Π-Σ)
+--       ( pb-c (Σ X P)))
+
+-- dependent-pullback-property-pullback-property-pushout :
+--   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
+--   (f : S → A) (g : S → B) (c : cocone f g X) →
+--   ({l : Level} → pullback-property-pushout l f g c) →
+--   ({l : Level} → dependent-pullback-property-pushout l f g c)
+-- dependent-pullback-property-pullback-property-pushout
+--   {S = S} {A} {B} {X}
+--   f g (pair i (pair j H)) pullback-c P =
+--   let c = pair i (pair j H) in
+--   is-pullback-htpy'
+--     -- ( (tr (fam-lifts S P) (eq-htpy (id ·l H))) ∘ (precompose-lifts P f i))
+--     ( (tr-eq-htpy-fam-lifts P id H) ·r (precompose-lifts P f i))
+--     -- ( precompose-lifts P g j)
+--     ( refl-htpy)
+--     ( cone-family-dependent-pullback-property f g c P id)
+--     { c' = cone-dependent-pullback-property-pushout f g c P}
+--     ( pair refl-htpy
+--       ( pair refl-htpy
+--         ( right-unit-htpy ∙h (coherence-triangle-precompose-lifts P H id))))
+--     ( is-pullback-cone-family-dependent-pullback-property f g c pullback-c P id)
 ```
 
 This concludes the proof of Theorem 18.1.4.
@@ -486,15 +486,15 @@ This concludes the proof of Theorem 18.1.4.
 We give some further useful implications.
 
 ```agda
-dependent-universal-property-universal-property-pushout :
-  { l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  ( f : S → A) (g : S → B) (c : cocone f g X) →
-  ( {l : Level} → universal-property-pushout l f g c) →
-  ( {l : Level} → dependent-universal-property-pushout l f g c)
-dependent-universal-property-universal-property-pushout f g c up-X =
-  dependent-universal-property-dependent-pullback-property-pushout f g c
-    ( dependent-pullback-property-pullback-property-pushout f g c
-      ( pullback-property-pushout-universal-property-pushout f g c up-X))
+-- dependent-universal-property-universal-property-pushout :
+--   { l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
+--   ( f : S → A) (g : S → B) (c : cocone f g X) →
+--   ( {l : Level} → universal-property-pushout l f g c) →
+--   ( {l : Level} → dependent-universal-property-pushout l f g c)
+-- dependent-universal-property-universal-property-pushout f g c up-X =
+--   dependent-universal-property-dependent-pullback-property-pushout f g c
+--     ( dependent-pullback-property-pullback-property-pushout f g c
+--       ( pullback-property-pushout-universal-property-pushout f g c up-X))
 ```
 
 ## Section 16.2 Families over pushouts
@@ -757,163 +757,3 @@ compute-path-fam-Fam-pushout :
 compute-path-fam-Fam-pushout {f = f} {g} c up-X P =
   pr2 (pr2 (pr2 (center (uniqueness-Fam-pushout f g c up-X P))))
 ```
-
-## Section 18.3 The Flattening lemma for pushouts
-
-### Definition 18.3.1
-
-```agda
-{-
-cocone-flattening-pushout :
-  { l1 l2 l3 l4 l5 : Level}
-  { S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  ( f : S → A) (g : S → B) (c : cocone f g X)
-  ( P : Fam-pushout l5 f g)
-  ( Q : X → UU l5)
-  ( e : equiv-Fam-pushout P (desc-fam f g c Q)) →
-  cocone
-    ( map-Σ (pr1 P) f (λ s → id))
-    ( map-Σ (pr1 (pr2 P)) g (λ s → map-equiv (pr2 (pr2 P) s)))
-    ( Σ X Q)
-cocone-flattening-pushout f g c P Q e =
-  pair
-    ( map-Σ Q
-      ( pr1 c)
-      ( λ a → map-equiv (pr1 e a)))
-    ( pair
-      ( map-Σ Q
-        ( pr1 (pr2 c))
-        ( λ b → map-equiv (pr1 (pr2 e) b)))
-      ( htpy-map-Σ Q
-        ( pr2 (pr2 c))
-        ( λ s → map-equiv (pr1 e (f s)))
-        ( λ s → inv-htpy (pr2 (pr2 e) s))))
--}
-```
-
-### Theorem 18.3.2 The flattening lemma
-
-```agda
-{-
-coherence-bottom-flattening-lemma' :
-  {l1 l2 l3 : Level} {B : UU l1} {Q : B → UU l2} {T : UU l3}
-  {b b' : B} (α : Id b b') {y : Q b} {y' : Q b'} (β : Id (tr Q α y) y')
-  (h : (b : B) → Q b → T) → Id (h b y) (h b' y')
-coherence-bottom-flattening-lemma' refl refl h = refl
-
-coherence-bottom-flattening-lemma :
-  {l1 l2 l3 l4 l5 : Level}
-  {A : UU l1} {B : UU l2} {P : A → UU l3} {Q : B → UU l4} {T : UU l5}
-  {f f' : A → B} (H : f ~ f')
-  {g : (a : A) → P a → Q (f a)}
-  {g' : (a : A) → P a → Q (f' a)}
-  (K : (a : A) → ((tr Q (H a)) ∘ (g a)) ~ (g' a))
-  (h : (b : B) → Q b → T) → (a : A) (p : P a) →
-  Id (h (f a) (g a p)) (h (f' a) (g' a p))
-coherence-bottom-flattening-lemma H K h a p =
-  coherence-bottom-flattening-lemma' (H a) (K a p) h
-coherence-cube-flattening-lemma :
-  {l1 l2 l3 l4 l5 : Level}
-  {A : UU l1} {B : UU l2} {P : A → UU l3} {Q : B → UU l4} {T : UU l5}
-  {f f' : A → B} (H : f ~ f')
-  {g : (a : A) → P a → Q (f a)}
-  {g' : (a : A) → P a → Q (f' a)}
-  (K : (a : A) → ((tr Q (H a)) ∘ (g a)) ~ (g' a))
-  (h : Σ B Q → T) →
-  Id ( eq-htpy
-       ( λ a → eq-htpy
-         ( coherence-bottom-flattening-lemma H K (ev-pair h) a)))
-     ( ap ev-pair
-       ( htpy-precomp (htpy-map-Σ Q H g K) T h))
-coherence-cube-flattening-lemma
-  {A = A} {B} {P} {Q} {T} {f = f} {f'} H {g} {g'} K =
-  ind-htpy f
-    ( λ f' H' →
-      (g : (a : A) → P a → Q (f a)) (g' : (a : A) → P a → Q (f' a))
-      (K : (a : A) → ((tr Q (H' a)) ∘ (g a)) ~ (g' a)) (h : Σ B Q → T) →
-      Id ( eq-htpy
-           ( λ a → eq-htpy
-             ( coherence-bottom-flattening-lemma H' K (ev-pair h) a)))
-         ( ap ev-pair
-           ( htpy-precomp (htpy-map-Σ Q H' g K) T h)))
-    ( λ g g' K h → {!ind-htpy g (λ g' K' → (h : Σ B Q → T) →
-      Id ( eq-htpy
-           ( λ a → eq-htpy
-             ( coherence-bottom-flattening-lemma
-                refl-htpy (λ a → htpy-eq (K' a)) (ev-pair h) a)))
-         ( ap ev-pair
-           ( htpy-precomp
-              ( htpy-map-Σ Q refl-htpy g
-                (λ a → htpy-eq (K' a))) T h))) ? (λ a → eq-htpy (K a)) h!})
-    H g g' K
-
-flattening-pushout' :
-  {l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S → A) (g : S → B) (c : cocone f g X) →
-  ( P : Fam-pushout l5 f g)
-  ( Q : X → UU l5)
-  ( e : equiv-Fam-pushout P (desc-fam f g c Q)) →
-  (l : Level) →
-  pullback-property-pushout l
-    ( map-Σ (pr1 P) f (λ s → id))
-    ( map-Σ (pr1 (pr2 P)) g (λ s → map-equiv (pr2 (pr2 P) s)))
-    ( cocone-flattening-pushout f g c P Q e)
-flattening-pushout' f g c P Q e l T =
-  is-pullback-top-is-pullback-bottom-cube-is-equiv
-    ( ( map-Π (λ x → precomp-Π (map-equiv (pr1 e x)) (λ q → T))) ∘
-      ( precomp-Π (pr1 c) (λ x → (Q x) → T)))
-    ( ( map-Π (λ x → precomp-Π (map-equiv (pr1 (pr2 e) x)) (λ q → T))) ∘
-      ( precomp-Π (pr1 (pr2 c)) (λ x → (Q x) → T)))
-    ( precomp-Π f (λ a → (pr1 P a) → T))
-    ( ( map-Π (λ s → precomp (map-equiv (pr2 (pr2 P) s)) T)) ∘
-      ( precomp-Π g (λ b → (pr1 (pr2 P) b) → T)))
-    ( precomp (map-Σ Q (pr1 c) (λ a → map-equiv (pr1 e a))) T)
-    ( precomp (map-Σ Q (pr1 (pr2 c)) (λ b → map-equiv (pr1 (pr2 e) b))) T)
-    ( precomp (map-Σ (pr1 P) f (λ s → id)) T)
-    ( precomp (map-Σ (pr1 (pr2 P)) g (λ s → map-equiv (pr2 (pr2 P) s))) T)
-    ev-pair
-    ev-pair
-    ev-pair
-    ev-pair
-    ( htpy-precomp
-      ( htpy-map-Σ Q
-        ( pr2 (pr2 c))
-        ( λ s → map-equiv (pr1 e (f s)))
-        ( λ s → inv-htpy (pr2 (pr2 e) s)))
-      ( T))
-    refl-htpy
-    refl-htpy
-    refl-htpy
-    refl-htpy
-    ( λ h → eq-htpy (λ s → eq-htpy
-      ( coherence-bottom-flattening-lemma
-        ( pr2 (pr2 c))
-        ( λ s → inv-htpy (pr2 (pr2 e) s))
-        ( h)
-        ( s))))
-    {!!}
-    is-equiv-ev-pair
-    is-equiv-ev-pair
-    is-equiv-ev-pair
-    is-equiv-ev-pair
-    {!!}
-
-flattening-pushout :
-  {l1 l2 l3 l4 l5 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
-  (f : S → A) (g : S → B) (c : cocone f g X) →
-  ( P : Fam-pushout l5 f g)
-  ( Q : X → UU l5)
-  ( e : equiv-Fam-pushout P (desc-fam f g c Q)) →
-  (l : Level) →
-  universal-property-pushout l
-    ( map-Σ (pr1 P) f (λ s → id))
-    ( map-Σ (pr1 (pr2 P)) g (λ s → map-equiv (pr2 (pr2 P) s)))
-    ( cocone-flattening-pushout f g c P Q e)
-flattening-pushout f g c P Q e l =
-  universal-property-pushout-pullback-property-pushout l
-    ( map-Σ (pr1 P) f (λ s → id))
-    ( map-Σ (pr1 (pr2 P)) g (λ s → map-equiv (pr2 (pr2 P) s)))
-    ( cocone-flattening-pushout f g c P Q e)
-    ( flattening-pushout' f g c P Q e l)
--}
-```
diff --git a/src/synthetic-homotopy-theory/26-id-pushout.lagda.md b/src/synthetic-homotopy-theory/26-id-pushout.lagda.md
index 6871fd856e..9666c7a2e3 100644
--- a/src/synthetic-homotopy-theory/26-id-pushout.lagda.md
+++ b/src/synthetic-homotopy-theory/26-id-pushout.lagda.md
@@ -33,6 +33,7 @@ open import foundation.whiskering-homotopies
 open import synthetic-homotopy-theory.26-descent
 open import synthetic-homotopy-theory.cocones-under-spans
 open import synthetic-homotopy-theory.dependent-cocones-under-spans
+open import synthetic-homotopy-theory.dependent-universal-property-pushouts
 open import synthetic-homotopy-theory.universal-property-pushouts
 ```
 
diff --git a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
index 1f55709c41..a1f8652ccf 100644
--- a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
@@ -8,14 +8,27 @@ module synthetic-homotopy-theory.dependent-pullback-property-pushouts where
 
 ```agda
 open import foundation.action-on-identifications-dependent-functions
+open import foundation.action-on-identifications-functions
 open import foundation.cones-over-cospans
+open import foundation.constant-type-families
 open import foundation.dependent-pair-types
 open import foundation.function-extensionality
+open import foundation.function-types
+open import foundation.functoriality-dependent-pair-types
+open import foundation.homotopies
+open import foundation.identity-types
+open import foundation.precomposition-functions
 open import foundation.pullbacks
 open import foundation.transport-along-identifications
+open import foundation.type-theoretic-principle-of-choice
 open import foundation.universe-levels
+open import foundation.whiskering-homotopies
+
+open import orthogonal-factorization-systems.lifts-families-of-elements
+open import orthogonal-factorization-systems.precomposition-lifts-families-of-elements
 
 open import synthetic-homotopy-theory.cocones-under-spans
+open import synthetic-homotopy-theory.pullback-property-pushouts
 ```
 
 </details>
@@ -65,3 +78,124 @@ dependent-pullback-property-pushout l {S} {A} {B} f g {X} (i , j , H) =
     ( λ (h : (b : B) → P (j b)) → λ s → h (g s))
     ( cone-dependent-pullback-property-pushout f g (i , j , H) P)
 ```
+
+## Properties
+
+### The dependent pullback property is logically equivalent to the pullback property
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
+  (f : S → A) (g : S → B) {X : UU l4} (c : cocone f g X)
+  where
+
+  pullback-property-dependent-pullback-property-pushout :
+    ({l : Level} → dependent-pullback-property-pushout l f g c) →
+    ({l : Level} → pullback-property-pushout l f g c)
+  pullback-property-dependent-pullback-property-pushout dpp-c Y =
+    is-pullback-htpy
+      ( λ h →
+        eq-htpy
+          ( λ s →
+            inv
+              ( tr-constant-type-family
+                ( coherence-square-cocone f g c s)
+                ( h (f s)))))
+      ( refl-htpy)
+      ( cone-dependent-pullback-property-pushout f g c (λ _ → Y))
+      ( ( refl-htpy) ,
+        ( refl-htpy) ,
+        ( λ h →
+          ( right-unit) ∙
+          ( ap
+            ( eq-htpy)
+            ( eq-htpy
+              ( λ s →
+                left-transpose-eq-concat _ _ _
+                  ( inv
+                    ( apd-constant-type-family h
+                      ( coherence-square-cocone f g c s))))) ∙
+          ( eq-htpy-concat-htpy _ _))))
+      ( dpp-c (λ _ → Y))
+
+  cone-family-dependent-pullback-property :
+    {l : Level} (P : X → UU l) →
+    cone-family
+      ( lift-family-of-elements P)
+      ( precomp-lift-family-of-elements P f)
+      ( precomp-lift-family-of-elements P g)
+      ( cone-pullback-property-pushout f g c X)
+      ( lift-family-of-elements P)
+  pr1 (cone-family-dependent-pullback-property P γ) h =
+    h ∘ horizontal-map-cocone f g c
+  pr1 (pr2 (cone-family-dependent-pullback-property P γ)) h =
+    h ∘ vertical-map-cocone f g c
+  pr2 (pr2 (cone-family-dependent-pullback-property P γ)) =
+    triangle-precompose-lift-family-of-elements-htpy P γ
+      ( coherence-square-cocone f g c)
+
+  is-pullback-cone-family-dependent-pullback-family :
+    {l : Level} (P : X → UU l) →
+    ({l : Level} → pullback-property-pushout l f g c) →
+    (γ : X → X) →
+    is-pullback
+      ( ( tr
+          ( lift-family-of-elements P)
+          ( htpy-precomp (coherence-square-cocone f g c) X γ)) ∘
+        ( precomp-lift-family-of-elements P f
+          ( γ ∘ horizontal-map-cocone f g c)))
+      ( precomp-lift-family-of-elements P g
+        ( γ ∘ vertical-map-cocone f g c))
+      ( cone-family-dependent-pullback-property P γ)
+  is-pullback-cone-family-dependent-pullback-family P pp-c =
+    is-pullback-family-is-pullback-tot
+      ( lift-family-of-elements P)
+      ( precomp-lift-family-of-elements P f)
+      ( precomp-lift-family-of-elements P g)
+      ( cone-pullback-property-pushout f g c X)
+      ( cone-family-dependent-pullback-property P)
+      ( pp-c X)
+      ( is-pullback-top-is-pullback-bottom-cube-is-equiv
+        ( precomp (horizontal-map-cocone f g c) (Σ X P))
+        ( precomp (vertical-map-cocone f g c) (Σ X P))
+        ( precomp f (Σ X P))
+        ( precomp g (Σ X P))
+        ( precomp-total-lift-family-of-elements P (horizontal-map-cocone f g c))
+        ( precomp-total-lift-family-of-elements P (vertical-map-cocone f g c))
+        ( precomp-total-lift-family-of-elements P f)
+        ( precomp-total-lift-family-of-elements P g)
+        ( map-inv-distributive-Π-Σ)
+        ( map-inv-distributive-Π-Σ)
+        ( map-inv-distributive-Π-Σ)
+        ( map-inv-distributive-Π-Σ)
+        ( htpy-precomp-total-lift-family-of-elements-htpy P
+          ( coherence-square-cocone f g c))
+        ( refl-htpy)
+        ( refl-htpy)
+        ( refl-htpy)
+        ( refl-htpy)
+        ( htpy-precomp (coherence-square-cocone f g c) (Σ X P))
+        ( coherence-blabla P (coherence-square-cocone f g c))
+        ( is-equiv-map-inv-distributive-Π-Σ)
+        ( is-equiv-map-inv-distributive-Π-Σ)
+        ( is-equiv-map-inv-distributive-Π-Σ)
+        ( is-equiv-map-inv-distributive-Π-Σ)
+        ( pp-c (Σ X P)))
+
+  dependent-pullback-property-pullback-property-pushout :
+    ({l : Level} → pullback-property-pushout l f g c) →
+    ({l : Level} → dependent-pullback-property-pushout l f g c)
+  dependent-pullback-property-pullback-property-pushout pp-c P =
+    is-pullback-htpy'
+      ( ( tr-lift-family-of-elements P id (coherence-square-cocone f g c)) ·r
+        ( precomp-lift-family-of-elements P f (horizontal-map-cocone f g c)))
+      ( refl-htpy)
+      ( cone-family-dependent-pullback-property P id)
+      { c' = cone-dependent-pullback-property-pushout f g c P}
+      ( ( refl-htpy) ,
+        ( refl-htpy) ,
+        ( ( right-unit-htpy) ∙h
+          ( coherence-triangle-precompose-lift-family-of-elements-htpy P id
+            ( coherence-square-cocone f g c))))
+      ( is-pullback-cone-family-dependent-pullback-family P pp-c id)
+```
diff --git a/src/synthetic-homotopy-theory/dependent-universal-property-coequalizers.lagda.md b/src/synthetic-homotopy-theory/dependent-universal-property-coequalizers.lagda.md
index b47ea42d6e..37e4f6b39a 100644
--- a/src/synthetic-homotopy-theory/dependent-universal-property-coequalizers.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-universal-property-coequalizers.lagda.md
@@ -15,7 +15,6 @@ open import foundation.fibers-of-maps
 open import foundation.functoriality-dependent-pair-types
 open import foundation.universe-levels
 
-open import synthetic-homotopy-theory.26-descent
 open import synthetic-homotopy-theory.coforks
 open import synthetic-homotopy-theory.dependent-cocones-under-spans
 open import synthetic-homotopy-theory.dependent-coforks
diff --git a/src/synthetic-homotopy-theory/pushouts.lagda.md b/src/synthetic-homotopy-theory/pushouts.lagda.md
index 599d95be59..bb55f0d156 100644
--- a/src/synthetic-homotopy-theory/pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/pushouts.lagda.md
@@ -21,7 +21,6 @@ open import foundation.retractions
 open import foundation.sections
 open import foundation.universe-levels
 
-open import synthetic-homotopy-theory.26-descent
 open import synthetic-homotopy-theory.cocones-under-spans
 open import synthetic-homotopy-theory.dependent-cocones-under-spans
 open import synthetic-homotopy-theory.dependent-universal-property-pushouts

From a90579a340e376fee8bd0674ce291c8a236cda89 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Tue, 19 Dec 2023 23:30:17 +0100
Subject: [PATCH 02/18] =?UTF-8?q?dependent-universal-property-pushout?=
 =?UTF-8?q?=E2=86=94universal-property-pushout?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 ...ndent-universal-property-pushouts.lagda.md | 58 ++++++++++++++-----
 1 file changed, 42 insertions(+), 16 deletions(-)

diff --git a/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
index 0278952857..79641566e3 100644
--- a/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
@@ -27,6 +27,7 @@ open import synthetic-homotopy-theory.cocones-under-spans
 open import synthetic-homotopy-theory.dependent-cocones-under-spans
 open import synthetic-homotopy-theory.dependent-pullback-property-pushouts
 open import synthetic-homotopy-theory.induction-principle-pushouts
+open import synthetic-homotopy-theory.universal-property-pushouts
 ```
 
 </details>
@@ -128,23 +129,23 @@ htpy-eq-dependent-cocone-map f g c ind-c {P} h h' p =
 dependent-universal-property-pushout-induction-principle-pushout :
   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
   (f : S → A) (g : S → B) {X : UU l4} (c : cocone f g X) →
-  ((l : Level) → induction-principle-pushout l f g c) →
-  ((l : Level) → dependent-universal-property-pushout l f g c)
+  ({l : Level} → induction-principle-pushout l f g c) →
+  ({l : Level} → dependent-universal-property-pushout l f g c)
 dependent-universal-property-pushout-induction-principle-pushout
-  f g c ind-c l P =
+  f g c ind-c P =
   is-equiv-is-invertible
-    ( ind-induction-principle-pushout f g c (ind-c l) P)
-    ( pr2 (ind-c l P))
+    ( ind-induction-principle-pushout f g c ind-c P)
+    ( pr2 (ind-c P))
     ( λ h →
       eq-htpy
         ( htpy-eq-dependent-cocone-map f g c
-          ( ind-c l)
+          ( ind-c)
           ( ind-induction-principle-pushout f g c
-            ( ind-c l)
+            ( ind-c)
             ( P)
             ( dependent-cocone-map f g c P h))
           ( h)
-          ( pr2 (ind-c l P) (dependent-cocone-map f g c P h))))
+          ( pr2 (ind-c P) (dependent-cocone-map f g c P h))))
 ```
 
 #### The dependent universal property of pushouts implies the induction principle of pushouts
@@ -153,11 +154,10 @@ dependent-universal-property-pushout-induction-principle-pushout
 induction-principle-pushout-dependent-universal-property-pushout :
   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
   (f : S → A) (g : S → B) {X : UU l4} (c : cocone f g X) →
-  ((l : Level) → dependent-universal-property-pushout l f g c) →
-  ((l : Level) → induction-principle-pushout l f g c)
+  ({l : Level} → dependent-universal-property-pushout l f g c) →
+  ({l : Level} → induction-principle-pushout l f g c)
 induction-principle-pushout-dependent-universal-property-pushout
-  f g c dup-c l P =
-  pr1 (dup-c l P)
+  f g c dup-c P = pr1 (dup-c P)
 ```
 
 ### The dependent pullback property of pushouts is equivalent to the dependent universal property of pushouts
@@ -184,10 +184,10 @@ triangle-dependent-pullback-property-pushout f g (pair i (pair j H)) P h =
 dependent-pullback-property-dependent-universal-property-pushout :
   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
   (f : S → A) (g : S → B) {X : UU l4} (c : cocone f g X) →
-  ((l : Level) → dependent-universal-property-pushout l f g c) →
-  ((l : Level) → dependent-pullback-property-pushout l f g c)
+  ({l : Level} → dependent-universal-property-pushout l f g c) →
+  ({l : Level} → dependent-pullback-property-pushout l f g c)
 dependent-pullback-property-dependent-universal-property-pushout
-  f g (pair i (pair j H)) I l P =
+  f g (pair i (pair j H)) I P =
   let c = (pair i (pair j H)) in
   is-equiv-top-map-triangle
     ( dependent-cocone-map f g c P)
@@ -201,7 +201,7 @@ dependent-pullback-property-dependent-universal-property-pushout
       ( λ h →
         is-equiv-tot-is-fiberwise-equiv
           ( λ h' → funext (λ x → tr P (H x) (h (f x))) (h' ∘ g))))
-    ( I l P)
+    ( I P)
 ```
 
 #### The dependent pullback property of pushouts implies the dependent universal property of pushouts
@@ -229,3 +229,29 @@ dependent-universal-property-dependent-pullback-property-pushout
         is-equiv-tot-is-fiberwise-equiv
           ( λ h' → funext (λ x → tr P (H x) (h (f x))) (h' ∘ g))))
 ```
+
+### The non-dependent and dependent universal property of pushouts are logically equivalent
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
+  (f : S → A) (g : S → B) (c : cocone f g X)
+  where
+
+  universal-property-dependent-universal-property-pushout :
+    ({l : Level} → dependent-universal-property-pushout l f g c) →
+    ({l : Level} → universal-property-pushout l f g c)
+  universal-property-dependent-universal-property-pushout dup-c {l} =
+    universal-property-pushout-pullback-property-pushout l f g c
+      ( pullback-property-dependent-pullback-property-pushout f g c
+        ( dependent-pullback-property-dependent-universal-property-pushout f g c
+          ( dup-c)))
+
+  dependent-universal-property-universal-property-pushout :
+    ({l : Level} → universal-property-pushout l f g c) →
+    ({l : Level} → dependent-universal-property-pushout l f g c)
+  dependent-universal-property-universal-property-pushout up-c =
+    dependent-universal-property-dependent-pullback-property-pushout f g c
+      ( dependent-pullback-property-pullback-property-pushout f g c
+        ( pullback-property-pushout-universal-property-pushout f g c up-c))
+```

From 5f4f0a6a420133f214bd1616ddeda3a326700fc6 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 5 Jan 2024 17:56:03 +0100
Subject: [PATCH 03/18] =?UTF-8?q?Prose=20for=20`htpy-htpy-map-=CE=A3`?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 ...unctoriality-dependent-pair-types.lagda.md | 44 ++++++++++++++++++-
 1 file changed, 43 insertions(+), 1 deletion(-)

diff --git a/src/foundation/functoriality-dependent-pair-types.lagda.md b/src/foundation/functoriality-dependent-pair-types.lagda.md
index 068351c63a..2bce2ead04 100644
--- a/src/foundation/functoriality-dependent-pair-types.lagda.md
+++ b/src/foundation/functoriality-dependent-pair-types.lagda.md
@@ -39,7 +39,43 @@ open import foundation-core.truncation-levels
 
 ## Properties
 
-### TODO
+### The map `htpy-map-Σ` preserves homotopies
+
+Given a [homotopy](foundation.homotopies.md) `H : f ~ f'` and a family of
+[dependent homotopies](foundation.dependent-homotopies.md) `K a : g a ~ g' a`
+over `H`, expressed as
+[commuting triangles](foundation.commuting-triangles-of-maps.md)
+
+```text
+        g a
+    C a ----> D (f a)
+      \     /
+  g' a \   / tr D (H a)
+        V V
+       D (f' a)         ,
+```
+
+we get a homotopy `htpy-map-Σ H K : map-Σ f g ~ map-Σ f' g'`.
+
+This assignment itself preserves homotopies: given `H` and `K` as above,
+`H' : f ~ f'` with `K' a : g a ~ g' a` over `H'`, we would like to express
+coherences between the pairs `H, H'` and `K, K'` which would ensure
+`htpy-map-Σ H K ~ htpy-map-Σ H' K'`. Because `H` and `H'` have the same type, we
+may require a homotopy `H ~ H'`, but `K` and `K'` are families of dependent
+homotopies over different homotopies, so their coherence is provided as a family
+of
+[commuting triangles of identifications](foundation.commuting-triangles-of-identifications.md)
+
+```text
+                      ap (tr D - (g a c)) (α a)
+  tr D (H a) (g a c) --------------------------- tr D (H' a) (g a c)
+                     \                         /
+                        \                   /
+                   K a c   \             /   K' a c
+                              \       /
+                                 \ /
+                               g' a c         .
+```
 
 ```agda
 module _
@@ -75,7 +111,13 @@ module _
                   ( ap-const (g' a c) (α a))) ∙
                 ( right-unit) ∙
                 ( β a c)))))
+```
 
+As a corollary of the above statement, we can provide a condition which
+guarantees that `htpy-map-Σ` is homotopic to the trivial homotopy.
+
+```agda
+  abstract
     htpy-htpy-map-Σ-refl-htpy :
       {f : A → B} {H : f ~ f} →
       {g : (x : A) → C x → D (f x)} {K : (a : A) → tr D (H a) ∘ g a ~ g a} →

From f1d53e8e4cdda19f78d77eab71a01ccb42df9dc1 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 5 Jan 2024 18:51:48 +0100
Subject: [PATCH 04/18] Prose for `tr-precomp-family`

---
 src/foundation/precomposition-type-families.lagda.md | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/src/foundation/precomposition-type-families.lagda.md b/src/foundation/precomposition-type-families.lagda.md
index bd58689295..7bbe49673e 100644
--- a/src/foundation/precomposition-type-families.lagda.md
+++ b/src/foundation/precomposition-type-families.lagda.md
@@ -48,7 +48,16 @@ module _
 
 ### Transport in precomposed type families
 
-TODO
+[Transporting](foundation.transport-along-homotopies.md) along a
+[homotopy](foundation.homotopies.md) `H : g ~ h` in the family `Q ∘ f` gives us
+a map of families of elements
+
+```text
+  ((a : A) → Q (f (g a))) → ((a : A) → Q (f (h a))) .
+```
+
+We show that this map is homotopic to transporting along
+`f ·l H : f ∘ g ~ f ∘ h` in the family `Q`.
 
 ```agda
 module _

From 475fde91d4095d7e6ebe93f733a7fa41f8f5f63f Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 5 Jan 2024 22:57:32 +0100
Subject: [PATCH 05/18] Prose for the naming "lifts" of elements

---
 .../lifts-families-of-elements.lagda.md       | 32 +++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
index fc79bb4650..4d55e6435b 100644
--- a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
@@ -47,6 +47,38 @@ elements `a` is a family of elements
   (i : I) → B (a i).
 ```
 
+To see how these families relate to
+[lifts of maps](orthogonal-factorization-systems.lifts-of-maps.md), consider the
+lifting diagram
+
+```text
+      Σ (x : A) (B x)
+            |
+            | pr1
+            |
+            v
+  I ------> A         .
+       a
+```
+
+Then a lift of the map `a` against `pr1` is a map `b : I → Σ A B`, such that the
+triangle commutes. Invoking the
+[type theoretic principle of choice](foundation.type-theoretic-principle-of-choice.md),
+we can show that this type is equivalent to the type of families of elements
+`(i : I) → B (a i)`:
+
+```text
+  Σ (b : I → Σ A B) ((i : I) → a i ＝ pr1 (b i))
+    ≃ (i : I) → Σ ((x , b) : Σ A B) (a i ＝ x)
+    ≃ (i : I) → Σ (x : A) (a i ＝ x × B x)
+    ≃ (i : I) → B (a i) .
+```
+
+The first equivalence is the principle of choice, the second is associativity of
+dependent pair types, and the third is the left unit law of dependent pair
+types, since `Σ (x : A) (a i ＝ x)` is
+[contractible](foundation.contractible-types.md).
+
 ## Definitions
 
 ### Dependent lifts of families of elements

From 1e6cea50bbbb4630641a3e6d20906fc517338796 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 5 Jan 2024 22:58:40 +0100
Subject: [PATCH 06/18] "total space of lifts of families" -> "lifted families"

---
 .../lifts-families-of-elements.lagda.md       | 18 ++++++++-----
 ...sition-lifts-families-of-elements.lagda.md | 26 +++++++++----------
 ...endent-pullback-property-pushouts.lagda.md | 10 +++----
 3 files changed, 29 insertions(+), 25 deletions(-)

diff --git a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
index 4d55e6435b..66f851c092 100644
--- a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
@@ -47,6 +47,10 @@ elements `a` is a family of elements
   (i : I) → B (a i).
 ```
 
+A family of elements equipped with a dependent lift is a
+{{#concept "dependent lifted family of elements"}}, and analogously a family of
+elements equipped with a lift is a {{#concept "lifted family of elements"}}.
+
 To see how these families relate to
 [lifts of maps](orthogonal-factorization-systems.lifts-of-maps.md), consider the
 lifting diagram
@@ -104,29 +108,29 @@ module _
   lift-family-of-elements = dependent-lift-family-of-elements (λ _ → B) a
 ```
 
-### Total space of dependent lifts of families of elements
+### Dependent lifted families of elements
 
 ```agda
 module _
   {l1 l2 l3 : Level} {I : UU l1} (A : I → UU l2) (B : (i : I) → A i → UU l3)
   where
 
-  total-dependent-lift-family-of-elements : UU (l1 ⊔ l2 ⊔ l3)
-  total-dependent-lift-family-of-elements =
+  dependent-lifted-family-of-elements : UU (l1 ⊔ l2 ⊔ l3)
+  dependent-lifted-family-of-elements =
     Σ ( (i : I) → A i)
       ( dependent-lift-family-of-elements B)
 ```
 
-### Total space of lifts of families of elements
+### Lifted families of elements
 
 ```agda
 module _
   {l1 l2 l3 : Level} (I : UU l1) {A : UU l2} (B : A → UU l3)
   where
 
-  total-lift-family-of-elements : UU (l1 ⊔ l2 ⊔ l3)
-  total-lift-family-of-elements =
-    total-dependent-lift-family-of-elements (λ (_ : I) → A) (λ _ → B)
+  lifted-family-of-elements : UU (l1 ⊔ l2 ⊔ l3)
+  lifted-family-of-elements =
+    dependent-lifted-family-of-elements (λ (_ : I) → A) (λ _ → B)
 ```
 
 ### Dependent lifts of binary families of elements
diff --git a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
index 07f2c826c0..d55a124436 100644
--- a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
@@ -54,9 +54,9 @@ module _
   (f : I → J)
   where
 
-  precomp-total-lift-family-of-elements :
-    total-lift-family-of-elements J B → total-lift-family-of-elements I B
-  precomp-total-lift-family-of-elements =
+  precomp-lifted-family-of-elements :
+    lifted-family-of-elements J B → lifted-family-of-elements I B
+  precomp-lifted-family-of-elements =
     map-Σ
       ( lift-family-of-elements B)
       ( precomp f A)
@@ -165,7 +165,7 @@ module _
 
   coherence-square-precomp-map-inv-distributive-Π-Σ :
     coherence-square-maps
-      ( precomp-total-lift-family-of-elements B f)
+      ( precomp-lifted-family-of-elements B f)
       ( map-inv-distributive-Π-Σ)
       ( map-inv-distributive-Π-Σ)
       ( precomp f (Σ A B))
@@ -180,11 +180,11 @@ module _
   {f : J → I}
   where
 
-  htpy-precomp-total-lift-family-of-elements-htpy :
+  htpy-precomp-lifted-family-of-elements-htpy :
     {g : J → I} (H : f ~ g) →
-    ( precomp-total-lift-family-of-elements B f) ~
-    ( precomp-total-lift-family-of-elements B g)
-  htpy-precomp-total-lift-family-of-elements-htpy H =
+    ( precomp-lifted-family-of-elements B f) ~
+    ( precomp-lifted-family-of-elements B g)
+  htpy-precomp-lifted-family-of-elements-htpy H =
     htpy-map-Σ
       ( lift-family-of-elements B)
       ( htpy-precomp H A)
@@ -192,10 +192,10 @@ module _
       ( λ a → triangle-precompose-lift-family-of-elements-htpy B a H)
 
   abstract
-    compute-htpy-precomp-total-lift-family-of-elements-htpy :
-      htpy-precomp-total-lift-family-of-elements-htpy refl-htpy ~
+    compute-htpy-precomp-lifted-family-of-elements-htpy :
+      htpy-precomp-lifted-family-of-elements-htpy refl-htpy ~
       refl-htpy
-    compute-htpy-precomp-total-lift-family-of-elements-htpy =
+    compute-htpy-precomp-lifted-family-of-elements-htpy =
       htpy-htpy-map-Σ-refl-htpy
         ( lift-family-of-elements B)
         ( compute-htpy-precomp-refl-htpy f A)
@@ -221,13 +221,13 @@ module _
       ( coherence-square-precomp-map-inv-distributive-Π-Σ B f)
       ( coherence-square-precomp-map-inv-distributive-Π-Σ B g)
       ( ( map-inv-distributive-Π-Σ) ·l
-        ( htpy-precomp-total-lift-family-of-elements-htpy B H))
+        ( htpy-precomp-lifted-family-of-elements-htpy B H))
 
   coherence-blabla-refl-htpy : statement-coherence-blabla refl-htpy
   coherence-blabla-refl-htpy =
     ( ap-left-whisk-htpy
       ( map-inv-distributive-Π-Σ)
-      ( compute-htpy-precomp-total-lift-family-of-elements-htpy B)) ∙h
+      ( compute-htpy-precomp-lifted-family-of-elements-htpy B)) ∙h
     ( inv-htpy
       ( λ h →
         compute-htpy-precomp-refl-htpy f
diff --git a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
index a1f8652ccf..1d0b3d20bd 100644
--- a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
@@ -160,15 +160,15 @@ module _
         ( precomp (vertical-map-cocone f g c) (Σ X P))
         ( precomp f (Σ X P))
         ( precomp g (Σ X P))
-        ( precomp-total-lift-family-of-elements P (horizontal-map-cocone f g c))
-        ( precomp-total-lift-family-of-elements P (vertical-map-cocone f g c))
-        ( precomp-total-lift-family-of-elements P f)
-        ( precomp-total-lift-family-of-elements P g)
+        ( precomp-lifted-family-of-elements P (horizontal-map-cocone f g c))
+        ( precomp-lifted-family-of-elements P (vertical-map-cocone f g c))
+        ( precomp-lifted-family-of-elements P f)
+        ( precomp-lifted-family-of-elements P g)
         ( map-inv-distributive-Π-Σ)
         ( map-inv-distributive-Π-Σ)
         ( map-inv-distributive-Π-Σ)
         ( map-inv-distributive-Π-Σ)
-        ( htpy-precomp-total-lift-family-of-elements-htpy P
+        ( htpy-precomp-lifted-family-of-elements-htpy P
           ( coherence-square-cocone f g c))
         ( refl-htpy)
         ( refl-htpy)

From 6e8bce281753d64293a2d92b33933871fe4eb43d Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Sat, 6 Jan 2024 17:40:35 +0100
Subject: [PATCH 07/18] Prose for `tr-lift-family-of-elements-precomp`

---
 .../lifts-families-of-elements.lagda.md       | 47 ++++++++++++-------
 ...sition-lifts-families-of-elements.lagda.md |  7 +--
 ...endent-pullback-property-pushouts.lagda.md |  3 +-
 3 files changed, 36 insertions(+), 21 deletions(-)

diff --git a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
index 66f851c092..6208bccc7e 100644
--- a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
@@ -161,7 +161,19 @@ module _
 
 ## Properties
 
-### Transport in lifts of families of elements
+### Transport in lifts of families of elements along homotopies of precompositions
+
+Given a map `a : I → A`, and a homotopy `H : f ~ g`, where `f, g : J → I`, we
+know that there is an identification `a ∘ f ＝ a ∘ g`. Transporting along this
+identification in the type of lifts of families of elements into a type family
+`B : A → 𝓤`, we get a map
+
+```text
+  ((j : J) → B (a (f j))) → ((j : J) → B (a (g j))) .
+```
+
+We show that this map is homotopic to transporting along `H` in the type family
+`B ∘ a : I → 𝓤`.
 
 ```agda
 module _
@@ -169,33 +181,34 @@ module _
   {J : UU l4} {f : J → I}
   where
 
-  statement-tr-lift-family-of-elements : {g : J → I} (H : f ~ g) → UU (l3 ⊔ l4)
-  statement-tr-lift-family-of-elements H =
+  statement-tr-lift-family-of-elements-precomp :
+    {g : J → I} (H : f ~ g) → UU (l3 ⊔ l4)
+  statement-tr-lift-family-of-elements-precomp H =
     tr (lift-family-of-elements B) (htpy-precomp H A a) ~
     tr-htpy (λ _ → precomp-family a B) H
 
-  tr-lift-family-of-elements-refl-htpy :
-    statement-tr-lift-family-of-elements refl-htpy
-  tr-lift-family-of-elements-refl-htpy b =
+  tr-lift-family-of-elements-precomp-refl-htpy :
+    statement-tr-lift-family-of-elements-precomp refl-htpy
+  tr-lift-family-of-elements-precomp-refl-htpy b =
     ap
       ( λ p → tr (lift-family-of-elements B) p b)
       ( compute-htpy-precomp-refl-htpy f A a)
 
-  tr-lift-family-of-elements :
-    {g : J → I} (H : f ~ g) → statement-tr-lift-family-of-elements H
-  tr-lift-family-of-elements =
+  tr-lift-family-of-elements-precomp :
+    {g : J → I} (H : f ~ g) → statement-tr-lift-family-of-elements-precomp H
+  tr-lift-family-of-elements-precomp =
     ind-htpy f
-      ( λ g → statement-tr-lift-family-of-elements)
-      ( tr-lift-family-of-elements-refl-htpy)
+      ( λ g → statement-tr-lift-family-of-elements-precomp)
+      ( tr-lift-family-of-elements-precomp-refl-htpy)
 
   abstract
-    compute-tr-lift-family-of-elements :
-      tr-lift-family-of-elements refl-htpy ＝
-      tr-lift-family-of-elements-refl-htpy
-    compute-tr-lift-family-of-elements =
+    compute-tr-lift-family-of-elements-precomp :
+      tr-lift-family-of-elements-precomp refl-htpy ＝
+      tr-lift-family-of-elements-precomp-refl-htpy
+    compute-tr-lift-family-of-elements-precomp =
       compute-ind-htpy f
-        ( λ g → statement-tr-lift-family-of-elements)
-        ( tr-lift-family-of-elements-refl-htpy)
+        ( λ g → statement-tr-lift-family-of-elements-precomp)
+        ( tr-lift-family-of-elements-precomp-refl-htpy)
 ```
 
 ## See also
diff --git a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
index d55a124436..7e1add859a 100644
--- a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
@@ -98,7 +98,7 @@ module _
   triangle-precompose-lift-family-of-elements-htpy-refl-htpy :
     statement-triangle-precompose-lift-family-of-elements-htpy refl-htpy
   triangle-precompose-lift-family-of-elements-htpy-refl-htpy b =
-    tr-lift-family-of-elements B a refl-htpy (b ∘ f)
+    tr-lift-family-of-elements-precomp B a refl-htpy (b ∘ f)
 
   triangle-precompose-lift-family-of-elements-htpy :
     {g : J → I} (H : f ~ g) →
@@ -121,7 +121,7 @@ module _
     {g : J → I} (H : f ~ g) → UU (l1 ⊔ l3 ⊔ l4)
   statement-coherence-triangle-precompose-lift-family-of-elements-htpy H =
     ( triangle-precompose-lift-family-of-elements-htpy H) ~
-    ( ( ( tr-lift-family-of-elements B a H) ·r
+    ( ( ( tr-lift-family-of-elements-precomp B a H) ·r
         ( precomp-lift-family-of-elements B f a)) ∙h
       ( λ b → eq-htpy (λ j → apd b (H j))))
 
@@ -202,7 +202,8 @@ module _
         ( λ a →
           ( htpy-eq
             ( compute-triangle-precompose-lift-family-of-elements-htpy B a)) ∙h
-          ( λ b → (htpy-eq (compute-tr-lift-family-of-elements B a) (b ∘ f))))
+          ( λ b →
+            htpy-eq (compute-tr-lift-family-of-elements-precomp B a) (b ∘ f)))
 ```
 
 ### TODO
diff --git a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
index 1d0b3d20bd..1c58d8e75e 100644
--- a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
@@ -187,7 +187,8 @@ module _
     ({l : Level} → dependent-pullback-property-pushout l f g c)
   dependent-pullback-property-pullback-property-pushout pp-c P =
     is-pullback-htpy'
-      ( ( tr-lift-family-of-elements P id (coherence-square-cocone f g c)) ·r
+      ( ( tr-lift-family-of-elements-precomp P id
+          ( coherence-square-cocone f g c)) ·r
         ( precomp-lift-family-of-elements P f (horizontal-map-cocone f g c)))
       ( refl-htpy)
       ( cone-family-dependent-pullback-property P id)

From 8d7d3affe2a0decdbad5b887a49b9b33abbec0ee Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Sat, 6 Jan 2024 18:35:28 +0100
Subject: [PATCH 08/18] Intro to precomposition of lifts of families of
 elements

---
 ...sition-lifts-families-of-elements.lagda.md | 128 ++++++++++++------
 ...endent-pullback-property-pushouts.lagda.md |   4 +-
 2 files changed, 87 insertions(+), 45 deletions(-)

diff --git a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
index 7e1add859a..7bb28dd50f 100644
--- a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
@@ -30,6 +30,34 @@ open import orthogonal-factorization-systems.lifts-families-of-elements
 
 </details>
 
+## Idea
+
+Consider a type family `B : A → 𝓤` and a map `a : I → A`. Then, given a map
+`f : J → I`, we may pull back a
+[lift](orthogonal-factorization-systems.lifts-families-of-elements.md) of `a` to
+a lift of `a ∘ f`.
+
+In other words, given a diagram
+
+```text
+                Σ (x : A) (B x)
+                      |
+                      | pr1
+                      |
+                      v
+  J ------> I ------> A         ,
+       f         a
+```
+
+we get a map of diagonals
+
+```text
+  ((i : I) → B (a i)) → ((j : J) → B (a (f j))) .
+```
+
+This map of lifts induces a map from lifted families of elements indexed by `I`
+to lifted families of elements indexed by `J`.
+
 ## Definitions
 
 ### Precomposition of lifts of families of elements by functions
@@ -37,25 +65,25 @@ open import orthogonal-factorization-systems.lifts-families-of-elements
 ```agda
 module _
   {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) {J : UU l4}
-  (f : I → J)
+  (f : J → I)
   where
 
   precomp-lift-family-of-elements :
-    (a : J → A) →
+    (a : I → A) →
     lift-family-of-elements B a → lift-family-of-elements B (a ∘ f)
   precomp-lift-family-of-elements a b i = b (f i)
 ```
 
-### Precomposition in total spaces of lifts of families of elements
+### Precomposition in lifted families of elements
 
 ```agda
 module _
   {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) {J : UU l4}
-  (f : I → J)
+  (f : J → I)
   where
 
   precomp-lifted-family-of-elements :
-    lifted-family-of-elements J B → lifted-family-of-elements I B
+    lifted-family-of-elements I B → lifted-family-of-elements J B
   precomp-lifted-family-of-elements =
     map-Σ
       ( lift-family-of-elements B)
@@ -67,7 +95,12 @@ module _
 
 ### Homotopies between maps induce commuting triangles of precompositions of lifts of families of elements
 
-We have a commuting triangle
+Consider two maps `f, g : J → I` and a homotopy `H : f ~ g` between them. The
+precomposition functions they induce on lifts of families of elements have
+different codomains, namely `lift-family-of-elements B (a ∘ f)` and
+`lift-family-of-elements B (a ∘ g)`, but they fit into a
+[commuting triangle](foundation.commuting-triangles-of-maps.md) with
+[transport](foundation.transport-along-identifications.md) in the type of lifts:
 
 ```text
                               precomp-lift B f a
@@ -87,72 +120,81 @@ module _
   {J : UU l4} {f : J → I}
   where
 
-  statement-triangle-precompose-lift-family-of-elements-htpy :
+  statement-triangle-precomp-lift-family-of-elements-htpy :
     {g : J → I} (H : f ~ g) → UU (l1 ⊔ l3 ⊔ l4)
-  statement-triangle-precompose-lift-family-of-elements-htpy {g} H =
+  statement-triangle-precomp-lift-family-of-elements-htpy {g} H =
     coherence-triangle-maps'
       ( precomp-lift-family-of-elements B g a)
       ( tr (lift-family-of-elements B) (htpy-precomp H A a))
       ( precomp-lift-family-of-elements B f a)
 
-  triangle-precompose-lift-family-of-elements-htpy-refl-htpy :
-    statement-triangle-precompose-lift-family-of-elements-htpy refl-htpy
-  triangle-precompose-lift-family-of-elements-htpy-refl-htpy b =
+  triangle-precomp-lift-family-of-elements-htpy-refl-htpy :
+    statement-triangle-precomp-lift-family-of-elements-htpy refl-htpy
+  triangle-precomp-lift-family-of-elements-htpy-refl-htpy b =
     tr-lift-family-of-elements-precomp B a refl-htpy (b ∘ f)
 
-  triangle-precompose-lift-family-of-elements-htpy :
+  triangle-precomp-lift-family-of-elements-htpy :
     {g : J → I} (H : f ~ g) →
-    statement-triangle-precompose-lift-family-of-elements-htpy H
-  triangle-precompose-lift-family-of-elements-htpy =
+    statement-triangle-precomp-lift-family-of-elements-htpy H
+  triangle-precomp-lift-family-of-elements-htpy =
     ind-htpy f
-      ( λ g → statement-triangle-precompose-lift-family-of-elements-htpy)
-      ( triangle-precompose-lift-family-of-elements-htpy-refl-htpy)
+      ( λ g → statement-triangle-precomp-lift-family-of-elements-htpy)
+      ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
 
   abstract
-    compute-triangle-precompose-lift-family-of-elements-htpy :
-      triangle-precompose-lift-family-of-elements-htpy refl-htpy ＝
-      triangle-precompose-lift-family-of-elements-htpy-refl-htpy
-    compute-triangle-precompose-lift-family-of-elements-htpy =
+    compute-triangle-precomp-lift-family-of-elements-htpy :
+      triangle-precomp-lift-family-of-elements-htpy refl-htpy ＝
+      triangle-precomp-lift-family-of-elements-htpy-refl-htpy
+    compute-triangle-precomp-lift-family-of-elements-htpy =
       compute-ind-htpy f
-        ( λ g → statement-triangle-precompose-lift-family-of-elements-htpy)
-        ( triangle-precompose-lift-family-of-elements-htpy-refl-htpy)
+        ( λ g → statement-triangle-precomp-lift-family-of-elements-htpy)
+        ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
+```
+
+### TODO
+
+```agda
+module _
+  {l1 l2 l3 l4 : Level} {I : UU l1} {A : UU l2} (B : A → UU l3) (a : I → A)
+  {J : UU l4} {f : J → I}
+  where
 
-  statement-coherence-triangle-precompose-lift-family-of-elements-htpy :
+  statement-coherence-triangle-precomp-lift-family-of-elements-htpy :
     {g : J → I} (H : f ~ g) → UU (l1 ⊔ l3 ⊔ l4)
-  statement-coherence-triangle-precompose-lift-family-of-elements-htpy H =
-    ( triangle-precompose-lift-family-of-elements-htpy H) ~
+  statement-coherence-triangle-precomp-lift-family-of-elements-htpy H =
+    ( triangle-precomp-lift-family-of-elements-htpy B a H) ~
     ( ( ( tr-lift-family-of-elements-precomp B a H) ·r
         ( precomp-lift-family-of-elements B f a)) ∙h
       ( λ b → eq-htpy (λ j → apd b (H j))))
 
-  coherence-triangle-precompose-lift-family-of-elements-htpy-refl-htpy :
-    statement-coherence-triangle-precompose-lift-family-of-elements-htpy
+  coherence-triangle-precomp-lift-family-of-elements-htpy-refl-htpy :
+    statement-coherence-triangle-precomp-lift-family-of-elements-htpy
       ( refl-htpy)
-  coherence-triangle-precompose-lift-family-of-elements-htpy-refl-htpy b =
-    ( htpy-eq (compute-triangle-precompose-lift-family-of-elements-htpy) b) ∙
+  coherence-triangle-precomp-lift-family-of-elements-htpy-refl-htpy b =
+    ( htpy-eq (compute-triangle-precomp-lift-family-of-elements-htpy B a) b) ∙
     ( inv right-unit) ∙
     ( identification-left-whisk
-      ( triangle-precompose-lift-family-of-elements-htpy-refl-htpy b)
+      ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy B a b)
       ( inv (eq-htpy-refl-htpy (b ∘ f))))
 
-  coherence-triangle-precompose-lift-family-of-elements-htpy :
+  coherence-triangle-precomp-lift-family-of-elements-htpy :
     {g : J → I} (H : f ~ g) →
-    statement-coherence-triangle-precompose-lift-family-of-elements-htpy H
-  coherence-triangle-precompose-lift-family-of-elements-htpy =
+    statement-coherence-triangle-precomp-lift-family-of-elements-htpy H
+  coherence-triangle-precomp-lift-family-of-elements-htpy =
     ind-htpy f
       ( λ g →
-        statement-coherence-triangle-precompose-lift-family-of-elements-htpy)
-      ( coherence-triangle-precompose-lift-family-of-elements-htpy-refl-htpy)
+        statement-coherence-triangle-precomp-lift-family-of-elements-htpy)
+      ( coherence-triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
 
   abstract
-    compute-coherence-triangle-precompose-lift-family-of-elements-htpy :
-      coherence-triangle-precompose-lift-family-of-elements-htpy refl-htpy ＝
-      coherence-triangle-precompose-lift-family-of-elements-htpy-refl-htpy
-    compute-coherence-triangle-precompose-lift-family-of-elements-htpy =
+    compute-coherence-triangle-precomp-lift-family-of-elements-htpy :
+      coherence-triangle-precomp-lift-family-of-elements-htpy refl-htpy ＝
+      coherence-triangle-precomp-lift-family-of-elements-htpy-refl-htpy
+    compute-coherence-triangle-precomp-lift-family-of-elements-htpy =
       compute-ind-htpy f
         ( λ g →
-          statement-coherence-triangle-precompose-lift-family-of-elements-htpy)
-        ( coherence-triangle-precompose-lift-family-of-elements-htpy-refl-htpy)
+          statement-coherence-triangle-precomp-lift-family-of-elements-htpy)
+        ( coherence-triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
 ```
 
 ### TODO
@@ -189,7 +231,7 @@ module _
       ( lift-family-of-elements B)
       ( htpy-precomp H A)
       ( precomp-lift-family-of-elements B f)
-      ( λ a → triangle-precompose-lift-family-of-elements-htpy B a H)
+      ( λ a → triangle-precomp-lift-family-of-elements-htpy B a H)
 
   abstract
     compute-htpy-precomp-lifted-family-of-elements-htpy :
@@ -201,7 +243,7 @@ module _
         ( compute-htpy-precomp-refl-htpy f A)
         ( λ a →
           ( htpy-eq
-            ( compute-triangle-precompose-lift-family-of-elements-htpy B a)) ∙h
+            ( compute-triangle-precomp-lift-family-of-elements-htpy B a)) ∙h
           ( λ b →
             htpy-eq (compute-tr-lift-family-of-elements-precomp B a) (b ∘ f)))
 ```
diff --git a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
index 1c58d8e75e..e88f62b22c 100644
--- a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
@@ -131,7 +131,7 @@ module _
   pr1 (pr2 (cone-family-dependent-pullback-property P γ)) h =
     h ∘ vertical-map-cocone f g c
   pr2 (pr2 (cone-family-dependent-pullback-property P γ)) =
-    triangle-precompose-lift-family-of-elements-htpy P γ
+    triangle-precomp-lift-family-of-elements-htpy P γ
       ( coherence-square-cocone f g c)
 
   is-pullback-cone-family-dependent-pullback-family :
@@ -196,7 +196,7 @@ module _
       ( ( refl-htpy) ,
         ( refl-htpy) ,
         ( ( right-unit-htpy) ∙h
-          ( coherence-triangle-precompose-lift-family-of-elements-htpy P id
+          ( coherence-triangle-precomp-lift-family-of-elements-htpy P id
             ( coherence-square-cocone f g c))))
       ( is-pullback-cone-family-dependent-pullback-family P pp-c id)
 ```

From f2407934299ee6ef43c19e005707be6a2c44ab5f Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Wed, 10 Jan 2024 22:02:31 +0100
Subject: [PATCH 09/18] =?UTF-8?q?Prose=20for=20dependent-pullback-property?=
 =?UTF-8?q?=E2=86=94pullback-property?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 ...endent-pullback-property-pushouts.lagda.md | 86 +++++++++++++++++++
 1 file changed, 86 insertions(+)

diff --git a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
index e88f62b22c..e322f572b5 100644
--- a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
@@ -83,6 +83,21 @@ dependent-pullback-property-pushout l {S} {A} {B} f g {X} (i , j , H) =
 
 ### The dependent pullback property is logically equivalent to the pullback property
 
+Consider a [cocone](synthetic-homotopy-theory.cocones-under-spans.md)
+
+```text
+        g
+    S -----> B
+    |        |
+  f |        | j
+    V        V
+    A -----> X  .
+        i
+```
+
+The non-dependent pullback property follows from the dependent one by applying
+the dependent pullback property to the constant type family `λ _ → Y`.
+
 ```agda
 module _
   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3}
@@ -117,7 +132,78 @@ module _
                       ( coherence-square-cocone f g c s))))) ∙
           ( eq-htpy-concat-htpy _ _))))
       ( dpp-c (λ _ → Y))
+```
+
+In the converse direction, we use the fact that by the
+[type theoretic principle of choice](foundation.type-theoretic-principle-of-choice.md),
+dependent functions distribute over Σ-types. That, and a handful of technical
+lemmas about [transport](foundation.transport-along-identifications.md) in
+[precomposed type families](foundation.precomposition-type-families.md) and
+[precomposition](orthogonal-factorization-systems.precomposition-lifts-families-of-elements.md)
+in
+[lifts of families of elements](orthogonal-factorization-systems.lifts-families-of-elements.md),
+allow us to construct the following
+[commuting cube](foundation.commuting-cubes-of-maps.md):
+
+```text
+                                Σ (h : X → X) ((x : X) → P (h x))
+                                       /        |        \
+                                     /          |          \
+                                   /            |            \
+                                 /              |              \
+                               /                |                \
+                             /                  |                  \
+                           /                    |                    \
+                         V                      V                      V
+  Σ (h : A → X) ((a : A) → P (h a))    X → Σ (x : X) (P x)    Σ (h : B → X) ((b : B) → P (h b))
+                         |\             /               \             /|
+                         |  \         /                   \         /  |
+                         |    \     /                       \     /    |
+                         |      \ /                           \ /      |
+                         |      / \                           / \      |
+                         |    /     \                       /     \    |
+                         |  /         \                   /         \  |
+                         VV             V               V             VV
+         A → Σ (x : X) (P x)    Σ (h : S → X) ((s : S) → P (h s))    B → Σ (x : X) (P x)
+                           \                    |                    /
+                             \                  |                  /
+                               \                |                /
+                                 \              |              /
+                                   \            |            /
+                                     \          |          /
+                                       \        |        /
+                                         V      V      V
+                                       S → Σ (x : X) (P x) .
+```
+
+The bottom square is the induced precomposition square for our fixed cocone, so
+by the assumed pullback property, instantiated at the type `Σ (x : X) (P x)`,
+it's a pullback. The top square is constructed by precomposition of maps on the
+first component, and by precomposition of lifts of families of elements on the
+second component. Since vertical maps are equivalences, by the principle of
+choice, and the bottom square is a pullback, we conclude that the top square is
+a pullback.
 
+Observe that restricting the top square to its first component, we again get the
+induced precomposition square, this time instantiated at `X`, so that is also a
+pullback. Hence the top square is a pullback of total spaces over a pullback
+square, which implies that we get a family of pullback squares of the fibers,
+i.e. for every `h : X → X` we have a pullback
+
+```text
+    (x : X) → P (h x) ---------> (b : B) → P (h (j b))
+            | ⌟                           |
+            |                             |
+            |                             |
+            |                             |
+            V                             V
+  (a : A) → P (h (i a)) -----> (s : S) → P (h (j (g s))) ,
+```
+
+and instantiating for `id : X → X` gives us exactly a proof of the dependent
+pullback property.
+
+```agda
   cone-family-dependent-pullback-property :
     {l : Level} (P : X → UU l) →
     cone-family

From 963ca2c173fee5948e8e3a5d9c4e4bb2fb490aaa Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Thu, 11 Jan 2024 21:47:58 +0100
Subject: [PATCH 10/18] =?UTF-8?q?Prose=20for=20`coherence-square-precomp-m?=
 =?UTF-8?q?ap-inv-distributive-=CE=A0-=CE=A3`?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 ...sition-lifts-families-of-elements.lagda.md | 20 ++++++++++++++++++-
 1 file changed, 19 insertions(+), 1 deletion(-)

diff --git a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
index 7bb28dd50f..31f6413820 100644
--- a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
@@ -197,7 +197,25 @@ module _
         ( coherence-triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
 ```
 
-### TODO
+### `precomp-lifted-family-of-elements` is homotopic to the precomposition map on functions up to equivalence
+
+We have a [commuting square](foundation.commuting-squares-of-maps.md) like this:
+
+```text
+                                     precomp-lifted-family f
+  Σ (a : I → A) ((i : I) → B (a i)) ------------------------> Σ (a : J → A) ((j : J) → B (a j))
+                  |                                                           |
+                  |                                                           |
+                  | map-inv-distributive-Π-Σ         map-inv-distributive-Π-Σ |
+                  |                                                           |
+                  V                                                           V
+              I → Σ A B ------------------------------------------------> J → Σ A B ,
+                                               - ∘ f
+```
+
+which shows that `precomp-lifted-family-of-elements f` is a good choice for a
+precomposition map in the type of lifted families of elements, since it's
+homotopic to the regular precomposition map up to equivalence.
 
 ```agda
 module _

From 30b91a8983104b69a7d8769894653be014a9528c Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 12 Jan 2024 21:47:49 +0100
Subject: [PATCH 11/18] =?UTF-8?q?Prose=20for=20`coherence-htpy-precomp-coh?=
 =?UTF-8?q?erence-square-precomp-map-inv-distributive-=CE=A0-=CE=A3`?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 ...sition-lifts-families-of-elements.lagda.md | 84 ++++++++++++++-----
 ...endent-pullback-property-pushouts.lagda.md |  6 +-
 2 files changed, 69 insertions(+), 21 deletions(-)

diff --git a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
index 31f6413820..f8caca023e 100644
--- a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
@@ -206,7 +206,7 @@ We have a [commuting square](foundation.commuting-squares-of-maps.md) like this:
   Σ (a : I → A) ((i : I) → B (a i)) ------------------------> Σ (a : J → A) ((j : J) → B (a j))
                   |                                                           |
                   |                                                           |
-                  | map-inv-distributive-Π-Σ         map-inv-distributive-Π-Σ |
+                  | map-inv-distributive-Π-Σ    ⇗    map-inv-distributive-Π-Σ |
                   |                                                           |
                   V                                                           V
               I → Σ A B ------------------------------------------------> J → Σ A B ,
@@ -232,7 +232,7 @@ module _
   coherence-square-precomp-map-inv-distributive-Π-Σ = refl-htpy
 ```
 
-### TODO
+### Precomposition of lifted families of elements preserves homotopies
 
 ```agda
 module _
@@ -240,11 +240,11 @@ module _
   {f : J → I}
   where
 
-  htpy-precomp-lifted-family-of-elements-htpy :
+  htpy-precomp-lifted-family-of-elements :
     {g : J → I} (H : f ~ g) →
     ( precomp-lifted-family-of-elements B f) ~
     ( precomp-lifted-family-of-elements B g)
-  htpy-precomp-lifted-family-of-elements-htpy H =
+  htpy-precomp-lifted-family-of-elements H =
     htpy-map-Σ
       ( lift-family-of-elements B)
       ( htpy-precomp H A)
@@ -252,10 +252,10 @@ module _
       ( λ a → triangle-precomp-lift-family-of-elements-htpy B a H)
 
   abstract
-    compute-htpy-precomp-lifted-family-of-elements-htpy :
-      htpy-precomp-lifted-family-of-elements-htpy refl-htpy ~
+    compute-htpy-precomp-lifted-family-of-elements :
+      htpy-precomp-lifted-family-of-elements refl-htpy ~
       refl-htpy
-    compute-htpy-precomp-lifted-family-of-elements-htpy =
+    compute-htpy-precomp-lifted-family-of-elements =
       htpy-htpy-map-Σ-refl-htpy
         ( lift-family-of-elements B)
         ( compute-htpy-precomp-refl-htpy f A)
@@ -266,7 +266,47 @@ module _
             htpy-eq (compute-tr-lift-family-of-elements-precomp B a) (b ∘ f)))
 ```
 
-### TODO
+### `coherence-square-precomp-map-inv-distributive-Π-Σ` commutes with induced homotopies between precompositions maps
+
+Diagrammatically, we have two ways of composing homotopies to connect `- ∘ f` and
+`precomp-lifted-family-of-elements g`. One factors through
+`precomp-lifted-family-of-elements f`:
+
+```text
+                                     precomp-lifted-family g
+                               -----------------------------------
+                             /                                     \
+                           /     ⇗ htpy-precomp-lifted-family H      \
+                         /                                             V
+  Σ (a : I → A) ((i : I) → B (a i)) ------------------------> Σ (a : J → A) ((j : J) → B (a j))
+                  |                  precomp-lifted-family f                  |
+                  |                                                           |
+                  |                             ⇗                             |
+                  | map-inv-distributive-Π-Σ         map-inv-distributive-Π-Σ |
+                  V                                                           V
+              I → Σ A B ------------------------------------------------> J → Σ A B ,
+                                              - ∘ f
+```
+
+while the other factors through `- ∘ g`:
+
+```text
+                                     precomp-lifted-family g
+  Σ (a : I → A) ((i : I) → B (a i)) ------------------------> Σ (a : J → A) ((j : J) → B (a j))
+                  |                                                           |
+                  |                                                           |
+                  | map-inv-distributive-Π-Σ    ⇗    map-inv-distributive-Π-Σ |
+                  |                                                           |
+                  V                           - ∘ g                           V
+              I → Σ A B ------------------------------------------------> J → Σ A B .
+                        \                                               >
+                          \             ⇗  htpy-precomp H             /
+                            \                                       /
+                              -------------------------------------
+                                              - ∘ f
+```
+
+We show that these homotopies are themselves homotopic, filling the cylinder.
 
 ```agda
 module _
@@ -274,21 +314,24 @@ module _
   {f : J → I}
   where
 
-  statement-coherence-blabla :
+  statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ :
     {g : J → I} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
-  statement-coherence-blabla {g} H =
+  statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ
+    {g} H =
     coherence-square-homotopies
       ( htpy-precomp H (Σ A B) ·r map-inv-distributive-Π-Σ)
       ( coherence-square-precomp-map-inv-distributive-Π-Σ B f)
       ( coherence-square-precomp-map-inv-distributive-Π-Σ B g)
       ( ( map-inv-distributive-Π-Σ) ·l
-        ( htpy-precomp-lifted-family-of-elements-htpy B H))
+        ( htpy-precomp-lifted-family-of-elements B H))
 
-  coherence-blabla-refl-htpy : statement-coherence-blabla refl-htpy
-  coherence-blabla-refl-htpy =
+  coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ-refl-htpy :
+    statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ
+      ( refl-htpy)
+  coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ-refl-htpy =
     ( ap-left-whisk-htpy
       ( map-inv-distributive-Π-Σ)
-      ( compute-htpy-precomp-lifted-family-of-elements-htpy B)) ∙h
+      ( compute-htpy-precomp-lifted-family-of-elements B)) ∙h
     ( inv-htpy
       ( λ h →
         compute-htpy-precomp-refl-htpy f
@@ -296,10 +339,13 @@ module _
           ( map-inv-distributive-Π-Σ h))) ∙h
     ( inv-htpy-right-unit-htpy)
 
-  coherence-blabla :
-    {g : J → I} (H : f ~ g) → statement-coherence-blabla H
-  coherence-blabla =
+  coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ :
+    {g : J → I} (H : f ~ g) →
+    statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ
+      ( H)
+  coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ =
     ind-htpy f
-      ( λ g → statement-coherence-blabla)
-      ( coherence-blabla-refl-htpy)
+      ( λ g →
+        statement-coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ)
+      ( coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ-refl-htpy)
 ```
diff --git a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
index e322f572b5..7dd82b23eb 100644
--- a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
@@ -254,14 +254,16 @@ pullback property.
         ( map-inv-distributive-Π-Σ)
         ( map-inv-distributive-Π-Σ)
         ( map-inv-distributive-Π-Σ)
-        ( htpy-precomp-lifted-family-of-elements-htpy P
+        ( htpy-precomp-lifted-family-of-elements P
           ( coherence-square-cocone f g c))
         ( refl-htpy)
         ( refl-htpy)
         ( refl-htpy)
         ( refl-htpy)
         ( htpy-precomp (coherence-square-cocone f g c) (Σ X P))
-        ( coherence-blabla P (coherence-square-cocone f g c))
+        ( coherence-htpy-precomp-coherence-square-precomp-map-inv-distributive-Π-Σ
+          ( P)
+          ( coherence-square-cocone f g c))
         ( is-equiv-map-inv-distributive-Π-Σ)
         ( is-equiv-map-inv-distributive-Π-Σ)
         ( is-equiv-map-inv-distributive-Π-Σ)

From 9ac77a96c514582c56151e0c1d1d1b14c391ed88 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 12 Jan 2024 21:51:04 +0100
Subject: [PATCH 12/18] Fix typos

---
 src/foundation/commuting-squares-of-maps.lagda.md | 2 +-
 src/foundation/whiskering-homotopies.lagda.md     | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/foundation/commuting-squares-of-maps.lagda.md b/src/foundation/commuting-squares-of-maps.lagda.md
index 3df33693bc..93688a63b5 100644
--- a/src/foundation/commuting-squares-of-maps.lagda.md
+++ b/src/foundation/commuting-squares-of-maps.lagda.md
@@ -590,7 +590,7 @@ newly created rectangles, or by first horizontally composing the squares, and
 then vertically composing the rectangles.
 
 The following lemma states that the big squares obtained by these two
-compositions are again homotopic. Diagramatically, we have
+compositions are again homotopic. Diagrammatically, we have
 
 ```text
  H | K   H | K
diff --git a/src/foundation/whiskering-homotopies.lagda.md b/src/foundation/whiskering-homotopies.lagda.md
index bfe1cc284d..07ce4de860 100644
--- a/src/foundation/whiskering-homotopies.lagda.md
+++ b/src/foundation/whiskering-homotopies.lagda.md
@@ -115,7 +115,7 @@ may be whiskered by a homotopy `L` on the left or right, which results in a
 commuting square of homotopies with `L` appended or prepended to the two ways of
 going around the square.
 
-Diagramatically, we may turn the pasting diagram
+Diagrammatically, we may turn the pasting diagram
 
 ```text
         H

From b4d1236d01c0a636d4aedc03952eb5a848155cc1 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 12 Jan 2024 22:02:49 +0100
Subject: [PATCH 13/18] Prose for
 `coherence-triangle-precomp-lift-family-of-elements`

---
 ...sition-lifts-families-of-elements.lagda.md | 44 +++++++++++--------
 ...endent-pullback-property-pushouts.lagda.md |  2 +-
 2 files changed, 26 insertions(+), 20 deletions(-)

diff --git a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
index f8caca023e..1c3af98afd 100644
--- a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
@@ -151,7 +151,13 @@ module _
         ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
 ```
 
-### TODO
+### `triangle-precomp-lift-family-of-elements-htpy` factors through transport along a homotopy in the famiy `B ∘ a`
+
+Instead of defining the homotopy `triangle-precomp-lift-family-of-elements-htpy`
+by homotopy induction, we could have defined it manually using the
+characterization of transport in the type of lifts of a family of elements.
+
+We show that these two definitions are homotopic.
 
 ```agda
 module _
@@ -159,42 +165,42 @@ module _
   {J : UU l4} {f : J → I}
   where
 
-  statement-coherence-triangle-precomp-lift-family-of-elements-htpy :
+  statement-coherence-triangle-precomp-lift-family-of-elements :
     {g : J → I} (H : f ~ g) → UU (l1 ⊔ l3 ⊔ l4)
-  statement-coherence-triangle-precomp-lift-family-of-elements-htpy H =
+  statement-coherence-triangle-precomp-lift-family-of-elements H =
     ( triangle-precomp-lift-family-of-elements-htpy B a H) ~
     ( ( ( tr-lift-family-of-elements-precomp B a H) ·r
         ( precomp-lift-family-of-elements B f a)) ∙h
       ( λ b → eq-htpy (λ j → apd b (H j))))
 
-  coherence-triangle-precomp-lift-family-of-elements-htpy-refl-htpy :
-    statement-coherence-triangle-precomp-lift-family-of-elements-htpy
+  coherence-triangle-precomp-lift-family-of-elements-refl-htpy :
+    statement-coherence-triangle-precomp-lift-family-of-elements
       ( refl-htpy)
-  coherence-triangle-precomp-lift-family-of-elements-htpy-refl-htpy b =
+  coherence-triangle-precomp-lift-family-of-elements-refl-htpy b =
     ( htpy-eq (compute-triangle-precomp-lift-family-of-elements-htpy B a) b) ∙
     ( inv right-unit) ∙
     ( identification-left-whisk
       ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy B a b)
       ( inv (eq-htpy-refl-htpy (b ∘ f))))
 
-  coherence-triangle-precomp-lift-family-of-elements-htpy :
+  coherence-triangle-precomp-lift-family-of-elements :
     {g : J → I} (H : f ~ g) →
-    statement-coherence-triangle-precomp-lift-family-of-elements-htpy H
-  coherence-triangle-precomp-lift-family-of-elements-htpy =
+    statement-coherence-triangle-precomp-lift-family-of-elements H
+  coherence-triangle-precomp-lift-family-of-elements =
     ind-htpy f
       ( λ g →
-        statement-coherence-triangle-precomp-lift-family-of-elements-htpy)
-      ( coherence-triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
+        statement-coherence-triangle-precomp-lift-family-of-elements)
+      ( coherence-triangle-precomp-lift-family-of-elements-refl-htpy)
 
   abstract
-    compute-coherence-triangle-precomp-lift-family-of-elements-htpy :
-      coherence-triangle-precomp-lift-family-of-elements-htpy refl-htpy ＝
-      coherence-triangle-precomp-lift-family-of-elements-htpy-refl-htpy
-    compute-coherence-triangle-precomp-lift-family-of-elements-htpy =
+    compute-coherence-triangle-precomp-lift-family-of-elements :
+      coherence-triangle-precomp-lift-family-of-elements refl-htpy ＝
+      coherence-triangle-precomp-lift-family-of-elements-refl-htpy
+    compute-coherence-triangle-precomp-lift-family-of-elements =
       compute-ind-htpy f
         ( λ g →
-          statement-coherence-triangle-precomp-lift-family-of-elements-htpy)
-        ( coherence-triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
+          statement-coherence-triangle-precomp-lift-family-of-elements)
+        ( coherence-triangle-precomp-lift-family-of-elements-refl-htpy)
 ```
 
 ### `precomp-lifted-family-of-elements` is homotopic to the precomposition map on functions up to equivalence
@@ -268,8 +274,8 @@ module _
 
 ### `coherence-square-precomp-map-inv-distributive-Π-Σ` commutes with induced homotopies between precompositions maps
 
-Diagrammatically, we have two ways of composing homotopies to connect `- ∘ f` and
-`precomp-lifted-family-of-elements g`. One factors through
+Diagrammatically, we have two ways of composing homotopies to connect `- ∘ f`
+and `precomp-lifted-family-of-elements g`. One factors through
 `precomp-lifted-family-of-elements f`:
 
 ```text
diff --git a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
index 7dd82b23eb..2ff8d22e32 100644
--- a/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-pullback-property-pushouts.lagda.md
@@ -284,7 +284,7 @@ pullback property.
       ( ( refl-htpy) ,
         ( refl-htpy) ,
         ( ( right-unit-htpy) ∙h
-          ( coherence-triangle-precomp-lift-family-of-elements-htpy P id
+          ( coherence-triangle-precomp-lift-family-of-elements P id
             ( coherence-square-cocone f g c))))
       ( is-pullback-cone-family-dependent-pullback-family P pp-c id)
 ```

From 9db3c4b52336fa0a74c9fe8dea8efa9a93da3a52 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Fri, 12 Jan 2024 22:08:05 +0100
Subject: [PATCH 14/18] Remove commented code

---
 .../26-descent.lagda.md                       | 420 ------------------
 1 file changed, 420 deletions(-)

diff --git a/src/synthetic-homotopy-theory/26-descent.lagda.md b/src/synthetic-homotopy-theory/26-descent.lagda.md
index b4d5efd0e4..632c1e795c 100644
--- a/src/synthetic-homotopy-theory/26-descent.lagda.md
+++ b/src/synthetic-homotopy-theory/26-descent.lagda.md
@@ -77,426 +77,6 @@ of those parts:
 - Proof of (4) → (5): `Ind-pushout-dependent-universal-property-pushout`
 - Proof of (5) → (4): `dependent-universal-property-pushout-Ind-pushout`
 
-### Proof of Theorem 18.1.4, (3) implies (2)
-
-```agda
--- pullback-property-dependent-pullback-property-pushout :
---   {l1 l2 l3 l4 : Level} (l : Level) {S : UU l1} {A : UU l2} {B : UU l3}
---   (f : S → A) (g : S → B) {X : UU l4} (c : cocone f g X) →
---   dependent-pullback-property-pushout l f g c →
---   pullback-property-pushout l f g c
--- pullback-property-dependent-pullback-property-pushout
---   l f g (pair i (pair j H)) dpb Y =
---   is-pullback-htpy
---     -- ( λ h s → tr (λ x → Y) (H s) (h (f s)))
---     ( λ h → eq-htpy (λ s → inv (tr-constant-type-family (H s) (h (f s)))))
---     -- ( _∘ g)
---     ( refl-htpy)
---     { c = pair
---       ( _∘ i)
---       ( pair (_∘ j) (λ h → eq-htpy (h ·l H)))}
---     ( cone-dependent-pullback-property-pushout
---       f g (pair i (pair j H)) (λ x → Y))
---     ( pair
---       ( λ h → refl)
---       ( pair
---         ( λ h → refl)
---         ( λ h → right-unit ∙
---           ( ( ap eq-htpy
---               ( eq-htpy (λ s →
---                 left-transpose-eq-concat
---                   ( tr-constant-type-family (H s) (h (i (f s))))
---                   ( ap h (H s))
---                   ( apd h (H s))
---                   ( inv (apd-constant-type-family h (H s)))))) ∙
---             ( eq-htpy-concat-htpy
---               ( λ s → inv (tr-constant-type-family (H s) (h (i (f s)))))
---               ( λ s → apd h (H s)))))))
---     ( dpb (λ x → Y))
-```
-
-### Proof of Theorem 18.1.4, (2) implies (3)
-
-We first define the family of lifts, which is indexed by maps $Y → X$.
-
-```agda
--- fam-lifts :
---   {l1 l2 l3 : Level} (Y : UU l1) {X : UU l2} (P : X → UU l3) →
---   (Y → X) → UU (l1 ⊔ l3)
--- fam-lifts Y P h = (y : Y) → P (h y)
-
--- tr-fam-lifts' :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
---   (h : B → X) {f g : A → B} (H : f ~ g) →
---   fam-lifts A P (h ∘ f) → fam-lifts A P (h ∘ g)
--- tr-fam-lifts' P h {f} {g} H k s = tr (P ∘ h) (H s) (k s)
-
--- TR-EQ-HTPY-FAM-LIFTS :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
---   (h : B → X) {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l4)
--- TR-EQ-HTPY-FAM-LIFTS {A = A} P h H =
---   tr (fam-lifts A P) (eq-htpy (h ·l H)) ~ (tr-fam-lifts' P h H)
-
--- tr-eq-htpy-fam-lifts-refl-htpy :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
---   (h : B → X) (f : A → B) → TR-EQ-HTPY-FAM-LIFTS P h (refl-htpy' f)
--- tr-eq-htpy-fam-lifts-refl-htpy P h f k =
---   ap (λ t → tr (fam-lifts _ P) t k) (eq-htpy-refl-htpy (h ∘ f))
-
--- abstract
---   tr-eq-htpy-fam-lifts :
---     {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
---     (h : B → X) {f g : A → B} (H : f ~ g) →
---     TR-EQ-HTPY-FAM-LIFTS P h H
---   tr-eq-htpy-fam-lifts P h {f} =
---     ind-htpy f
---       ( λ g H → TR-EQ-HTPY-FAM-LIFTS P h H)
---       ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
-
---   compute-tr-eq-htpy-fam-lifts :
---     {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4) →
---     (h : B → X) (f : A → B) →
---     Id ( tr-eq-htpy-fam-lifts P h (refl-htpy' f))
---         ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
---   compute-tr-eq-htpy-fam-lifts P h f =
---     compute-ind-htpy f
---       ( λ g H → TR-EQ-HTPY-FAM-LIFTS P h H)
---       ( tr-eq-htpy-fam-lifts-refl-htpy P h f)
-```
-
-One of the basic operations on lifts is precomposition by an ordinary function.
-
-```agda
--- precompose-lifts :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
---   (P : X → UU l4) → (f : A → B) → (h : B → X) →
---   (fam-lifts B P h) → (fam-lifts A P (h ∘ f))
--- precompose-lifts P f h h' a = h' (f a)
-```
-
-Given two homotopic maps, their precomposition functions have different
-codomains. However, there is a commuting triangle. We obtain this triangle by
-homotopy induction.
-
-```agda
--- TRIANGLE-PRECOMPOSE-LIFTS :
---   { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
---   ( P : X → UU l4) {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
--- TRIANGLE-PRECOMPOSE-LIFTS {A = A} {B} {X} P {f} {g} H =
---   (h : B → X) →
---     ( (tr (fam-lifts A P) (eq-htpy (h ·l H))) ∘ (precompose-lifts P f h)) ~
---     ( precompose-lifts P g h)
-
--- triangle-precompose-lifts-refl-htpy :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
---   (P : X → UU l4) (f : A → B) → TRIANGLE-PRECOMPOSE-LIFTS P (refl-htpy' f)
--- triangle-precompose-lifts-refl-htpy {A = A} P f h h' =
---   tr-eq-htpy-fam-lifts-refl-htpy P h f (λ a → h' (f a))
-
--- triangle-precompose-lifts :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
---   (P : X → UU l4) {f g : A → B} (H : f ~ g) →
---   TRIANGLE-PRECOMPOSE-LIFTS P H
--- triangle-precompose-lifts {A = A} P {f} =
---   ind-htpy f
---     ( λ g H → TRIANGLE-PRECOMPOSE-LIFTS P H)
---     ( triangle-precompose-lifts-refl-htpy P f)
-
--- compute-triangle-precompose-lifts :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
---   (P : X → UU l4) (f : A → B) →
---   Id
---     ( triangle-precompose-lifts P (refl-htpy' f))
---     ( triangle-precompose-lifts-refl-htpy P f)
--- compute-triangle-precompose-lifts P f =
---   compute-ind-htpy f
---     ( λ g → TRIANGLE-PRECOMPOSE-LIFTS P)
---     ( triangle-precompose-lifts-refl-htpy P f)
-```
-
-There is a similar commuting triangle with the computed transport function. This
-time we don't use homotopy induction to construct the homotopy. We give an
-explicit definition instead.
-
-```agda
--- triangle-precompose-lifts' :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
---   (P : X → UU l4) {f g : A → B} (H : f ~ g) → (h : B → X) →
---   ( (tr-fam-lifts' P h H) ∘ (precompose-lifts P f h)) ~
---   ( precompose-lifts P g h)
--- triangle-precompose-lifts' P H h k = eq-htpy (λ a → apd k (H a))
-
--- compute-triangle-precompose-lifts' :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
---   (P : X → UU l4) (f : A → B) → (h : B → X) →
---   ( triangle-precompose-lifts' P (refl-htpy' f) h) ~
---   ( refl-htpy' ( precompose-lifts P f h))
--- compute-triangle-precompose-lifts' P f h k = eq-htpy-refl-htpy _
-```
-
-There is a coherence between the two commuting triangles. This coherence is
-again constructed by homotopy induction.
-
-```agda
--- COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
---   {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
--- COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS {A = A} {B} {X} P {f} {g} H =
---   (h : B → X) →
---     ( triangle-precompose-lifts P H h) ~
---     ( ( ( tr-eq-htpy-fam-lifts P h H) ·r (precompose-lifts P f h)) ∙h
---       ( triangle-precompose-lifts' P H h))
-
--- coherence-triangle-precompose-lifts-refl-htpy :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
---   (f : A → B) → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P (refl-htpy' f)
--- coherence-triangle-precompose-lifts-refl-htpy P f h =
---   ( htpy-eq (htpy-eq (compute-triangle-precompose-lifts P f) h)) ∙h
---   ( ( ( inv-htpy-right-unit-htpy) ∙h
---       ( ap-concat-htpy
---         ( λ h' → tr-eq-htpy-fam-lifts-refl-htpy P h f (λ a → h' (f a)))
---         ( inv-htpy (compute-triangle-precompose-lifts' P f h)))) ∙h
---     ( htpy-eq
---       ( ap
---         ( λ t →
---           ( t ·r (precompose-lifts P f h)) ∙h
---           ( triangle-precompose-lifts' P refl-htpy h))
---         ( inv (compute-tr-eq-htpy-fam-lifts P h f)))))
-
--- abstract
---   coherence-triangle-precompose-lifts :
---     {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
---     {f g : A → B} (H : f ~ g) → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H
---   coherence-triangle-precompose-lifts P {f} =
---     ind-htpy f
---       ( λ g H → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H)
---       ( coherence-triangle-precompose-lifts-refl-htpy P f)
-
---   compute-coherence-triangle-precompose-lifts :
---     {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
---     (f : A → B) →
---       Id ( coherence-triangle-precompose-lifts P (refl-htpy' f))
---           ( coherence-triangle-precompose-lifts-refl-htpy P f)
---   compute-coherence-triangle-precompose-lifts P f =
---     compute-ind-htpy f
---       ( λ g H → COHERENCE-TRIANGLE-PRECOMPOSE-LIFTS P H)
---       ( coherence-triangle-precompose-lifts-refl-htpy P f)
-
--- total-lifts :
---   {l1 l2 l3 : Level} (A : UU l1) {X : UU l2} (P : X → UU l3) →
---   UU (l1 ⊔ l2 ⊔ l3)
--- total-lifts A {X} P = universally-structured-Π {A = A} {B = λ a → X} (λ a → P)
-
--- precompose-total-lifts :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
---   (P : X → UU l4) → (A → B) →
---   total-lifts B P → total-lifts A P
--- precompose-total-lifts {A = A} P f =
---   map-Σ
---     ( λ h → (a : A) → P (h a))
---     ( λ h → h ∘ f)
---     ( precompose-lifts P f)
-
--- coherence-square-map-inv-distributive-Π-Σ :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
---   (P : X → UU l4) (f : A → B) →
---   coherence-square-maps
---     ( precompose-total-lifts P f)
---     ( map-inv-distributive-Π-Σ {A = B} {B = λ x → X} {C = λ x y → P y})
---     ( map-inv-distributive-Π-Σ)
---     ( λ h → h ∘ f)
--- coherence-square-map-inv-distributive-Π-Σ P f = refl-htpy
-```
-
-Our goal is now to produce a homotopy between `precompose-total-lifts P f` and
-`precompose-total-lifts P g` for homotopic maps `f` and `g`, and a coherence
-filling a cylinder.
-
-```agda
--- HTPY-PRECOMPOSE-TOTAL-LIFTS :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3}
---   (P : X → UU l4) {f g : A → B} (H : f ~ g) →
---   UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
--- HTPY-PRECOMPOSE-TOTAL-LIFTS P {f} {g} H =
---   (precompose-total-lifts P f) ~ (precompose-total-lifts P g)
-
--- htpy-precompose-total-lifts :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
---   {f g : A → B} (H : f ~ g) → HTPY-PRECOMPOSE-TOTAL-LIFTS P H
--- htpy-precompose-total-lifts {A = A} {B} P {f} {g} H =
---   htpy-map-Σ
---     ( fam-lifts A P)
---     ( λ h → eq-htpy (h ·l H))
---     ( precompose-lifts P f)
---     ( triangle-precompose-lifts P H)
-```
-
-We show that when `htpy-precompose-total-lifts` is applied to `refl-htpy`, it
-computes to `refl-htpy`.
-
-```agda
--- tr-id-left-subst :
---   {l1 l2 : Level} {A : UU l1} {B : UU l2} {f : A → B} {x y : A}
---   (p : Id x y) (b : B) → (q : Id (f x) b) →
---   Id (tr (λ (a : A) → Id (f a) b) p q) ((inv (ap f p)) ∙ q)
--- tr-id-left-subst refl b q = refl
-
--- compute-htpy-precompose-total-lifts :
---   { l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
---   ( f : A → B) →
---   ( htpy-precompose-total-lifts P (refl-htpy {f = f})) ~
---   ( refl-htpy' (map-Σ (fam-lifts A P) (λ h → h ∘ f) (precompose-lifts P f)))
--- compute-htpy-precompose-total-lifts {A = A} P f (pair h h') =
---   let α = λ (t : Id (h ∘ f) (h ∘ f)) → tr (fam-lifts A P) t (λ a → h' (f a))
---   in
---   ap eq-pair-Σ'
---     ( eq-pair-Σ
---       ( eq-htpy-refl-htpy (h ∘ f))
---       ( ( tr-id-left-subst
---           { f = α}
---           ( eq-htpy-refl-htpy (h ∘ f))
---           ( λ a → h' (f a))
---           ( triangle-precompose-lifts P refl-htpy h h')) ∙
---         ( ( ap
---             ( λ t → inv (ap α (eq-htpy-refl-htpy (λ a → h (f a)))) ∙ t)
---             ( htpy-eq
---               ( htpy-eq (compute-triangle-precompose-lifts P f) h) h')) ∙
---           ( left-inv (triangle-precompose-lifts-refl-htpy P f h h')))))
-
--- COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
---   {f g : A → B} (H : f ~ g) → UU (l1 ⊔ l2 ⊔ l3 ⊔ l4)
--- COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P {f} {g} H =
---   ( ( coherence-square-map-inv-distributive-Π-Σ P f) ∙h
---     ( map-inv-distributive-Π-Σ ·l ( htpy-precompose-total-lifts P H))) ~
---   ( ( ( λ h → eq-htpy (h ·l H)) ·r map-inv-distributive-Π-Σ) ∙h
---     ( coherence-square-map-inv-distributive-Π-Σ P g))
-
--- coherence-inv-htpy-distributive-Π-Σ-refl-htpy :
---   {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
---   (f : A → B) → COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P (refl-htpy' f)
--- coherence-inv-htpy-distributive-Π-Σ-refl-htpy {X = X} P f =
---   ( ap-concat-htpy
---     ( coherence-square-map-inv-distributive-Π-Σ P f)
---     ( λ h →
---       ap
---         ( ap map-inv-distributive-Π-Σ)
---         ( compute-htpy-precompose-total-lifts P f h))) ∙h
---   ( ap-concat-htpy'
---     ( refl-htpy)
---     ( inv-htpy
---       ( λ h →
---         compute-htpy-precomp-refl-htpy f (Σ X P) (map-inv-distributive-Π-Σ h))))
-
--- abstract
---   coherence-inv-htpy-distributive-Π-Σ :
---     {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {X : UU l3} (P : X → UU l4)
---     {f g : A → B} (H : f ~ g) → COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P H
---   coherence-inv-htpy-distributive-Π-Σ P {f} =
---     ind-htpy f
---       ( λ g H → COHERENCE-INV-HTPY-DISTRIBUTIVE-Π-Σ P H)
---       ( coherence-inv-htpy-distributive-Π-Σ-refl-htpy P f)
-
--- cone-family-dependent-pullback-property :
---   {l1 l2 l3 l4 l : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
---   (f : S → A) (g : S → B) (c : cocone f g X) (P : X → UU l) →
---   cone-family
---     ( fam-lifts S P)
---     ( precompose-lifts P f)
---     ( precompose-lifts P g)
---     ( cone-pullback-property-pushout f g c X)
---     ( fam-lifts X P)
--- cone-family-dependent-pullback-property f g c P γ =
---   pair
---     ( precompose-lifts P (pr1 c) γ)
---     ( pair
---       ( precompose-lifts P (pr1 (pr2 c)) γ)
---       ( triangle-precompose-lifts P (pr2 (pr2 c)) γ))
-
--- is-pullback-cone-family-dependent-pullback-property :
---   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
---   (f : S → A) (g : S → B) (c : cocone f g X) →
---   ({l : Level} → pullback-property-pushout l f g c) →
---   {l : Level} (P : X → UU l) (γ : X → X) →
---   is-pullback
---     ( ( tr (fam-lifts S P) (eq-htpy (γ ·l (pr2 (pr2 c))))) ∘
---       ( precompose-lifts P f (γ ∘ (pr1 c))))
---     ( precompose-lifts P g (γ ∘ (pr1 (pr2 c))))
---     ( cone-family-dependent-pullback-property f g c P γ)
--- is-pullback-cone-family-dependent-pullback-property {S = S} {A} {B} {X}
---   f g (pair i (pair j H)) pb-c P =
---   let c = pair i (pair j H) in
---   is-pullback-family-is-pullback-tot
---     ( fam-lifts S P)
---     ( precompose-lifts P f)
---     ( precompose-lifts P g)
---     ( cone-pullback-property-pushout f g c X)
---     ( cone-family-dependent-pullback-property f g c P)
---     ( pb-c X)
---     ( is-pullback-top-is-pullback-bottom-cube-is-equiv
---       ( precomp i (Σ X P))
---       ( precomp j (Σ X P))
---       ( precomp f (Σ X P))
---       ( precomp g (Σ X P))
---       ( map-Σ (fam-lifts A P) (precomp i X) (precompose-lifts P i))
---       ( map-Σ (fam-lifts B P) (precomp j X) (precompose-lifts P j))
---       ( map-Σ (fam-lifts S P) (precomp f X) (precompose-lifts P f))
---       ( map-Σ (fam-lifts S P) (precomp g X) (precompose-lifts P g))
---       ( map-inv-distributive-Π-Σ)
---       ( map-inv-distributive-Π-Σ)
---       ( map-inv-distributive-Π-Σ)
---       ( map-inv-distributive-Π-Σ)
---       ( htpy-precompose-total-lifts P H)
---       ( refl-htpy)
---       ( refl-htpy)
---       ( refl-htpy)
---       ( refl-htpy)
---       ( htpy-precomp H (Σ X P))
---       ( coherence-inv-htpy-distributive-Π-Σ P H)
---       ( is-equiv-map-inv-distributive-Π-Σ)
---       ( is-equiv-map-inv-distributive-Π-Σ)
---       ( is-equiv-map-inv-distributive-Π-Σ)
---       ( is-equiv-map-inv-distributive-Π-Σ)
---       ( pb-c (Σ X P)))
-
--- dependent-pullback-property-pullback-property-pushout :
---   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
---   (f : S → A) (g : S → B) (c : cocone f g X) →
---   ({l : Level} → pullback-property-pushout l f g c) →
---   ({l : Level} → dependent-pullback-property-pushout l f g c)
--- dependent-pullback-property-pullback-property-pushout
---   {S = S} {A} {B} {X}
---   f g (pair i (pair j H)) pullback-c P =
---   let c = pair i (pair j H) in
---   is-pullback-htpy'
---     -- ( (tr (fam-lifts S P) (eq-htpy (id ·l H))) ∘ (precompose-lifts P f i))
---     ( (tr-eq-htpy-fam-lifts P id H) ·r (precompose-lifts P f i))
---     -- ( precompose-lifts P g j)
---     ( refl-htpy)
---     ( cone-family-dependent-pullback-property f g c P id)
---     { c' = cone-dependent-pullback-property-pushout f g c P}
---     ( pair refl-htpy
---       ( pair refl-htpy
---         ( right-unit-htpy ∙h (coherence-triangle-precompose-lifts P H id))))
---     ( is-pullback-cone-family-dependent-pullback-property f g c pullback-c P id)
-```
-
-This concludes the proof of Theorem 18.1.4.
-
-We give some further useful implications.
-
-```agda
--- dependent-universal-property-universal-property-pushout :
---   { l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
---   ( f : S → A) (g : S → B) (c : cocone f g X) →
---   ( {l : Level} → universal-property-pushout l f g c) →
---   ( {l : Level} → dependent-universal-property-pushout l f g c)
--- dependent-universal-property-universal-property-pushout f g c up-X =
---   dependent-universal-property-dependent-pullback-property-pushout f g c
---     ( dependent-pullback-property-pullback-property-pushout f g c
---       ( pullback-property-pushout-universal-property-pushout f g c up-X))
-```
-
 ## Section 16.2 Families over pushouts
 
 ### Definition 18.2.1

From b2a209fa1429caabf6a0b5d841b182334b55d921 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Sat, 20 Jan 2024 19:15:37 +0100
Subject: [PATCH 15/18] Table for equivalent conditions for being a pushout

---
 .../26-descent.lagda.md                       | 30 -------------------
 ...ndent-universal-property-pushouts.lagda.md |  5 ++++
 .../universal-property-pushouts.lagda.md      | 22 +++-----------
 tables/pushouts.md                            | 17 +++++++++++
 4 files changed, 26 insertions(+), 48 deletions(-)
 create mode 100644 tables/pushouts.md

diff --git a/src/synthetic-homotopy-theory/26-descent.lagda.md b/src/synthetic-homotopy-theory/26-descent.lagda.md
index 632c1e795c..79e084feb2 100644
--- a/src/synthetic-homotopy-theory/26-descent.lagda.md
+++ b/src/synthetic-homotopy-theory/26-descent.lagda.md
@@ -47,36 +47,6 @@ open import synthetic-homotopy-theory.universal-property-pushouts
 
 </details>
 
-### Remark 18.1.3 Computation of the identity type of `dependent-cocone`
-
-Before we state the main theorem of this section, we also state a dependent
-version of the pullback property of pushouts.
-
-## Theorem 18.1.4
-
-    The following properties are all equivalent:
-
-    1. universal-property-pushout
-    2. pullback-property-pushout
-    3. dependent-pullback-property-pushout
-    4. dependent-universal-property-pushout
-    5. Ind-pushout
-
-We have already shown (1) ↔ (2). Therefore we will first show (3) ↔ (4) ↔ (5).
-Finally, we will show (2) ↔ (3). Here are the precise references to the proofs
-of those parts:
-
-- Proof of (1) → (2): `pullback-property-pushout-universal-property-pushout`
-- Proof of (2) → (1): `universal-property-pushout-pullback-property-pushout`
-- Proof of (2) → (3): `dependent-pullback-property-pullback-property-pushout`
-- Proof of (3) → (2): `pullback-property-dependent-pullback-property-pushout`
-- Proof of (3) → (4):
-  `dependent-universal-property-dependent-pullback-property-pushout`
-- Proof of (4) → (3):
-  `dependent-pullback-property-dependent-universal-property-pushout`
-- Proof of (4) → (5): `Ind-pushout-dependent-universal-property-pushout`
-- Proof of (5) → (4): `dependent-universal-property-pushout-Ind-pushout`
-
 ## Section 16.2 Families over pushouts
 
 ### Definition 18.2.1
diff --git a/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
index 79641566e3..23a340bb74 100644
--- a/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/dependent-universal-property-pushouts.lagda.md
@@ -232,6 +232,11 @@ dependent-universal-property-dependent-pullback-property-pushout
 
 ### The non-dependent and dependent universal property of pushouts are logically equivalent
 
+This follows from the fact that the
+[dependent pullback property of pushouts](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md)
+is logically equivalent to the
+[pullback property of pushouts](synthetic-homotopy-theory.pullback-property-pushouts.md).
+
 ```agda
 module _
   {l1 l2 l3 l4 : Level} {S : UU l1} {A : UU l2} {B : UU l3} {X : UU l4}
diff --git a/src/synthetic-homotopy-theory/universal-property-pushouts.lagda.md b/src/synthetic-homotopy-theory/universal-property-pushouts.lagda.md
index 5c419dde39..61273f1b7b 100644
--- a/src/synthetic-homotopy-theory/universal-property-pushouts.lagda.md
+++ b/src/synthetic-homotopy-theory/universal-property-pushouts.lagda.md
@@ -59,24 +59,10 @@ map is an equivalence:
 ```
 
 There are several ways of asserting a condition equivalent to the universal
-property of pushouts:
-
-1. The universal property of pushouts
-2. The
-   [pullback property of pushouts](synthetic-homotopy-theory.pullback-property-pushouts.md).
-   This is a restatement of the universal property of pushouts in terms of
-   pullbacks.
-3. The
-   [dependent universal property of pushouts](synthetic-homotopy-theory.dependent-universal-property-pushouts.md).
-   This property characterizes _dependent_ functions out of a pushout
-4. The
-   [dependent pullback property of pushouts](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md).
-   This is a restatement of the dependent universal property of pushouts in
-   terms of pullbacks
-5. The
-   [induction principle of pushouts](synthetic-homotopy-theory.induction-principle-pushouts.md).
-   This weaker form of the dependent universal property of pushouts expresses
-   the induction principle of pushouts seen as higher inductive types.
+property of pushouts. The statements and proofs of mutual equivalence may be
+found in the following table:
+
+{{#include tables/pushouts.md}}
 
 ## Definition
 
diff --git a/tables/pushouts.md b/tables/pushouts.md
new file mode 100644
index 0000000000..f397b801f5
--- /dev/null
+++ b/tables/pushouts.md
@@ -0,0 +1,17 @@
+| Concept                                                                                                          | Location                                                                                                                                 |
+| ---------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
+| (1) **Universal property of pushouts**<br>characterizes functions out of a pushout                               | [`synthetic-homotopy-theory.universal-property-pushouts`](synthetic-homotopy-theory.universal-property-pushouts.md)                      |
+| (2) **Dependent universal property of pushouts**<br>characterizes dependent functions out of a pushout           | [`synthetic-homotopy-theory.dependent-universal-property-pushouts`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md)  |
+| (3) **Pullback property of pushouts**<br>states the universal property in terms of pullbacks                     | [`synthetic-homotopy-theory.pullback-property-pushouts`](synthetic-homotopy-theory.pullback-property-pushouts.md)                        |
+| (4) **Dependent pullback property of pushouts**<br>states the dependent universal property in terms of pullbacks | [`synthetic-homotopy-theory.dependent-pullback-property-pushouts`](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md)    |
+| (5) **Induction principle of pushouts**<br>is the induction principle of pushouts seen as higher inductive types | [`synthetic-homotopy-theory.induction-principle-pushouts`](synthetic-homotopy-theory.induction-principle-pushouts.md)                    |
+| (1) → (2)                                                                                                        | [`dependent-universal-property-universal-property-pushouts`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md)         |
+| (2) → (1)                                                                                                        | [`universal-property-dependent-universal-property-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md)          |
+| (1) → (3)                                                                                                        | [`pullback-property-pushout-universal-property-pushout`](synthetic-homotopy-theory.universal-property-pushouts.md)                       |
+| (3) → (1)                                                                                                        | [`universal-property-pushout-pullback-property-pushout`](synthetic-homotopy-theory.universal-property-pushouts.md)                       |
+| (2) → (4)                                                                                                        | [`dependent-pullback-property-dependent-universal-property-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md) |
+| (4) → (2)                                                                                                        | [`dependent-universal-property-dependent-pullback-property-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md) |
+| (3) → (4)                                                                                                        | [`dependent-pullback-property-pullback-property-pushout`](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md)             |
+| (4) → (3)                                                                                                        | [`pullback-property-dependent-pullback-property-pushout`](synthetic-homotopy-theory.dependent-pullback-property-pushouts.md)             |
+| (2) → (5)                                                                                                        | [`induction-principle-pushout-dependent-universal-property-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md) |
+| (5) → (2)                                                                                                        | [`dependent-universal-property-pushout-induction-principle-pushout`](synthetic-homotopy-theory.dependent-universal-property-pushouts.md) |

From d887713e18995b71d5b1ecd78b42f7518e054740 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Sun, 21 Jan 2024 16:06:11 +0100
Subject: [PATCH 16/18] Make a diagram less ambiguous

---
 .../functoriality-dependent-pair-types.lagda.md | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/src/foundation/functoriality-dependent-pair-types.lagda.md b/src/foundation/functoriality-dependent-pair-types.lagda.md
index 2bce2ead04..c3a07e1526 100644
--- a/src/foundation/functoriality-dependent-pair-types.lagda.md
+++ b/src/foundation/functoriality-dependent-pair-types.lagda.md
@@ -67,14 +67,15 @@ of
 [commuting triangles of identifications](foundation.commuting-triangles-of-identifications.md)
 
 ```text
-                      ap (tr D - (g a c)) (α a)
-  tr D (H a) (g a c) --------------------------- tr D (H' a) (g a c)
-                     \                         /
-                        \                   /
-                   K a c   \             /   K' a c
-                              \       /
-                                 \ /
-                               g' a c         .
+                      ap (λ p → tr D p (g a c)) (α a)
+  tr D (H a) (g a c) --------------------------------- tr D (H' a) (g a c)
+                     \                               /
+                        \                         /
+                           \                   /
+                      K a c   \             /   K' a c
+                                 \       /
+                                   \ /
+                                 g' a c         .
 ```
 
 ```agda

From 8d480b72c8483b2962507602ec4ba236009b9997 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Tue, 23 Jan 2024 17:23:20 +0100
Subject: [PATCH 17/18] Prose fixes

---
 .../functoriality-dependent-pair-types.lagda.md      | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/foundation/functoriality-dependent-pair-types.lagda.md b/src/foundation/functoriality-dependent-pair-types.lagda.md
index c3a07e1526..456ba36e76 100644
--- a/src/foundation/functoriality-dependent-pair-types.lagda.md
+++ b/src/foundation/functoriality-dependent-pair-types.lagda.md
@@ -48,11 +48,11 @@ over `H`, expressed as
 
 ```text
         g a
-    C a ----> D (f a)
-      \     /
-  g' a \   / tr D (H a)
-        V V
-       D (f' a)         ,
+   C a -----> D (f a)
+      \      /
+  g' a \    / tr D (H a)
+        V  V
+      D (f' a)         ,
 ```
 
 we get a homotopy `htpy-map-Σ H K : map-Σ f g ~ map-Σ f' g'`.
@@ -61,7 +61,7 @@ This assignment itself preserves homotopies: given `H` and `K` as above,
 `H' : f ~ f'` with `K' a : g a ~ g' a` over `H'`, we would like to express
 coherences between the pairs `H, H'` and `K, K'` which would ensure
 `htpy-map-Σ H K ~ htpy-map-Σ H' K'`. Because `H` and `H'` have the same type, we
-may require a homotopy `H ~ H'`, but `K` and `K'` are families of dependent
+may require a homotopy `α : H ~ H'`, but `K` and `K'` are families of dependent
 homotopies over different homotopies, so their coherence is provided as a family
 of
 [commuting triangles of identifications](foundation.commuting-triangles-of-identifications.md)

From 5741aaee776dc6a500ed66ea06df2e713d489255 Mon Sep 17 00:00:00 2001
From: VojtechStep <vojtechstepancik@outlook.com>
Date: Sat, 27 Jan 2024 18:09:31 +0100
Subject: [PATCH 18/18] Review suggestions

---
 ...unctoriality-dependent-pair-types.lagda.md | 29 ++++++++-------
 .../precomposition-type-families.lagda.md     | 30 ++++++++--------
 ...ype-theoretic-principle-of-choice.lagda.md |  4 +++
 .../lifts-families-of-elements.lagda.md       | 14 ++++----
 ...sition-lifts-families-of-elements.lagda.md | 36 +++++++++----------
 5 files changed, 61 insertions(+), 52 deletions(-)

diff --git a/src/foundation/functoriality-dependent-pair-types.lagda.md b/src/foundation/functoriality-dependent-pair-types.lagda.md
index 456ba36e76..cdf87ea21b 100644
--- a/src/foundation/functoriality-dependent-pair-types.lagda.md
+++ b/src/foundation/functoriality-dependent-pair-types.lagda.md
@@ -74,28 +74,28 @@ of
                            \                   /
                       K a c   \             /   K' a c
                                  \       /
-                                   \ /
-                                 g' a c         .
+                                    \ /
+                                  g' a c        .
 ```
 
 ```agda
 module _
-  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {C : A → UU l3}
-  (D : B → UU l4)
+  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {C : A → UU l3} (D : B → UU l4)
+  {f f' : A → B} {H H' : f ~ f'}
+  {g : (a : A) → C a → D (f a)}
+  {g' : (a : A) → C a → D (f' a)}
+  {K : (a : A) → dependent-homotopy (λ _ → D) (λ _ → H a) (g a) (g' a)}
+  {K' : (a : A) → dependent-homotopy (λ _ → D) (λ _ → H' a) (g a) (g' a)}
   where
 
   abstract
     htpy-htpy-map-Σ :
-      {f f' : A → B} {H H' : f ~ f'} →
-      {g : (a : A) → C a → D (f a)} {g' : (a : A) → C a → D (f' a)} →
-      {K : (a : A) → dependent-homotopy (λ _ → D) (λ _ → H a) (g a) (g' a)} →
-      {K' : (a : A) → dependent-homotopy (λ _ → D) (λ _ → H' a) (g a) (g' a)} →
       (α : H ~ H') →
       (β :
         (a : A) (c : C a) →
         K a c ＝ ap (λ p → tr D p (g a c)) (α a) ∙ K' a c) →
       htpy-map-Σ D H g K ~ htpy-map-Σ D H' g K'
-    htpy-htpy-map-Σ {g = g} {g'} {K} {K'} α β (a , c) =
+    htpy-htpy-map-Σ α β (a , c) =
       ap
         ( eq-pair-Σ')
         ( eq-pair-Σ
@@ -118,15 +118,20 @@ As a corollary of the above statement, we can provide a condition which
 guarantees that `htpy-map-Σ` is homotopic to the trivial homotopy.
 
 ```agda
+module _
+  {l1 l2 l3 l4 : Level} {A : UU l1} {B : UU l2} {C : A → UU l3} (D : B → UU l4)
+  {f : A → B} {H : f ~ f}
+  {g : (a : A) → C a → D (f a)}
+  {K : (a : A) → tr D (H a) ∘ g a ~ g a}
+  where
+
   abstract
     htpy-htpy-map-Σ-refl-htpy :
-      {f : A → B} {H : f ~ f} →
-      {g : (x : A) → C x → D (f x)} {K : (a : A) → tr D (H a) ∘ g a ~ g a} →
       (α : H ~ refl-htpy) →
       (β : (a : A) (c : C a) → K a c ＝ ap (λ p → tr D p (g a c)) (α a)) →
       htpy-map-Σ D H g K ~ refl-htpy
     htpy-htpy-map-Σ-refl-htpy α β =
-      htpy-htpy-map-Σ α (λ a c → β a c ∙ inv right-unit)
+      htpy-htpy-map-Σ D α (λ a c → β a c ∙ inv right-unit)
 ```
 
 ### The map on total spaces induced by a family of truncated maps is truncated
diff --git a/src/foundation/precomposition-type-families.lagda.md b/src/foundation/precomposition-type-families.lagda.md
index 7bbe49673e..c257e0b17c 100644
--- a/src/foundation/precomposition-type-families.lagda.md
+++ b/src/foundation/precomposition-type-families.lagda.md
@@ -46,7 +46,7 @@ module _
 
 ## Properties
 
-### Transport in precomposed type families
+### Transport along homotopies in precomposed type families
 
 [Transporting](foundation.transport-along-homotopies.md) along a
 [homotopy](foundation.homotopies.md) `H : g ~ h` in the family `Q ∘ f` gives us
@@ -65,25 +65,25 @@ module _
   {X : UU l4} {g : X → A}
   where
 
-  statement-tr-precomp-family :
+  statement-tr-htpy-precomp-family :
     {h : X → A} (H : g ~ h) → UU (l3 ⊔ l4)
-  statement-tr-precomp-family H =
+  statement-tr-htpy-precomp-family H =
     tr-htpy (λ _ → precomp-family f Q) H ~ tr-htpy (λ _ → Q) (f ·l H)
 
-  tr-precomp-family :
-    {h : X → A} (H : g ~ h) →
-    statement-tr-precomp-family H
-  tr-precomp-family =
-    ind-htpy g
-      ( λ h → statement-tr-precomp-family)
-      ( refl-htpy)
-
   abstract
-    compute-tr-precomp-family :
-      tr-precomp-family refl-htpy ＝
+    tr-htpy-precomp-family :
+      {h : X → A} (H : g ~ h) →
+      statement-tr-htpy-precomp-family H
+    tr-htpy-precomp-family =
+      ind-htpy g
+        ( λ h → statement-tr-htpy-precomp-family)
+        ( refl-htpy)
+
+    compute-tr-htpy-precomp-family :
+      tr-htpy-precomp-family refl-htpy ＝
       refl-htpy
-    compute-tr-precomp-family =
+    compute-tr-htpy-precomp-family =
       compute-ind-htpy g
-        ( λ h → statement-tr-precomp-family)
+        ( λ h → statement-tr-htpy-precomp-family)
         ( refl-htpy)
 ```
diff --git a/src/foundation/type-theoretic-principle-of-choice.lagda.md b/src/foundation/type-theoretic-principle-of-choice.lagda.md
index 031a9289b0..605aec74bc 100644
--- a/src/foundation/type-theoretic-principle-of-choice.lagda.md
+++ b/src/foundation/type-theoretic-principle-of-choice.lagda.md
@@ -37,6 +37,10 @@ In this file we record some further facts about the
 [structures](foundation.structure.md) introduced in
 [`foundation-core.type-theoretic-principle-of-choice`](foundation-core.type-theoretic-principle-of-choice.md).
 
+We relate precomposition of maps into a dependent pair type by a function with
+precomposition in dependent pair types of functions in the file
+[`orthogonal-factorization-systems.precomposition-lifts-families-of-elements`](orthogonal-factorization-systems.precomposition-lifts-families-of-elements.md).
+
 ## Lemma
 
 ### Characterizing the identity type of `universally-structured-Π`
diff --git a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
index 6208bccc7e..c0e5399585 100644
--- a/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/lifts-families-of-elements.lagda.md
@@ -194,14 +194,14 @@ module _
       ( λ p → tr (lift-family-of-elements B) p b)
       ( compute-htpy-precomp-refl-htpy f A a)
 
-  tr-lift-family-of-elements-precomp :
-    {g : J → I} (H : f ~ g) → statement-tr-lift-family-of-elements-precomp H
-  tr-lift-family-of-elements-precomp =
-    ind-htpy f
-      ( λ g → statement-tr-lift-family-of-elements-precomp)
-      ( tr-lift-family-of-elements-precomp-refl-htpy)
-
   abstract
+    tr-lift-family-of-elements-precomp :
+      {g : J → I} (H : f ~ g) → statement-tr-lift-family-of-elements-precomp H
+    tr-lift-family-of-elements-precomp =
+      ind-htpy f
+        ( λ g → statement-tr-lift-family-of-elements-precomp)
+        ( tr-lift-family-of-elements-precomp-refl-htpy)
+
     compute-tr-lift-family-of-elements-precomp :
       tr-lift-family-of-elements-precomp refl-htpy ＝
       tr-lift-family-of-elements-precomp-refl-htpy
diff --git a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
index 1c3af98afd..1cc89a4539 100644
--- a/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
+++ b/src/orthogonal-factorization-systems/precomposition-lifts-families-of-elements.lagda.md
@@ -49,7 +49,7 @@ In other words, given a diagram
        f         a
 ```
 
-we get a map of diagonals
+we get a map of lifts of families of elements
 
 ```text
   ((i : I) → B (a i)) → ((j : J) → B (a (f j))) .
@@ -133,15 +133,15 @@ module _
   triangle-precomp-lift-family-of-elements-htpy-refl-htpy b =
     tr-lift-family-of-elements-precomp B a refl-htpy (b ∘ f)
 
-  triangle-precomp-lift-family-of-elements-htpy :
-    {g : J → I} (H : f ~ g) →
-    statement-triangle-precomp-lift-family-of-elements-htpy H
-  triangle-precomp-lift-family-of-elements-htpy =
-    ind-htpy f
-      ( λ g → statement-triangle-precomp-lift-family-of-elements-htpy)
-      ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
-
   abstract
+    triangle-precomp-lift-family-of-elements-htpy :
+      {g : J → I} (H : f ~ g) →
+      statement-triangle-precomp-lift-family-of-elements-htpy H
+    triangle-precomp-lift-family-of-elements-htpy =
+      ind-htpy f
+        ( λ g → statement-triangle-precomp-lift-family-of-elements-htpy)
+        ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy)
+
     compute-triangle-precomp-lift-family-of-elements-htpy :
       triangle-precomp-lift-family-of-elements-htpy refl-htpy ＝
       triangle-precomp-lift-family-of-elements-htpy-refl-htpy
@@ -183,16 +183,16 @@ module _
       ( triangle-precomp-lift-family-of-elements-htpy-refl-htpy B a b)
       ( inv (eq-htpy-refl-htpy (b ∘ f))))
 
-  coherence-triangle-precomp-lift-family-of-elements :
-    {g : J → I} (H : f ~ g) →
-    statement-coherence-triangle-precomp-lift-family-of-elements H
-  coherence-triangle-precomp-lift-family-of-elements =
-    ind-htpy f
-      ( λ g →
-        statement-coherence-triangle-precomp-lift-family-of-elements)
-      ( coherence-triangle-precomp-lift-family-of-elements-refl-htpy)
-
   abstract
+    coherence-triangle-precomp-lift-family-of-elements :
+      {g : J → I} (H : f ~ g) →
+      statement-coherence-triangle-precomp-lift-family-of-elements H
+    coherence-triangle-precomp-lift-family-of-elements =
+      ind-htpy f
+        ( λ g →
+          statement-coherence-triangle-precomp-lift-family-of-elements)
+        ( coherence-triangle-precomp-lift-family-of-elements-refl-htpy)
+
     compute-coherence-triangle-precomp-lift-family-of-elements :
       coherence-triangle-precomp-lift-family-of-elements refl-htpy ＝
       coherence-triangle-precomp-lift-family-of-elements-refl-htpy
