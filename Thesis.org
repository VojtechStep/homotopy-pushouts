#+TITLE: Formalization of Homotopy Pushouts in Homotopy Type Theory
#+AUTHOR: Vojtěch Štěpančík
#+KEYWORDS: synthetic homotopy theory, homotopy type theory, univalent foundations of mathematics, formalization, homotopy pushouts
#+DESCRIPTION: Homotopy pushouts can be constructed as higher inductive types in Homotopy Type Theory, and their properties
#+DESCRIPTION: may be explored using the logical framework and formalized in a proof assitant. This thesis focuses on
#+DESCRIPTION: the descent property, characterizing type families over pushouts, and the flattening lemma, characterizing
#+DESCRIPTION: the total spaces of such families. We then use the built machinery to provide the first fully formalized
#+DESCRIPTION: proof of Wärn's zigzag construction of identity types of pushouts as sequential colimits.

# Document settings
#+LATEX_COMPILER: lualatex
#+BIBLIOGRAPHY: ./bibliography.bib
#+CITE_EXPORT: biblatex iso-numeric,sorting=nyt,maxcitenames=3,backref=true,useprefix=true
#+LATEX_CLASS: report
#+LATEX_CLASS_OPTIONS: [12pt,a4paper,twoside,openright]
#+OPTIONS: title:nil toc:nil ':t

# Package options, derived partially from the thesis template
#+LATEX_HEADER: \geometry{margin=25mm,bindingoffset=14.2mm}
#+LATEX_HEADER: \let\openright=\cleardoublepage
#+LATEX_HEADER: \hypersetup{unicode,breaklinks=true,pdfapart=2,pdfaconformance=U}
#+LATEX_HEADER: \usetikzlibrary{decorations.pathmorphing}
#+LATEX_HEADER: \input{tex/pdfa.tex}

# Highlight overfull
#+LATEX_HEADER: \overfullrule=1mm

#+LATEX_HEADER: \newcommand{\TODO}[1][]{{\leavevmode\color{red}{\ifthenelse{\equal{#1}{}}{TODO}{#1}}}}

#+LATEX_HEADER: \newcommand{\ie}{i.e.~}
#+LATEX_HEADER: \newcommand{\eg}{e.g.~}

#+MACRO: AU [[https://unimath.github.io/agda-unimath/][agda-unimath]]
#+MACRO: AURepo [[https://github.com/UniMath/agda-unimath][repository]]

#+MACRO: PR (eval (let* ((full-name (concat $1 "-" $2 ".patch")) (path (concat "attachments/" full-name))) (if (file-exists-p path) (concat "=" full-name "= ([[https://github.com/UniMath/agda-unimath/pull/" $1 "][PR]])") (error (concat "File does not exist: " path)))))

#+LATEX_HEADER: \newcommand{\DeclareBinOperator}[2]{\newcommand{#1}{\mathbin{#2}}}

# Syntax macros
#+LATEX_HEADER: \newcommand{\blank}{{-}}
#+LATEX_HEADER: \newcommand{\typeformer}[1]{\operatorname{#1}}
#+LATEX_HEADER: \newcommand{\constructor}[1]{\operatorname{#1}}
#+LATEX_HEADER: \newcommand{\defterm}[1]{\operatorname{#1}}
#+LATEX_HEADER: \newcommand{\term}[1]{\operatorname{#1}}
#+LATEX_HEADER: \DeclareMathOperator{\id}{id}
# #+LATEX_HEADER: \newcommand{\defeq}{\mathrel{:=}}
#+LATEX_HEADER: \DeclareBinOperator{\defeq}{:=}
#+LATEX_HEADER: \DeclareBinOperator{\judeq}{\doteq}
#+LATEX_HEADER: \DeclareBinOperator{\comp}{\circ}

#+LATEX_HEADER: \DeclareMathOperator{\equivEq}{equiv-eq}

#+LATEX_HEADER: \DeclareMathOperator{\Id}{Id}
#+LATEX_HEADER: \DeclareMathOperator{\refl}{refl}
#+LATEX_HEADER: \DeclareBinOperator{\concat}{\bullet}
#+LATEX_HEADER: \DeclareMathOperator{\lunit}{lunit}
#+LATEX_HEADER: \DeclareMathOperator{\runit}{runit}
#+LATEX_HEADER: \DeclareMathOperator{\tr}{tr}
#+LATEX_HEADER: \DeclareMathOperator{\ap}{ap}
#+LATEX_HEADER: \DeclareMathOperator{\apd}{apd}

#+LATEX_HEADER: \DeclareBinOperator{\htpy}{\sim}
#+LATEX_HEADER: \DeclareMathOperator{\reflhtpy}{refl-htpy}
#+LATEX_HEADER: \DeclareBinOperator{\hconcat}{\concat_h}
#+LATEX_HEADER: \DeclareMathOperator{\eqHtpy}{eq-htpy}
#+LATEX_HEADER: \DeclareBinOperator{\lwhisk}{\cdot_{l}}
#+LATEX_HEADER: \DeclareBinOperator{\rwhisk}{\cdot_{r}}

#+LATEX_HEADER: \newcommand{\N}{\mathbb{N}}

# Products
#+LATEX_HEADER: \DeclareMathOperator{\pr}{pr}

# Pushouts/coproducts
#+LATEX_HEADER: \DeclareMathOperator{\inl}{inl}
#+LATEX_HEADER: \DeclareMathOperator{\inr}{inr}
#+LATEX_HEADER: \newcommand{\codiag}{\nabla}
#+LATEX_HEADER: \newcommand{\coprodM}[2]{\left[#1, #2\right]}
#+LATEX_HEADER: \DeclareMathOperator{\cocone}{cocone}
#+LATEX_HEADER: \DeclareMathOperator{\coconeMap}{cocone-map}
#+LATEX_HEADER: \DeclareMathOperator{\depCocone}{dep-cocone}
#+LATEX_HEADER: \DeclareMathOperator{\depCoconeMap}{dep-cocone-map}
#+LATEX_HEADER: \DeclareMathOperator{\incl}{incl}

# Apparently unicode-math doesn't fix \Sigma in operator font,
# so use the "fixed" mupSigma command
# https://tex.stackexchange.com/questions/477662/fontspec-breaks-capital-greek-letters-in-declaremathoperator
#+LATEX_HEADER: \DeclareMathOperator{\uncurry}{ind-\mupSigma}
#+LATEX_HEADER: \DeclareMathOperator{\tot}{tot}

# Object macros
#+LATEX_HEADER: \newcommand{\POData}[2]{\typeformer{Pushout}\;#1\;#2}
#+LATEX_HEADER: \newcommand{\PO}[3]{#2 \sqcup_{#1} #3}
#+LATEX_HEADER: \renewcommand{\S}{\mathcal{S}}

#+LATEX_HEADER: \newcommand{\D}{\mathcal{D}}
#+LATEX_HEADER: \DeclareMathOperator{\cofork}{cofork}
#+LATEX_HEADER: \DeclareMathOperator{\coforkMap}{cofork-map}
#+LATEX_HEADER: \DeclareMathOperator{\depCofork}{dep-cofork}
#+LATEX_HEADER: \DeclareMathOperator{\depCoforkMap}{dep-cofork-map}
#+LATEX_HEADER: \DeclareMathOperator{\spanDoubleArrow}{span-double-arrow}
#+LATEX_HEADER: \DeclareMathOperator{\coconeCofork}{cocone-cofork}
#+LATEX_HEADER: \DeclareMathOperator{\depCoconeDepCofork}{dep-cocone-dep-cofork}

# Universes
#+LATEX_HEADER: \newcommand{\UU}{\mathcal{U}}
#+LATEX_HEADER: \newcommand{\UV}{\mathcal{V}}
#+LATEX_HEADER: \newcommand{\UW}{\mathcal{W}}

# Descent data
#+LATEX_HEADER: \newcommand{\DD}{\term{DD}}
#+LATEX_HEADER: \newcommand{\ddFam}{\term{dd-fam}}
#+LATEX_HEADER: \newcommand{\correspDD}{\approx}

#+LATEX_HEADER: \newcommand{\sectDD}{\term{sect}}
#+LATEX_HEADER: \newcommand{\evreflidsystemDD}{\term{ev-refl-id-system-DD}}
#+LATEX_HEADER: \newcommand{\indidsystemDD}{\term{ind-Q}}

# Title page
#+begin_export latex
\def\Department{Department of Algebra}
\def\ThesisSupervisor{doctor Egbert Rijke}
\def\StudyProgramme{Mathematical Structures}
\def\StudyBranch{MSPN}
\def\YearSubmitted{2024}
\def\Dedication{
DEDICATION
}
\include{tex/title.tex}
\tableofcontents
#+end_export

# Theorem environments
#+begin_export latex
\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newaliascnt{lemma}{thm}
\newtheorem{lemma}[lemma]{Lemma}
\aliascntresetthe{lemma}
\newaliascnt{corol}{thm}
\newtheorem{corol}[corol]{Corollary}
\aliascntresetthe{corol}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newaliascnt{constr}{defn}
\newtheorem{constr}[constr]{Construction}
\aliascntresetthe{constr}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\def\thmautorefname{Theorem}
\def\lemmaautorefname{Lemma}
\def\corolautorefname{Corollary}
\def\defnautorefname{Definition}
\def\constructorautorefname{Construction}
#+end_export

* Introduction
:PROPERTIES:
:UNNUMBERED: t
:END:

 Homotopy Type Theory [cite//b:@UF13] is a logical framework built on Martin-Löf's type theory and the univalence axiom, which characterizes identity types of universes. It is inspired by the homotopy interpretation of dependent type theory, in which types are interpreted as spaces, elements of types as points in the spaces, and identifications of elements as paths between the points. Using proof assistants such as Agda [cite//b:@Agda], one can translate proofs in Homotopy Type Theory into programs in a programming language, engaging in an activity called "formalization". The validity of the constructions is verified by type-checking the programs.

 In this setting, one can define higher inductive types (HITs), by specifying both /point/ constructors, and higher /path/ constructors of the type. Homotopy pushouts are examples of HITs — given types $S, A, B$ and maps $f : S → A$, $g : S → B$, we define $\POData{f}{g}$ to be the higher inductive type with point constructors

 \begin{align*}
   \constructor{inl} &: A \to \POData{f}{g} \\
   \constructor{inr} &: B \to \POData{f}{g}
 \end{align*}

 and a path constructor

 \begin{align*}
   \constructor{glue} : (s : S) \to \constructor{inl}(f s) =_{\POData{f}{g}} \constructor{inr}(g s)
 \end{align*}

 This work focuses on homotopy pushouts \mdash specifically we provide an exposition and formalization of the descent property and flattening lemma, and use the built infrastructure to formally prove correctness of Wärn's zigzag construction of identity types of pushouts.

 \TODO[We build more infrastructure than strictly necessary for sequential colimits, since we anticipate it will be useful when formalizing applications of the zigzag construction. The formalized material comes from SvDR20, and as a byproduct we started an effort to collect pages for formalization of results from the literature. Even though it is not of mathematical nature, it is relevant to the formalization aspect, as it builds more documentation, makes the development accessible, and sets an example for beginning formalizers].

 \TODO[Mention that David writes "At the time of writing, no such formalisation has been carried out, but we believe it would be feasible and worthwhile". But it's in the categorical paper?]

 \TODO[Contributions: Chapter 1 and first section of chapter 2 consist of exposition to material that had already been formalized in the library. Formalization of all other parts of the thesis are original contributions to the library. The uniform treatment of sections of descent data, its application to identity systems in terms of descent data, the presented proof of the flattening lemma, and the proof of correctness of the zigzag construction is original research.]

* Homotopy Type Theory

#+NAME: lemma:is-equiv-concat
#+begin_lemma
\TODO[is-equiv concat].
#+end_lemma

#+NAME: lemma:tr-id-right
#+begin_lemma
\TODO[tr-id-right].
#+end_lemma

#+NAME: lemma:is-equiv-tr
#+begin_lemma
For every type $A$, type family $B : A \to \UU$, two elements $x, y : A$ and an identification $p : x = y$, the transport map $\tr_P p : B x \to B y$ is an equivalence.
#+end_lemma

#+begin_proof
\TODO
#+end_proof

#+NAME: lemma:compute-equiv-eq-ap
#+begin_lemma
\TODO[transport is equiv-eq(ap)].
#+end_lemma

#+NAME: lemma:fundamental-theorem-id
#+ATTR_LATEX: :options [Fundamental theorem of identity types]
#+begin_lemma
\TODO[Fundamental theorem of identity types]
#+end_lemma

#+NAME: lemma:3for2-equiv
#+ATTR_LATEX: :options [3-for-2 property of equivalences]
#+begin_lemma
Consider a commuting triangle of maps
#+begin_center
\begin{tikzcd}
  A \arrow[rr, "f"] \arrow[rd, "h"'] & & B \arrow[ld, "g"] \\
  & C.
\end{tikzcd}

If any two of the maps are equivalences, then so is the third.
#+end_center
#+end_lemma

#+begin_proof
\TODO
#+end_proof

#+NAME: lemma:distributive-pi-sigma
#+begin_lemma
\TODO[Distributivity of Pi over Sigma].
#+end_lemma

** Higher inductive types

\TODO[Does this even deserve a chapter? Or should it be assimilated into "Pushouts"?]

* Pushouts

\TODO[Decide how to treat and write "span" vs "span diagram"].

\TODO[We differentiate between the concept of a "span", which is an element on a structure with a fixed domain and codomain, and a "span diagram", which is a pair of types with a span between them. The distinction is important when looking at morphisms of these structures --- a morphism of spans is a map between the spanning types, equipped with two homotopies for the appropriate triangles, while a morphism of span diagrams is a natural transformation. The presented material does not formally require the notion of spans, so we introduce span diagrams as the primitive notion. A similar distinction may be done between "cocone structure" with a specific vertex, and a "cocone". It is not realized in the current work, but there are plans to make the change in the library].

#+begin_defn
A *span diagram* is a quintuple $(A, B, S, f, g)$, where $A : \UU$, $B : \UV$ and $S : \UW$ are types, and $f : S \to A$ and $g : S \to B$ are ordinary maps.

We call $A$, $B$ and $S$ the *domain*, *codomain*, and the *spanning type* of the span diagram, respectively.
#+end_defn

#+begin_remark
\TODO[This might be a bad idea:] In the prose, we will often write $\S$ or $\S \judeq (f, g)$ for a span diagram, implicitly introducing the relevant types as the domains and codomains of the maps $f$ and $g$, which will by convention be called $A$, $B$ and $S$ as in the definition. We hope to not cause confusion by this choice.
#+end_remark

#+begin_defn
Given a span diagram $\S \judeq (f, g)$ and a type $X : \UU$, a *cocone* under $\S$ on $X$ is a triple $(i, j, H)$, where $i : A \to X$ and $j : B \to X$ are ordinary maps, and $H$ is a homotopy witnessing that the square
#+begin_center
\begin{tikzcd}
  S \arrow[r, "g"] \arrow[d, "f"']
  & B \arrow[d, "j"] \\
  A \arrow[r, "i"']
  & X
\end{tikzcd}
#+end_center
commutes, \ie $H : i \comp f \htpy j \comp g$.

We write $\cocone(\S, X)$ for the type of cocones under $\S$ on $X$.
#+end_defn

\TODO[To define what a "colimiting cocone" is in type theory, we derive inspiration from the categorical description as a classifier of cocones (phrasing?): a cocone $c$ on $X$ is a pushout if maps $X \to Y$ are in bijection with cocones on $Y$. There is a natural construction for extending a cocone $c$ on $X$ by a map $X \to Y$ to a cocone on $Y$, and we say that $c$ is a pushout of $\S$ exactly when this extension map is an equivalence $(X \to Y) \simeq \cocone(\S, Y)$].

#+begin_constr
Given a cocone $c \judeq (i, j, H) : \cocone(\S, X)$ and a type $Y : \UV$ we construct a map
\begin{equation*}
  \coconeMap_c^Y : (X \to Y) \to \cocone(\S, Y)
\end{equation*}
which sends $h$ to $(h \comp i, h \comp j, h \lwhisk H)$.

We may omit the upper index $Y$ or the lower index $c$, or both, if the appropriate value is clear from context.
#+end_constr

#+begin_defn
A cocone $c$ under $\S$ on $X$ satisfies the *universal property of pushouts* if for all $Y : \UV$, the map $\coconeMap_c^Y$ is an equivalence.

A cocone satisfying the universal property of pushouts is called a *pushout*. We will sometimes abuse notation and call just the type $X$ the pushout.
#+end_defn

The universal property characterizes simple maps out of the colimit. In dependent type theory, we can also ask about characterizations of /dependent/ maps out of the colimit. To that end we introduce dependent cocones and the dependent universal property.

#+begin_defn
Consider a cocone $c \judeq (i, j, H) : \cocone(\S, X)$ and a type family $P : X \to \UV$. A *dependent cocone* over $c$ on $P$ is a triple $(i', j', H')$, where $i' : (a : A) \to P(i a)$ and $j' : (b : B) \to P(j b)$ are dependent maps over $i$ and $j$, respectively, and $H$ is a \TODO[dependent homotopy] between $i' \comp f$ and $j' \comp g$, \ie a family of identifications
\begin{alignat*}{2}
  H &:&& (s : S) \to i'(f s) =_{H s} j'(g s) \\
    &\judeq\;&& (s : S) \to \tr_P(H s) (i'(f s)) = j'(g s).
\end{alignat*}

We write $\depCocone(c, P)$ for the type of dependent cocones over $c$ on $P$.
#+end_defn

#+begin_constr
Given a cocone $c \judeq (i, j, H) : \cocone(\S, X)$ and a type family $P : X \to \UV$, define a map
\begin{equation*}
  \depCoconeMap_c^P : ((x : X) \to P(x)) \to \depCocone(c, P)
\end{equation*}
which sends $h$ to $(h \comp i, h \comp j, \lambda s \to \apd_h(H s))$.

We may omit the indices $c$ or $P$ if they are clear from context.
#+end_constr

#+begin_defn
A cocone $c : \cocone(\S, X)$ satisfies the *dependent universal property of pushouts* if for all $P : X \to \UV$, the map $\depCoconeMap_c^P$ is an equivalence.
#+end_defn

Note that the dependent universal property isn't a property of dependent cocones, but rather a property of cocones and their extensions by dependent functions.

We don't introduce a new name for cocones satisfying the dependent universal property, because the two properties turn out to be equivalent. The proof relies on the pullback property and the dependent pullback property of pushouts, which relate

#+name: lemma:dup-iff-up-pushout
#+begin_lemma
A cocone $c : \cocone(\S, X)$ satisfies the universal property of pushouts if and only if it satisfies the dependent universal property of pushouts.
#+end_lemma

#+begin_proof
\TODO[Figure out how to skip this proof].
#+end_proof

#+name: remark:universal-properties
#+begin_remark
This equivalence of a non-dependent and dependent universal property is a more general phenomenon. In homotopy type theory, there are often multiple ways of describing universal properties. These expressions usually involve a base sort of objects and dependent objects, which can be equipped with some structure functorial in an appropriate notion of maps and dependent maps.

The functorial action
\begin{equation*}
  \term{fmap} : (X \to Y) \to \term{structure}(X) \to \term{structure}(Y)
\end{equation*}
can have its arguments rearranged so that for every structured object $(X, s)$ and a plain object $Y$, we get an "evaluation" map
\begin{equation*}
  \term{ev-map}_{(X, s)}^Y : (X \to Y) \to \term{structure}(Y).
\end{equation*}
In the dependent case, we get a map
\begin{equation*}
  \term{dep-ev-map}_{(X, s)}^P : ((x : X) \to P(x)) \to \term{dep-structure}((X, s), P).
\end{equation*}

When talking about pushouts, we take the base objects to be types, dependent objects to be type families, and maps and dependent maps to be ordinary functions and dependent functions. The functorial structure on a type $X$ is the structure of a cocone on $X$ under a fixed span $\S$, and the dependent structure on a type family $P : X \to \UV$ over a cocone $c$ on $X$ is the structure of a dependent cocone on $P$ over $c$. The evaluation maps are $\coconeMap$ and $\depCoconeMap$, respectively.

With these general definitions in place, consider a structured object $(X, s)$; we may ask for the following properties to be satisfied:
- Universal property: For every object $Y$, $\term{ev-map}_{(X, s)}^Y$ is an equivalence
- Dependent universal property: For every dependent object $P$, $\term{dep-ev-map}_{(X, s)}^P$ is an equivalence
- Recursion principle and uniqueness: For every object $Y$, $\term{ev-map}_{(X, s)}^Y$ has a unique section
- Induction principle: For every dependent object $P$, $\term{dep-ev-map}_{(X, s)}^P$ has a section

The universal properties correspond to a notion of initiality: the evaluation map is an equivalence if and only if it has contractible fibers, \ie for all structured objects $(X, s)$ and $(Y, t)$, there is a unique map $h : X \to Y$ such that $\term{ev-map}_{(X, s)}^Y h = t$. The condition asks for $h$ to preserve the structure. In other words, the universal property says that $(X, s)$ is the initial object in a hypothetical "category" of structured objects and homomorphisms.

It was first shown by [cite/t:@AGS12] that the four properties are equivalent for a class of examples, where we have objects, type families, ordinary functions, dependent functions, and the (dependent) structures are (fibered) algebras for a polynomial functor. The result was later extended by
[cite/t:@Soj15] to include (fibered) algebras for W-suspensions, a higher inductive analogue of W-types. The structure of a (dependent) cocone can be expressed as a (fibered) algebra of a specific W-suspension, so this result is applicable to [[lemma:dup-iff-up-pushout]], but it hasn't been formalized in the library.

We will rely on informal understanding of this principle when discussing options for formalization of a universal property of the identity types of pushouts in [[#sec:identity-systems]].
#+end_remark

** Descent property

The study of type theoretic descent describes how type families over a colimit and related concepts, such as fiberwise maps or sections, arise as local data with gluing conditions \TODO[source?]. It has been studied to some extent by Rijke in [cite//b:@Rij19] and [cite//b:@Rij22Pre].

The universal property of pushouts characterizes maps out of a pushout to any type in any universe, so in particular maps where the codomain itself is a universe: a type family $P : X \to \UU$ corresponds to a cocone $(P_A, P_B, H)$ where $P_A : A \to \UU$, $P_B : B \to \UU$ are type families, and $H$ is a homotopy in the universe $H : (s : S) \to P_A(f s) = P_B(g s)$. Since identifications in universes are characterized by equivalences via the univalence axiom, we arrive at the definition of descent data:

#+begin_defn
Given a span diagram $\S \defeq (f, g)$, we call *descent data* over $\S$ a triple $(P_A, P_B, P_S)$ consisting of type families
\begin{align*}
  P_A &: A \to \UU \\
  P_B &: B \to \UU \\
\intertext{and a fiberwise equivalence}
  P_S &: (s : S) \to P_A(f s) \simeq P_B(g s).
\end{align*}

We use the notation $\DD(\S)$ for the type of descent data over a span diagram $\S$.
#+end_defn

It may not be immediately clear why "descent data" is an appropriate name for this concept, because there is no apparent downward motion. Traditionally, descent is studied in the context of a collection of objects $X_i$ covering a single object $X$, and local structure on the individual $X_i$'s descending onto $X$, collecting into a global structure, given that the pieces are appropriately compatible on any "overlaps". A pushout $X$ of $\S$ is covered by $A$ and $B$, and the overlaps are encoded in $f$ and $g$. Structure on $A$ and $B$, expressed as type families $P_A$ and $P_B$, "descends" to a structure on $X$ (a type family over $X$). Two elements "overlap" in $X$ if there is an identification between them coming from $S$, and the gluing/compatibility condition exactly requires the local structure of $P_A$ and $P_B$ to agree on such elements, i.e. asks for an equivalence $P_A(f s) \simeq P_B(g s)$.

The first task is to establish an equivalence between type families over a pushout and descent data over its defining span. A map from type families to descent data is easy enough to construct:

#+begin_constr
Given a cocone $c \judeq (i, j, H)$ on $X$, construct a map
\begin{displaymath}
  \ddFam_c : (X \to \UU) \to \DD(\S)
\end{displaymath}
which sends a type family $P : X \to \UU$ to the descent data $(P_A, P_B, P_S)$ obtained by precomposing
\begin{alignat*}{3}
  P_A &\defeq (\lambda a \to P(i a)) &&: A \to \UU \\
  P_B &\defeq (\lambda b \to P(j b)) &&: B \to \UU \\
\intertext{and transporting in $P$}
  P_S &\defeq (\lambda s \to \tr_P (H s)) &\quad&: (s : S) \to P (i (f s)) \simeq P (j (g s)).
\end{alignat*}

Note that $\tr_P (H s)$ is an equivalence by [[lemma:is-equiv-tr]].
#+end_constr

To show that $\ddFam_c$ is an equivalence, we employ a common technique for proving equivalences: construct a commuting diagram involving $\ddFam_c$ in which all other maps are equivalences. By repeated applications of [[lemma:3for2-equiv]], it follows that $\ddFam_c$ is an equivalence.

#+NAME: thm:descent-property
#+ATTR_LATEX: :options [Descent property]
#+begin_thm
Consider a span diagram $\S \defeq (f, g)$ and its pushout cocone $c$ on $X$. Then the map $\ddFam_c$ is an equivalence $(X \to \UU) \simeq \DD(\S)$.
#+end_thm

#+begin_proof
There is a triangle of maps
#+begin_center
\begin{tikzcd}
  (X \to \UU) \arrow[rr, "\coconeMap_c", "\simeq"'] \arrow[dr, "\ddFam_c"']
  && \cocone(\S, \UU) \arrow[dl, "\tot(\tot(\lambda s \to \equivEq))", "\simeq"'] \\
  & \DD(\S).
\end{tikzcd}
#+end_center

The top map is an equivalence by assumption, since $c$ is a pushout. The right map is an equivalence, because the map $\tot(h)$ is an equivalence if and only if $h$ is a fiberwise equivalence, and $\equivEq$ is an equivalence by the univalence axiom \TODO[ref]. By [[lemma:3for2-equiv]], it suffices to show that the triangle commutes to prove that $\ddFam_c$ is an equivalence.

By chasing a type family $P$ along the diagram, we see that we need to provide an identification
\[
  (P \comp i, P \comp j, \lambda s \to \tr_P(H s)) = (P \comp i, P \comp j, \lambda s \to \equivEq(\ap_P(H s))).
\]

The first two components are identical. To identify the third component, we invoke function extensionality \TODO[ref]; then it suffices to prove that for all $s : S$, there is an identification of equivalences
\[
  \tr_P(H s) = \equivEq(\ap_P(H s)),
\]
which is always the case by [[lemma:compute-equiv-eq-ap]] applied to the identification\linebreak ${H s : i(f s) = j(g s)}$.
#+end_proof

A corollary of $\ddFam_c$ being an equivalence is that it has contractible fibers, \ie for any descent data $(P_A, P_B, P_S)$ there is a unique type family $P$ such that $\ddFam_c(P) = (P_A, P_B, P_S)$. We proceed to work on characterization of identifications of descent data to get a more pleasant statement of this theorem. \TODO[phrasing]

#+begin_defn
Consider a span diagram $\S \judeq (f, g)$, and two descent data $(P_A, P_B, P_S)$ and $(Q_A, Q_B, Q_S)$ over it. A *morphism* of descent data between them is a pair of fiberwise maps
\begin{align*}
  h_A &: (a : A) → P_A a → Q_A a\\
  h_B &: (b : B) → P_B b → Q_B b
\end{align*}
equipped with a family of homotopies $h_S$ indexed by $s : S$ making
#+begin_center
\begin{tikzcd}
  P_A(f s) \arrow[r, "h_A(f s)"] \arrow[d, "P_S s"'] & Q_A(f s) \arrow[d, "Q_S s"] \\
  P_B(g s) \arrow[r, "h_B(g s)"'] & Q_B(g s)
\end{tikzcd}
#+end_center
commute.

We write $(h_A, h_B, h_S) : (P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)$.
#+end_defn

Analogously, we define equivalences of descent data.

#+begin_defn
Consider a span diagram $\S \judeq (f, g)$, and two descent data $(P_A, P_B, P_S)$ and $(Q_A, Q_B, Q_S)$ over it. An *equivalence* of descent data between them is a pair of fiberwise equivalences
\begin{align*}
  e_A &: (a : A) → P_A a \simeq Q_A a\\
  e_B &: (b : B) → P_B b \simeq Q_B b
\end{align*}
equipped with a family of homotopies $e_S$ indexed by $s : S$ making
#+begin_center
\begin{tikzcd}
  P_A(f s) \arrow[r, "e_A(f s)"] \arrow[d, "P_S s"'] & Q_A(f s) \arrow[d, "Q_S s"] \\
  P_B(g s) \arrow[r, "e_B(g s)"'] & Q_B(g s)
\end{tikzcd}
#+end_center
commute.

We write $(e_A, e_B, e_S) : (P_A, P_B, P_S) \simeq (Q_A, Q_B, Q_S)$.
#+end_defn

#+begin_remark
\TODO[equivalences with coherence vs hom with is-equiv].
#+end_remark

#+begin_lemma
\TODO[Equivalences characterize identifications]
#+end_lemma

#+attr_latex: [Uniqueness of descent data]
#+begin_thm
Consider a span diagram $\S \judeq (f, g)$ and a pushout cocone $c \judeq (i, j, H)$ on $X$. Then for any descent data $(P_A, P_B, P_S)$ over $\S$, the type of type families $P : X \to \UU$ equipped with equivalences
\begin{align*}
  e_A : (a : A) \to P(i a) \simeq P_A(a) \\
  e_B : (b : B) \to P(j b) \simeq P_B(b)
\end{align*}
and a family of coherences $e_s$
#+begin_center
\begin{tikzcd}
  P(i (f s)) \arrow[r, "e_A(f s)"] \arrow[d, "\tr_P(H s)"'] & P_A(f s) \arrow[d, "P_S s"] \\
  P(j (g s)) \arrow[r, "e_B(g s)"'] & P_B(g s)
\end{tikzcd}
#+end_center
indexed by $s : S$, is contractible.
#+end_thm

#+begin_proof
The type of quadruples $(P, e_A, e_B, e_S)$ is exactly the type of type families $P : X \to \UU$ equipped with an equivalence $(e_A, e_B, e_S) : \ddFam_c(P) \simeq (P_A, P_B, P_S)$. Equivalences of descent data characterize identifications of descent data, so the second part corresponds to an identification $\ddFam_c(P) = (P_A, P_B, P_S)$. Since contractibility is preserved by equivalences, it suffices to show that the type $\Sigma (P : X \to \UU). (\ddFam_c(P) = (P_A, P_B, P_S))$ is contractible. But that is exactly the type of fibers of $\ddFam_c$ over $(P_A, P_B, P_S)$, which are contractible on account of $\ddFam_c$ being an equivalence.
#+end_proof

When relating concepts from the world of type families with concepts from the world of descent data, it can be beneficial to be parametric over the data of a type family $P$ and its "corresponding descent data", meaning some descent data $(P_A, P_B, P_S)$ which is equivalent to the descent data induced by $P$. Of course, by the descent theorem this data is completely determined by either $P$ or $(P_A, P_B, P_S)$ up to identification, but this level of generality allows users to provide their own equivalences for potentially better computational properties. We introduce a shorthand notation.

#+begin_defn
Given a span $\S$ and a cocone $c$ on $X$, we define the type of *families with descent data* to be the type of triples $(P, P', e)$ consisting of a type family $P : X \to \UU$, descent data $P' : \DD(\S)$, and an equivalence of descent data $e : \ddFam_c(P) \simeq P'$.

We write $e : P \correspDD P'$ for a family $P$ with descent data $P'$ related by an equivalence $e$. We also say that $P$ is characterized by $P'$.
#+end_defn

#+begin_remark
\TODO[Note that we don't require $c$ to be a pushout. In subsequent development, and in the formalization, we often parameterize constructions by a family with descent data, which incentivizes general constructions applicable to non-pushout cocones.]
#+end_remark

#+begin_remark
\TODO[Move this to flattening?] The concept of a family with descent data has a direction: the equivalence relates $\ddFam_c(P)$ on the left with $P'$ on the right. It lends itself well to characterizations of concrete type families, where $P$ has a specific shape, and we want to recover the shape of corresponding descent data by computing $P(i a)$'s and $P(j b)$'s. However there are applications where the converse direction is more suitable. In those cases we write $e : P' \correspDD P$ for descent data $P'$, a type family $P$, and an equivalence of descent data $e : P' \simeq \ddFam(P)$.
#+end_remark

As a first example of a family with descent data, we characterize the type family of based identity types.

#+begin_constr
Given a span $\S \judeq (f, g)$, a cocone $(i, j, H)$ on $X$ and a point $x_0 : X$, construct the descent data $(I_A, I_B, I_S)$ as \TODO[typesetting]
\begin{align*}
  I_A &\defeq (\lambda a \to x = (i a)) &&: A \to \UU \\
  I_B &\defeq (\lambda b \to x = (j b)) &&: B \to \UU \\
  I_S &\defeq (\lambda s, p \to p \concat (H s)) &&: (s : S) \to I_A(f s) \simeq I_B(g s).
\end{align*}

The concatenation operation is an equivalence by [[lemma:is-equiv-concat]].
#+end_constr

#+begin_remark
Note that the basepoint $x_0$ is not mentioned in the notation $(I_A, I_B, I_S)$. \TODO[Whenever we use it, it should be clear from the context].
#+end_remark

#+name: lemma:fam-with-dd-id
#+begin_lemma
Given a cocone and a basepoint $x_0 : X$ as above, the type family $\Id(x_0) : X \to \UU$ is characterized by the descent data $(I_A, I_B, I_S)$. Explicitly, there are equivalences
\begin{align*}
  e_A &: (a : A) \to (x_0 = (i a)) \simeq I_A(a) \\
  e_B &: (b : B) \to (x_0 = (j b)) \simeq I_B(b)
\end{align*}
and a coherence $e_S$
#+begin_center
\begin{tikzcd}
  (x_0 = i (f s))
  \arrow[r, "e_A(f s)"]
  \arrow[d, "\tr_{\Id(x_0)} (H s)"']
  & I_A(f s)
  \arrow[d, "I_S s"] \\
  (x_0 = j (g s))
  \arrow[r, "e_B(g s)"']
  & I_B(g s)
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_proof
By definition, $I_A(a) \judeq (x_0 = (i a))$ and $I_B(b) \judeq (x_0 = (j b))$, so we may choose the identity equivalence for $e_A$ and $e_B$. Then the coherence datum amounts to showing that $\tr_{\Id(x_0)}(H s, p) = p \concat (H s)$, which is [[lemma:tr-id-right]].
#+end_proof

For any given type family $P$ over $X$, we can talk about its /sections/, elements of the type $(x : X) \to P(x)$. We define an analogous concept of /sections of descent data/, and show that indeed they correspond to sections of type families over pushouts.

#+begin_defn
Given a span $\S$ and descent data $(P_A, P_B, P_S)$ over it, a *section* of $(P_A, P_B, P_S)$ is a triple $(t_A, t_B, t_S)$ consisting of sections
\begin{align*}
  t_A &: (a : A) \to P_A(a) \\
  t_B &: (b : B) \to P_B(b)
\intertext{and a coherence}
  t_S &: (s : S) \to P_S(s, t_A(f s)) = t_B(g s).
\end{align*}

We write $\sectDD(P_A, P_B, P_S)$ for the type of sections of $(P_A, P_B, P_S)$.
#+end_defn

#+name: def:sect-sect
#+begin_constr
Given a span $\S \judeq (f, g)$, a cocone $c \judeq (i, j, H)$ on $X$, and a family with descent data $e : P \correspDD (P_A, P_B, P_S)$, construct a map
\[
  \term{sect-sect}_c : ((x : X) \to P(x)) \to \sectDD(P_A, P_B, P_S)
\]
by assigning to a dependent function $h$ the section
\begin{alignat*}{3}
  &(\lambda a \to e_A(h(i a))) &&:\,&& (a : A) \to P_A(a) \\
  &(\lambda b \to e_B(h(j b))) &&:&& (b : B) \to P_B(b) \\
  &(\lambda s \to (e_S(h(i(f s))))^{-1} \concat \ap_{e_B}(\apd_h(H s))) &&:&& (s : S) \to \\
  &&&&&P_S(s, e_A(h(i(f s)))) = e_B(h(j(g s))).
\end{alignat*}
#+end_constr

#+name: lemma:is-equiv-sect-sect
#+begin_lemma
Consider a span $\S$, a pushout cocone $c$ on $X$ and a family with descent data $P \correspDD (P_A, P_B, P_S)$. Then the map $\term{sect-sect}_c$ is an equivalence.
#+end_lemma

#+begin_proof
The map factors through the dependent cocone map as
#+begin_center
\begin{tikzcd}
  ((x : X) \to P(x))
  \arrow[rr, "\depCoconeMap_c", "\simeq"']
  \arrow[dr, "\term{sect-sect}_c"']
  && \depCocone(c, P)
  \arrow[dl, "\simeq"] \\
  & \sectDD(P_A, P_B, P_S),
\end{tikzcd}
#+end_center
where the right map takes $(i', j', H')$ to
\begin{alignat*}{3}
  &(\lambda a \to e_A(i' a)) &\quad&:\,&& (a : A) \to P_A(a) \\
  &(\lambda b \to e_B(j' b)) &&:&& (b : B) \to P_B(b) \\
  &(\lambda s \to (e_S(i'(f s)))^{-1} \concat \ap_{e_B}(H' s)) &&:&& (s : S) \to \\
  &&&&&P_S(s, e_A(i'(f s))) = e_B(j'(g s)).
\end{alignat*}

The right map is an equivalence, because its action on the first two components is postcomposition by a fiberwise equivalence, which is an equivalence, and its action on the third component is a fiberwise application of $\ap_{e_B}$, which is an equivalence, and concatenation with an identification, which is an equivalence.

The triangle commutes by $\reflhtpy$. By the 3-for-2 property of equivalences, it follows that $\term{sect-sect}_c$ is an equivalence.
#+end_proof

\TODO[Are homotopies of sections worth mentioning? It gives a nicer phrasing of (some) computation rules by computing the fibers of $\term{sect-sect}_c$, but it's all pretty standard stuff].

Equipped with the tools for computing data over pushouts by gluing together data over its components, we continue by computing fiberwise maps and equivalences over pushouts. We first characterize type families of fiberwise maps, \ie families with fibers of the shape $P(x) \to Q(x)$.

#+begin_remark
It is important to differentiate between families of /function types/, \ie a type family that to every $x : X$ assigns the /type/ $P(x) \to Q(x)$, and families of /functions/, \ie a family that to every $x : X$ assigns a /function/ from $P(x)$ to $R(x)$. Descent data plays the role of a family of types, so it makes sense to talk about "descent data corresponding to a family of function types", but it doesn't make sense to talk about "descent data corresponding to a family of functions". The kind of objects that corresponds to families of functions are the sections of the descent data of a family of function types.
#+end_remark

#+name: lemma:family-with-dd-function-types
#+begin_lemma
Given a cocone $c$ on $X$ and two families with descent data $e^P : P \approx (P_A, P_B, P_S)$ and $e^Q : Q \approx (Q_A, Q_B, Q_S)$, the type family
\[
  (\lambda x \to (P(x) \to Q(x))) : X \to \UU
\]
is characterized by the descent data
\begin{alignat*}{3}
  &(\lambda a \to (P_A(a) \to Q_A(a))) &\quad&:\,&&A \to \UU \\
  &(\lambda b \to (P_B(b) \to Q_B(b))) &&:&&B \to \UU \\
  &(\lambda s, h \to Q_S(s) \comp h \comp (P_S(s))^{-1}) &&:&&(s : S) \to \\
  &&&&&(P_A(f s) \to Q_A(f s)) \simeq (P_B(g s) \to Q_B(g s)).
\end{alignat*}

Note that postcomposition and precomposition by an equivalence is an equivalence of function types.
#+end_lemma

#+begin_proof
We need to provide equivalences
\begin{align*}
  e_A &: (a : A) \to (P(i a) \to Q(i a)) \simeq (P_A(a) \to Q_A(a)) \\
  e_B &: (b : B) \to (P(j b) \to Q(j b)) \simeq (P_B(b) \to Q_B(b))
\end{align*}
and a coherence $e_S$
#+begin_center
\begin{tikzcd}[column sep=large]
  (P(i(f s)) \to Q(i(f s)))
  \arrow[r, "e_A(f s)"]
  \arrow[d, "\tr_{(\lambda x \to (P(x) \to Q(x)))}(H s)"']
  & (P_A(f s) \to Q_A(f s))
  \arrow[d, "Q_S(s) \comp \, \blank \, \comp (P_S(s))^{-1}"] \\
  (P(j(g s)) \to Q(j(g s)))
  \arrow[r, "e_B(g s)"']
  & (P_B(g s) \to Q_B(g s)).
\end{tikzcd}
#+end_center

Define the equivalences by
\begin{align*}
e_A(a, h) &\defeq e^Q_A(a) \comp h \comp (e^P_A(a))^{-1}\\
e_B(b, h) &\defeq e^Q_B(b) \comp h \comp (e^P_B(b))^{-1}.
\end{align*}

Transport in a type family of function types can be computed as composition of transports in the involved families by \TODO[ref], so the left map can be replaced by $\tr_Q(H s) \comp \blank \comp \tr_P(H s)^{-1}$. Since we want to identify two functions, we invoke function extensionality, and are left with the goal
#+begin_center
\begin{tikzcd}
  P_B(g s)
  \arrow[r, "(P_S(s))^{-1}"]
  \arrow[d, "(e^P_B(g s))^{-1}"']
  & P_A(f s)
  \arrow[d, "(e^P_A(f s))^{-1}"] \\
  P(j(g s))
  \arrow[r, "\tr_P(H s)^{-1}"']
  & P(i(f s))
  \arrow[r, "h"]
  & Q(i(f s))
  \arrow[r, "e^Q_A(f s)"]
  \arrow[d, "\tr_Q(H s)"']
  & Q_A(f s)
  \arrow[d, "Q_S(s)"] \\
  && Q(j(g s))
  \arrow[r, "e^Q_B(g s)"']
  & Q_B(g s)
\end{tikzcd}
#+end_center
for all $h : P(i(f s)) \to Q(i(f s))$. The right square is exactly $e^Q_S(s)$, and the left square is $e^P_S(s)$ mirrored vertically and horizontally.
#+end_proof

#+name: lemma:hom-sect-dd
#+begin_lemma
The type of sections of the descent data defined in [[lemma:family-with-dd-function-types]] is equivalent to morphisms $(P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)$.
#+end_lemma

#+begin_proof
\TODO
#+end_proof

#+begin_thm
Consider a span $\S$, a pushout cocone $c \judeq (i, j, H)$ on $X$, and two families with descent data $e^P : P \correspDD (P_A, P_B, P_S)$ and $e^Q : Q \correspDD (Q_A, Q_B, Q_S)$. Then there is an equivalence
\[
  \term{hom-map} : ((x : X) \to P(x) \to Q(x)) \simeq ((P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)).
\]
Additionally, the following diagrams commute for all $h : (x : X) \to P(x) \to Q(x)$
#+begin_center
\begin{tikzcd}[column sep=6em]
  P(i a)
  \arrow[r, "h(i a)"]
  \arrow[d, "e^P_A(a)"']
  & Q(i a)
  \arrow[d, "e^Q_A(a)"] \\
  P_A(a)
  \arrow[r, "\term{hom-map}(h)_A(a)"']
  & Q_A(a)
\end{tikzcd}
\begin{tikzcd}[column sep=6em]
  P(j b)
  \arrow[r, "h(j b)"]
  \arrow[d, "e^P_B(b)"']
  & Q(j b)
  \arrow[d, "e^Q_B(b)"] \\
  P_B(b)
  \arrow[r, "\term{hom-map}(h)_B(b)"']
  & Q_B(b).
\end{tikzcd}
#+end_center
#+end_thm

#+begin_proof
The type of fiberwise maps is by definition the type of sections of the family $\lambda x \to (P(x) \to Q(x))$, which is equivalent to the type of sections of the descent data from [[lemma:family-with-dd-function-types]] by [[lemma:is-equiv-sect-sect]]. That type of sections is equivalent to the type of morphisms of descent data by [[lemma:hom-sect-dd]].

Computing the action of this equivalence on a fiberwise map $h : (x : X) \to P(x) \to Q(x)$, we get the definitional equalities
\begin{alignat*}{2}
  &\term{hom-map}(h)_A &&\defeq \lambda a \to e^Q_A(a) \comp h(i a) \comp (e^P_A(a))^{-1} \\
  &\term{hom-map}(h)_B &&\defeq \lambda b \to e^Q_B(b) \comp h(j b) \comp (e^P_B(b))^{-1},
\end{alignat*}
so by transposing $e^P_A(a)$ and $e^P_B(b)$, we get the desired computation rules.
#+end_proof

Completely analogously, we may characterize the type family of equivalence types, and show that fiberwise equivalences correspond to equivalences of descent data. We present the statements without proof \TODO[but they are formalized].

#+begin_lemma
Given a cocone $c$ on $X$ and two families with descent data $e^P : P \correspDD (P_A, P_B, P_S)$ and $e^Q : Q \correspDD (Q_A, Q_B, Q_S)$, the type family
\begin{displaymath}
  (\lambda x \to (P(x) \simeq Q(x))) : X \to \UU
\end{displaymath}
is characterized by the descent data
\begin{alignat*}{3}
  &(\lambda a \to (P_A(a) \simeq Q_A(a))) &\quad&:\,&&A \to \UU \\
  &(\lambda b \to (P_B(b) \simeq Q_B(b))) &&:&&B \to \UU \\
  &(\lambda s, h \to Q_S(s) \comp h \comp (P_S(s))^{-1}) &&:&&(s : S) \to \\
  &&&&&(P_A(f s) \simeq Q_A(f s)) \simeq (P_B(g s) \simeq Q_B(g s)).
\end{alignat*}
#+end_lemma

#+name: thm:equivDD-equiv
#+begin_thm
Consider a span $\S$, a pushout cocone $c \judeq (i, j, H)$ on $X$, and two families with descent data $e^P : P \correspDD (P_A, P_B, P_S)$ and $e^Q : Q \correspDD (Q_A, Q_B, Q_S)$. Then there is an equivalence
\begin{displaymath}
  \term{equivDD-equiv} : ((x : X) \to P(x) \simeq Q(x)) \simeq ((P_A, P_B, P_S) \simeq (Q_A, Q_B, Q_S)).
\end{displaymath}
Additionally, the following diagrams commute for all $e : (x : X) \to P(x) \simeq Q(x)$
#+begin_center
\begin{tikzcd}[column sep=8em]
  P(i a)
  \arrow[r, "e(i a)"]
  \arrow[d, "e^P_A(a)"']
  & Q(i a)
  \arrow[d, "e^Q_A(a)"] \\
  P_A(a)
  \arrow[r, "\term{equivDD-equiv}(e)_A(a)"']
  & Q_A(a)
\end{tikzcd}
\begin{tikzcd}[column sep=8em]
  P(j b)
  \arrow[r, "e(j b)"]
  \arrow[d, "e^P_B(b)"']
  & Q(j b)
  \arrow[d, "e^Q_B(b)"] \\
  P_B(b)
  \arrow[r, "\term{equivDD-equiv}(e)_B(b)"']
  & Q_B(b).
\end{tikzcd}
#+end_center
#+end_thm

\TODO[Does it make sense to talk about homotopies of morphisms of descent data? I formalized it all, and we can show that for a morphism, the type of fiberwise functions such that the induced morphism is homotopic to the original one is contractible, but that still needs a bit more work to properly interpret the computation rules (the computation on points is easy enough, but the path case is tricky). It adds approx. 1 page].

#+begin_comment
,#+begin_defn
For any two morphisms $(h_A, h_B, h_S)$ and $(k_A, k_B, k_S)$ between $(P_A, P_B, P_S)$ and $(Q_A, Q_B, Q_S)$, we define the type of *homotopies* to be the type of triples $(H_A, H_B, H_S)$ consisting of fiberwise homotopies
\begin{align*}
  H_A &: (a : A) \to h_A(a) \htpy k_A(a) \\
  H_B &: (b : B) \to h_B(b) \htpy h_B(b)
\end{align*}
and a coherence datum $H_S$ indexed by $s : S$, asserting that the squares of homotopies
,#+begin_center
\begin{tikzcd}[column sep=6em]
  h_B(g s) \comp P_S(s)
  \arrow[r, squiggly, "H_B(g s) \rwhisk P_S(s)"]
  \arrow[d, squiggly, "h_S(s)"']
  & k_B(g s) \comp P_S(s)
  \arrow[d, squiggly, "k_S(s)"] \\
  Q_S(s) \comp h_A(f s)
  \arrow[r, squiggly, "Q_S(s) \lwhisk H_A(f s)"'] & Q_S(s) \comp k_A(f s)
\end{tikzcd}
,#+end_center
commute.

We write $(H_A, H_B, H_S) : (h_A, h_B, h_S) \htpy (k_A, k_B, k_S)$.
,#+end_defn

,#+begin_remark
The coherence can be seen as a filler of the shape one gets by gluing the squares $h_S$ and $k_S$ along the common vertical maps, as in
,#+begin_center
\begin{tikzcd}[row sep=5em]
  P_A(f s)
  \arrow[r, bend left, "k_A(f s)"]
  \arrow[r, bend right, "h_A(f s)"']
  \arrow[d, "P_S(s)"']
  & Q_A(f s) \arrow[d, "Q_S(s)"] \\
  P_B(g s)
  \arrow[r, bend left, "k_B(g s)"]
  \arrow[r, bend right, "h_B(g s)"']
  & Q_B(g s).
\end{tikzcd}
,#+end_center

The front square is $h_S$, the back square is $k_S$, the top face is $H_A$ and the bottom face is $H_B$. The coherence $H_S$ expresses that going along the front square and then the top face is homotopic to first going along the bottom face and then the back square.
,#+end_remark

,#+begin_lemma
The type of homotopies of morphisms of descent data characterizes the identity type of morphisms of descent data. In other words, given two morphisms of descent data $h, k : (P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)$, there is an equivalence
\begin{equation*}
  \defterm{extensionality-hom-DD} : (h = k) \simeq (h \htpy k).
\end{equation*}
,#+end_lemma

,#+begin_proof
We define the underlying map by path induction. Assume $h \doteq k$ are identified by $\refl$. The identity homotopy $h \htpy k$ is defined as \TODO[typesetting]
\begin{align*}
  H_A &\defeq (\lambda a \to \reflhtpy) &&: (a : A) \to h_A \htpy h_A \\
  H_B &\defeq (\lambda b \to \reflhtpy) &&: (b : B) \to h_B \htpy h_B \\
  H_S &\defeq (\lambda s \to \runit)    &&: (s : S) \to h_S(s) \concat refl = h_S(s).
\end{align*}

To show that it is an equivalence, we may appeal to [[lemma:fundamental-theorem-id]]. It then suffices to show that the type $\Sigma (k : P \to Q). (h \htpy k)$ is contractible.
,#+end_proof

,#+begin_corol
\TODO[Uniqueness of a fiberwise map with nice computational properties].
,#+end_corol
#+end_comment

The correspondence of concepts between the world of type families over pushouts and the world of descent data is summarized in [[fig:descent-table]]. Since we want to arrive at an alternative characterization of the identity descent data $(I_A, I_B, I_S)$ via the zigzag construction, we chose to identify its universal property. We can take inspiration from the various universal properties satisfied by the family of identity types $\Id(x_0) \defeq (\lambda x \to (x_0 = x))$. Some of those properties arise from it being the initial pointed type family, in the sense of [[remark:universal-properties]]. As we will see, in this case the induction principle can be reduced to defining a converse map; it will automatically be a section. \TODO[We make an educated guess that it will be the easiest property to formalize]. It also corresponds to the induction principle stated by [cite/t:@KvR19].

However, the induction principle speaks about dependent type families of the sort $(x : X) \to (p : P(x)) \to \UU$. Instead of building new infrastructure for "dependent descent data", we notice that by uncurrying, those dependent type families are exactly the type families $\Sigma X P \to \UU$! This observation makes us ask another question --- to use descent, we need type families over a pushout; by assumption, $X$ is a pushout, but here we require $\Sigma X P$ to be a pushouts as well. The next section is dedicated to proving that indeed, the total space of a family over a pushout is a pushout.

#+name: fig:descent-table
#+caption: Translation table between type families and descent data
#+begin_figure
|                    | Families                       | Descent data                             |
|--------------------+--------------------------------+------------------------------------------|
| Objects            | $P : X \to \UU$                | $(P_A, P_B, P_S)$                        |
| Sections           | $(x : X) \to P(x)$             | $\sectDD(P_A, P_B, P_S)$                 |
| Morphisms          | $(x : X) \to P(x) \to Q(x)$    | $(P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)$    |
| Equivalences       | $(x : X) \to P(x) \simeq Q(x)$ | $(P_A, P_B, P_S) \simeq (Q_A, Q_B, Q_S)$ |
| Identity objects   | $\lambda x \to (x_0 = x)$      | $(I_A, I_B, I_S)$                        |
| Identity induction | Identity systems               | ???                                      |
#+end_figure

** Flattening lemma

The flattening lemma for pushouts effectively states that pushouts commute with dependent pair types --- the total space of a type family over a pushout is a pushout of total spaces of the corresponding descent data.

The presented proof is split into two parts. First we prove the statement specifically for a type family and the descent data it induces, which reduces the amount of data we need to make coherent. Then we relate the cocone for descent data induced by the family to the cocone for arbitrary corresponding descent data, in a way that preserves being a pushout.

#+name: lemma:is-pushout-bottom-ff-is-pushout-top
#+begin_lemma
\TODO[In a cube where vertical maps are equivalences, the bottom square is a pushout iff the top square is a pushout].
#+end_lemma

#+begin_proof
\TODO[Probably omitted. Goes through the pullback property and the dual statement for pullbacks].
#+end_proof

#+begin_constr
Given a span diagram $\S \judeq (f, g)$ and descent data $(P_A, P_B, P_S)$, construct the *total span diagram* \TODO[($\Sigma \S$ ?)]
#+begin_center
\begin{tikzcd}[column sep=huge]
  \Sigma A P_A
  & \Sigma S (P_A \comp f)
  \arrow[l, "\tot_f(\id)"']
  \arrow[r, "\tot_g(P_S)"]
  & \Sigma B P_B.
\end{tikzcd}
#+end_center
#+end_constr

#+begin_constr
Given a span $\S \judeq (f, g)$, a cocone $c \judeq (i, j, H)$ on $X$, and a family with descent data $(P_A, P_B, P_S) \correspDD P$, construct the *total cocone* \TODO[($\Sigma c$ ?)] under the total span
#+begin_center
\begin{tikzcd}[column sep=huge]
  \Sigma S (P_A \comp f)
  \arrow[d, "\tot_f(\id)"']
  \arrow[r, "\tot_g(P_S)"]
  & \Sigma B P_B
  \arrow[d, "\tot_j(e_B)"] \\
  \Sigma A P_A
  \arrow[r, "\tot_i(e_A)"']
  \arrow[ur, phantom, "H'"]
  & \Sigma X P,
\end{tikzcd}
#+end_center
where the coherence $H'$ at $s : S$, $p : P_A(f s)$ is given by
\begin{align*}
  H'_1 &\defeq H(s) &&: (i (f s)) = (j (g s)) \\
  H'_2 &\defeq e_S(s, p)^{-1} &&: \tr_P(H(s), e_A(s, p)) = e_B(P_S(s, p)).
\end{align*}
\TODO[An identification in $\Sigma$ is a $\Sigma$ of identifications].
#+end_constr

#+name: lemma:flattening-base
#+begin_lemma
Given a pushout square $(i, j, H)$ on $X$ and a type family $P : X \to \UU$, the total cocone of $(P \comp i, P \comp j, \tr_P(H)) \correspDD P$ is a pushout.
#+end_lemma

#+begin_proof
The goal is to prove that for any type $Y$, the map
\begin{displaymath}
  \coconeMap_{\Sigma c} : (\Sigma X P \to Y) \to \cocone(\Sigma c, Y)
\end{displaymath}
is an equivalence. We achieve that by forming a commuting pentagon, in which all other maps are equivalences:
#+begin_center
\begin{tikzcd}[ampersand replacement=\&]
  (\Sigma X P \to Y)
  \arrow[r, "\coconeMap_{\Sigma c}"]
  \&
  \begin{aligned}
    \Sigma
    &(h_A : \Sigma A (P \comp i) \to Y) \\
    &(h_B : \Sigma B (P \comp j) \to Y). \\
    &((s, p) : \Sigma S (P \comp i \comp f)) \to \\
    &h_A(f s, p) = h_B(g s, \tr_P(H s, p))
  \end{aligned}
  \arrow[dd, "\term{ev-pair}^3", "\simeq"'] \\
  (x : X) \to P(x) \to Y
  \arrow[u, "\uncurry", "\simeq"']
  \arrow[d, "\depCoconeMap_c"', "\simeq"] \\
  \begin{aligned}
    \Sigma
    &(h_A : (a : A) \to P(i a) \to Y) \\
    &(h_B : (b : B) \to P(j b) \to Y). \\
    &(s : S) \to \\
    &\tr_{(\lambda x \to (P(x) \to Y))}(H s, h_A(f s)) = h_B(g s)
  \end{aligned}
  \&
  \begin{aligned}
    \Sigma
    &(h_A : (a : A) \to P(i a) \to Y) \\
    &(h_B : (b : B) \to P(j b) \to Y). \\
    &(s : S) (p : P(i(f s))) \to \\
    &h_A(f s, p) = h_B(g s, \tr_P(H s, p)).
  \end{aligned}
  \arrow[l, "\tot(\tot(\varphi))", "\simeq"']
\end{tikzcd}
#+end_center

The types $\cocone(\Sigma \S, Y)$ and $\depCocone(c, (\lambda x \to (P(x) \to Y)))$ were expanded in the diagram. The pentagon commutes by reflexivity on the first two components. To finish the proof, we need to define an equivalence
\begin{displaymath}
  \varphi : (h_A(f s) \htpy h_B(g s) \comp \tr_P(H s)) \simeq (\tr_{(\lambda x \to (P(x) \to Y))}(H s, h_A(f s)) = h_B(g s))
\end{displaymath}
such that $\apd_h(H s) = \varphi(\lambda p \to \ap_{\uncurry(h)}((H s, \refl)))$ \TODO[implicitly applying eq-$\Sigma$-eq-pair]. This map and its computation rule is defined in the next lemma in more generality, which finishes the proof.
#+end_proof

#+begin_lemma
Given maps $i, j : S \to X$ with a homotopy $H : i \htpy j$, a type family $P : X \to \UU$, a type $Y$, and two dependent maps
\begin{align*}
  k &: (s : S) \to P(i s) \to Y\\
  l &: (s : S) \to P(j s) \to Y,
\end{align*}
there is for every $s : S$ an equivalence
\begin{displaymath}
  \varphi : (k(s) \htpy l(s) \comp \tr_P(H s)) \simeq (\tr_{(\lambda x \to (P(x) \to Y))}(H s, k(s)) = l(s))
\end{displaymath}

Additionally, for $k \judeq (h \comp i)$ and $l \judeq (h \comp j)$ where $h : (x : X) \to P(x) \to Y$ is any dependent map, it computes as
\begin{displaymath}
  \varphi(\lambda p \to \ap_{\uncurry(h)}((H s, \refl))) = \apd_h(H s).
\end{displaymath}
#+end_lemma

#+begin_proof
By homotopy induction \TODO[define homotopy induction], it suffices to consider the case where $j \judeq i$ and $H$ is the reflexivity homotopy. The goal is
\begin{displaymath}
  (k(s) \htpy l(s)) \simeq (k(s) = l(s)),
\end{displaymath}
which holds by function extensionality.

The computation rule follows again by induction on $H$. Then it suffices to show that $\varphi(\reflhtpy) = \refl$. By computation of homotopy induction $\varphi(\reflhtpy)$ computes to $\eqHtpy(\reflhtpy)$, which computes to $\refl$.
#+end_proof

#+name: lemma:flattening-cube
#+begin_lemma
Given a type family $P : X \to \UU$ with corresponding descent data $(P_A, P_B, P_S)$, there is a commuting cube
#+begin_center
\begin{tikzcd}[column sep=huge, row sep=huge]
  & \Sigma S (P_A \comp f)
  \arrow[dl, "\tot_f(\id)"']
  \arrow[d, "\tot(e_A)"]
  \arrow[dr, "\tot_g(P_S)"]
  & \\
  \Sigma A P_A
  \arrow[d, "\tot(e_A)"']
  & \Sigma S (P \comp i \comp f)
  \arrow[dl, "\tot_f(\id)"', very near start]
  \arrow[dr, "\tot_g(\tr_P(H))", very near start]
  & \Sigma B P_B
  \arrow[dl, crossing over, "\tot_j(e_B)", very near end]
  \arrow[d, "\tot(e_B)"] \\
  \Sigma A (P \comp i)
  \arrow[dr, "\tot_i(\id)"']
  & \Sigma X P
  \arrow[from=ul, crossing over, "\tot_i(e_A)"', very near end]
  \arrow[d, "\id"]
  & \Sigma B (P \comp j)
  \arrow[dl, "\tot_j(\id)"] \\
  & \Sigma X P
\end{tikzcd}
#+end_center
where the top square is the coherence of the total cocone of $(P_A, P_B, P_S) \correspDD P$, and the bottom square is the coherence of the total cocone of $(P \comp i, P \comp j, \tr_P(H)) \correspDD P$.
#+end_lemma

#+begin_proof
The back left, front left, and front right squares commute by $\reflhtpy$. The back right square commutes by $(\refl, (e_s)^{-1})$. The commuting cube is therefore an element of the type
\begin{align*}
  &(\tot_i(\id) \lwhisk \reflhtpy) \hconcat (\reflhtpy \rwhisk \tot_f(\id)) \hconcat (\id \lwhisk (H, e_S^{-1})) = \\
  &((H, \reflhtpy) \rwhisk \tot(e_A)) \hconcat (\tot_j(\id) \lwhisk (\reflhtpy, e_S^{-1})) \hconcat (\reflhtpy \rwhisk \tot_g(P_S)).
\end{align*}

The left homotopy computes to $\id \lwhisk (H, e_S^{-1})$, which is identical to $(H, e_S^{-1})$. The last concatenant \TODO[is that a word?] of the right homotopy is $\reflhtpy$, so we can compute it away.

The new goal is
\begin{align*}
  (H, e_S^{-1}) = (H, \reflhtpy) \hconcat (\tot_j(\id) \lwhisk (\reflhtpy, e_S^{-1})).
\end{align*}

The total map $\tot_j(\id)$ acts on $(\reflhtpy, e_S^{-1})$ component-wise, so it can be further computed to $(\reflhtpy, \id \lwhisk (e_S^{-1}))$, which is identical to $(\reflhtpy, e_S^{-1})$. To finish the proof, we note that any identification $(p, q) : (s, t) = (s', t')$ in a $\Sigma$ type can be decomposed as $(p, \refl) \concat (\refl, q)$.
#+end_proof

#+name: lemma:flattening-lemma
#+attr_latex: :options [Flattening lemma]
#+begin_thm
Given a pushout $c$ and a family with descent data $(P_A, P_B, P_S) \correspDD P$, the total cocone is a pushout.
#+end_thm

#+begin_proof
By [[lemma:flattening-base]], the bottom square in [[lemma:flattening-cube]] is a pushout, and all of $e_A(a)$, $e_A(f s)$, $e_B(b)$ and $\id$ are equivalences, so it follows by [[lemma:is-pushout-bottom-ff-is-pushout-top]] that the top square is a pushout.
#+end_proof

** Identity systems
:PROPERTIES:
:CUSTOM_ID: sec:identity-systems
:END:

We define a universal property of descent data for the identity types of pushouts, which allows their alternative characterizations. The property is analogous to a pointed type family being an identity system, which manifests it as the homotopy-initial pointed type family \TODO[Define pointed-type-family identity systems somewhere]; in fact, we show that a type family over a pushout is an identity system if and only if the corresponding descent data satisfies this universal property.

Given descent data $(P_A, P_B, P_S)$ for a span diagram $\S \judeq (f, g)$ and a point ${p_0 : P_A(a_0)}$ over a basepoint $a_0 : A$, we would like to mirror the definition of identity systems. A naïve translation would lead us to define dependent descent data and its sections. We choose to sidestep building that technical infrastructure.

By the descent property, there is a unique type family $P : X → \UU$ corresponding to $(P_A, P_B, P_S)$. Observe that the type of dependent type families $(x : X) → P(x) → \UU$ is equivalent to the uncurried form $(\Sigma X P) → \UU$. By the flattening lemma, the total space $\Sigma X P$ is the pushout of the span diagram of total spaces
#+begin_center
\begin{tikzcd}[column sep=large]
  \Sigma A P_A
  & \Sigma S (P_A \circ f)
  \arrow[l, "\tot_f \id"']
  \arrow[r, "\tot_g P_S"]
  & \Sigma B P_B
\end{tikzcd}
#+end_center

so, again by the descent property, descent data over it correspond to type families over $\Sigma X P$. Hence we can talk about descent data $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ over the total span diagram instead of dependent descent data. We write a $\Sigma$ in the indices of $Q$ to remind ourselves that it is descent data over the total span diagram.

#+begin_constr
Assume a span diagram $\S \judeq (f, g)$, descent data $(P_A, P_B, P_S)$ over it, a basepoint $a_0 : A$ and a point $p_0 : P_A(a_0)$. For any descent data $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ over the total span, define the map
\begin{align*}
  \evreflidsystemDD : \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S}) &\to Q_{\Sigma A}(a_0, p_0) \\
  (t_A, t_B, t_S) &\mapsto t_A (a_0, p_0).
\end{align*}
#+end_constr

#+begin_defn
Descent data $(P_A, P_B, P_S)$ equipped with a point $p_0 : P_A(a_0)$ satisfies the *induction principle of identity systems* if for all $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$, the map $\evreflidsystemDD$ has a section, in the sense that there is a converse map
\begin{equation*}
  \indidsystemDD : Q_{\Sigma A}(a_0, p_0) \to \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})
\end{equation*}
and an identification
\begin{equation*}
  (\indidsystemDD(q_0))_A (a_0, p_0) = q_0
\end{equation*}
for all $q_0 : Q_{\Sigma A}(a_0, p_0)$.

Such descent data is called an *identity system* at $p_0$.
#+end_defn

\TODO[Mind the unfortunate
terminology clash between "sections of descent data" and "sections of a map"].

#+begin_remark
Note that this development is biased towards the left --- we pick a basepoint in the domain $a_0 : A$, a point in the left type family $p_0 : P_A(a_0)$, and the evaluation map evaluates the left map of the section. By symmetry of pushouts we could just as well work with the points $b_0 : B$, $p_0 : P_B(b_0)$, and the evaluation map evaluating the right map of the section.
#+end_remark

#+begin_remark
By showing that the canonical descent data for identity types is an identity system, we recover the "induction principle for pushout equality" stated and proved by [cite/t/f:@KvR19] \TODO[figure out proper citation incantation].

First observe that the type of sections of $\evreflidsystemDD$ is
\begin{align*}
  \Sigma \;
  &(\indidsystemDD : (Q_{\Sigma A} (a_0, p_0)) \to \sectDD (Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})) \\
  &((q_0 : Q_{\Sigma A} (a_0, p_0)) \to (\indidsystemDD q_0)_A (a_0, p_0) = q_0),
\end{align*}
which is equivalent to the type
\begin{align}
  &(q_0 : Q_{\Sigma A} (a_0, p_0)) \to \nonumber\\
  &\Sigma \;
  (\indidsystemDD : \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})) \label{kvr:section} \\
  &\quad(\indidsystemDD_A (a_0, p_0) = q_0) \label{kvr:issection}
\end{align}
by [[lemma:distributive-pi-sigma]].

Then the induction terms from [cite//b:@KvR19] (with names changed to fit our naming scheme)
\begin{align*}
  \term{ind_A} &: (a : A) (r : i(a_0) = i(a)) → Q_{\Sigma A} (a, r) \\
  \term{ind_B} &: (b : B) (r : i(a_0) = j(b)) → Q_{\Sigma B} (b, r)
\end{align*}
are the first and second components of the section \ref{kvr:section} induced by $q_0$, and their computation rules
\begin{align*}
  &\term{ind_A} (a_0, \refl) = q_0 \\
  &Q_{\Sigma S} (s, r, \term{ind_A} (f s, r)) = \term{ind_B} (g s, r \concat H s)
\end{align*}
arise as the second component \ref{kvr:issection}, and the coherence condition of \ref{kvr:section}, respectively.
#+end_remark

We first show a result relating identity systems stated as pointed type families and identity systems stated as pointed descent data.

#+name: lemma:square-id-system-id-system-DD
#+begin_lemma
Consider a pushout cocone $c$ on $X$, a type family with corresponding descent data $e^P : P \correspDD (P_A, P_B, P_S)$ and a point $p_0 : P_A(a_0)$. Then for any type family with corresponding descent data $e^Q : Q_{\Sigma} \correspDD (Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ there is a commuting diagram
#+begin_equation
\begin{tikzcd}[row sep=large, column sep=small]
  ((x : X) (p : P(x)) \to Q_{\Sigma} (x , p))
  \arrow[r, "\simeq"]
  \arrow[d, "\term{ev-refl-id-system}"']
  & ((u : \Sigma X P) \to Q_{\Sigma} u)
  \arrow[r, "\simeq"]
  & \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})
  \arrow[d, "\evreflidsystemDD"'] \\
  Q_{\Sigma}(i a_0, (e^P_A(a_0))^{-1}(p_0))
  \arrow[rr, "e^Q_A(a_0{,} p_0)"', "\simeq"]
  &
  & Q_{\Sigma A}(a_0, p_0).
\end{tikzcd}
#+end_equation
#+end_lemma

#+begin_proof
The top equivalences are, from left to right, $\uncurry$ and $\term{sect-sect}_{\Sigma c}$. To see that the square commutes, note that the first component of $\term{sect-sect}_{\Sigma c}(\uncurry(h))$ sends $(a, p) : \Sigma A P_A$ to $e^Q_A(h(ia, (e^P_A(a))^{-1}(p)))$ by definition of the total cocone. The square commutes by $\reflhtpy$.
#+end_proof

#+name: lemma:is-id-system-DD-is-id-system
#+begin_corol
Assume $e : P \correspDD (P_A, P_B, P_S)$ where $P$ is an identity system at $(e_A(a_0))^{-1}(p_0) : P(i a_0)$. Then $(P_A, P_B, P_S)$ is an identity system at $p_0$.
#+end_corol

#+begin_proof
For every $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ there is a corresponding type family $Q_{\Sigma}$. Then we may apply [[lemma:square-id-system-id-system-DD]]. The top and bottom maps are equivalences, and the left maps has a section by assumption, hence the right map has a section.
#+end_proof

#+name: lemma:is-id-system-is-id-system-DD
#+begin_corol
Analogously, if $(P_A, P_B, P_S)$ is an identity system at $p_0 : P_A(a_0)$, then $P$ is an identity system at $(e_A(a_0))^{-1}(p_0)$.
#+end_corol

#+begin_thm
Given a span $\S$, a point $a_0 : A$, and a pushout cocone $c$ on $X$, the descent data $(I_A, I_B, I_S)$ is an identity system at $\refl_{i a_0}$.
#+end_thm

#+begin_proof
By [[lemma:fam-with-dd-id]] and [[lemma:is-id-system-DD-is-id-system]], the descent data $(I_A, I_B, I_S)$ is an identity system at $\refl : (i a_0) = (i a_0)$ if and only if the corresponding type family $\Id (i a_0) : X → 𝒰$ is an identity system at $\refl$, which is established in \TODO[ref].
#+end_proof

The induction principle of identity systems is stated in terms of an evaluation map having a section, which makes it consistent with statements of other induction principles in Homotopy Type Theory. However, the following lemma shows that the condition on the converse map of being a section is redundant.

#+begin_lemma
Consider a span diagram $\S$ and its pushout cocone $c$ on $X$. To show that $(P_A, P_B, P_S)$ is an identity system at $p₀ : P_A(a_0)$, it suffices to provide a map
\begin{displaymath}
  H : Q_{\Sigma A}(a_0, p_0) \to \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})
\end{displaymath}
for every descent data $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ over the total span diagram.
#+end_lemma

#+begin_proof
Construct the unique type family $P : X → \UU$ for $(P_A, P_B, P_S)$. It suffices to show that $P$ is an identity system. Equivalently, it suffices to show that the total space $\Sigma X P$ is contractible. We can prove that using the property that a type is contractible if we provide a point, here $(i a_0, (e^P_A a_0)^{-1}(p_0))$, and a map
\begin{equation*}
  H' : (Q_{\Sigma} : \Sigma X P → \UU) → (q_0 : Q_{\Sigma} (i a_0, (e^P_A a)^{-1} p_0)) → (u : \Sigma X P) → Q_{\Sigma}(u).
\end{equation*}
Assume such $Q_{\Sigma}$ and $q_0$. A section $(u : \Sigma X P) → Q_{\Sigma}(u)$ is given by a section
of $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$, and we can get one by applying $H$ to
$e^Q_A ((a_0, p_0), q_0): Q_{\Sigma A} (a_0, p_0)$.
#+end_proof

#+begin_remark
Note that the pushout $c$ is not used in the statement of the lemma. We include it as a parameter to avoid assuming existence of all pushouts.
#+end_remark

#+begin_thm
Consider a span diagram $\S$, a point $a_0 : A$, and a pushout cocone $c$. For any identity system $(P_A, P_B, P_S)$ at $p_0 : P_A(a_0)$, there is a unique equivalence of descent data
\begin{displaymath}
  e : (I_A, I_B, I_S) \simeq (P_A, P_B, P_S)
\end{displaymath}
such that $e_A(\refl) = p_0$.
#+end_thm

#+begin_proof
Construct the unique type family $P : X → \UU$ corresponding to $(P_A, P_B, P_S)$. By [[thm:equivDD-equiv]] the type of point preserving equivalences between $(I_A, I_B, I_S)$ and $(P_A, P_B, P_S)$ is equivalent to the type of fiberwise equivalences $(x : X) → ((i a_0) = x) \simeq P(x)$ that send $\refl$ to $(e^P_A a_0)^{-1}(p_0)$. To show that this type is contractible, it suffices to show that the total space $\Sigma X P$ is contractible \TODO[ref]. It is contractible if $P$ is an identity system, which it is by [[lemma:is-id-system-is-id-system-DD]] and the assumption that $(P_A, P_B, P_S)$ is an identity system.
#+end_proof

Unfolding the data of the equivalence, we get
\begin{align*}
  e_A &: (a : A) \to (i a_0 = i a) \simeq P_A(a) \\
  e_B &: (b : B) \to (i a_0 = j b) \simeq P_B(b) \\
  e_S &: (s : S) (p : i a_0 = i(f s)) \to e_B(g s, p \concat (H s)) = P_S(s, e_A(f s, p)).
\end{align*}

** van Kampen squares

\TODO[Should I finish this section? It gets wishy-washy kinda quickly].

There is an alternative description of descent and flattening, one that doesn't mention universes and is phrased only with pushouts and pullbacks. This section is meant to be an informal exposition of the relationship between the type-theoretic and homotopy-theoretic perspectives. The material hasn't been formalized yet in the {{{AU}}} library at the time of writing.

[cite/t:@LS04] define van Kampen squares as pushout squares satisfying the first and second cube theorems of [cite/t:@Mat76]. We will see that the first cube theorem corresponds to type-theoretic descent, and the second cube theorem corresponds to the flattening lemma, a results that [cite/t:@War24] hints at is folklore (\TODO[verify this, but I haven't found any explanation]). [cite/t:@Rij19 proof of Theorem 2.2.11] shows that the second cube theorem follows from the flattening lemma.

#+begin_defn
Consider a pushout square
#+begin_center
\begin{tikzcd}
  S
  \arrow[r, "g"]
  \arrow[d, "f"']
  \arrow[dr, phantom, "\ulcorner", at end]
  & B
  \arrow[d, "j"] \\
  A
  \arrow[r, "i"']
  \arrow[ur, phantom, "H"]
  & X.
\end{tikzcd}
#+end_center
If for all commuting cubes
#+begin_center
\begin{tikzcd}[]
  & S' \arrow[dl] \arrow[d] \arrow[dr] \\
  A' \arrow[d]
  & S \arrow[dl, "f"', near start] \arrow[dr, "g", near start]
  & B' \arrow[dl, crossing over] \arrow[d] \\
  A \arrow[dr, "i"']
  & X' \arrow[from=ul, crossing over] \arrow[d]
  & B \arrow[dl, "j"] \\
  & X
\end{tikzcd}
#+end_center
where the bottom square is $H$ and the two back faces are pullback squares, it holds that
1. if the top square is a pushout, then the two front faces are pullbacks; then $H$ satisfies the *first cube axiom*
2. if the two front faces are pullbacks, then the top square is a pushout; then $H$ satisfies the *second cube axiom*.
#+end_defn

#+begin_defn
A pushout square is *van Kampen* if it satisfies both the first and second cube axioms.
#+end_defn

* Other colimits

Pushouts and the empty type suffice to construct many other kinds of colimits. We are particularly interested in sequential colimits, which figure prominently in the zigzag construction in [[#sec:zigzag-constr]]. Sequential colimits and some of their properties may be derived from pushouts. Their construction is more natural if we first formalize a basic theory of coequalizers on top of pushouts, and then we formalize sequential colimits on top of coequalizers.

** Coequalizers

#+begin_defn
A *double arrow* is a pair of types $A : \UU$, $B : \UV$, equipped with a pair of maps $f, g : A \to U$.
#+end_defn

#+begin_defn
Given a double arrow $\D \judeq (f, g)$ and a type $X : \UU$, a *cofork* under $\D$ on $X$ is a pair $(i, H)$, where $i : B \to X$ is a map, and $H$ is a homotopy of type $i \comp f \htpy i \comp g$.

We write $\cofork(\D, X)$ for the type of coforks under $\D$ on $X$.
#+end_defn

#+begin_constr
Given a cofork $c \judeq (i, H) : \cofork(\D, X)$ on $X$ and a type $Y : \UV$, we construct a map
\begin{displaymath}
  \coforkMap_c^Y : (X \to Y) \to \cofork(\D, Y)
\end{displaymath}
which sends $h$ to $(h \comp i, h \lwhisk H)$.
#+end_constr

#+begin_defn
A cofork $c$ under $\D$ on $X$ satisfies the *universal property of coequalizers* if for all $Y : \UV$, the map $\coforkMap_c^Y$ is an equivalence.

A cocone satisfying the universal property of coequalizers is called a *coequalizer*.
#+end_defn

#+begin_constr
Construct the map $\spanDoubleArrow$ by
#+begin_center
\begin{tikzcd}
  A \arrow[r, shift left, "g"] \arrow[r, shift right, "f"'] & B
\end{tikzcd}
\hspace{3em} $\mapsto$ \hspace{3em}
\begin{tikzcd}
  A & A + A \arrow[l, "\codiag"'] \arrow[r, "\coprodM{f}{g}"] & B,
\end{tikzcd}
#+end_center
where the left map is the codiagonal map, sending $\inl(a)$ and $\inr(a)$ to $a$, and the right map is defined by the universal property of coproducts to send $\inl(a)$ to $f(a)$ and $\inr(a)$ to $g(a)$.
#+end_constr

The standard coequalizer of $\D$ may be obtained as the pushout of $\spanDoubleArrow(\D)$.

#+name: lemma:cocone-cofork
#+begin_lemma
For any double arrow $\D$ and a type $X$, there is an equivalence
\begin{displaymath}
  \coconeCofork : \cofork(\D, X) \simeq \cocone(\spanDoubleArrow(\D), X)
\end{displaymath}
which fits into the following commuting triangle for every cofork $c : \cofork(\D, X)$
#+begin_center
\begin{tikzcd}[column sep=small]
  (X \to Y)
  \arrow[rr, "\coforkMap_c"]
  \arrow[dr, "\coconeMap_{\coconeCofork(c)}"']
  && \cofork(\D, Y)
  \arrow[dl, "\coconeCofork", "\simeq"'] \\
  & \cocone(\spanDoubleArrow(\D), Y)
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_proof
To define the forward map, assume a cofork $(j, H)$, where $j : B \to X$ and $H : j \comp f \htpy j \comp g$. To construct the cocone under $\spanDoubleArrow(\D)$, take $j \comp f : A \to X$ to be the first component and $j$ to be the second component. It remains to construct a homotopy
#+begin_center
\begin{tikzcd}
  A + A
  \arrow[r, "\coprodM{f}{g}"]
  \arrow[d, "\codiag"']
  & B
  \arrow[d, "j"] \\
  A
  \arrow[r, "j \comp f"']
  & X.
\end{tikzcd}
#+end_center
On $\inl(a) : A + A$ the square commutes by $\refl$, and on $\inr(a) : A + A$ it commutes by $H : j \comp f \htpy j \comp g$, which we write as $\coprodM{\reflhtpy}{H}$.

To define the inverse map, assume a cocone $(i, j, H)$ where $i : A \to X$, $j : B \to X$, and $H$ witnesses commutativity of the square
#+begin_center
\begin{tikzcd}
  A + A
  \arrow[r, "\coprodM{f}{g}"]
  \arrow[d, "\codiag"']
  & B
  \arrow[d, "j"] \\
  A
  \arrow[r, "i"']
  & X.
\end{tikzcd}
#+end_center

Since the codomain of the homotopy is a coproduct, it corresponds to a pair of homotopies $H_1 : i \htpy j \comp f$ and $H_2 : i \htpy j \comp g$. To construct the cofork under $\D$, take $j$ to be the first component, and the concatenation $H_1^{-1} \hconcat H_2 : j \comp f \htpy j \comp g$ for the second component.

\TODO[We need to show that they are mutual inverses. It requires homotopies of cocones and coforks, which I want to avoid, so maybe skip that?]

To show commutativity of the triangle, chase a map $h : X \to Y$:
#+begin_center
\begin{tikzcd}[ampersand replacement=\&, column sep=small]
  h
  \arrow[rr, mapsto]
  \arrow[dr, mapsto]
  \&\&(h \comp j, h \lwhisk H)
  \arrow[dl, mapsto] \\
  \&\left(
  \begin{aligned}
    &h \comp j \comp f, \\
    &h \comp j, \\
    &h \lwhisk \coprodM{\reflhtpy}{H}
  \end{aligned}
  \right)
  =
  \left(
  \begin{aligned}
    &h \comp j \comp f, \\
    &h \comp j, \\
    &\coprodM{\reflhtpy}{h \lwhisk H}
  \end{aligned}
  \right).
\end{tikzcd}
#+end_center

The first two components are identical, so it suffices to show that for all $a : A + A$, the identifications $\ap_h(\coprodM{\reflhtpy}{H}(a))$ and $\coprodM{\reflhtpy}{\ap_h(H(a))}$ agree. On elements of the form $\inl(a)$ they both compute to $\refl$, and on elements of the form $\inr(a)$ they compute to $\ap_h(H(a))$, so they are identified by $\refl$.
#+end_proof

#+name: lemma:coeq-pushout
#+begin_lemma
The equivalence $\coconeCofork$ restricts to an equivalence between \linebreak pushouts of $\spanDoubleArrow(\D)$ and coequalizers of $\D$. In other words, a cofork $c$ satisfies the universal property of coequalizers if and only if the cocone $\coconeCofork(c)$ satisfies the universal property of pushouts.
#+end_lemma

#+begin_proof
By the commuting triangle in [[lemma:cocone-cofork]] and the 3-for-2 property of equivalences, $\coforkMap_c$ is an equivalence if and only if the corresponding $\coconeMap$ is an equivalence.
#+end_proof

We define dependent coforks and the dependent universal property of coequalizers analogously to the case of dependent cocones.

#+begin_defn
Consider a cofork $c \judeq (i, H) : \cofork(\D, X)$ and a type family $P : X \to \UU$. A *dependent cofork* over $c$ on $P$ is a pair $(i', H')$, where
\begin{align*}
  &i' : (b : B) \to P(i b) \\
  &H' : (a : A) \to \tr_P(H a) (i(f a)) = i(g a).
\end{align*}

We write $\depCofork(c, P)$ for the type of dependent coforks over $c$ on $P$.
#+end_defn

#+begin_constr
Given a cofork $c \judeq (i, H) : \cofork(\D, X)$ and a type family $P : X \to \UU$, define a map
\begin{displaymath}
  \depCoforkMap_c^P : ((x : X) \to P(x)) \to \depCofork(c, P)
\end{displaymath}
which sends $h$ to $(h \comp i, \lambda a \to \apd_h(H a))$.
#+end_constr

#+begin_defn
A cofork $c$ satisfies the *dependent universal property of coequalizers* if for all $P : X \to \UU$, the map $\depCoforkMap_c^P$ is an equivalence.
#+end_defn

#+name: lemma:dep-cocone-dep-cofork
#+begin_lemma
For any cofork $c : \cofork(\D, X)$, there is an equivalence
\begin{align*}
  \depCoconeDepCofork
  &: \depCofork(c, X) \\
  & \simeq \depCocone(\coconeCofork(c), P)
\end{align*}
such that the following diagram commutes for every cofork $c : \cofork(\D, X)$
#+begin_center
\begin{tikzcd}[column sep=tiny]
  (X \to Y)
  \arrow[rr, "\depCoforkMap_c"]
  \arrow[dr, "\depCoconeMap_{\coconeCofork(c)}"']
  && \depCofork(c, P)
  \arrow[dl, "\depCoconeDepCofork", "\simeq"'] \\
  & \depCocone(\coconeCofork(c), P)
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_proof
Completely analogous to the proof of [[lemma:cocone-cofork]].
#+end_proof

#+name: lemma:coeq-pushout-dup
#+begin_lemma
A cofork $c : \cofork(\D, X)$ satisfies the dependent universal property of coequalizers if and only if the cocone $\coconeCofork(c)$ satisfies the dependent universal property of pushouts.
#+end_lemma

#+begin_proof
By the commuting triangle in [[lemma:dep-cocone-dep-cofork]], the map $\depCoforkMap_c$ is an equivalence if and only if $\depCoconeMap_{\coconeCofork(c)}$ is an equivalence.
#+end_proof

#+begin_lemma
A cofork satisfies the universal property of coequalizers if and only if it satisfies the dependent universal property of coequalizers.
#+end_lemma

#+begin_proof
Given a cofork $c$, there is a sequence of logical equivalences
\begin{align*}
  & \text{$c$ satisfies the universal property of coequalizers} \\
  & \leftrightarrow \text{$\coconeCofork(c)$ satisfies the universal property of pushouts} \\
  & \leftrightarrow \text{$\coconeCofork(c)$ satisfies the dependent universal property of pushouts} \\
  & \leftrightarrow \text{$c$ satisfies the dependent universal property of coequalizers}.
\end{align*}

The equivalences are, in order: [[lemma:coeq-pushout]], [[lemma:dup-iff-up-pushout]], and [[lemma:coeq-pushout-dup]].
#+end_proof

Coequalizers also satisfy descent, but we do not explore it in the thesis. It is simple enough to derive for different colimits from the univalence axiom. We do, however, prove the flattening lemma for coequalizers, which we will use to prove the flattening lemma for sequential colimits.

#+begin_constr
Given a double arrow $\D \judeq (f, g)$, a cofork $(i, H)$ on $X$, and a type family $P : X \to \UU$, define the *total cofork* to be
#+begin_center
\begin{tikzcd}[column sep=huge]
  \Sigma A (P \comp i \comp f)
  \arrow[r, shift left, "\tot_g(\tr_P(H))"]
  \arrow[r, shift right, "\tot_f(\id)"']
  & \Sigma B (P \comp i)
  \arrow[r, "\tot_i(\id)"]
  & \Sigma X P,
\end{tikzcd}
#+end_center
where the homotopy is
\begin{displaymath}
  (H, \reflhtpy) : (\tot_i(\id) \comp \tot_f(\id)) \htpy (\tot_i(\id) \comp \tot_g(\tr_P(H))).
\end{displaymath}
#+end_constr

#+attr_latex: :options [Flattening lemma for coequalizers]
#+begin_thm
Given a coequalizer $c$ on $X$ and a type family $P : X \to \UU$, the total cofork is also a coequalizer.
#+end_thm

#+begin_proof
To show that the total cocone is a coequalizer, it suffices to show that the corresponding cocone is a pushout. Construct the cube
#+begin_center
\begin{tikzcd}[column sep=huge, row sep=large]
  & \Sigma (A + A) (P \comp i \comp f \comp \codiag)
  \arrow[dl, "\tot_\codiag(\id)"']
  \arrow[d, "\psi", "\simeq"']
  \arrow[dr, "\tot_{\coprodM{f}{g}}(\tr_P\coprodM{\reflhtpy}{H})"] \\
  \Sigma A (P \comp i \comp f)
  \arrow[d, "\id"']
  & (\Sigma A (P \comp i \comp f)) + (\Sigma A (P \comp i \comp f))
  \arrow[dl, "\codiag", near start]
  \arrow[dr, "\coprodM{\tot_f(\id)}{\tot_g(\tr_P(H))}"', near start]
  & \Sigma B (P \comp i)
  \arrow[dl, crossing over, "\tot_i(\id)", near end]
  \arrow[d, "\id"] \\
  \Sigma A (P \comp i \comp f)
  \arrow[dr, "\tot_i(\id) \comp \tot_f(\id)"']
  & \Sigma X P
  \arrow[from=ul, crossing over, "\tot_{i \comp f}(\id)"', near end]
  \arrow[d, "\id"]
  & \Sigma B (P \comp i)
  \arrow[dl, "\tot_i(\id)"] \\
  & \Sigma X P
\end{tikzcd}
#+end_center
where the homotopy
\begin{displaymath}
  \coprodM{\reflhtpy}{H} : (i \comp f \comp \codiag) \htpy (i \comp \coprodM{f}{g})
\end{displaymath}
is defined by sending $\inl(a)$ to $\reflhtpy(a) : i(f a) = i(f a)$ and $\inr(a)$ to $H(a) : i(f a) = i(g a)$. The equivalence
\begin{displaymath}
  \psi : (\Sigma (A + A) (P \comp i \comp f \comp \codiag)) \simeq ((\Sigma A (P \comp i \comp f)) + (\Sigma A (P \comp i \comp f)))
\end{displaymath}
sends $(\inl(a), p)$ to $\inl(a, p)$ and $(\inr(a), p)$ to $\inr(a, p)$.

The bottom square is the cocone corresponding to the total cofork, \linebreak $\coconeCofork(\Sigma c)$ \TODO[the notation hasn't been established], and the top square is the total cocone of the corresponding cocone, $\Sigma (\coconeCofork(c))$. The two front squares commute by $\reflhtpy$, and the back two squares commute by $(\coprodM{\reflhtpy}{\reflhtpy}, \reflhtpy)$.

Since $c$ is a coequalizer by assumption, it holds that the corresponding cocone is a pushout, so by [[lemma:flattening-lemma]] the top square of the cube is a pushout. Note that all the vertical maps are equivalences, and the goal is to show that the bottom square is a pushout. Hence it suffices to show that the cube commutes.

To show that the cube commutes, we proceed by cases: for elements of the form $(\inl(a), p)$, all the identifications collapse to $\refl$, so in that fiber the cube commutes by $\refl$. For elements of the form $(\inr(a), p)$, we need an identification
\begin{displaymath}
  \refl \concat \refl \concat (\ap_{\id} (H(a), \refl)) = (H(a), \refl) \concat \refl \concat \refl,
\end{displaymath}
which we can get by unit laws for concatenating $\refl$'s and whiskering by $\id$.
#+end_proof

** Sequential colimits

\TODO[I formalized sections 3 and 4 from SvDR20, and the main theorem for the special case of equifibered sequencial diagrams].
[cite/t/cf:@SvDR20]

\TODO[Note that AFAIK descent and flattening aren't necessary for the main result of this thesis, but flattening and esp. generalized flattening are used in SvDR20 to prove connectivity results, which are then used in applications].

#+begin_defn
\TODO[Sequential diagrams].
#+end_defn

#+begin_remark
\TODO[AKA cotowers --- we decided to use (inverse) sequential diagrams in agda-unimath].
#+end_remark

#+begin_defn
\TODO[Cocones under sequential diagrams].
#+end_defn

The standard sequential colimit may be obtained as a coequalizer of
#+begin_center
\begin{tikzcd}[column sep=large]
  \Sigma \N A
  \arrow[r, shift right=1.25, "\id"']
  \arrow[r, shift left=1.25, "\tot_{\term{suc}}(a)"]
  & \Sigma \N A
\end{tikzcd}
#+end_center

#+begin_defn
\TODO[Dependent cocones under sequential diagrams].
#+end_defn

#+begin_defn
\TODO[Universal property].
#+end_defn

#+begin_defn
\TODO[Dependent universal property].
#+end_defn

#+begin_lemma
\TODO[DUP $\leftrightarrow$ UP].
#+end_lemma

#+begin_lemma
\TODO[Functoriality].
#+end_lemma

\TODO[The initial motivation for shifts is to show that dropping a finite number of vertices from a sequential diagram preserves the colimit. It is also useful for showing that zigzags induce equivalences in the colimit].

#+begin_constr
\TODO[Shifts of sequential diagrams].
#+end_constr

#+begin_constr
\TODO[Inclusion morphisms into shifts].
#+end_constr

#+begin_constr
\TODO[Shifts of morphisms of sequential diagrams].
#+end_constr

#+begin_constr
\TODO[Shifts of cocones].
#+end_constr

#+begin_constr
\TODO[Shifts of homotopies of cocones].
#+end_constr

#+begin_constr
\TODO[Unshifts of cocones].
#+end_constr

#+begin_constr
\TODO[Unshifts of homotopies of cocones].
#+end_constr

* Proof of correctness of the zigzag construction

\TODO[Mention that there are multiple versions].
\TODO[Mention that ours is a slight variation by switching relations for spans].

** Zigzags of sequential diagrams

#+begin_defn
\TODO[Zigzags].
#+end_defn

** The zigzag construction
:PROPERTIES:
:CUSTOM_ID: sec:zigzag-constr
:END:

#+begin_center
\begin{tikzcd}[column sep=6em]
  \Sigma (s : S) (r : b = (g s)). \; P_B^n(b)
  \arrow[r, "\tot(\tot(\blank \concat_n \overline{s}))"]
  \arrow[d, "\pr_3"']
  \arrow[rd, phantom, "\ulcorner", at end]
  & \Sigma (s : S) (r : b = (g s)). \; P_A^n(f s)
  \arrow[d, "\blank \concat_n' s \defeq \inr"] \\ P_B^n(b)
  \arrow[r, "\incl_B^n \defeq \inl"']
  & P_B^{n + 1}(b)
\end{tikzcd}
#+end_center

#+begin_center
\begin{tikzcd}[column sep=6em]
  \Sigma (s : S) (r : a = (f s)). \; P_A^n(a)
  \arrow[r, "\tot(\tot(\blank \concat_n' s))"]
  \arrow[d, "\pr_3"']
  \arrow[rd, phantom, "\ulcorner", at end]
  & \Sigma (s : S) (r : a = (f s)). \; P_B^{n + 1}(g s)
  \arrow[d, "\blank \concat_n \overline{s} \defeq \inr"] \\
  P_A^n(a)
  \arrow[r, "\incl_A^n \defeq \inl"']
  & P_A^{n + 1}(a)
\end{tikzcd}
#+end_center

** Proof of correctness

\TODO[The objective is to show that the zigzag descent data is an identity system. To do that, assume "dependent" descent data $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$, and a point $q_0 : Q_{\Sigma A}(a_0, \iota_A^0(\refl))$ and conjure a section of $Q$. Explicitly (write out the type of a section), which in every case proceeds by induction on $P_\bullet^{\infty}$.]

* Conclusion

Future work:
- more abstract proof of the last coherence: using the calculus of dependent identifications, and/or a more general lemma about coherent sections over zigzags; although that might have limited applications
- formalize applications
- formalize categorical statement

#+PRINT_BIBLIOGRAPHY: :heading bibintoc

\appendix
* List of attachments

Attachments consist of Git patch files, submitted as pull requests to the {{{AU}}} GitHub {{{AURepo}}}. They may be found in the =attachments= directory in the thesis source [[https://github.com/VojtechStep/homotopy-pushouts][repository]], and should also be included with any distribution of the thesis.

- {{{PR(535,refactor-descent-circle)}}}
- {{{PR(709,descent-circle)}}}
- {{{PR(724,foundation-precomp-concat-squares)}}}
- {{{PR(725,foundation-horizontal-paste-pushouts)}}}
- {{{PR(755,foundation-vertical-paste-pushouts)}}}
- {{{PR(758,foundation-unpaste-pushouts)}}}
- {{{PR(764,flattening-pushouts-family)}}}
- {{{PR(792,coequalizers)}}}
- {{{PR(816,flattening-pushouts-descent-data)}}}
- {{{PR(831,flattening-coequalizers)}}}
- {{{PR(841,sequential-colimits)}}}
- {{{PR(919,functoriality-sequential-colimits)}}}
- {{{PR(972,flattening-sequential-colimits-family)}}}
- {{{PR(978,refactor-functoriality-sequential-colimits)}}}
- {{{PR(988,refactor-lifts-families)}}}
- {{{PR(1070,shifts-sequential-colimits)}}}
- {{{PR(1098,refactor-coequalizers)}}}
- {{{PR(1109,flattening-sequential-colimits-descent-data)}}}
- {{{PR(1117,equivalences-sequential-comp)}}}
- {{{PR(1129,zigzags-sequential-diagrams)}}}
- {{{PR(1140,descent-coequalizers)}}}
- {{{PR(1145,descent-pushouts)}}}
- {{{PR(1148,characterization-families-pushouts)}}}
- {{{PR(1150,identity-systems-descent-pushouts)}}}


* COMMENT Battle plan
- [cite:@BW22] 2.5 for straightening/unstraightening

- [X] $\Sigma$ -types over pushouts
  - [X] Flattening lemma
  - [X] Applications
- [X] Path spaces of pushouts
  - [X] Formalize Kraus, von Raumer
    - [X] Understand the proof
    - [X] Convert from relations to spans?
  - [X] Figure out how to encode the sequence construction
    - [X] Induction on naturals with Σ → Σ, pushing forward $(a_0 \rightsquigarrow_t a , a_0 \rightsquigarrow_{t+1} b) \mapsto (a_0 \rightsquigarrow_{t + 2} a , a_0 \rightsquigarrow_{t + 3} b)$
    - [X] Try encoding the construction with spans instead of relations
- [X] Descent stuff
- [X] Zig-zags of sequences induce equivalences on sequential colimits
  - [X] More general functoriality of sequential colimits - not just standard ones, but formulated with UP

- [ ] Link constructions in prose to their definitions
- [ ] Link formal statements to the formalization

# The local variable is necessary to setup hyperref correctly

# Local Variables:
# org-latex-default-packages-alist: (("" "graphicx" t) ("" "wrapfig" nil) ("" "rotating" nil) ("normalem" "ulem" t) ("" "amsmath" t) ("" "amssymb" t) ("" "amsthm" t) ("" "capt-of" nil) ("rgb" "xcolor" nil) ("pdfa" "hyperref" nil) ("" "hyperxmp" nil) ("" "geometry" nil) ("nottoc" "tocbibind" nil) ("" "newpxtext" nil) ("" "unicode-math" nil) ("" "aliascnt") ("" "tikz-cd" t))
# org-latex-classes: (("report" "\\documentclass{report}" ("\\chapter{%s}" . "\\chapter*{%1$s}\\addcontentsline{toc}{chapter}{%1$s}") ("\\section{%s}" . "\\section*{%s}") ("\\subsection{%s}" . "\\subsection*{%s}") ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
# org-latex-reference-command: "\\autoref{%s}"
# eval: (general-define-key :states 'normal :keymaps 'local "C-c C-f" #'hl-todo-next "C-c C-b" #'hl-todo-previous)
# eval: (general-define-key :states 'insert :keymaps 'local "C-c C-." #'latex-insert-block)
# End:
