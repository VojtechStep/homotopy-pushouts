#+TITLE: Formalization of Homotopy Pushouts in Homotopy Type Theory
#+AUTHOR: Vojtěch Štěpančík
#+KEYWORDS: synthetic homotopy theory, homotopy type theory, univalent foundations of mathematics, formalization, homotopy pushouts

#+DESCRIPTION: Homotopy pushouts can be constructed as higher inductive types in Homotopy Type
#+DESCRIPTION: Theory, and their properties may be explored using the logical framework and
#+DESCRIPTION: formalized in a proof assistant. This thesis focuses on the descent property,
#+DESCRIPTION: due to Rijke \cite{Rij19}, which characterizes type families over pushouts; the
#+DESCRIPTION: flattening lemma, due to Brunerie \cite{Bru16}, which characterizes the total
#+DESCRIPTION: spaces of such families; and the universal property of identity types of
#+DESCRIPTION: pushouts, due to Kraus and von Raumer \cite{KvR19}. We also build elementary
#+DESCRIPTION: infrastructure for sequential colimits, following a paper of Sojakova, van Dorn,
#+DESCRIPTION: and Rijke \cite{SvDR20}. We then use the built machinery to provide a partial
#+DESCRIPTION: formalized proof of Wärn's zigzag construction of identity types of pushouts as
#+DESCRIPTION: sequential colimits \cite{War23}, leaving one coherence problem open.

# Document settings
#+LATEX_COMPILER: lualatex
#+BIBLIOGRAPHY: ./bibliography.bib
#+CITE_EXPORT: biblatex iso-numeric,sorting=nyt,maxcitenames=3,backref=true,useprefix=true
#+LATEX_CLASS: report
#+LATEX_CLASS_OPTIONS: [12pt,a4paper,twoside,openright]
#+OPTIONS: title:nil toc:nil ':t H:5

# Package options, derived partially from the thesis template
#+LATEX_HEADER: \geometry{margin=25mm,bindingoffset=14.2mm}
#+LATEX_HEADER: \let\openright=\cleardoublepage
#+LATEX_HEADER: \hypersetup{unicode,breaklinks=true,pdfapart=2,pdfaconformance=U}
#+LATEX_HEADER: \usetikzlibrary{decorations.pathmorphing}
#+LATEX_HEADER: \input{tex/pdfa.tex}

# Highlight overfull
#+LATEX_HEADER: \overfullrule=1mm

#+LATEX_HEADER: \newcommand{\TODO}[1][]{{\leavevmode\color{red}{\ifthenelse{\equal{#1}{}}{TODO}{#1}}}}

#+LATEX_HEADER: \newcommand{\ie}{i.e.~}
#+LATEX_HEADER: \newcommand{\eg}{e.g.~}

#+MACRO: AU [[https://unimath.github.io/agda-unimath/][agda-unimath]]
#+MACRO: AURepo [[https://github.com/UniMath/agda-unimath][repository]]

#+MACRO: PR (eval (let* ((full-name (concat $1 "-" $2 ".patch")) (path (concat "attachments/" full-name))) (if (file-exists-p path) (concat "=" full-name "= ([[https://github.com/UniMath/agda-unimath/pull/" $1 "][PR]])") (error (concat "File does not exist: " path)))))

#+LATEX_HEADER: \newcommand{\DeclareBinOperator}[2]{\newcommand{#1}{\mathbin{#2}}}

# Syntax macros
#+LATEX_HEADER: \newcommand{\blank}{{-}}
#+LATEX_HEADER: \newcommand{\typeformer}[1]{\operatorname{#1}}
#+LATEX_HEADER: \newcommand{\constructor}[1]{\operatorname{#1}}
#+LATEX_HEADER: \newcommand{\defterm}[1]{\operatorname{#1}}
#+LATEX_HEADER: \newcommand{\term}[1]{\operatorname{#1}}
#+LATEX_HEADER: \DeclareMathOperator{\id}{id}
#+LATEX_HEADER: \DeclareBinOperator{\defeq}{:=}
#+LATEX_HEADER: \DeclareBinOperator{\judeq}{\doteq}
#+LATEX_HEADER: \DeclareBinOperator{\comp}{\circ}

#+LATEX_HEADER: \DeclareMathOperator{\equivEq}{equiv-eq}

#+LATEX_HEADER: \DeclareMathOperator{\Id}{Id}
#+LATEX_HEADER: \DeclareMathOperator{\refl}{refl}
#+LATEX_HEADER: \DeclareBinOperator{\concat}{\bullet}
#+LATEX_HEADER: \DeclareMathOperator{\lunit}{lunit}
#+LATEX_HEADER: \DeclareMathOperator{\runit}{runit}
#+LATEX_HEADER: \DeclareMathOperator{\tr}{tr}
#+LATEX_HEADER: \DeclareMathOperator{\ap}{ap}
#+LATEX_HEADER: \DeclareMathOperator{\apd}{apd}

#+LATEX_HEADER: \DeclareBinOperator{\htpy}{\sim}
#+LATEX_HEADER: \DeclareMathOperator{\reflhtpy}{refl-htpy}
#+LATEX_HEADER: \DeclareBinOperator{\hconcat}{\concat_h}
#+LATEX_HEADER: \DeclareMathOperator{\eqHtpy}{eq-htpy}
#+LATEX_HEADER: \DeclareBinOperator{\lwhisk}{\cdot_{l}}
#+LATEX_HEADER: \DeclareBinOperator{\rwhisk}{\cdot_{r}}
#+LATEX_HEADER: \DeclareMathOperator{\runithtpy}{runit-htpy}

#+LATEX_HEADER: \newcommand{\N}{\mathbb{N}}
#+LATEX_HEADER: \newcommand{\0}{\mathbb{0}}
#+LATEX_HEADER: \newcommand{\1}{\mathbb{1}}

# Products
#+LATEX_HEADER: \DeclareMathOperator{\pr}{pr}

# Pushouts/coproducts
#+LATEX_HEADER: \DeclareMathOperator{\inl}{inl}
#+LATEX_HEADER: \DeclareMathOperator{\inr}{inr}
#+LATEX_HEADER: \DeclareMathOperator{\glue}{glue}
#+LATEX_HEADER: \DeclareMathOperator{\depCogap}{dep-cogap}
#+LATEX_HEADER: \newcommand{\codiag}{\nabla}
#+LATEX_HEADER: \newcommand{\coprodM}[2]{\left[#1, #2\right]}
#+LATEX_HEADER: \DeclareMathOperator{\cocone}{cocone}
#+LATEX_HEADER: \DeclareMathOperator{\coconeMap}{cocone-map}
#+LATEX_HEADER: \DeclareMathOperator{\depCocone}{dep-cocone}
#+LATEX_HEADER: \DeclareMathOperator{\depCoconeMap}{dep-cocone-map}
#+LATEX_HEADER: \DeclareMathOperator{\incl}{incl}
#+LATEX_HEADER: \DeclareMathOperator{\exf}{ex-falso}
#+LATEX_HEADER: \DeclareMathOperator{\psh}{pushout}

# Apparently unicode-math doesn't fix \Sigma in operator font,
# so use the "fixed" mupSigma command
# https://tex.stackexchange.com/questions/477662/fontspec-breaks-capital-greek-letters-in-declaremathoperator
#+LATEX_HEADER: \DeclareMathOperator{\uncurry}{ind-\mupSigma}
#+LATEX_HEADER: \DeclareMathOperator{\curry}{ev-pair}
#+LATEX_HEADER: \DeclareMathOperator{\tot}{tot}

# Object macros
#+LATEX_HEADER: \newcommand{\POData}[2]{\typeformer{Pushout}\;#1\;#2}
#+LATEX_HEADER: \newcommand{\PO}[3]{#2 \sqcup_{#1} #3}
#+LATEX_HEADER: \renewcommand{\S}{\mathcal{S}}
#+LATEX_HEADER: \newcommand{\T}{\mathcal{T}}

# Coequalizers
#+LATEX_HEADER: \newcommand{\D}{\mathcal{D}}
#+LATEX_HEADER: \DeclareMathOperator{\cofork}{cofork}
#+LATEX_HEADER: \DeclareMathOperator{\coforkMap}{cofork-map}
#+LATEX_HEADER: \DeclareMathOperator{\depCofork}{dep-cofork}
#+LATEX_HEADER: \DeclareMathOperator{\depCoforkMap}{dep-cofork-map}
#+LATEX_HEADER: \DeclareMathOperator{\spanDoubleArrow}{span-double-arrow}
#+LATEX_HEADER: \DeclareMathOperator{\coconeCofork}{cocone-cofork}
#+LATEX_HEADER: \DeclareMathOperator{\depCoconeDepCofork}{dep-cocone-dep-cofork}

# Sequential colimits
#+LATEX_HEADER: \newcommand{\A}{\mathcal{A}}
#+LATEX_HEADER: \newcommand{\B}{\mathcal{B}}
#+LATEX_HEADER: \newcommand{\C}{\mathcal{C}}
#+LATEX_HEADER: \DeclareMathOperator{\coconeN}{cocone\N}
#+LATEX_HEADER: \DeclareMathOperator{\coconeNMap}{cocone\N-map}
#+LATEX_HEADER: \DeclareMathOperator{\depCoconeN}{dep-cocone\N}
#+LATEX_HEADER: \DeclareMathOperator{\depCoconeNMap}{dep-cocone\N-map}
#+LATEX_HEADER: \DeclareMathOperator{\doubleArrowSeq}{double-arrow-seq}
#+LATEX_HEADER: \DeclareMathOperator{\coforkCoconeN}{cofork-cocone\N}
#+LATEX_HEADER: \DeclareMathOperator{\depCoforkDepCoconeN}{dep-cofork-dep-cocone\N}
#+LATEX_HEADER: \DeclareMathOperator{\precompHomN}{precomp-hom\N}
#+LATEX_HEADER: \DeclareMathOperator{\fmapHomN}{fmap-hom\N}
#+LATEX_HEADER: \DeclareMathOperator{\inclHomN}{incl-hom\N}
#+LATEX_HEADER: \DeclareMathOperator{\DDN}{DD\N}
#+LATEX_HEADER: \DeclareMathOperator{\ddNFam}{dd\N-fam}

# Universes
#+LATEX_HEADER: \newcommand{\UU}{\mathcal{U}}
#+LATEX_HEADER: \newcommand{\UV}{\mathcal{V}}
#+LATEX_HEADER: \newcommand{\UW}{\mathcal{W}}

# Descent data
#+LATEX_HEADER: \newcommand{\DD}{\term{DD}}
#+LATEX_HEADER: \newcommand{\ddFam}{\term{dd-fam}}
#+LATEX_HEADER: \newcommand{\correspDD}{\approx}

#+LATEX_HEADER: \newcommand{\sectDD}{\term{sect}}
#+LATEX_HEADER: \newcommand{\evreflidsystemDD}{\term{ev-refl-id-system-DD}}
#+LATEX_HEADER: \newcommand{\indidsystemDD}{\term{ind-Q}}

# Zigzag construction
#+LATEX_HEADER: \DeclareMathOperator{\PInf}{P^{\infty}}
#+LATEX_HEADER: \DeclareMathOperator{\reflinf}{\refl_{\infty}}
#+LATEX_HEADER: \newcommand{\concatInf}[1]{#1 \concat_{\infty}}


# Title page
#+begin_export latex
\def\TitleCS{Formalizace homotopických pushoutů v homotopické teorii typů}
\def\Department{Department of Algebra}
\def\DepartmentCS{Katedra algebry}
\def\ThesisSupervisor{doctor Egbert Rijke}
\def\StudyProgramme{Mathematical Structures}
\def\StudyBranch{MSPN}
\def\YearSubmitted{2024}
\def\Dedication{
DEDICATION
}
\def\AbstractCS{
\TODO[přeložit]
Homotopy pushouts can be constructed as higher inductive types in Homotopy Type
Theory, and their properties may be explored using the logical framework and
formalized in a proof assistant. This thesis focuses on the descent property,
due to Rijke \cite{Rij19}, which characterizes type families over pushouts; the
flattening lemma, due to Brunerie \cite{Bru16}, which characterizes the total
spaces of such families; and the universal property of identity types of
pushouts, due to Kraus and von Raumer \cite{KvR19}. We also build elementary
infrastructure for sequential colimits, following a paper of Sojakova, van Dorn,
and Rijke \cite{SvDR20}. We then use the built machinery to provide a partial
formalized proof of Wärn's zigzag construction of identity types of pushouts as
sequential colimits \cite{War23}, leaving one coherence problem open.
}
\def\KeywordsCS{syntetická homotopická teorie, homotopická teorie typů, univalentní základy matematiky, formalizace, homotopické pushouty}
\include{tex/title.tex}
\tableofcontents
#+end_export

# Theorem environments
#+begin_export latex
\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newaliascnt{lemma}{thm}
\newtheorem{lemma}[lemma]{Lemma}
\aliascntresetthe{lemma}
\newaliascnt{corol}{thm}
\newtheorem{corol}[corol]{Corollary}
\aliascntresetthe{corol}
% I was really hoping to get away without this one...
\newaliascnt{conj}{thm}
\newtheorem{conj}[conj]{Conjecture}
\aliascntresetthe{conj}

\theoremstyle{definition}
\newaliascnt{defn}{thm}
\newtheorem{defn}[defn]{Definition}
\aliascntresetthe{defn}
\newaliascnt{constr}{defn}
\newtheorem{constr}[constr]{Construction}
\aliascntresetthe{constr}

\theoremstyle{remark}
\newaliascnt{remark}{thm}
\newtheorem{remark}[remark]{Remark}
\aliascntresetthe{remark}

\def\thmautorefname{Theorem}
\def\lemmaautorefname{Lemma}
\def\corolautorefname{Corollary}
\def\conjautorefname{Conjecture}
\def\defnautorefname{Definition}
\def\constructorautorefname{Construction}
\def\chapterautorefname{Chapter}
#+end_export

* Introduction
:PROPERTIES:
:UNNUMBERED: t
:END:

 Homotopy Type Theory [cite//b:@UF13] is a logical framework built on Martin-Löf's type theory [cite//b:@ML75] and the univalence axiom, which characterizes identity types of universes. It is inspired by the homotopy interpretation of dependent type theory [cite//b:@AGMV11], in which types are interpreted as spaces, elements of types as points in the spaces, and identifications of elements as paths between the points. Using proof assistants such as Agda [cite//b:@Agda], one can translate proofs in Homotopy Type Theory into programs in a programming language, engaging in an activity called "formalization" [cite//b:@NPS90]. The validity of the constructions is verified by type-checking the programs.

 This work focuses on homotopy pushouts --- specifically we provide an exposition and formalization of the descent property [cite//b:@Rij19] and flattening lemma [cite//b:@Bru16], and use the built infrastructure to formally prove correctness of Wärn's zigzag construction of identity types of pushouts [cite//b:@War23].

 \TODO[We build more infrastructure than strictly necessary for sequential colimits, since we anticipate it will be useful when formalizing applications of the zigzag construction. The formalized material comes from SvDR20, and as a byproduct we started an effort to collect pages for formalization of results from the literature. Even though it is not of mathematical nature, it is relevant to the formalization aspect, as it builds more documentation, makes the development accessible, and sets an example for beginning formalizers].

 \TODO[Mention that David writes "At the time of writing, no such formalisation has been carried out, but we believe it would be feasible and worthwhile". But it's in the categorical paper?]

 \TODO[The bulk of the work is the reusable and documented formalization of the presented material in the {{{AU}}} library. The relevant proofs were "unformalized" into English and are presented below.]

**** Organization

The thesis is divided into four chapters. [[#chap:hott]] provides an abridged introduction to homotopy type theory, presenting the necessary foundational results of homotopy type theory on which we build. Those results are taken either from the "HoTT Book" [cite//b:@UF13], or from Rijke's textbook [cite//b:@Rij22] and the formalization in the {{{AU}}} library. [[#chap:pushouts]] introduces pushouts as structures satisfying a universal property, and describes some of their elementary properties, namely formation of type families over pushouts, a universal property of total spaces of type families over pushouts, and a universal property of identity systems of pushouts. [[#chap:colimits]] defines coequalizers and sequential colimits as other kinds of colimits, and shows how their existence and properties can be derived from pushouts. The focus of the chapter is primarily on sequential colimits, as the constructions are used in the succeeding [[#chap:zigzag-construction]]. The latter describes an explicit construction claimed to be an identity system of pushouts, built up of sequential colimits of pushouts, due to [cite/t:@War23]. It then proceeds to a description of a formalized partial proof that the construction is indeed an identity system, which has been carried out for the thesis.

**** Contributions

 \TODO[Chapter 1 and first section of chapter 2 consist of exposition to material that had already been formalized in the library. Formalization of all other parts of the thesis are original contributions to the library. The uniform treatment of sections of descent data, its application to identity systems in terms of descent data, the presented proof of the flattening lemma, and the proof of correctness of the zigzag construction is original research.]

* Homotopy Type Theory
:PROPERTIES:
:CUSTOM_ID: chap:hott
:END:


#+NAME: lemma:is-equiv-concat
#+begin_lemma
\TODO[is-equiv concat].
#+end_lemma

#+NAME: lemma:tr-id-right
#+begin_lemma
\TODO[tr-id-right].
#+end_lemma

#+NAME: lemma:is-equiv-tr
#+begin_lemma
For every type $A$, type family $B : A \to \UU$, two elements $x, y : A$ and an identification $p : x = y$, the transport map $\tr_P p : B x \to B y$ is an equivalence.
#+end_lemma

#+begin_proof
\TODO
#+end_proof

#+NAME: lemma:compute-equiv-eq-ap
#+begin_lemma
\TODO[transport is equiv-eq(ap)].
#+end_lemma

The following is a variation of the encode-decode method due to [cite/t:@LS13]
#+NAME: lemma:fundamental-theorem-id
#+ATTR_LATEX: :options [Fundamental theorem of identity types]
#+begin_lemma
\TODO[Fundamental theorem of identity types]
#+end_lemma

#+begin_lemma
\TODO[SIP] [cite/t:@Acz12]
#+end_lemma

#+NAME: lemma:3for2-equiv
#+ATTR_LATEX: :options [3-for-2 property of equivalences]
#+begin_lemma
Consider a commuting triangle of maps
#+begin_center
\begin{tikzcd}
  A \arrow[rr, "f"] \arrow[rd, "h"'] & & B \arrow[ld, "g"] \\
  & C.
\end{tikzcd}

If any two of the maps are equivalences, then so is the third.
#+end_center
#+end_lemma

#+begin_proof
\TODO
#+end_proof

#+NAME: lemma:distributive-pi-sigma
#+begin_lemma
\TODO[Distributivity of Pi over Sigma].
#+end_lemma

** Higher inductive types

\TODO[Does this even deserve a chapter? Or should it be assimilated into "Pushouts"?]

* Pushouts
:PROPERTIES:
:CUSTOM_ID: chap:pushouts
:END:

\TODO[Section introduction]

** Universal property

\TODO[Decide how to treat and write "span" vs "span diagram"].

\TODO[We differentiate between the concept of a "span", which is an element on a structure with a fixed domain and codomain, and a "span diagram", which is a pair of types with a span between them. The distinction is important when looking at morphisms of these structures --- a morphism of spans is a map between the spanning types, equipped with two homotopies for the appropriate triangles, while a morphism of span diagrams is a natural transformation. The presented material does not formally require the notion of spans, so we introduce span diagrams as the primitive notion. A similar distinction may be done between "cocone structure" with a specific vertex, and a "cocone". It is not realized in the current work, but there are plans to make the change in the library].

#+begin_defn
A *span diagram* is a quintuple $(A, B, S, f, g)$, where $A : \UU$, $B : \UV$ and $S : \UW$ are types, and $f : S \to A$ and $g : S \to B$ are ordinary maps.

We call $A$, $B$ and $S$ the *domain*, *codomain*, and the *spanning type* of the span diagram, respectively.
#+end_defn

#+begin_remark
\TODO[This might be a bad idea:] In the prose, we will often write $\S$ or $\S \judeq (f, g)$ for a span diagram, implicitly introducing the relevant types as the domains and codomains of the maps $f$ and $g$, which will by convention be called $A$, $B$ and $S$ as in the definition. We hope to not cause confusion by this choice.
#+end_remark

#+begin_defn
Given a span diagram $\S \judeq (f, g)$ and a type $X : \UU$, a *cocone* under $\S$ on $X$ is a triple $(i, j, H)$, where $i : A \to X$ and $j : B \to X$ are ordinary maps, and $H$ is a homotopy witnessing that the square
#+begin_center
\begin{tikzcd}
  S \arrow[r, "g"] \arrow[d, "f"']
  & B \arrow[d, "j"] \\
  A \arrow[r, "i"']
  & X
\end{tikzcd}
#+end_center
commutes, \ie $H : i \comp f \htpy j \comp g$.

We write $\cocone(\S, X)$ for the type of cocones under $\S$ on $X$.
#+end_defn

\TODO[To define what a "colimiting cocone" is in type theory, we derive inspiration from the categorical description as a classifier of cocones (phrasing?): a cocone $c$ on $X$ is a pushout if maps $X \to Y$ are in bijection with cocones on $Y$. There is a natural construction for extending a cocone $c$ on $X$ by a map $X \to Y$ to a cocone on $Y$, and we say that $c$ is a pushout of $\S$ exactly when this extension map is an equivalence $(X \to Y) \simeq \cocone(\S, Y)$].

#+begin_constr
Given a cocone $c \judeq (i, j, H) : \cocone(\S, X)$ and a type $Y : \UV$ we construct a map
\begin{equation*}
  \coconeMap_c^Y : (X \to Y) \to \cocone(\S, Y)
\end{equation*}
which sends $h$ to $(h \comp i, h \comp j, h \lwhisk H)$.

We may omit the upper index $Y$ or the lower index $c$, or both, if the appropriate value is clear from context.
#+end_constr

#+begin_defn
A cocone $c$ under $\S$ on $X$ satisfies the *universal property of pushouts* if for all $Y : \UV$, the map $\coconeMap_c^Y$ is an equivalence.

A cocone satisfying the universal property of pushouts is called a *pushout*. We will sometimes abuse notation and call just the type $X$ the pushout.
#+end_defn

Having $\coconeMap$ be an equivalence means that we not only have the converse map, which maps cocones to functions, but in particular the converse map is a section, so the cocone induced by the obtained map is the same as the original cocone. However identifications of cocones are not very practical objects. Instead of using them directly, we characterize the identity types of cocones as homotopies of cocones.

#+begin_defn
Given a span diagram $\S \judeq (f, g)$ and two cocones $c \judeq (i, j, H)$ and $c' \judeq (i', j', H')$ on $X$, the type of *homotopies* between $c$ and $c'$, denoted $c \htpy c'$, is the type of triples $(K_A, K_B, \alpha)$, where $K_A$ and $K_B$ are homotopies
\begin{align*}
  K_A &: i \htpy i' \\
  K_B &: j \htpy j'
\end{align*}
and $\alpha$ is a coherence witnessing that the following square of homotopies commutes
#+begin_center
\begin{tikzcd}
  i \comp f
  \arrow[r, squiggly, no head, "K_A \rwhisk f"]
  \arrow[d, squiggly, no head, "H"']
  & i' \comp f
  \arrow[d, squiggly, no head, "H'"] \\
  j \comp g
  \arrow[r, squiggly, no head, "K_B \rwhisk g"']
  & j' \comp g.
\end{tikzcd}
#+end_center
#+end_defn

#+begin_constr
Given a cocone $c \judeq (i, j, H) : \cocone(\S, X)$, construct the *reflexivity homotopy* $\term{cocone-refl-htpy} : c \htpy c$ from the data
\begin{alignat*}{2}
  &\reflhtpy &&: i \htpy i \\
  &\reflhtpy &&: j \htpy h \\
  &\runithtpy &&: H \hconcat \reflhtpy \htpy H.
\end{alignat*}
#+end_constr

#+name: lemma:htpy-eq-cocone
#+begin_lemma
For a span diagram $\S$ and two cocones $c$ and $c'$ on $X$, there is an equivalence
\begin{displaymath}
  \term{htpy-eq-cocone} : (c = c') \simeq (c \htpy c')
\end{displaymath}
which sends $\refl$ to $\term{cocone-refl-htpy}$.
#+end_lemma

The proof is a prototypical application of the fundamental theorem of identity types and the structure identity principle. We only write this one out for demonstration, as other straightforward proofs of characterizations of identity types are omitted from the thesis.

#+begin_proof
The underlying map is defined by path induction to send $\refl$ to $\term{cocone-refl-htpy}$. We use [[lemma:fundamental-theorem-id]] to prove that it is an equivalence, so it suffices to show that the type of cocones $c'$ such that $c \htpy c'$ is contractible. Since $c \htpy c'$ is a $\Sigma$ type, we invoke the structure identity principle \TODO[ref], which leaves us to show that the type
\begin{displaymath}
  \Sigma (i' : A \to X).\, (i \htpy i')
\end{displaymath}
is contractible to some point $(i', L)$, which by function extensionality it is at $(i, \reflhtpy)$, and then that the type
\begin{alignat*}{2}
  &\Sigma\, &&(j' : B \to X) (H' : i \comp f \htpy j' \comp g). \\
  &&&\Sigma\, (K_B : j \htpy j').\, (H \hconcat K_B \rwhisk g) \htpy (\reflhtpy \hconcat H')
\end{alignat*}
is contractible.

We use the structure identity principle again, so the new goal is to show that
\begin{displaymath}
  \Sigma (j' : B \to X).\, (j \htpy j')
\end{displaymath}
is contractible, which it is at $(j, \reflhtpy)$, and that the type
\begin{displaymath}
  \Sigma (H' : i \comp f \htpy j \comp g).\, (H \hconcat \reflhtpy) \htpy H'
\end{displaymath}
is contractible. And it is contractible once again at $(H \hconcat \reflhtpy, \reflhtpy)$.
#+end_proof

#+begin_lemma
Given a span diagram $\S \judeq (f, g)$, a pushout cocone $c \judeq (i, j, H) : \cocone(\S, X)$ and a cocone $c' \judeq (i', j', H') : \cocone(\S, Y)$, there is a unique map $h : X \to Y$ equipped with the homotopies
\begin{align*}
  K_A &: h \comp i \htpy i' \\
  K_B &: h \comp j \htpy j'
\end{align*}
and the coherence $\alpha$ witnessing that the following square of homotopies commutes
#+begin_center
\begin{tikzcd}
  h \comp i \comp f
  \arrow[r, squiggly, no head, "K_A \rwhisk f"]
  \arrow[d, squiggly, no head, "h \lwhisk H"']
  & i' \comp f
  \arrow[d, squiggly, no head, "H'"] \\
  h \comp j \comp g
  \arrow[r, squiggly, no head, "K_B \rwhisk g"']
  & j' \comp g.
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_proof
The data claimed to be unique is an element of the type
\begin{displaymath}
  \Sigma (h : X \to Y).\, (\coconeMap_c(h) \htpy c'),
\end{displaymath}
which is equivalent to the type of fibers of $\coconeMap_c$ at $c'$, by [[lemma:htpy-eq-cocone]]. Since $\coconeMap_c$ is an equivalence by assumption, it has contractible fibers.
#+end_proof

The universal property characterizes simple maps out of the colimit. In dependent type theory, we can also ask about characterizations of /dependent/ maps out of the colimit. To that end we introduce dependent cocones and the dependent universal property.

#+begin_defn
Consider a cocone $c \judeq (i, j, H) : \cocone(\S, X)$ and a type family $P : X \to \UV$. A *dependent cocone* over $c$ on $P$ is a triple $(i', j', H')$, where $i' : (a : A) \to P(i a)$ and $j' : (b : B) \to P(j b)$ are dependent maps over $i$ and $j$, respectively, and $H$ is a \TODO[dependent homotopy] between $i' \comp f$ and $j' \comp g$, \ie a family of identifications
\begin{alignat*}{2}
  H &:&& (s : S) \to i'(f s) =_{H s} j'(g s) \\
    &\judeq\;&& (s : S) \to \tr_P(H s) (i'(f s)) = j'(g s).
\end{alignat*}

We write $\depCocone(c, P)$ for the type of dependent cocones over $c$ on $P$.
#+end_defn

#+begin_constr
Given a cocone $c \judeq (i, j, H) : \cocone(\S, X)$ and a type family $P : X \to \UV$, define a map
\begin{equation*}
  \depCoconeMap_c^P : ((x : X) \to P(x)) \to \depCocone(c, P)
\end{equation*}
which sends $h$ to $(h \comp i, h \comp j, \lambda s \to \apd_h(H s))$.

We may omit the indices $c$ or $P$ if they are clear from context.
#+end_constr

#+begin_defn
A cocone $c : \cocone(\S, X)$ satisfies the *dependent universal property of pushouts* if for all $P : X \to \UV$, the map $\depCoconeMap_c^P$ is an equivalence.
#+end_defn

Note that the dependent universal property isn't a property of dependent cocones, but rather a property of cocones and their extensions by dependent functions.

#+begin_defn
Given a span diagram $\S \judeq (f, g)$, a cocone $c \judeq (\_, \_, H) : \cocone(\S, X)$ and two dependent cocones $d \judeq (i, j, L)$ and $d' \judeq (i', j', L')$ on $P$, the type of *homotopies* between $d$ and $d'$, denoted $d \judeq d'$, is the type of triples $(K_A, K_B, \alpha)$, where $K_A$ and $K_B$ are homotopies
\begin{align*}
  K_A &: i \htpy i' \\
  K_B &: j \htpy j'
\end{align*}
and $\alpha$ is a coherence witnessing that the following square of identifications commutes for every $s : S$
#+begin_center
\begin{tikzcd}[column sep=6em]
  \tr_P(H s)(i(f s))
  \arrow[r, equal, "\ap_{\tr_P(H s)}(K_A(f s))"]
  \arrow[d, equal, "L(s)"']
  & \tr_P(H s)(i'(f s))
  \arrow[d, equal, "L'(s)"] \\
  j (g s)
  \arrow[r, equal, "K_B(g s)"']
  & j' (g s).
\end{tikzcd}
#+end_center
#+end_defn

#+begin_lemma
For every pair of dependent cocones $d, d' : \depCocone(c, P)$, there is an equivalence
\begin{displaymath}
  \term{htpy-eq-dep-cocone}: (d = d') \simeq (d \htpy d').
\end{displaymath}
#+end_lemma

#+begin_lemma
Given a span diagram $\S \judeq (f, g)$, a pushout cocone $c \judeq (i, j, H) : \cocone(\S, X)$, and a dependent cocone $d \judeq (i', j', H') : \depCocone(c, P)$, there is a unique dependent map $h : (x : X) \to P(x)$ equipped homotopies
\begin{align*}
  K_A &: h \comp i \htpy i' \\
  K_B &: h \comp j \htpy j'
\end{align*}
and a coherence $\alpha$ witnessing that the following square of identifications commutes for all $s : S$
#+begin_center
\begin{tikzcd}[column sep=6em]
  \tr_P(H s)(h(i(f s)))
  \arrow[r, equals, "\ap_{\tr_P(H s)}(K_A(f s))"]
  \arrow[d, equals, "\apd_h(H s)"']
  & \tr_P(H s)(i'(f s))
  \arrow[d, "H'(s)"] \\
  h(j(g s))
  \arrow[r, equals, "K_B(g s)"']
  & j'(g s).
\end{tikzcd}
#+end_center
#+end_lemma

We don't introduce a new name for cocones satisfying the dependent universal property, because the two properties turn out to be equivalent. The proof relies on the pullback property and the dependent pullback property of pushouts, which relate pushouts and pullbacks of function types. As this thesis does not discuss pullbacks, we defer the proof to [cite/t:@Rij22Pre, Theorem 25.1.4].

#+name: lemma:dup-iff-up-pushout
#+begin_thm
A cocone $c : \cocone(\S, X)$ satisfies the universal property of pushouts if and only if it satisfies the dependent universal property of pushouts.
#+end_thm

#+begin_proof
There is a chain of logical equivalences
\begin{align*}
  & \text{$c$ satisfies the universal property of pushouts} \\
  & \leftrightarrow \text{$c$ satisfies the pullback property of pushouts} \\
  & \leftrightarrow \text{$c$ satisfies the dependent pullback property of pushouts} \\
  & \leftrightarrow \text{$c$ satisfies the dependent universal property of pushouts}.
\end{align*}
#+end_proof

#+name: remark:universal-properties
#+begin_remark
This equivalence of a non-dependent and dependent universal property is a more general phenomenon. In homotopy type theory, there are often multiple ways of describing universal properties. These expressions usually involve a base sort of objects and dependent objects, which can be equipped with some structure functorial in an appropriate notion of maps and dependent maps.

The functorial action
\begin{equation*}
  \term{fmap} : (X \to Y) \to \term{structure}(X) \to \term{structure}(Y)
\end{equation*}
can have its arguments rearranged so that for every structured object $(X, s)$ and a plain object $Y$, we get an "evaluation" map
\begin{equation*}
  \term{ev-map}_{(X, s)}^Y : (X \to Y) \to \term{structure}(Y).
\end{equation*}
In the dependent case, we get a map
\begin{equation*}
  \term{dep-ev-map}_{(X, s)}^P : ((x : X) \to P(x)) \to \term{dep-structure}((X, s), P).
\end{equation*}

When talking about pushouts, we take the base objects to be types, dependent objects to be type families, and maps and dependent maps to be ordinary functions and dependent functions. The functorial structure on a type $X$ is the structure of a cocone on $X$ under a fixed span diagram $\S$, and the dependent structure on a type family $P : X \to \UV$ over a cocone $c$ on $X$ is the structure of a dependent cocone on $P$ over $c$. The evaluation maps are $\coconeMap$ and $\depCoconeMap$, respectively.

With these general definitions in place, consider a structured object $(X, s)$; we may ask for the following properties to be satisfied:
- Universal property: For every object $Y$, $\term{ev-map}_{(X, s)}^Y$ is an equivalence
- Dependent universal property: For every dependent object $P$, $\term{dep-ev-map}_{(X, s)}^P$ is an equivalence
- Recursion principle and uniqueness: For every object $Y$, $\term{ev-map}_{(X, s)}^Y$ has a unique section
- Induction principle: For every dependent object $P$, $\term{dep-ev-map}_{(X, s)}^P$ has a section

The universal properties correspond to a notion of initiality: the evaluation map is an equivalence if and only if it has contractible fibers, \ie for all structured objects $(X, s)$ and $(Y, t)$, there is a unique map $h : X \to Y$ such that $\term{ev-map}_{(X, s)}^Y h = t$. The condition asks for $h$ to preserve the structure. In other words, the universal property says that $(X, s)$ is the initial object in a hypothetical "category" of structured objects and homomorphisms.

It was first shown by [cite/t:@AGS12] that the four properties are equivalent for a class of examples, where we have objects, type families, ordinary functions, dependent functions, and the (dependent) structures are (fibered) algebras for a polynomial functor. The result was later extended by
[cite/t:@Soj15] to include (fibered) algebras for W-suspensions, a higher inductive analogue of W-types. The structure of a (dependent) cocone can be expressed as a (fibered) algebra of a specific W-suspension, so this result is applicable to [[lemma:dup-iff-up-pushout]], but it hasn't been formalized in the library.

We will rely on informal understanding of this principle when discussing options for formalization of a universal property of the identity types of pushouts in [[#sec:identity-systems]].
#+end_remark

** Descent property

The study of type theoretic descent describes how type families over a colimit and related concepts, such as fiberwise maps or sections, arise as local data with gluing conditions \TODO[source?]. It has been studied to some extent by Rijke in [cite//b:@Rij19] and [cite//b:@Rij22Pre].

The universal property of pushouts characterizes maps out of a pushout to any type in any universe, so in particular maps where the codomain itself is a universe: a type family $P : X \to \UU$ corresponds to a cocone $(P_A, P_B, H)$ where $P_A : A \to \UU$, $P_B : B \to \UU$ are type families, and $H$ is a homotopy in the universe $H : (s : S) \to P_A(f s) = P_B(g s)$. Since identifications in universes are characterized by equivalences via the univalence axiom, we arrive at the definition of descent data:

#+begin_defn
Given a span diagram $\S \defeq (f, g)$, we call *descent data* over $\S$ a triple $(P_A, P_B, P_S)$ consisting of type families
\begin{align*}
  P_A &: A \to \UU \\
  P_B &: B \to \UU \\
\intertext{and a fiberwise equivalence}
  P_S &: (s : S) \to P_A(f s) \simeq P_B(g s).
\end{align*}

We use the notation $\DD(\S)$ for the type of descent data over a span diagram $\S$.
#+end_defn

It may not be immediately clear why "descent data" is an appropriate name for this concept, because there is no apparent downward motion. Traditionally, descent is studied in the context of a collection of objects $X_i$ covering a single object $X$, and local structure on the individual $X_i$'s descending onto $X$, collecting into a global structure, given that the pieces are appropriately compatible on any "overlaps". A pushout $X$ of $\S$ is covered by $A$ and $B$, and the overlaps are encoded in $f$ and $g$. Structure on $A$ and $B$, expressed as type families $P_A$ and $P_B$, "descends" to a structure on $X$ (a type family over $X$). Two elements "overlap" in $X$ if there is an identification between them coming from $S$, and the gluing/compatibility condition exactly requires the local structure of $P_A$ and $P_B$ to agree on such elements, i.e. asks for an equivalence $P_A(f s) \simeq P_B(g s)$.

The first task is to establish an equivalence between type families over a pushout and descent data over its defining span. A map from type families to descent data is easy enough to construct:

#+begin_constr
Given a cocone $c \judeq (i, j, H)$ on $X$, construct a map
\begin{displaymath}
  \ddFam_c : (X \to \UU) \to \DD(\S)
\end{displaymath}
which sends a type family $P : X \to \UU$ to the descent data $(P_A, P_B, P_S)$ obtained by precomposing
\begin{alignat*}{3}
  P_A &\defeq (\lambda a \to P(i a)) &&: A \to \UU \\
  P_B &\defeq (\lambda b \to P(j b)) &&: B \to \UU \\
\intertext{and transporting in $P$}
  P_S &\defeq (\lambda s \to \tr_P (H s)) &\quad&: (s : S) \to P (i (f s)) \simeq P (j (g s)).
\end{alignat*}

Note that $\tr_P (H s)$ is an equivalence by [[lemma:is-equiv-tr]].
#+end_constr

To show that $\ddFam_c$ is an equivalence, we employ a common technique for proving equivalences: construct a commuting diagram involving $\ddFam_c$ in which all other maps are equivalences. By repeated applications of [[lemma:3for2-equiv]], it follows that $\ddFam_c$ is an equivalence.

#+NAME: thm:descent-property
#+ATTR_LATEX: :options [Descent property]
#+begin_thm
Consider a span diagram $\S \defeq (f, g)$ and its pushout cocone $c$ on $X$. Then the map $\ddFam_c$ is an equivalence $(X \to \UU) \simeq \DD(\S)$.
#+end_thm

#+begin_proof
There is a triangle of maps
#+begin_center
\begin{tikzcd}
  (X \to \UU) \arrow[rr, "\coconeMap_c", "\simeq"'] \arrow[dr, "\ddFam_c"']
  && \cocone(\S, \UU) \arrow[dl, "\tot(\tot(\lambda s \to \equivEq))", "\simeq"'] \\
  & \DD(\S).
\end{tikzcd}
#+end_center

The top map is an equivalence by assumption, since $c$ is a pushout. The right map is an equivalence, because the map $\tot(h)$ is an equivalence if and only if $h$ is a fiberwise equivalence, and $\equivEq$ is an equivalence by the univalence axiom \TODO[ref]. By [[lemma:3for2-equiv]], it suffices to show that the triangle commutes to prove that $\ddFam_c$ is an equivalence.

By chasing a type family $P$ along the diagram, we see that we need to provide an identification
\[
  (P \comp i, P \comp j, \lambda s \to \tr_P(H s)) = (P \comp i, P \comp j, \lambda s \to \equivEq(\ap_P(H s))).
\]

The first two components are identical. To identify the third component, we invoke function extensionality \TODO[ref]; then it suffices to prove that for all $s : S$, there is an identification of equivalences
\[
  \tr_P(H s) = \equivEq(\ap_P(H s)),
\]
which is always the case by [[lemma:compute-equiv-eq-ap]] applied to the identification\linebreak ${H s : i(f s) = j(g s)}$.
#+end_proof

A corollary of $\ddFam_c$ being an equivalence is that it has contractible fibers, \ie for any descent data $(P_A, P_B, P_S)$ there is a unique type family $P$ such that $\ddFam_c(P) = (P_A, P_B, P_S)$. We proceed to work on characterization of identifications of descent data to get a more pleasant statement of this theorem. \TODO[phrasing]

#+begin_defn
Consider a span diagram $\S \judeq (f, g)$, and two descent data $(P_A, P_B, P_S)$ and $(Q_A, Q_B, Q_S)$ over it. A *morphism* of descent data between them is a pair of fiberwise maps
\begin{align*}
  h_A &: (a : A) → P_A a → Q_A a\\
  h_B &: (b : B) → P_B b → Q_B b
\end{align*}
equipped with a family of homotopies $h_S$ indexed by $s : S$ making
#+begin_center
\begin{tikzcd}
  P_A(f s) \arrow[r, "h_A(f s)"] \arrow[d, "P_S s"'] & Q_A(f s) \arrow[d, "Q_S s"] \\
  P_B(g s) \arrow[r, "h_B(g s)"'] & Q_B(g s)
\end{tikzcd}
#+end_center
commute.

We write $(h_A, h_B, h_S) : (P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)$.
#+end_defn

Analogously, we define equivalences of descent data.

#+begin_defn
Consider a span diagram $\S \judeq (f, g)$, and two descent data $(P_A, P_B, P_S)$ and $(Q_A, Q_B, Q_S)$ over it. An *equivalence* of descent data between them is a pair of fiberwise equivalences
\begin{align*}
  e_A &: (a : A) → P_A a \simeq Q_A a\\
  e_B &: (b : B) → P_B b \simeq Q_B b
\end{align*}
equipped with a family of homotopies $e_S$ indexed by $s : S$ making
#+begin_center
\begin{tikzcd}
  P_A(f s) \arrow[r, "e_A(f s)"] \arrow[d, "P_S s"'] & Q_A(f s) \arrow[d, "Q_S s"] \\
  P_B(g s) \arrow[r, "e_B(g s)"'] & Q_B(g s)
\end{tikzcd}
#+end_center
commute.

We write $(e_A, e_B, e_S) : (P_A, P_B, P_S) \simeq (Q_A, Q_B, Q_S)$.
#+end_defn

#+begin_remark
\TODO[equivalences with coherence vs hom with is-equiv].
#+end_remark

#+begin_lemma
\TODO[Equivalences characterize identifications]
#+end_lemma

#+attr_latex: [Uniqueness of descent data]
#+begin_thm
Consider a span diagram $\S \judeq (f, g)$ and a pushout cocone $c \judeq (i, j, H)$ on $X$. Then for any descent data $(P_A, P_B, P_S)$ over $\S$, the type of type families $P : X \to \UU$ equipped with an equivalence of descent data $\ddFam_c(P) \simeq (P_A, P_B, P_S)$ is contractible. In other words, there is a unique quadruple $(P, e_A, e_B, e_S)$ consisting of a type family $P : X \to \UU$, equivalences
\begin{align*}
  e_A : (a : A) \to P(i a) \simeq P_A(a) \\
  e_B : (b : B) \to P(j b) \simeq P_B(b),
\end{align*}
and a family of coherences $e_s$
#+begin_center
\begin{tikzcd}
  P(i (f s)) \arrow[r, "e_A(f s)"] \arrow[d, "\tr_P(H s)"'] & P_A(f s) \arrow[d, "P_S s"] \\
  P(j (g s)) \arrow[r, "e_B(g s)"'] & P_B(g s)
\end{tikzcd}
#+end_center
indexed by $s : S$.
#+end_thm

#+begin_proof
Equivalences of descent data characterize identifications of descent data, so the type of type families $P : X \to \UU$ equipped with an equivalence \linebreak ${\ddFam_c(P) \simeq (P_A, P_B, P_S)}$ is equivalent to the type of type families $P : X \to \UU$ with an identification $\ddFam_c(P) = (P_A, P_B, P_S)$. Since contractibility is preserved by equivalences, it suffices to show that the latter type is contractible. But that is exactly the type of fibers of $\ddFam_c$ over $(P_A, P_B, P_S)$, which are contractible on account of $\ddFam_c$ being an equivalence.
#+end_proof

When relating concepts from the world of type families with concepts from the world of descent data, it can be beneficial to be parametric over the data of a type family $P$ and its "corresponding descent data", meaning some descent data $(P_A, P_B, P_S)$ which is equivalent to the descent data induced by $P$. Of course, by the descent theorem this data is completely determined by either $P$ or $(P_A, P_B, P_S)$ up to identification, but this level of generality allows users to provide their own equivalences for potentially better computational properties. We introduce a shorthand notation.

#+begin_defn
Given a span diagram $\S$ and a cocone $c$ on $X$, we define the type of *families with descent data* to be the type of triples $(P, P', e)$ consisting of a type family $P : X \to \UU$, descent data $P' : \DD(\S)$, and an equivalence of descent data $e : \ddFam_c(P) \simeq P'$.

We write $e : P \correspDD P'$ for a family $P$ with descent data $P'$ related by an equivalence $e$. We also say that $P$ is characterized by $P'$.
#+end_defn

#+begin_remark
\TODO[Note that we don't require $c$ to be a pushout. In subsequent development, and in the formalization, we often parameterize constructions by a family with descent data, which incentivizes general constructions applicable to non-pushout cocones.]
#+end_remark

#+begin_remark
\TODO[Move this to flattening?] The concept of a family with descent data has a direction: the equivalence relates $\ddFam_c(P)$ on the left with $P'$ on the right. It lends itself well to characterizations of concrete type families, where $P$ has a specific shape, and we want to recover the shape of corresponding descent data by computing $P(i a)$'s and $P(j b)$'s. However there are applications where the converse direction is more suitable. In those cases we write $e : P' \correspDD P$ for descent data $P'$, a type family $P$, and an equivalence of descent data $e : P' \simeq \ddFam(P)$.
#+end_remark

As a first example of a family with descent data, we characterize the type family of based identity types.

#+begin_constr
Given a span diagram $\S \judeq (f, g)$, a cocone $(i, j, H)$ on $X$ and a point $x_0 : X$, construct the descent data $(I_A, I_B, I_S)$ as \TODO[typesetting]
\begin{align*}
  I_A &\defeq (\lambda a \to x = (i a)) &&: A \to \UU \\
  I_B &\defeq (\lambda b \to x = (j b)) &&: B \to \UU \\
  I_S &\defeq (\lambda s, p \to p \concat (H s)) &&: (s : S) \to I_A(f s) \simeq I_B(g s).
\end{align*}

The concatenation operation is an equivalence by [[lemma:is-equiv-concat]].
#+end_constr

#+begin_remark
Note that the basepoint $x_0$ is not mentioned in the notation $(I_A, I_B, I_S)$. \TODO[Whenever we use it, it should be clear from the context].
#+end_remark

#+name: lemma:fam-with-dd-id
#+begin_lemma
Given a cocone and a basepoint $x_0 : X$ as above, the type family $\Id(x_0) : X \to \UU$ is characterized by the descent data $(I_A, I_B, I_S)$. Explicitly, there are equivalences
\begin{align*}
  e_A &: (a : A) \to (x_0 = (i a)) \simeq I_A(a) \\
  e_B &: (b : B) \to (x_0 = (j b)) \simeq I_B(b)
\end{align*}
and a coherence $e_S$
#+begin_center
\begin{tikzcd}
  (x_0 = i (f s))
  \arrow[r, "e_A(f s)"]
  \arrow[d, "\tr_{\Id(x_0)} (H s)"']
  & I_A(f s)
  \arrow[d, "I_S s"] \\
  (x_0 = j (g s))
  \arrow[r, "e_B(g s)"']
  & I_B(g s)
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_proof
By definition, $I_A(a) \judeq (x_0 = (i a))$ and $I_B(b) \judeq (x_0 = (j b))$, so we may choose the identity equivalence for $e_A$ and $e_B$. Then the coherence datum amounts to showing that $\tr_{\Id(x_0)}(H s, p) = p \concat (H s)$, which is [[lemma:tr-id-right]].
#+end_proof

For any given type family $P$ over $X$, we can talk about its /sections/, elements of the type $(x : X) \to P(x)$. We define an analogous concept of /sections of descent data/, and show that indeed they correspond to sections of type families over pushouts.

#+begin_defn
Given a span diagram $\S$ and descent data $(P_A, P_B, P_S)$ over it, a *section* of $(P_A, P_B, P_S)$ is a triple $(t_A, t_B, t_S)$ consisting of sections
\begin{align*}
  t_A &: (a : A) \to P_A(a) \\
  t_B &: (b : B) \to P_B(b)
\intertext{and a coherence}
  t_S &: (s : S) \to P_S(s, t_A(f s)) = t_B(g s).
\end{align*}

We write $\sectDD(P_A, P_B, P_S)$ for the type of sections of $(P_A, P_B, P_S)$.
#+end_defn

#+name: def:sect-sect
#+begin_constr
Given a span diagram $\S \judeq (f, g)$, a cocone $c \judeq (i, j, H)$ on $X$, and a family with descent data $e : P \correspDD (P_A, P_B, P_S)$, construct a map
\[
  \term{sect-sect}_c : ((x : X) \to P(x)) \to \sectDD(P_A, P_B, P_S)
\]
by assigning to a dependent function $h$ the section
\begin{alignat*}{3}
  &(\lambda a \to e_A(h(i a))) &&:\,&& (a : A) \to P_A(a) \\
  &(\lambda b \to e_B(h(j b))) &&:&& (b : B) \to P_B(b) \\
  &(\lambda s \to (e_S(h(i(f s))))^{-1} \concat \ap_{e_B}(\apd_h(H s))) &&:&& (s : S) \to \\
  &&&&&P_S(s, e_A(h(i(f s)))) = e_B(h(j(g s))).
\end{alignat*}
#+end_constr

#+name: lemma:is-equiv-sect-sect
#+begin_lemma
Consider a span diagram $\S$, a pushout cocone $c$ on $X$ and a family with descent data $P \correspDD (P_A, P_B, P_S)$. Then the map $\term{sect-sect}_c$ is an equivalence.
#+end_lemma

#+begin_proof
The map factors through the dependent cocone map as
#+begin_center
\begin{tikzcd}
  ((x : X) \to P(x))
  \arrow[rr, "\depCoconeMap_c", "\simeq"']
  \arrow[dr, "\term{sect-sect}_c"']
  && \depCocone(c, P)
  \arrow[dl, "\simeq"] \\
  & \sectDD(P_A, P_B, P_S),
\end{tikzcd}
#+end_center
where the right map takes $(i', j', H')$ to
\begin{alignat*}{3}
  &(\lambda a \to e_A(i' a)) &\quad&:\,&& (a : A) \to P_A(a) \\
  &(\lambda b \to e_B(j' b)) &&:&& (b : B) \to P_B(b) \\
  &(\lambda s \to (e_S(i'(f s)))^{-1} \concat \ap_{e_B}(H' s)) &&:&& (s : S) \to \\
  &&&&&P_S(s, e_A(i'(f s))) = e_B(j'(g s)).
\end{alignat*}

The right map is an equivalence, because its action on the first two components is postcomposition by a fiberwise equivalence, which is an equivalence, and its action on the third component is a fiberwise application of $\ap_{e_B}$, which is an equivalence, and concatenation with an identification, which is an equivalence.

The triangle commutes by $\reflhtpy$. By the 3-for-2 property of equivalences, it follows that $\term{sect-sect}_c$ is an equivalence.
#+end_proof

\TODO[Are homotopies of sections worth mentioning? It gives a nicer phrasing of (some) computation rules by computing the fibers of $\term{sect-sect}_c$, but it's all pretty standard stuff].

Equipped with the tools for computing data over pushouts by gluing together data over its components, we continue by computing fiberwise maps and equivalences over pushouts. We first characterize type families of fiberwise maps, \ie families with fibers of the shape $P(x) \to Q(x)$.

#+begin_remark
It is important to differentiate between families of /function types/, \ie a type family that to every $x : X$ assigns the /type/ $P(x) \to Q(x)$, and families of /functions/, \ie a family that to every $x : X$ assigns a /function/ from $P(x)$ to $R(x)$. Descent data plays the role of a family of types, so it makes sense to talk about "descent data corresponding to a family of function types", but it doesn't make sense to talk about "descent data corresponding to a family of functions". The kind of objects that corresponds to families of functions are the sections of the descent data of a family of function types.
#+end_remark

#+name: lemma:family-with-dd-function-types
#+begin_lemma
Given a cocone $c$ on $X$ and two families with descent data $e^P : P \approx (P_A, P_B, P_S)$ and $e^Q : Q \approx (Q_A, Q_B, Q_S)$, the type family
\[
  (\lambda x \to (P(x) \to Q(x))) : X \to \UU
\]
is characterized by the descent data
\begin{alignat*}{3}
  &(\lambda a \to (P_A(a) \to Q_A(a))) &\quad&:\,&&A \to \UU \\
  &(\lambda b \to (P_B(b) \to Q_B(b))) &&:&&B \to \UU \\
  &(\lambda s, h \to Q_S(s) \comp h \comp (P_S(s))^{-1}) &&:&&(s : S) \to \\
  &&&&&(P_A(f s) \to Q_A(f s)) \simeq (P_B(g s) \to Q_B(g s)).
\end{alignat*}

Note that postcomposition and precomposition by an equivalence is an equivalence of function types.
#+end_lemma

#+begin_proof
We need to provide equivalences
\begin{align*}
  e_A &: (a : A) \to (P(i a) \to Q(i a)) \simeq (P_A(a) \to Q_A(a)) \\
  e_B &: (b : B) \to (P(j b) \to Q(j b)) \simeq (P_B(b) \to Q_B(b))
\end{align*}
and a coherence $e_S$
#+begin_center
\begin{tikzcd}[column sep=large]
  (P(i(f s)) \to Q(i(f s)))
  \arrow[r, "e_A(f s)"]
  \arrow[d, "\tr_{(\lambda x \to (P(x) \to Q(x)))}(H s)"']
  & (P_A(f s) \to Q_A(f s))
  \arrow[d, "Q_S(s) \comp \, \blank \, \comp (P_S(s))^{-1}"] \\
  (P(j(g s)) \to Q(j(g s)))
  \arrow[r, "e_B(g s)"']
  & (P_B(g s) \to Q_B(g s)).
\end{tikzcd}
#+end_center

Define the equivalences by
\begin{align*}
e_A(a, h) &\defeq e^Q_A(a) \comp h \comp (e^P_A(a))^{-1}\\
e_B(b, h) &\defeq e^Q_B(b) \comp h \comp (e^P_B(b))^{-1}.
\end{align*}

Transport in a type family of function types can be computed as composition of transports in the involved families by \TODO[ref], so the left map can be replaced by $\tr_Q(H s) \comp \blank \comp \tr_P(H s)^{-1}$. Since we want to identify two functions, we invoke function extensionality, and are left with the goal
#+begin_center
\begin{tikzcd}
  P_B(g s)
  \arrow[r, "(P_S(s))^{-1}"]
  \arrow[d, "(e^P_B(g s))^{-1}"']
  & P_A(f s)
  \arrow[d, "(e^P_A(f s))^{-1}"] \\
  P(j(g s))
  \arrow[r, "\tr_P(H s)^{-1}"']
  & P(i(f s))
  \arrow[r, "h"]
  & Q(i(f s))
  \arrow[r, "e^Q_A(f s)"]
  \arrow[d, "\tr_Q(H s)"']
  & Q_A(f s)
  \arrow[d, "Q_S(s)"] \\
  && Q(j(g s))
  \arrow[r, "e^Q_B(g s)"']
  & Q_B(g s)
\end{tikzcd}
#+end_center
for all $h : P(i(f s)) \to Q(i(f s))$. The right square is exactly $e^Q_S(s)$, and the left square is $e^P_S(s)$ mirrored vertically and horizontally.
#+end_proof

#+name: lemma:hom-sect-dd
#+begin_lemma
The type of sections of the descent data defined in [[lemma:family-with-dd-function-types]] is equivalent to morphisms $(P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)$.
#+end_lemma

#+begin_proof
\TODO
#+end_proof

#+begin_thm
Consider a span diagram $\S$, a pushout cocone $c \judeq (i, j, H)$ on $X$, and two families with descent data $e^P : P \correspDD (P_A, P_B, P_S)$ and $e^Q : Q \correspDD (Q_A, Q_B, Q_S)$. Then there is an equivalence
\[
  \term{hom-map} : ((x : X) \to P(x) \to Q(x)) \simeq ((P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)).
\]
Additionally, the following diagrams commute for all $h : (x : X) \to P(x) \to Q(x)$
#+begin_center
\begin{tikzcd}[column sep=6em]
  P(i a)
  \arrow[r, "h(i a)"]
  \arrow[d, "e^P_A(a)"']
  & Q(i a)
  \arrow[d, "e^Q_A(a)"] \\
  P_A(a)
  \arrow[r, "\term{hom-map}(h)_A(a)"']
  & Q_A(a)
\end{tikzcd}
\begin{tikzcd}[column sep=6em]
  P(j b)
  \arrow[r, "h(j b)"]
  \arrow[d, "e^P_B(b)"']
  & Q(j b)
  \arrow[d, "e^Q_B(b)"] \\
  P_B(b)
  \arrow[r, "\term{hom-map}(h)_B(b)"']
  & Q_B(b).
\end{tikzcd}
#+end_center
#+end_thm

#+begin_proof
The type of fiberwise maps is by definition the type of sections of the family $\lambda x \to (P(x) \to Q(x))$, which is equivalent to the type of sections of the descent data from [[lemma:family-with-dd-function-types]] by [[lemma:is-equiv-sect-sect]]. That type of sections is equivalent to the type of morphisms of descent data by [[lemma:hom-sect-dd]].

Computing the action of this equivalence on a fiberwise map $h : (x : X) \to P(x) \to Q(x)$, we get the definitional equalities
\begin{alignat*}{2}
  &\term{hom-map}(h)_A &&\defeq \lambda a \to e^Q_A(a) \comp h(i a) \comp (e^P_A(a))^{-1} \\
  &\term{hom-map}(h)_B &&\defeq \lambda b \to e^Q_B(b) \comp h(j b) \comp (e^P_B(b))^{-1},
\end{alignat*}
so by transposing $e^P_A(a)$ and $e^P_B(b)$, we get the desired computation rules.
#+end_proof

Completely analogously, we may characterize the type family of equivalence types, and show that fiberwise equivalences correspond to equivalences of descent data. We present the statements without proof \TODO[but they are formalized].

#+begin_lemma
Given a cocone $c$ on $X$ and two families with descent data $e^P : P \correspDD (P_A, P_B, P_S)$ and $e^Q : Q \correspDD (Q_A, Q_B, Q_S)$, the type family
\begin{displaymath}
  (\lambda x \to (P(x) \simeq Q(x))) : X \to \UU
\end{displaymath}
is characterized by the descent data
\begin{alignat*}{3}
  &(\lambda a \to (P_A(a) \simeq Q_A(a))) &\quad&:\,&&A \to \UU \\
  &(\lambda b \to (P_B(b) \simeq Q_B(b))) &&:&&B \to \UU \\
  &(\lambda s, h \to Q_S(s) \comp h \comp (P_S(s))^{-1}) &&:&&(s : S) \to \\
  &&&&&(P_A(f s) \simeq Q_A(f s)) \simeq (P_B(g s) \simeq Q_B(g s)).
\end{alignat*}
#+end_lemma

#+name: thm:equivDD-equiv
#+begin_thm
Consider a span diagram $\S$, a pushout cocone $c \judeq (i, j, H)$ on $X$, and two families with descent data $e^P : P \correspDD (P_A, P_B, P_S)$ and $e^Q : Q \correspDD (Q_A, Q_B, Q_S)$. Then there is an equivalence
\begin{displaymath}
  \term{equivDD-equiv} : ((x : X) \to P(x) \simeq Q(x)) \simeq ((P_A, P_B, P_S) \simeq (Q_A, Q_B, Q_S)).
\end{displaymath}
Additionally, the following diagrams commute for all $e : (x : X) \to P(x) \simeq Q(x)$
#+begin_center
\begin{tikzcd}[column sep=8em]
  P(i a)
  \arrow[r, "e(i a)"]
  \arrow[d, "e^P_A(a)"']
  & Q(i a)
  \arrow[d, "e^Q_A(a)"] \\
  P_A(a)
  \arrow[r, "\term{equivDD-equiv}(e)_A(a)"']
  & Q_A(a)
\end{tikzcd}
\begin{tikzcd}[column sep=8em]
  P(j b)
  \arrow[r, "e(j b)"]
  \arrow[d, "e^P_B(b)"']
  & Q(j b)
  \arrow[d, "e^Q_B(b)"] \\
  P_B(b)
  \arrow[r, "\term{equivDD-equiv}(e)_B(b)"']
  & Q_B(b).
\end{tikzcd}
#+end_center
#+end_thm

\TODO[Does it make sense to talk about homotopies of morphisms of descent data? I formalized it all, and we can show that for a morphism, the type of fiberwise functions such that the induced morphism is homotopic to the original one is contractible, but that still needs a bit more work to properly interpret the computation rules (the computation on points is easy enough, but the path case is tricky). It adds approx. 1 page].

#+begin_comment
,#+begin_defn
For any two morphisms $(h_A, h_B, h_S)$ and $(k_A, k_B, k_S)$ between $(P_A, P_B, P_S)$ and $(Q_A, Q_B, Q_S)$, we define the type of *homotopies* to be the type of triples $(H_A, H_B, H_S)$ consisting of fiberwise homotopies
\begin{align*}
  H_A &: (a : A) \to h_A(a) \htpy k_A(a) \\
  H_B &: (b : B) \to h_B(b) \htpy h_B(b)
\end{align*}
and a coherence datum $H_S$ indexed by $s : S$, asserting that the squares of homotopies
,#+begin_center
\begin{tikzcd}[column sep=6em]
  h_B(g s) \comp P_S(s)
  \arrow[r, squiggly, "H_B(g s) \rwhisk P_S(s)"]
  \arrow[d, squiggly, "h_S(s)"']
  & k_B(g s) \comp P_S(s)
  \arrow[d, squiggly, "k_S(s)"] \\
  Q_S(s) \comp h_A(f s)
  \arrow[r, squiggly, "Q_S(s) \lwhisk H_A(f s)"'] & Q_S(s) \comp k_A(f s)
\end{tikzcd}
,#+end_center
commute.

We write $(H_A, H_B, H_S) : (h_A, h_B, h_S) \htpy (k_A, k_B, k_S)$.
,#+end_defn

,#+begin_remark
The coherence can be seen as a filler of the shape one gets by gluing the squares $h_S$ and $k_S$ along the common vertical maps, as in
,#+begin_center
\begin{tikzcd}[row sep=5em]
  P_A(f s)
  \arrow[r, bend left, "k_A(f s)"]
  \arrow[r, bend right, "h_A(f s)"']
  \arrow[d, "P_S(s)"']
  & Q_A(f s) \arrow[d, "Q_S(s)"] \\
  P_B(g s)
  \arrow[r, bend left, "k_B(g s)"]
  \arrow[r, bend right, "h_B(g s)"']
  & Q_B(g s).
\end{tikzcd}
,#+end_center

The front square is $h_S$, the back square is $k_S$, the top face is $H_A$ and the bottom face is $H_B$. The coherence $H_S$ expresses that going along the front square and then the top face is homotopic to first going along the bottom face and then the back square.
,#+end_remark

,#+begin_lemma
The type of homotopies of morphisms of descent data characterizes the identity type of morphisms of descent data. In other words, given two morphisms of descent data $h, k : (P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)$, there is an equivalence
\begin{equation*}
  \defterm{extensionality-hom-DD} : (h = k) \simeq (h \htpy k).
\end{equation*}
,#+end_lemma

,#+begin_proof
We define the underlying map by path induction. Assume $h \doteq k$ are identified by $\refl$. The identity homotopy $h \htpy k$ is defined as \TODO[typesetting]
\begin{align*}
  H_A &\defeq (\lambda a \to \reflhtpy) &&: (a : A) \to h_A \htpy h_A \\
  H_B &\defeq (\lambda b \to \reflhtpy) &&: (b : B) \to h_B \htpy h_B \\
  H_S &\defeq (\lambda s \to \runit)    &&: (s : S) \to h_S(s) \concat refl = h_S(s).
\end{align*}

To show that it is an equivalence, we may appeal to [[lemma:fundamental-theorem-id]]. It then suffices to show that the type $\Sigma (k : P \to Q). (h \htpy k)$ is contractible.
,#+end_proof

,#+begin_corol
\TODO[Uniqueness of a fiberwise map with nice computational properties].
,#+end_corol
#+end_comment

The correspondence of concepts between the world of type families over pushouts and the world of descent data is summarized in [[fig:descent-table]]. Since we want to arrive at an alternative characterization of the identity descent data $(I_A, I_B, I_S)$ via the zigzag construction, we chose to identify its universal property. We can take inspiration from the various universal properties satisfied by the family of identity types $\Id(x_0) \defeq (\lambda x \to (x_0 = x))$. Some of those properties arise from it being the initial pointed type family, in the sense of [[remark:universal-properties]]. As we will see, in this case the induction principle can be reduced to defining a converse map; it will automatically be a section. \TODO[We make an educated guess that it will be the easiest property to formalize]. It also corresponds to the induction principle stated by [cite/t:@KvR19].

However, the induction principle speaks about dependent type families of the sort $(x : X) \to (p : P(x)) \to \UU$. Instead of building new infrastructure for "dependent descent data", we notice that by uncurrying, those dependent type families are exactly the type families $\Sigma X P \to \UU$! This observation makes us ask another question --- to use descent, we need type families over a pushout; by assumption, $X$ is a pushout, but here we require $\Sigma X P$ to be a pushouts as well. The next section is dedicated to proving that indeed, the total space of a family over a pushout is a pushout.

#+name: fig:descent-table
#+caption: Translation table between type families and descent data
#+begin_figure
|                    | Families                       | Descent data                             |
|--------------------+--------------------------------+------------------------------------------|
| Objects            | $P : X \to \UU$                | $(P_A, P_B, P_S)$                        |
| Sections           | $(x : X) \to P(x)$             | $\sectDD(P_A, P_B, P_S)$                 |
| Morphisms          | $(x : X) \to P(x) \to Q(x)$    | $(P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)$    |
| Equivalences       | $(x : X) \to P(x) \simeq Q(x)$ | $(P_A, P_B, P_S) \simeq (Q_A, Q_B, Q_S)$ |
| Identity objects   | $\lambda x \to (x_0 = x)$      | $(I_A, I_B, I_S)$                        |
| Identity induction | Identity systems               | ???                                      |
#+end_figure

** Flattening lemma

The flattening lemma for pushouts effectively states that pushouts commute with dependent pair types --- the total space of a type family over a pushout is a pushout of total spaces of the corresponding descent data.

The presented proof is split into two parts. First we prove the statement specifically for a type family and the descent data it induces, which reduces the amount of data we need to make coherent. Then we relate the cocone for descent data induced by the family to the cocone for arbitrary corresponding descent data, in a way that preserves being a pushout.

#+name: lemma:is-pushout-bottom-ff-is-pushout-top
#+begin_lemma
\TODO[In a cube where vertical maps are equivalences, the bottom square is a pushout iff the top square is a pushout].
#+end_lemma

#+begin_proof
\TODO[Probably omitted. Goes through the pullback property and the dual statement for pullbacks].
#+end_proof

#+begin_constr
Given a span diagram $\S \judeq (f, g)$ and descent data $(P_A, P_B, P_S)$, construct the *total span diagram* \TODO[($\Sigma \S$ ?)]
#+begin_center
\begin{tikzcd}[column sep=huge]
  \Sigma A P_A
  & \Sigma S (P_A \comp f)
  \arrow[l, "\tot_f(\id)"']
  \arrow[r, "\tot_g(P_S)"]
  & \Sigma B P_B.
\end{tikzcd}
#+end_center
#+end_constr

#+begin_constr
Given a span diagram $\S \judeq (f, g)$, a cocone $c \judeq (i, j, H)$ on $X$, and a family with descent data $(e_A, e_B, e_S) : (P_A, P_B, P_S) \correspDD P$, construct the *total cocone* \TODO[($\Sigma c$ ?)] under the total span diagram
#+begin_center
\begin{tikzcd}[column sep=huge]
  \Sigma S (P_A \comp f)
  \arrow[d, "\tot_f(\id)"']
  \arrow[r, "\tot_g(P_S)"]
  & \Sigma B P_B
  \arrow[d, "\tot_j(e_B)"] \\
  \Sigma A P_A
  \arrow[r, "\tot_i(e_A)"']
  \arrow[ur, phantom, "H'"]
  & \Sigma X P,
\end{tikzcd}
#+end_center
where the coherence $H'$ at $s : S$, $p : P_A(f s)$ is given by
\begin{align*}
  H'_1 &\defeq H(s) &&: i (f s) = j (g s) \\
  H'_2 &\defeq e_S(s, p)^{-1} &&: \tr_P(H(s), e_A(s, p)) = e_B(P_S(s, p)).
\end{align*}
\TODO[An identification in $\Sigma$ is a $\Sigma$ of identifications].
#+end_constr

#+name: lemma:flattening-base
#+begin_lemma
Given a pushout square $(i, j, H)$ on $X$ and a type family $P : X \to \UU$, the total cocone of $(P \comp i, P \comp j, \tr_P(H)) \correspDD P$ is a pushout.
#+end_lemma

#+begin_proof
The goal is to prove that for any type $Y$, the map
\begin{displaymath}
  \coconeMap_{\Sigma c} : (\Sigma X P \to Y) \to \cocone(\Sigma c, Y)
\end{displaymath}
is an equivalence. We achieve that by forming a commuting pentagon, in which all other maps are equivalences:
#+begin_center
\begin{tikzcd}[ampersand replacement=\&]
  (\Sigma X P \to Y)
  \arrow[r, "\coconeMap_{\Sigma c}"]
  \&
  \begin{aligned}
    \Sigma
    &(h_A : \Sigma A (P \comp i) \to Y) \\
    &(h_B : \Sigma B (P \comp j) \to Y). \\
    &((s, p) : \Sigma S (P \comp i \comp f)) \to \\
    &h_A(f s, p) = h_B(g s, \tr_P(H s, p))
  \end{aligned}
  \arrow[dd, "\curry^3", "\simeq"'] \\
  (x : X) \to P(x) \to Y
  \arrow[u, "\uncurry", "\simeq"']
  \arrow[d, "\depCoconeMap_c"', "\simeq"] \\
  \begin{aligned}
    \Sigma
    &(h_A : (a : A) \to P(i a) \to Y) \\
    &(h_B : (b : B) \to P(j b) \to Y). \\
    &(s : S) \to \\
    &\tr_{(\lambda x \to (P(x) \to Y))}(H s, h_A(f s)) = h_B(g s)
  \end{aligned}
  \&
  \begin{aligned}
    \Sigma
    &(h_A : (a : A) \to P(i a) \to Y) \\
    &(h_B : (b : B) \to P(j b) \to Y). \\
    &(s : S) (p : P(i(f s))) \to \\
    &h_A(f s, p) = h_B(g s, \tr_P(H s, p)).
  \end{aligned}
  \arrow[l, "\tot(\tot(\varphi))", "\simeq"']
\end{tikzcd}
#+end_center

The types $\cocone(\Sigma \S, Y)$ and $\depCocone(c, (\lambda x \to (P(x) \to Y)))$ were expanded in the diagram. The pentagon commutes by reflexivity on the first two components. To finish the proof, we need to define an equivalence
\begin{displaymath}
  \varphi : (h_A(f s) \htpy h_B(g s) \comp \tr_P(H s)) \simeq (\tr_{(\lambda x \to (P(x) \to Y))}(H s, h_A(f s)) = h_B(g s))
\end{displaymath}
such that $\apd_h(H s) = \varphi(\lambda p \to \ap_{\uncurry(h)}((H s, \refl)))$ \TODO[implicitly applying eq-$\Sigma$-eq-pair]. This map and its computation rule is defined in the next lemma in more generality, which finishes the proof.
#+end_proof

#+begin_lemma
Given maps $i, j : S \to X$ with a homotopy $H : i \htpy j$, a type family $P : X \to \UU$, a type $Y$, and two dependent maps
\begin{align*}
  k &: (s : S) \to P(i s) \to Y\\
  l &: (s : S) \to P(j s) \to Y,
\end{align*}
there is for every $s : S$ an equivalence
\begin{displaymath}
  \varphi : (k(s) \htpy l(s) \comp \tr_P(H s)) \simeq (\tr_{(\lambda x \to (P(x) \to Y))}(H s, k(s)) = l(s))
\end{displaymath}

Additionally, for $k \judeq (h \comp i)$ and $l \judeq (h \comp j)$ where $h : (x : X) \to P(x) \to Y$ is any dependent map, it computes as
\begin{displaymath}
  \varphi(\lambda p \to \ap_{\uncurry(h)}((H s, \refl))) = \apd_h(H s).
\end{displaymath}
#+end_lemma

#+begin_proof
By homotopy induction \TODO[define homotopy induction], it suffices to consider the case where $j \judeq i$ and $H$ is the reflexivity homotopy. The goal is
\begin{displaymath}
  (k(s) \htpy l(s)) \simeq (k(s) = l(s)),
\end{displaymath}
which holds by function extensionality.

The computation rule follows again by induction on $H$. Then it suffices to show that $\varphi(\reflhtpy) = \refl$. By computation of homotopy induction $\varphi(\reflhtpy)$ computes to $\eqHtpy(\reflhtpy)$, which computes to $\refl$.
#+end_proof

#+name: lemma:flattening-cube
#+begin_lemma
Given a type family $P : X \to \UU$ with corresponding descent data $(P_A, P_B, P_S)$, there is a commuting cube
#+begin_center
\begin{tikzcd}[column sep=huge, row sep=huge]
  & \Sigma S (P_A \comp f)
  \arrow[dl, "\tot_f(\id)"']
  \arrow[d, "\tot(e_A)"]
  \arrow[dr, "\tot_g(P_S)"]
  & \\
  \Sigma A P_A
  \arrow[d, "\tot(e_A)"']
  & \Sigma S (P \comp i \comp f)
  \arrow[dl, "\tot_f(\id)"', very near start]
  \arrow[dr, "\tot_g(\tr_P(H))", very near start]
  & \Sigma B P_B
  \arrow[dl, crossing over, "\tot_j(e_B)", very near end]
  \arrow[d, "\tot(e_B)"] \\
  \Sigma A (P \comp i)
  \arrow[dr, "\tot_i(\id)"']
  & \Sigma X P
  \arrow[from=ul, crossing over, "\tot_i(e_A)"', very near end]
  \arrow[d, "\id"]
  & \Sigma B (P \comp j)
  \arrow[dl, "\tot_j(\id)"] \\
  & \Sigma X P
\end{tikzcd}
#+end_center
where the top square is the coherence of the total cocone of $(P_A, P_B, P_S) \correspDD P$, and the bottom square is the coherence of the total cocone of $(P \comp i, P \comp j, \tr_P(H)) \correspDD P$.
#+end_lemma

#+begin_proof
The back left, front left, and front right squares commute by $\reflhtpy$. The back right square commutes by $(\refl, (e_s)^{-1})$. The commuting cube is therefore an element of the type
\begin{align*}
  &(\tot_i(\id) \lwhisk \reflhtpy) \hconcat (\reflhtpy \rwhisk \tot_f(\id)) \hconcat (\id \lwhisk (H, e_S^{-1})) = \\
  &((H, \reflhtpy) \rwhisk \tot(e_A)) \hconcat (\tot_j(\id) \lwhisk (\reflhtpy, e_S^{-1})) \hconcat (\reflhtpy \rwhisk \tot_g(P_S)).
\end{align*}

The left homotopy computes to $\id \lwhisk (H, e_S^{-1})$, which is identical to $(H, e_S^{-1})$. The last concatenant \TODO[is that a word?] of the right homotopy is $\reflhtpy$, so we can compute it away.

The new goal is
\begin{align*}
  (H, e_S^{-1}) = (H, \reflhtpy) \hconcat (\tot_j(\id) \lwhisk (\reflhtpy, e_S^{-1})).
\end{align*}

The total map $\tot_j(\id)$ acts on $(\reflhtpy, e_S^{-1})$ component-wise, so it can be further computed to $(\reflhtpy, \id \lwhisk (e_S^{-1}))$, which is identical to $(\reflhtpy, e_S^{-1})$. To finish the proof, we note that any identification $(p, q) : (s, t) = (s', t')$ in a $\Sigma$ type can be decomposed as $(p, \refl) \concat (\refl, q)$.
#+end_proof

#+name: lemma:flattening-lemma
#+attr_latex: :options [Flattening lemma]
#+begin_thm
Given a pushout $c$ and a family with descent data $(P_A, P_B, P_S) \correspDD P$, the total cocone is a pushout.
#+end_thm

#+begin_proof
By [[lemma:flattening-base]], the bottom square in [[lemma:flattening-cube]] is a pushout, and all of $e_A(a)$, $e_A(f s)$, $e_B(b)$ and $\id$ are equivalences, so it follows by [[lemma:is-pushout-bottom-ff-is-pushout-top]] that the top square is a pushout.
#+end_proof

** Identity systems
:PROPERTIES:
:CUSTOM_ID: sec:identity-systems
:END:

We define a universal property of descent data for the identity types of pushouts, which allows their alternative characterizations. The property is analogous to a pointed type family being an identity system, which manifests it as the homotopy-initial pointed type family \TODO[Define pointed-type-family identity systems somewhere]; in fact, we show that a type family over a pushout is an identity system if and only if the corresponding descent data satisfies this universal property.

Given descent data $(P_A, P_B, P_S)$ for a span diagram $\S \judeq (f, g)$ and a point ${p_0 : P_A(a_0)}$ over a basepoint $a_0 : A$, we would like to mirror the definition of identity systems. A naïve translation would lead us to define dependent descent data and its sections. We choose to sidestep building that technical infrastructure.

By the descent property, there is a unique type family $P : X → \UU$ corresponding to $(P_A, P_B, P_S)$. Observe that the type of dependent type families $(x : X) → P(x) → \UU$ is equivalent to the uncurried form $(\Sigma X P) → \UU$. By the flattening lemma, the total space $\Sigma X P$ is the pushout of the span diagram of total spaces
#+begin_center
\begin{tikzcd}[column sep=large]
  \Sigma A P_A
  & \Sigma S (P_A \circ f)
  \arrow[l, "\tot_f \id"']
  \arrow[r, "\tot_g P_S"]
  & \Sigma B P_B
\end{tikzcd}
#+end_center

so, again by the descent property, descent data over it correspond to type families over $\Sigma X P$. Hence we can talk about descent data $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ over the total span diagram instead of dependent descent data. We write a $\Sigma$ in the indices of $Q$ to remind ourselves that it is descent data over the total span diagram.

#+begin_constr
Assume a span diagram $\S \judeq (f, g)$, descent data $(P_A, P_B, P_S)$ over it, a basepoint $a_0 : A$ and a point $p_0 : P_A(a_0)$. For any descent data $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ over the total span, define the map
\begin{align*}
  \evreflidsystemDD : \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S}) &\to Q_{\Sigma A}(a_0, p_0) \\
  (t_A, t_B, t_S) &\mapsto t_A (a_0, p_0).
\end{align*}
#+end_constr

#+begin_defn
Descent data $(P_A, P_B, P_S)$ equipped with a point $p_0 : P_A(a_0)$ satisfies the *induction principle of identity systems* if for all $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$, the map $\evreflidsystemDD$ has a section, in the sense that there is a converse map
\begin{equation*}
  \indidsystemDD : Q_{\Sigma A}(a_0, p_0) \to \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})
\end{equation*}
and an identification
\begin{equation*}
  (\indidsystemDD(q_0))_A (a_0, p_0) = q_0
\end{equation*}
for all $q_0 : Q_{\Sigma A}(a_0, p_0)$.

Such descent data is called an *identity system* at $p_0$.
#+end_defn

\TODO[Mind the unfortunate
terminology clash between "sections of descent data" and "sections of a map"].

#+begin_remark
Note that this development is biased towards the left --- we pick a basepoint in the domain $a_0 : A$, a point in the left type family $p_0 : P_A(a_0)$, and the evaluation map evaluates the left map of the section. By symmetry of pushouts we could just as well work with the points $b_0 : B$, $p_0 : P_B(b_0)$, and the evaluation map evaluating the right map of the section.
#+end_remark

#+begin_remark
By showing that the canonical descent data for identity types is an identity system, we recover the "induction principle for pushout equality" stated and proved by [cite/t/f:@KvR19] \TODO[figure out proper citation incantation].

First observe that the type of sections of $\evreflidsystemDD$ is
\begin{align*}
  \Sigma \;
  &(\indidsystemDD : (Q_{\Sigma A} (a_0, p_0)) \to \sectDD (Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})) \\
  &((q_0 : Q_{\Sigma A} (a_0, p_0)) \to (\indidsystemDD q_0)_A (a_0, p_0) = q_0),
\end{align*}
which is equivalent to the type
\begin{align}
  &(q_0 : Q_{\Sigma A} (a_0, p_0)) \to \nonumber\\
  &\Sigma \;
  (\indidsystemDD : \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})) \label{kvr:section} \\
  &\quad(\indidsystemDD_A (a_0, p_0) = q_0) \label{kvr:issection}
\end{align}
by [[lemma:distributive-pi-sigma]].

Then the induction terms from [cite//b:@KvR19] (with names changed to fit our naming scheme)
\begin{align*}
  \term{ind_A} &: (a : A) (r : i(a_0) = i(a)) → Q_{\Sigma A} (a, r) \\
  \term{ind_B} &: (b : B) (r : i(a_0) = j(b)) → Q_{\Sigma B} (b, r)
\end{align*}
are the first and second components of the section \ref{kvr:section} induced by $q_0$, and their computation rules
\begin{align*}
  &\term{ind_A} (a_0, \refl) = q_0 \\
  &Q_{\Sigma S} (s, r, \term{ind_A} (f s, r)) = \term{ind_B} (g s, r \concat H s)
\end{align*}
arise as the second component \ref{kvr:issection}, and the coherence condition of \ref{kvr:section}, respectively.
#+end_remark

We first show a result relating identity systems stated as pointed type families and identity systems stated as pointed descent data.

#+name: lemma:square-id-system-id-system-DD
#+begin_lemma
Consider a pushout cocone $c$ on $X$, a type family with corresponding descent data $e^P : P \correspDD (P_A, P_B, P_S)$ and a point $p_0 : P_A(a_0)$. Then for any type family with corresponding descent data $e^Q : Q_{\Sigma} \correspDD (Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ there is a commuting diagram
#+begin_equation
\begin{tikzcd}[row sep=large, column sep=small]
  ((x : X) (p : P(x)) \to Q_{\Sigma} (x , p))
  \arrow[r, "\simeq"]
  \arrow[d, "\term{ev-refl-id-system}"']
  & ((u : \Sigma X P) \to Q_{\Sigma} u)
  \arrow[r, "\simeq"]
  & \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})
  \arrow[d, "\evreflidsystemDD"'] \\
  Q_{\Sigma}(i a_0, (e^P_A(a_0))^{-1}(p_0))
  \arrow[rr, "e^Q_A(a_0{,} p_0)"', "\simeq"]
  &
  & Q_{\Sigma A}(a_0, p_0).
\end{tikzcd}
#+end_equation
#+end_lemma

#+begin_proof
The top equivalences are, from left to right, $\uncurry$ and $\term{sect-sect}_{\Sigma c}$. To see that the square commutes, note that the first component of $\term{sect-sect}_{\Sigma c}(\uncurry(h))$ sends $(a, p) : \Sigma A P_A$ to $e^Q_A(h(ia, (e^P_A(a))^{-1}(p)))$ by definition of the total cocone. The square commutes by $\reflhtpy$.
#+end_proof

#+name: lemma:is-id-system-DD-is-id-system
#+begin_corol
Assume $e : P \correspDD (P_A, P_B, P_S)$ where $P$ is an identity system at $(e_A(a_0))^{-1}(p_0) : P(i a_0)$. Then $(P_A, P_B, P_S)$ is an identity system at $p_0$.
#+end_corol

#+begin_proof
For every $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ there is a corresponding type family $Q_{\Sigma}$. Then we may apply [[lemma:square-id-system-id-system-DD]]. The top and bottom maps are equivalences, and the left maps has a section by assumption, hence the right map has a section.
#+end_proof

#+name: lemma:is-id-system-is-id-system-DD
#+begin_corol
Analogously, if $(P_A, P_B, P_S)$ is an identity system at $p_0 : P_A(a_0)$, then $P$ is an identity system at $(e_A(a_0))^{-1}(p_0)$.
#+end_corol

#+begin_thm
Given a span diagram $\S$, a point $a_0 : A$, and a pushout cocone $c$ on $X$, the descent data $(I_A, I_B, I_S)$ is an identity system at $\refl_{i a_0}$.
#+end_thm

#+begin_proof
By [[lemma:fam-with-dd-id]] and [[lemma:is-id-system-DD-is-id-system]], the descent data $(I_A, I_B, I_S)$ is an identity system at $\refl : (i a_0) = (i a_0)$ if and only if the corresponding type family $\Id (i a_0) : X → 𝒰$ is an identity system at $\refl$, which is established in \TODO[ref].
#+end_proof

The induction principle of identity systems is stated in terms of an evaluation map having a section, which makes it consistent with statements of other induction principles in Homotopy Type Theory. However, the following lemma shows that the condition on the converse map of being a section is redundant.

#+name: lemma:identity-system-ind-singleton
#+begin_lemma
Consider a span diagram $\S$ and its pushout cocone $c$ on $X$. To show that $(P_A, P_B, P_S)$ is an identity system at $p₀ : P_A(a_0)$, it suffices to provide a map
\begin{displaymath}
  H : Q_{\Sigma A}(a_0, p_0) \to \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})
\end{displaymath}
for every descent data $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ over the total span diagram.
#+end_lemma

#+begin_proof
Construct the unique type family $P : X → \UU$ for $(P_A, P_B, P_S)$. It suffices to show that $P$ is an identity system. Equivalently, it suffices to show that the total space $\Sigma X P$ is contractible. We can prove that using the property that a type is contractible if we provide a point, here $(i a_0, (e^P_A a_0)^{-1}(p_0))$, and a map
\begin{equation*}
  H' : (Q_{\Sigma} : \Sigma X P → \UU) → (q_0 : Q_{\Sigma} (i a_0, (e^P_A a)^{-1} p_0)) → (u : \Sigma X P) → Q_{\Sigma}(u).
\end{equation*}
Assume such $Q_{\Sigma}$ and $q_0$. A section $(u : \Sigma X P) → Q_{\Sigma}(u)$ is given by a section
of $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$, and we can get one by applying $H$ to
$e^Q_A ((a_0, p_0), q_0): Q_{\Sigma A} (a_0, p_0)$.
#+end_proof

#+begin_remark
Note that the pushout $c$ is not used in the statement of the lemma. We include it as a parameter to avoid assuming existence of all pushouts.
#+end_remark

#+name: thm:unique-uniqueness-id-system
#+begin_thm
Consider a span diagram $\S$, a point $a_0 : A$, and a pushout cocone $c$. For any identity system $(P_A, P_B, P_S)$ at $p_0 : P_A(a_0)$, there is a unique equivalence of descent data
\begin{displaymath}
  e : (I_A, I_B, I_S) \simeq (P_A, P_B, P_S)
\end{displaymath}
such that $e_A(\refl) = p_0$.
#+end_thm

#+begin_proof
Construct the unique type family $P : X → \UU$ corresponding to $(P_A, P_B, P_S)$. By [[thm:equivDD-equiv]] the type of point preserving equivalences between $(I_A, I_B, I_S)$ and $(P_A, P_B, P_S)$ is equivalent to the type of fiberwise equivalences $(x : X) → ((i a_0) = x) \simeq P(x)$ that send $\refl$ to $(e^P_A a_0)^{-1}(p_0)$. To show that this type is contractible, it suffices to show that the total space $\Sigma X P$ is contractible \TODO[ref]. It is contractible if $P$ is an identity system, which it is by [[lemma:is-id-system-is-id-system-DD]] and the assumption that $(P_A, P_B, P_S)$ is an identity system.
#+end_proof

Unfolding the data of the equivalence, we get
\begin{align*}
  e_A &: (a : A) \to (i a_0 = i a) \simeq P_A(a) \\
  e_B &: (b : B) \to (i a_0 = j b) \simeq P_B(b) \\
  e_S &: (s : S) (p : i a_0 = i(f s)) \to e_B(g s, p \concat (H s)) = P_S(s, e_A(f s, p)).
\end{align*}

** COMMENT van Kampen squares

\TODO[Should I finish this section? It gets wishy-washy kinda quickly].

There is an alternative description of descent and flattening, one that doesn't mention universes and is phrased only with pushouts and pullbacks. This section is meant to be an informal exposition of the relationship between the type-theoretic and homotopy-theoretic perspectives. The material hasn't been formalized yet in the {{{AU}}} library at the time of writing.

[cite/t:@LS04] define van Kampen squares as pushout squares satisfying the first and second cube theorems of [cite/t:@Mat76]. We will see that the first cube theorem corresponds to type-theoretic descent, and the second cube theorem corresponds to the flattening lemma, a results that [cite/t:@War24] hints at is folklore (\TODO[verify this, but I haven't found any explanation]). [cite/t:@Rij19 proof of Theorem 2.2.11] shows that the second cube theorem follows from the flattening lemma.

#+begin_defn
Consider a pushout square
#+begin_center
\begin{tikzcd}
  S
  \arrow[r, "g"]
  \arrow[d, "f"']
  \arrow[dr, phantom, "\ulcorner", at end]
  & B
  \arrow[d, "j"] \\
  A
  \arrow[r, "i"']
  \arrow[ur, phantom, "H"]
  & X.
\end{tikzcd}
#+end_center
If for all commuting cubes
#+begin_center
\begin{tikzcd}[]
  & S' \arrow[dl] \arrow[d] \arrow[dr] \\
  A' \arrow[d]
  & S \arrow[dl, "f"', near start] \arrow[dr, "g", near start]
  & B' \arrow[dl, crossing over] \arrow[d] \\
  A \arrow[dr, "i"']
  & X' \arrow[from=ul, crossing over] \arrow[d]
  & B \arrow[dl, "j"] \\
  & X
\end{tikzcd}
#+end_center
where the bottom square is $H$ and the two back faces are pullback squares, it holds that
1. if the top square is a pushout, then the two front faces are pullbacks; then $H$ satisfies the *first cube axiom*
2. if the two front faces are pullbacks, then the top square is a pushout; then $H$ satisfies the *second cube axiom*.
#+end_defn

#+begin_defn
A pushout square is *van Kampen* if it satisfies both the first and second cube axioms.
#+end_defn

* Other colimits
:PROPERTIES:
:CUSTOM_ID: chap:colimits
:END:

Pushouts and the empty type suffice to construct many other kinds of colimits. We are particularly interested in sequential colimits, which figure prominently in the zigzag construction in [[#sec:zigzag-constr]]. Sequential colimits and some of their properties may be derived from pushouts. Their construction is more natural if we first formalize a basic theory of coequalizers on top of pushouts, and then we formalize sequential colimits on top of coequalizers.

** Coequalizers
:PROPERTIES:
:CUSTOM_ID: sec:coequalizers
:END:

#+begin_defn
A *double arrow* is a pair of types $A : \UU$, $B : \UV$, equipped with a pair of maps $f, g : A \to U$.
#+end_defn

#+begin_defn
Given a double arrow $\D \judeq (f, g)$ and a type $X : \UU$, a *cofork* under $\D$ on $X$ is a pair $(i, H)$, where $i : B \to X$ is a map, and $H$ is a homotopy of type $i \comp f \htpy i \comp g$.

We write $\cofork(\D, X)$ for the type of coforks under $\D$ on $X$.
#+end_defn

#+begin_constr
Given a cofork $c \judeq (i, H) : \cofork(\D, X)$ on $X$ and a type $Y : \UV$, we construct a map
\begin{displaymath}
  \coforkMap_c^Y : (X \to Y) \to \cofork(\D, Y)
\end{displaymath}
which sends $h$ to $(h \comp i, h \lwhisk H)$.
#+end_constr

#+begin_defn
A cofork $c$ under $\D$ on $X$ satisfies the *universal property of coequalizers* if for all $Y : \UV$, the map $\coforkMap_c^Y$ is an equivalence.

A cofork satisfying the universal property of coequalizers is called a *coequalizer*.
#+end_defn

#+begin_constr
Construct the map $\spanDoubleArrow$ from double arrows to span diagrams by
#+begin_center
\begin{tikzcd}
  A \arrow[r, shift left=1.25, "g"] \arrow[r, shift right=1.25, "f"'] & B
\end{tikzcd}
\hspace{3em} $\mapsto$ \hspace{3em}
\begin{tikzcd}
  A & A + A \arrow[l, "\codiag"'] \arrow[r, "\coprodM{f}{g}"] & B,
\end{tikzcd}
#+end_center
where the left map is the codiagonal map, sending $\inl(a)$ and $\inr(a)$ to $a$, and the right map is defined by the universal property of coproducts to send $\inl(a)$ to $f(a)$ and $\inr(a)$ to $g(a)$.
#+end_constr

The standard coequalizer of $\D$ may be obtained as the pushout of $\spanDoubleArrow(\D)$.

#+name: lemma:cocone-cofork
#+begin_lemma
For any double arrow $\D$ and a type $X$, there is an equivalence
\begin{displaymath}
  \coconeCofork : \cofork(\D, X) \simeq \cocone(\spanDoubleArrow(\D), X)
\end{displaymath}
which fits into the following commuting triangle for every cofork $c : \cofork(\D, X)$
#+begin_center
\begin{tikzcd}[column sep=small]
  (X \to Y)
  \arrow[rr, "\coforkMap_c"]
  \arrow[dr, "\coconeMap_{\coconeCofork(c)}"']
  && \cofork(\D, Y)
  \arrow[dl, "\coconeCofork", "\simeq"'] \\
  & \cocone(\spanDoubleArrow(\D), Y).
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_proof
To define the forward map, assume a cofork $(j, H)$, where $j : B \to X$ and $H : j \comp f \htpy j \comp g$. To construct the cocone under $\spanDoubleArrow(\D)$, take $j \comp f : A \to X$ to be the first component and $j$ to be the second component. It remains to construct a homotopy
#+begin_center
\begin{tikzcd}
  A + A
  \arrow[r, "\coprodM{f}{g}"]
  \arrow[d, "\codiag"']
  & B
  \arrow[d, "j"] \\
  A
  \arrow[r, "j \comp f"']
  & X.
\end{tikzcd}
#+end_center
On $\inl(a) : A + A$ the square commutes by $\refl$, and on $\inr(a) : A + A$ it commutes by $H : j \comp f \htpy j \comp g$, which we write as $\coprodM{\reflhtpy}{H}$.

To define the inverse map, assume a cocone $(i, j, H)$ where $i : A \to X$, $j : B \to X$, and $H$ witnesses commutativity of the square
#+begin_center
\begin{tikzcd}
  A + A
  \arrow[r, "\coprodM{f}{g}"]
  \arrow[d, "\codiag"']
  & B
  \arrow[d, "j"] \\
  A
  \arrow[r, "i"']
  & X.
\end{tikzcd}
#+end_center

Since the codomain of the homotopy is a coproduct, it corresponds to a pair of homotopies $H_1 : i \htpy j \comp f$ and $H_2 : i \htpy j \comp g$. To construct the cofork under $\D$, take $j$ to be the first component, and the concatenation $H_1^{-1} \hconcat H_2 : j \comp f \htpy j \comp g$ for the second component.

\TODO[We need to show that they are mutual inverses. It requires homotopies of cocones and coforks, which I want to avoid, so maybe skip that?]

To show commutativity of the triangle, chase a map $h : X \to Y$:
#+begin_center
\begin{tikzcd}[ampersand replacement=\&, column sep=small]
  h
  \arrow[rr, mapsto]
  \arrow[dr, mapsto]
  \&\&(h \comp j, h \lwhisk H)
  \arrow[dl, mapsto] \\
  \&\left(
  \begin{aligned}
    &h \comp j \comp f, \\
    &h \comp j, \\
    &h \lwhisk \coprodM{\reflhtpy}{H}
  \end{aligned}
  \right)
  =
  \left(
  \begin{aligned}
    &h \comp j \comp f, \\
    &h \comp j, \\
    &\coprodM{\reflhtpy}{h \lwhisk H}
  \end{aligned}
  \right).
\end{tikzcd}
#+end_center

The first two components are identical, so it suffices to show that for all $a : A + A$, the identifications $\ap_h(\coprodM{\reflhtpy}{H}(a))$ and $\coprodM{\reflhtpy}{\ap_h(H(a))}$ agree. On elements of the form $\inl(a)$ they both compute to $\refl$, and on elements of the form $\inr(a)$ they compute to $\ap_h(H(a))$, so they are identified by $\refl$.
#+end_proof

#+name: lemma:coeq-pushout
#+begin_lemma
The equivalence $\coconeCofork$ restricts to an equivalence between \linebreak pushouts of $\spanDoubleArrow(\D)$ and coequalizers of $\D$. In other words, a cofork $c$ satisfies the universal property of coequalizers if and only if the cocone $\coconeCofork(c)$ satisfies the universal property of pushouts.
#+end_lemma

#+begin_proof
By the commuting triangle in [[lemma:cocone-cofork]] and the 3-for-2 property of equivalences, $\coforkMap_c$ is an equivalence if and only if the corresponding $\coconeMap$ is an equivalence.
#+end_proof

We define dependent coforks and the dependent universal property of coequalizers analogously to the case of dependent cocones.

#+begin_defn
Consider a cofork $c \judeq (i, H) : \cofork(\D, X)$ and a type family $P : X \to \UU$. A *dependent cofork* over $c$ on $P$ is a pair $(i', H')$, where
\begin{alignat*}{2}
  &i' &&: (b : B) \to P(i b) \\
  &H' &&: (a : A) \to \tr_P(H a) (i(f a)) = i(g a).
\end{alignat*}

We write $\depCofork(c, P)$ for the type of dependent coforks over $c$ on $P$.
#+end_defn

#+begin_constr
Given a cofork $c \judeq (i, H) : \cofork(\D, X)$ and a type family $P : X \to \UU$, define a map
\begin{displaymath}
  \depCoforkMap_c^P : ((x : X) \to P(x)) \to \depCofork(c, P)
\end{displaymath}
which sends $h$ to $(h \comp i, \lambda a \to \apd_h(H a))$.
#+end_constr

#+begin_defn
A cofork $c$ satisfies the *dependent universal property of coequalizers* if for all $P : X \to \UU$, the map $\depCoforkMap_c^P$ is an equivalence.
#+end_defn

#+name: lemma:dep-cocone-dep-cofork
#+begin_lemma
For any cofork $c : \cofork(\D, X)$, there is an equivalence
\begin{align*}
  \depCoconeDepCofork
  &: \depCofork(c, P) \\
  & \simeq \depCocone(\coconeCofork(c), P)
\end{align*}
such that the following diagram commutes
#+begin_center
\begin{tikzcd}[column sep=tiny]
  (X \to Y)
  \arrow[rr, "\depCoforkMap_c"]
  \arrow[dr, "\depCoconeMap_{\coconeCofork(c)}"']
  && \depCofork(c, P)
  \arrow[dl, "\depCoconeDepCofork", "\simeq"'] \\
  & \depCocone(\coconeCofork(c), P).
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_proof
Completely analogous to the proof of [[lemma:cocone-cofork]].
#+end_proof

#+name: lemma:coeq-pushout-dup
#+begin_lemma
A cofork $c : \cofork(\D, X)$ satisfies the dependent universal property of coequalizers if and only if the cocone $\coconeCofork(c)$ satisfies the dependent universal property of pushouts.
#+end_lemma

#+begin_proof
By the commuting triangle in [[lemma:dep-cocone-dep-cofork]], the map $\depCoforkMap_c$ is an equivalence if and only if $\depCoconeMap_{\coconeCofork(c)}$ is an equivalence.
#+end_proof

#+begin_thm
A cofork satisfies the universal property of coequalizers if and only if it satisfies the dependent universal property of coequalizers.
#+end_thm

#+begin_proof
Given a cofork $c$, there is a sequence of logical equivalences
\begin{align*}
  & \text{$c$ satisfies the universal property of coequalizers} \\
  & \leftrightarrow \text{$\coconeCofork(c)$ satisfies the universal property of pushouts} \\
  & \leftrightarrow \text{$\coconeCofork(c)$ satisfies the dependent universal property of pushouts} \\
  & \leftrightarrow \text{$c$ satisfies the dependent universal property of coequalizers}.
\end{align*}

The equivalences are, in order: [[lemma:coeq-pushout]], [[lemma:dup-iff-up-pushout]], and [[lemma:coeq-pushout-dup]].
#+end_proof

Coequalizers also satisfy descent, but we do not explore it in the thesis. It is simple enough to derive for different colimits from the univalence axiom. We do, however, prove the flattening lemma for coequalizers, which we will use to prove the flattening lemma for sequential colimits.

#+begin_constr
Given a double arrow $\D \judeq (f, g)$, a cofork $(i, H)$ on $X$, and a type family $P : X \to \UU$, define the *total cofork* to be
#+begin_center
\begin{tikzcd}[column sep=huge]
  \Sigma A (P \comp i \comp f)
  \arrow[r, shift left=1.25, "\tot_g(\tr_P(H))"]
  \arrow[r, shift right=1.25, "\tot_f(\id)"']
  & \Sigma B (P \comp i)
  \arrow[r, "\tot_i(\id)"]
  & \Sigma X P,
\end{tikzcd}
#+end_center
where the map $\tot_g(\tr_P(H))$ takes $(a, p)$ to $(g a, \tr_P(H a, p))$, and the homotopy is
\begin{displaymath}
  (H, \reflhtpy) : (\tot_i(\id) \comp \tot_f(\id)) \htpy (\tot_i(\id) \comp \tot_g(\tr_P(H))).
\end{displaymath}
#+end_constr

#+attr_latex: :options [Flattening lemma for coequalizers]
#+begin_thm
Given a coequalizer $c$ on $X$ and a type family $P : X \to \UU$, the total cofork is also a coequalizer.
#+end_thm

#+begin_proof
To show that the total cocone is a coequalizer, it suffices to show that the corresponding cocone is a pushout. Construct the cube
#+begin_center
\begin{tikzcd}[column sep=huge, row sep=large]
  & \Sigma (A + A) (P \comp i \comp f \comp \codiag)
  \arrow[dl, "\tot_\codiag(\id)"']
  \arrow[d, "\psi", "\simeq"']
  \arrow[dr, "\tot_{\coprodM{f}{g}}(\tr_P\coprodM{\reflhtpy}{H})"] \\
  \Sigma A (P \comp i \comp f)
  \arrow[d, "\id"']
  & (\Sigma A (P \comp i \comp f)) + (\Sigma A (P \comp i \comp f))
  \arrow[dl, "\codiag", near start]
  \arrow[dr, "\coprodM{\tot_f(\id)}{\tot_g(\tr_P(H))}"', near start]
  & \Sigma B (P \comp i)
  \arrow[dl, crossing over, "\tot_i(\id)", near end]
  \arrow[d, "\id"] \\
  \Sigma A (P \comp i \comp f)
  \arrow[dr, "\tot_i(\id) \comp \tot_f(\id)"']
  & \Sigma X P
  \arrow[from=ul, crossing over, "\tot_{i \comp f}(\id)"', near end]
  \arrow[d, "\id"]
  & \Sigma B (P \comp i)
  \arrow[dl, "\tot_i(\id)"] \\
  & \Sigma X P
\end{tikzcd}
#+end_center
where the homotopy
\begin{displaymath}
  \coprodM{\reflhtpy}{H} : (i \comp f \comp \codiag) \htpy (i \comp \coprodM{f}{g})
\end{displaymath}
is defined by sending $\inl(a)$ to $\reflhtpy(a) : i(f a) = i(f a)$ and $\inr(a)$ to $H(a) : i(f a) = i(g a)$. The equivalence
\begin{displaymath}
  \psi : (\Sigma (A + A) (P \comp i \comp f \comp \codiag)) \simeq ((\Sigma A (P \comp i \comp f)) + (\Sigma A (P \comp i \comp f)))
\end{displaymath}
sends $(\inl(a), p)$ to $\inl(a, p)$ and $(\inr(a), p)$ to $\inr(a, p)$.

The bottom square is the cocone corresponding to the total cofork, \linebreak $\coconeCofork(\Sigma c)$ \TODO[the notation hasn't been established], and the top square is the total cocone of the corresponding cocone, $\Sigma (\coconeCofork(c))$. The two front squares commute by $\reflhtpy$, and the back two squares commute by $(\coprodM{\reflhtpy}{\reflhtpy}, \reflhtpy)$.

Since $c$ is a coequalizer by assumption, it holds that the corresponding cocone is a pushout, so by [[lemma:flattening-lemma]] the top square of the cube is a pushout. Note that all the vertical maps are equivalences, and the goal is to show that the bottom square is a pushout. Hence it suffices to show that the cube commutes.

To show that the cube commutes, we proceed by cases: for elements of the form $(\inl(a), p)$, all the identifications collapse to $\refl$, so in that fiber the cube commutes by $\refl$. For elements of the form $(\inr(a), p)$, we need an identification
\begin{displaymath}
  \refl \concat \refl \concat (\ap_{\id} (H(a), \refl)) = (H(a), \refl) \concat \refl \concat \refl,
\end{displaymath}
which we can get by unit laws for concatenating $\refl$'s and whiskering by $\id$.
#+end_proof

** Sequential colimits

\TODO[I formalized sections 3 and 4 from SvDR20, and the main theorem for the special case of equifibered sequencial diagrams].
[cite/t/cf:@SvDR20]

\TODO[Note that AFAIK descent and flattening aren't necessary for the main result of this thesis, but flattening and esp. generalized flattening are used in SvDR20 to prove connectivity results, which are then used in applications].

#+begin_defn
A *sequential diagram* is a pair $(A, a)$ of a sequence of types $A : \N \to \UU$ and a family of maps $a : (n : \N) \to A(n) \to A(n + 1)$.

We will often write $A_n$ and $a_n$ for $A(n)$ and $a(n)$, respectively.
#+end_defn

#+begin_remark
In the literature, sequential diagrams are also known as "cotowers". We decided to use "sequential diagrams" in the {{{AU}}} library, because we believe it to be a more approachable term.
#+end_remark

#+begin_defn
Given a sequential diagram $\A \judeq (A, a)$ and a type $X$, a *cocone* under $\A$ on $X$ is a pair $(i, H)$ consisting of a family of maps ${i : (n : \N) \to A_n \to X}$ and a family of homotopies $H : (n : \N) \to i_n \htpy i_{n + 1} \comp a_n$.
#+begin_center
\begin{tikzcd}
  A_0 \arrow[r, "a_0"]
  \arrow[dr, "i_0"', ""{name=I0, anchor=center}]
  & A_1
  \arrow[r, "a_1"]
  \arrow[d, "i_1"]
  \arrow[from=I0, phantom, "H_0"]
  & A_2 \arrow[r, "a_2"]
  \arrow[dl, "i_2", ""{name=I2, anchor=center}]
  & \cdots \\
  & X
  \arrow[urr, phantom, "\cdots"]
  \arrow[from=1-2, to=I2, phantom, "H_1"]
\end{tikzcd}
#+end_center

We write $\coconeN(\A, X)$ for the type of cocones under the sequential diagram $\A$ on the type $X$.
#+end_defn

#+begin_remark
In the prose, we use "cocone" to mean both "cocone under a span diagram" and "cocone under a sequential diagram". The kind of diagram should be clear from the context.
#+end_remark

#+begin_constr
Given a cocone $c \judeq (i, H) : \coconeN(\A, X)$ and a type $Y : \UU$, we construct a map
\begin{displaymath}
  \coconeNMap_c^Y : (X \to Y) \to \coconeN(\A, Y)
\end{displaymath}
which sends $h$ to $(\lambda n \to h \comp i_n, \lambda n \to h \lwhisk H_n)$.
#+end_constr

#+begin_defn
A cocone $c : \coconeN(\A, X)$ satisfies the *universal property of sequential colimits* if for all $Y : \UU$, the map $\coconeNMap_c^Y$ is an equivalence.

A cocone satisfying the universal property of sequential colimits is called a *sequential colimit*.
#+end_defn

To provide usable computation rules for maps out of sequential colimits, we introduce homotopies of cocones under sequential diagrams.

#+begin_defn
Given a sequential diagram $\A \judeq (A, a)$ and two cocones $c \judeq (i, H)$ and $c' \judeq (i', H')$ on $X$, a *homotopy* between $c$ and $c'$ is a pair $(K, \alpha)$ consisting of a family of homotopies
\begin{displaymath}
  K : (n : \N) \to i_n \htpy i'_n
\end{displaymath}
and a family of commuting squares of homotopies, one for each $n : \N$,
#+begin_center
\begin{tikzcd}[column sep=large]
  i_n
  \arrow[r, squiggly, no head, "K_n"]
  \arrow[d, squiggly, no head, "H_n"']
  & i'_n
  \arrow[d, squiggly, no head, "H'_n"] \\
  i_{n + 1} \comp a_n
  \arrow[r, squiggly, no head, "K_{n + 1} \rwhisk a_n"']
  & i'_{n + 1} \comp a_n.
\end{tikzcd}
#+end_center

We write $c \htpy c'$ for the type of homotopies between $c$ and $c'$.
#+end_defn

#+begin_lemma
For a sequential diagram $\A$ and two cocones $c, c' : \coconeN(\A, X)$, there is an equivalence
\begin{displaymath}
  \term{htpy-eq-cocone\N} : (c = c') \simeq (c \htpy c').
\end{displaymath}
#+end_lemma

#+name: lemma:comp-up-sequential-colimit
#+begin_lemma
Given a sequential diagram $\A \judeq (A, a)$, a sequential colimit $c \judeq (i, H) : \coconeN(\A, X)$ and a cocone $c' \judeq (i', H') : \coconeN(\A, Y)$, there is a unique map $h : X \to Y$ equipped with a family of homotopies
\begin{displaymath}
  K : (n : \N) \to h \comp i_n \htpy i'_n
\end{displaymath}
and a family of commuting squares of homotopies, indexed by $n : \N$
#+begin_center
\begin{tikzcd}[column sep=huge]
  h \comp i_n
  \arrow[r, squiggly, no head, "K_n"]
  \arrow[d, squiggly, no head, "h \lwhisk H_n"']
  & i'_n
  \arrow[d, squiggly, no head, "H'"] \\
  h \comp i_{n + 1} \comp a_n
  \arrow[r, squiggly, no head, "K_{n + 1} \rwhisk a_n"']
  & i'_{n + 1} \comp a_n
\end{tikzcd}
#+end_center
#+end_lemma

We proceed to build sequential colimits out of coequalizers.

#+begin_constr
Construct the map $\doubleArrowSeq$ from sequential diagrams to double arrows by
#+begin_center
\begin{tikzcd}[column sep=small]
  A_0 \arrow[r, "a_0"] & A_1 \arrow[r, "a_1"] & \cdots
\end{tikzcd}
\hspace{2em} $\mapsto$ \hspace{2em}
\begin{tikzcd}[column sep=large]
  \Sigma \N A
  \arrow[r, shift left=1.25, "\tot_{+1}(a_{\blank})"]
  \arrow[r, shift right=1.25, "\id"']
  & \Sigma \N A,
\end{tikzcd}
#+end_center
where the map $\tot_{+1}(a_{\blank})$ takes $(n, x)$ to $(n + 1, a_n(x))$.
#+end_constr

The sequential colimit of $\A$ may be obtained as the coequalizer of \linebreak $\doubleArrowSeq(\A)$. Proofs of some of the following lemmas mirror exactly their counterparts in [[#sec:coequalizers]], and are therefore omitted.

#+begin_lemma
For any sequential diagram $\A$ and a type $X$, there is an equivalence
\begin{displaymath}
  \coforkCoconeN : \coconeN(\A, X) \simeq \cofork(\doubleArrowSeq(\A), X)
\end{displaymath}
which fits into the following commuting triangle for every cocone $c : \coconeN(\A, X)$
#+begin_center
\begin{tikzcd}[column sep=0]
  (X \to Y)
  \arrow[rr, "\coconeNMap_c"]
  \arrow[dr, "\coforkMap_{\coforkCoconeN(c)}"']
  && \coconeN(\A, Y)
  \arrow[dl, "\coforkCoconeN", "\simeq"'] \\
  & \cofork(\doubleArrowSeq(\A), X).
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_proof
To define the forward map, assume a cocone $(i, H)$ where
\begin{alignat*}{2}
  &i &&: (n : \N) \to A_n \to X \\
  &H &&: (n : \N) (x : A_n) \to i_n(x) = i_{n + 1}(a_n x).
\end{alignat*}

Uncurrying both components, we get
\begin{alignat*}{2}
  &\uncurry(i) &&: \Sigma \N A \to X \\
  &\uncurry(H) &&: \uncurry(i) \htpy \uncurry(i) \comp \tot_{+1}(a_{\blank}),
\end{alignat*}
which is a cofork under $\doubleArrowSeq(\A)$.

In reverse, assume a cofork $(j, K)$ where
\begin{alignat*}{2}
  &j &&: \Sigma \N A \to X \\
  &K &&: j \htpy j \comp \tot_{+1}(a_{\blank}),
\end{alignat*}
and curry both components to get
\begin{alignat*}{2}
  &\curry(j) &&: (n : \N) \to A_n \to X \\
  &\curry(K) &&: (n : \N) \to \curry(j)(n) \htpy \curry(j)(n + 1) \comp a_n,
\end{alignat*}
which is a cocone under $\A$.

Since currying and uncurrying are judgmental inverses, we conclude that the forward and backward maps are inverses of each other by $\reflhtpy$ and $\reflhtpy$.

To prove commutativity of the triangle, assume a cocone $(i, H)$ and compute the action on a map $h : X \to Y$. The resulting coforks we get are
\begin{displaymath}
\begin{aligned}
  &h \comp \uncurry(i) \\
  &h \lwhisk \uncurry(H)
\end{aligned}
\text{\hspace{2em} and \hspace{2em}}
\begin{aligned}
  &\uncurry(\lambda n \to h \comp i_n) \\
  &\uncurry(\lambda n \to h \lwhisk H_n)
\end{aligned}
\end{displaymath}
which both compute to
\begin{align*}
  &\lambda (n, x) \to h(i_n x) \\
  &\lambda (n, x) \to \ap_h(H_n x),
\end{align*}
so the triangle also commutes by $\reflhtpy$.
#+end_proof

#+begin_lemma
A cocone $c : \coconeN(\A, X)$ is a sequential colimit if and only if the cofork $\coforkCoconeN(c)$ is a coequalizer.
#+end_lemma

#+begin_proof
Omitted.
#+end_proof

#+begin_defn
Consider a cocone $c \judeq (i, H) : \coconeN(\A, X)$ and a type family $P : X \to \UU$. A *dependent cocone* over $c$ on $P$ is a pair $(i', H')$ where
\begin{alignat*}{2}
  &i' &&: (n : \N) (x : A_n) \to P(i_n x) \\
  &H' &&: (n : \N) (x : A_n) \to \tr_P(H_n x, i'_n x) = i'_{n + 1} (a_n a).
\end{alignat*}

We write $\depCoconeN(c, P)$ for the type of dependent cocones over $c$ on $P$.
#+end_defn

#+begin_constr
Given a cofork $c \judeq (i, H) : \coconeN(\A, X)$ and a type family $P : X \to \UU$, construct the map
\begin{displaymath}
  \depCoconeNMap_c^P : ((x : X) \to P(x)) \to \depCoconeN(c, P)
\end{displaymath}
which sends $h$ to $(\lambda n \to h \comp i_n, \lambda n, x \to \apd_h(H_n x))$.
#+end_constr

#+begin_defn
A cocone $c$ satisfies the *dependent universal property of sequential colimits* if for all $P : X \to \UU$, the map $\depCoconeNMap_c^P$ is an equivalence.
#+end_defn

We define homotopies of dependent cocones, because later on in [[#sec:zigzag-correct]] we work with the computation rules of dependent maps from sequential colimits induced by dependent cocones.

#+begin_defn
Given a sequential diagram $\A \judeq (A, a)$, a cocone $c \judeq (i, H)$ on $X$, and two dependent cocones $d \judeq (j, L)$ and $d' \judeq (j', L')$ on $P$, a *homotopy* between $d$ and $d'$ is a pair $(K, \alpha)$ of a family of homotopies
\begin{displaymath}
  K : (n : \N) \to j_n \htpy j'_n
\end{displaymath}
and a family of commuting squares of identifications, indexed by $n : \N$ and $x : A_n$
#+begin_center
\begin{tikzcd}[column sep=6em]
  \tr_P(H_n x)(j_n x)
  \arrow[r, equals, "\ap_{\tr_P(H_n x)}(K_n x)"]
  \arrow[d, equals, "L_n(x)"']
  & \tr_P(H_n x)(j'_n x)
  \arrow[d, equals, "L'_n(x)"] \\
  j_{n + 1}(a_n x)
  \arrow[r, equals, "K_{n + 1}(a_n x)"']
  & j'_{n + 1}(a_n x).
\end{tikzcd}
#+end_center

We write $d \htpy d'$ for the type of homotopies between $d$ and $d'$.
#+end_defn

#+begin_lemma
For every pair of dependent cocones $d, d' : \depCoconeN(c, P)$, there is an equivalence
\begin{displaymath}
  \term{htpy-eq-dep-cocone\N} : (d = d') \simeq (d \htpy d').
\end{displaymath}
#+end_lemma

#+begin_lemma
Given a sequential diagram $\A \judeq (A, a)$, a sequential colimit $c \judeq (i, H) : \coconeN(\A, X)$ and a dependent cocone $d \judeq (i', H') : \depCoconeN(c, P)$, there is a unique dependent map $h : (x : X) \to P(x)$ equipped with a family of homotopies
\begin{displaymath}
  K : (n : \N) \to h \comp i_n \htpy i'_n
\end{displaymath}
and a family of commuting squares of identifications indexed by $n : \N$ and $x : A_n$
#+begin_center
\begin{tikzcd}[column sep=6em]
  \tr_P(H_n x)(h(i_n x))
  \arrow[r, equals, "\ap_{\tr_P(H_n x)}(K_n x)"]
  \arrow[d, equals, "\apd_h(H_n x)"']
  & \tr_P(H_n x)(i'_n x)
  \arrow[d, equals, "H'(x)"] \\
  h(i_{n + 1}(a_n x))
  \arrow[r, equals, "K_{n + 1}(a_n x)"']
  & i'_{n + 1}(a_n x)
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_lemma
For any cocone $c : \coconeN(\A, X)$, there is an equivalence
\begin{align*}
  \depCoforkDepCoconeN
  &: \depCoconeN(c, P) \\
  &\simeq \depCofork(\coforkCoconeN(c), P)
\end{align*}
such that the following diagram commutes
#+begin_center
\begin{tikzcd}[column sep={8em,between origins}]
  ((x : X) \to P(x))
  \arrow[rr, "\depCoconeNMap_c"]
  \arrow[dr, "\depCoforkMap_{\coforkCoconeN(c)}"', near start]
  && \depCoconeN(c, P)
  \arrow[dl, "\depCoforkDepCoconeN", near start] \\
  & \depCofork(\coforkCoconeN(c), P).
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_proof
Omitted.
#+end_proof

#+begin_lemma
A cocone $c : \coconeN(\A, X)$ satisfies the dependent universal property of sequential colimits if and only if the cofork $\coforkCoconeN(c)$ satisfies the dependent universal property of coequalizers.
#+end_lemma

#+begin_proof
Omitted.
#+end_proof

#+begin_thm
A cocone $c : \coconeN(\A, X)$ satisfies the universal property of sequential colimits if and only if it satisfies the dependent universal property of sequential colimits.
#+end_thm

#+begin_proof
Omitted.
#+end_proof

*** Functoriality

\TODO[Uniformly constructing a sequential colimit of every sequential diagram amounts to having a map from the type of sequential diagrams to a universe type. We show that this action on objects extends to an action on morphisms, which takes a morphism of sequential diagrams to a map between the corresponding types. Additionally, this action on morphisms is functorial, \ie it takes the identity morphism to the identity map and composition of morphisms to composition of maps.

To formally state this property, we first need to define morphisms of sequential diagrams and their composition. We also show that homotopies of morphisms of sequential diagrams induce homotopies of the appropriate maps between colimits.

The theory does not assume a uniform construction of standard sequential colimits. Instead the constructions and proofs are parametric over a user-provided sequential colimit. This generality is important for later applications in [[#sec:zigzags]], where the colimit is not judgmentally equal to the standard one.]

\TODO[The formalization covers Lemma 3.5. The text of the thesis skips the proof of preservation of equivalences.]

#+begin_defn
Given sequential diagrams $(A, a)$ and $(B, b)$, define the type of *morphisms* from $(A, a)$ to $(B, b)$, denoted $(A, a) \to (B, b)$, as the type of pairs $(f, H)$ consisting of a family of maps
\begin{displaymath}
  f : (n : \N) \to A_n \to B_n
\end{displaymath}
and a family of homotopies witnessing that the following squares of maps, indexed by $n : \N$, commute
#+begin_center
\begin{tikzcd}
  A_n \arrow[r, "a_n"] \arrow[d, "f_n"']
  & A_{n + 1} \arrow[d, "f_{n + 1}"] \\
  B_n \arrow[r, "b_n"'] \arrow[ur, phantom, "H_n"]
  & B_{n + 1}.
\end{tikzcd}
#+end_center
#+end_defn

All sequential diagrams come equipped with an identity morphism.

#+begin_constr
Given a sequential diagram $(A, a)$, construct the *identity morphism* $(A, a) \to (A, a)$ consisting of the data
\begin{alignat*}{2}
  &(\lambda n \to \id) &&: (n : \N) \to A_n \to A_n \\
  &(\lambda n \to \reflhtpy) &&: (n : \N) \to a_n \htpy a_n.
\end{alignat*}
#+end_constr

Morphisms can be composed.

#+begin_constr
Given sequential diagrams $(A, a)$, $(B, b)$ and $(C, c)$, and morphisms
\begin{align*}
  F \judeq (f, H) &: (A, a) \to (B, b) \\
  G \judeq (g, K) &: (B, b) \to (C, c),
\end{align*}
construct the *composed morphism* $G \comp F : (A, a) \to (C, c)$ by function composition
\begin{displaymath}
  (\lambda n \to g_n \comp f_n) : (n : \N) \to A_n \to C_n
\end{displaymath}
and pasting of commuting squares
#+begin_center
\begin{tikzcd}
  A_n \arrow[r, "a_n"] \arrow[d, "f_n"']
  & A_{n + 1} \arrow[d, "f_{n + 1}"] \\
  B_n \arrow[r, "b_n"'] \arrow[d, "g_n"']
  \arrow[ur, phantom, "H_n"]
  & B_{n + 1} \arrow[d, "g_{n + 1}"] \\
  C_n \arrow[r, "c_n"']
  \arrow[ur, phantom, "K_n"]
  & C_{n + 1}.
\end{tikzcd}
#+end_center
#+end_constr

To construct a map $X \to Y$ between sequential colimits, we can use the universal property of $X$. That requires us to construct a cocone under $X$'s diagram on $Y$.

#+begin_constr
Given a sequential diagram $\B$ and a cocone $c \judeq (i, H) : \coconeN(\B, Y)$, define for every sequential diagram $\A$ the map
\begin{displaymath}
  \precompHomN_c^{\A} : (\A \to \B) \to \coconeN(\A, Y)
\end{displaymath}
which sends a morphism $(f, K)$ to the cocone
#+begin_center
\begin{tikzcd}[column sep=tiny]
  A_n \arrow[rr, "a_n"] \arrow[d, "f_n"']
  && A_{n + 1} \arrow[d, "f_{n + 1}"] \\
  B_n \arrow[rr, "b_n"]
  \arrow[dr, "i_n"', ""{name=IN, anchor=center}]
  \arrow[urr, phantom, "K_n"]
  && B_{n + 1} \arrow[dl, "i_{n + 1}"] \\
  & Y.
  \arrow[from=IN, to=2-3, phantom, "H_n"]
\end{tikzcd}
#+end_center
#+end_constr

#+begin_remark
This construction is in a sense dual to $\coconeNMap$ --- $\coconeNMap$ extends a cocone by postcomposing a map $X \to Y$ on the right, and \linebreak $\precompHomN$ extends a cocone by "precomposing" a morphism $(B, b) \to (A, a)$ on the left.
#+end_remark

#+begin_constr
Given sequential diagrams $\A$ and $\B$, a sequential colimit $c : \coconeN(\A, X)$, and a cocone $c' : \coconeN(\B, Y)$, construct the map
\begin{displaymath}
  \fmapHomN : (\A \to \B) \to (X \to Y)
\end{displaymath}
using the universal property of $c$, as the map taking a morphism $f : \A \to \B$ to the unique map induced by the cocone $\precompHomN_{c'}(f) : \cocone(\A, Y)$.

We often write $f_{\infty} : X \to Y$ for the map induced by a morphism $f : \A \to \B$.
#+end_constr

#+name: lemma:prism-hom-seq-diag
#+begin_lemma
The map $f_{\infty}$ fits into commuting squares
#+begin_center
\begin{tikzcd}
  A_n \arrow[r, "f_n"] \arrow[d, "i_n"']
  & B_n \arrow[d, "i'_n"] \\
  X \arrow[r, "f_{\infty}"']
  & Y.
\end{tikzcd}
#+end_center
which in turn fit into commuting prisms
#+begin_center
\begin{tikzcd}[column sep=tiny, row sep=small]
  A_n
  \arrow[dd, "f_n"']
  \arrow[rr, "a_n"]
  \arrow[dr, "i_n"', near end]
  && A_{n + 1}
  \arrow[dd, "f_{n + 1}"]
  \arrow[dl, "i_{n + 1}", near end] \\
  & X \\
  B_n \arrow[rr, "b_n", very near start]
  \arrow[dr, "i'_n"']
  && B_{n + 1} \arrow[dl, "i'_{n + 1}"] \\
  & Y.
  \arrow[from=uu, dotted, crossing over]
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_proof
The data is obtained from the extra computation rules stated in [[lemma:comp-up-sequential-colimit]]. The commuting squares are kept as-is, which causes the unexpected change of orientation --- the computation rules provide a homotopy $\coconeNMap_c(f_{\infty}) \htpy \precompHomN(f)$, not the other way around.

The type of prisms as above is equivalent to the type of coherences of homotopies $\coconeNMap_c(f_{\infty}) \htpy \precompHomN(f)$ by mechanical homotopy algebra.
#+end_proof

#+begin_remark
\TODO[Some theory of commuting prisms was built for the library as part of this thesis. The theory is not elaborated on in the text].
#+end_remark

#+name: lemma:colim-preserves-id
#+begin_lemma
The map $\fmapHomN$ preserves identity morphisms. That is to say, given a sequential diagram $\A$ and its colimit $X$, the identity morphism $\id : \A \to \A$ induces the map $\id_{\infty} : X \to X$, which is homotopic to the identity function $\id : X \to X$.
#+end_lemma

#+begin_proof
By [[lemma:comp-up-sequential-colimit]], the map $\id_{\infty}$ is the unique map such that the cocone $\coconeNMap(\id_{\infty})$ is homotopic to the cocone $\precompHomN(\id)$. Hence to show that $\id_{\infty} \htpy \id$, it suffices to show that $\coconeNMap(\id)$ is homotopic to $\precompHomN(\id)$. In other words, the goal is to provide a homotopy
#+begin_center
\begin{tikzcd}[column sep=tiny]
  A_n \arrow[rr, "a_n"] \arrow[dr, "i_n"']
  && A_{n + 1} \arrow[dl, "i_{n + 1}"] \\
  & X \arrow[d, "\id"] \\
  & X
\end{tikzcd}
$\htpy$ \hspace{1em}
\begin{tikzcd}[column sep=tiny]
A_n \arrow[rr, "a_n"] \arrow[d, "\id"']
&& A_{n + 1} \arrow[d, "\id"] \\
A_n \arrow[rr, "a_n"] \arrow[dr, "i_n"']
&& A_{n + 1} \arrow[dl, "i_{n + 1}"] \\
& X.
\end{tikzcd}
#+end_center

The homotopy on maps is satisfied by $\reflhtpy : i_n \htpy i_n$, and for coherences we need to give
\begin{displaymath}
  \alpha_n : ((\id \lwhisk H_n) \hconcat \reflhtpy) \htpy (H_n \hconcat \reflhtpy),
\end{displaymath}
which follows from the left unit law of whiskering by $\id$.
#+end_proof

#+name: lemma:colim-preserves-comp
#+begin_lemma
The map $\fmapHomN$ preserves composition, in the sense that for morphisms $f : \A \to \B$ and $g : \B \to \C$, colimits $c \judeq (i, H) : \coconeN(\A, X)$ and $c' \judeq (i', H') : \coconeN(\B, Y)$ and a cocone $c'' \judeq (i'', H'') : \coconeN(\C, Z)$, there is a homotopy $(g \comp f)_{\infty} \htpy (g_{\infty} \comp f_{\infty})$.
#+end_lemma

#+begin_proof
As in the identity case, it suffices to give a homotopy of cocones
\begin{displaymath}
  \coconeNMap(g_{\infty} \comp f_{\infty}) \htpy \precompHomN(g \comp f).
\end{displaymath}

This is equivalent to providing a family of commuting squares
#+begin_center
\begin{tikzcd}[column sep=large]
  A_n \arrow[r, "g_n \comp f_n"] \arrow[d, "i_n"']
  & C_n \arrow[d, "i''_n"] \\
  X \arrow[r, "g_{\infty} \comp f_{\infty}"']
  & Z
\end{tikzcd}
#+end_center
and fitting them into a family of commuting prisms
#+begin_center
\begin{tikzcd}[column sep=small, row sep=small]
  A_n
  \arrow[dd, "g_n \comp f_n"']
  \arrow[rr, "a_n"]
  \arrow[dr]
  && A_{n + 1}
  \arrow[dd, "g_{n + 1} \comp f_{n + 1}"]
  \arrow[dl] \\
  & X \\
  C_n \arrow[rr, "c_n", very near start]
  \arrow[dr, "i''_n"']
  && C_{n + 1} \arrow[dl, "i''_{n + 1}"] \\
  & Z.
  \arrow[from=uu, "g_{\infty} \comp f_{\infty}", very near start, crossing over]
\end{tikzcd}
#+end_center

Since $f_\infty$ and $g_\infty$ are both constructed from morphisms of sequential diagrams, they come equipped with their respective homotopies
#+begin_center
\begin{tikzcd}
  A_n \arrow[r, "f_n"] \arrow[d, "i_n"']
  & B_n \arrow[d, "i'_n"] \\
  X \arrow[r, "f_{\infty}"']
  & Y
\end{tikzcd}
\hspace{1em} and \hspace{1em}
\begin{tikzcd}
  B_n \arrow[r, "g_n"] \arrow[d, "i'_n"']
  & C_n \arrow[d, "i''_n"] \\
  Y \arrow[r, "g_{\infty}"']
  & Z,
\end{tikzcd}
#+end_center
and the prisms
#+begin_center
\begin{tikzcd}[column sep=tiny, row sep=small]
  A_n
  \arrow[dd, "f_n"']
  \arrow[rr, "a_n"]
  \arrow[dr, "i_n"', near end]
  && A_{n + 1}
  \arrow[dd, "f_{n + 1}"]
  \arrow[dl, "i_{n + 1}", near end] \\
  & X \\
  B_n \arrow[rr, "b_n", very near start]
  \arrow[dr, "i'_n"']
  && B_{n + 1} \arrow[dl, "i'_{n + 1}"] \\
  & Y
  \arrow[from=uu, "f_{\infty}", near start, crossing over]
\end{tikzcd}
\hspace{1em} and \hspace{1em}
\begin{tikzcd}[column sep=tiny, row sep=small]
  B_n
  \arrow[dd, "g_n"']
  \arrow[rr, "b_n"]
  \arrow[dr, "i'_n"', near end]
  && B_{n + 1}
  \arrow[dd, "g_{n + 1}"]
  \arrow[dl, "i'_{n + 1}", near end] \\
  & Y \\
  C_n \arrow[rr, "c_n", very near start]
  \arrow[dr, "i''_n"']
  && C_{n + 1} \arrow[dl, "i''_{n + 1}"] \\
  & Z.
  \arrow[from=uu, "g_{\infty}", near start, crossing over]
\end{tikzcd}
#+end_center

Putting the squares side-by-side and stacking the prisms atop each other gives the desired homotopy.
#+end_proof

The last property we will need is that taking a sequential colimit also extends to an action on homotopies.

#+begin_defn
Given two sequential diagrams $\A \judeq (A, a)$ and $\B \judeq (B, b)$, and two morphisms $f \judeq (i, H), g \judeq (i', H') : \A \to \B$, a *homotopy* between $f$ and $g$ is a pair $(K, \alpha)$ consisting of a family of homotopies
\begin{displaymath}
  K : (n : \N) \to i_n \htpy i'_n
\end{displaymath}
and a family of commuting squares of homotopies indexed by $n : \N$
#+begin_center
\begin{tikzcd}[column sep=large]
  b_n \comp i_n
  \arrow[r, squiggly, no head, "b_n \lwhisk K_n"]
  \arrow[d, squiggly, no head, "H_n"']
  & b_n \comp i'_n
  \arrow[d, squiggly, no head, "H'_n"] \\
  i_{n + 1} \comp a_n
  \arrow[r, squiggly, no head, "K_{n + 1} \rwhisk a_n"']
  & i'_{n + 1} \comp a_n.
\end{tikzcd}
#+end_center

We write $f \htpy g$ for the type of homotopies between $f$ and $g$.
#+end_defn

#+begin_lemma
For any two morphisms of sequential diagrams $f, g : \A \to \B$, there is an equivalence
\begin{displaymath}
  \term{htpy-eq-hom\N} : (f = g) \simeq (f \htpy g).
\end{displaymath}
#+end_lemma

#+name: lemma:colim-preserves-htpy
#+begin_lemma
Taking sequential colimits of sequential diagrams preserves homotopies. Specifically, given sequential diagrams $\A, \B$ and morphisms $f, g : \A \to \B$, there is a map
\begin{displaymath}
  \term{hmap-hom\N} : (f \htpy g) \to (f_{\infty} \htpy g_{\infty}).
\end{displaymath}
#+end_lemma

#+begin_proof
Turn the homotopy $H : f \htpy g$ into an identification of morphisms of sequential diagrams $H' : f = g$, apply $\fmapHomN$ on the identification to get $H'' : f_{\infty} = g_{\infty}$, which begets (\TODO[that's a big word]) a homotopy of type $f_{\infty} \htpy g_{\infty}$.
#+end_proof

*** Colimits of shifted sequential diagrams

Sequential diagrams consist of an infinite amount of data, represented by an infinite sequence of types and maps between them. It is natural to ask how much individual vertices of that sequence influence the resulting colimit, and one might expect that removing a vertex from the sequence does not change the colimit at all. That is in fact true for any finite amount of vertices removed from the sequence. Here we limit ourselves to removing vertices from the beginning of the sequence, which is described by an operation called "shifting".

A shift of a sequential diagram $\A$ is the sequential diagram consisting of the types and maps shifted by one to the left. It is denoted $\A[1]$. This shifting can be iterated for any natural number $k$; then the resulting sequential diagram is denoted $\A[k]$.

Similarly, a shift of a morphism of sequential diagrams is a morphism from the shifted domain into the shifted codomain. In symbols, given a morphism $f : \A \to \B$, we have $f[k] : \A[k] \to \B[k]$.

We also define shifts of cocones and homotopies of cocones, which can additionally be "unshifted".

Importantly the type of cocones under a sequential diagram is equivalent to the type of cocones under its shift, as we will show by proving that shifting and unshifting are inverse operations. It follows that the sequential colimit of a shifted sequential diagram is equivalent to the colimit of the original diagram.

In the later chapters we only ever need to shift by one, but arbitrary shifts are used in the statement and proof of the main theorem of [cite/t:@SvDR20], which they use to prove connectivity and truncation results for sequential colimits, which in turn is necessary for proving some of the applications of the zigzag construction of identity types of pushouts, studied by [cite/t:@War23].

#+begin_constr
Given a sequential diagram $\A \judeq (A, a)$, construct its *shift* by one as the diagram
#+begin_center
\begin{tikzcd}
  A_1 \arrow[r, "a_1"] & A_2 \arrow[r, "a_2"] & \cdots.
\end{tikzcd}
#+end_center
Call this $\A[1]$.

Then construct arbitrary shifts by induction
\begin{align*}
  &\A[0] \defeq \A \\
  &\A[k + 1] \defeq (\A[k])[1].
\end{align*}
#+end_constr

#+begin_remark
The constructions of shifts are defined by first defining a shift by one, and then recursively shifting by one according to the argument $k$. An alternative would be to shift all data using addition on the natural numbers.

However, in our setting addition computes only on one side, so we have a choice to make: given a number $k$ to shift by, do we define the \(n\)-th level of the shifted structure to be the \((n+k)\)-th, or \((k+n)\)-th level of the original?

The former runs into issues already when defining the shifted sequence, since $a_{n + k}$ has the type $A_{n + k} \to A_{(n + k) + 1}$, but we need a map of type $A_{n + k} \to A_{(n + 1) + k}$, which forces us to introduce a transport.

On the other hand, the latter requires transport when proving anything by induction on $k$ and doesn't satisfy the judgmental equality $\A[0] \judeq \A$, because $A_{(k + 1) + n}$ is not $A_{(k + n) + 1}$ and $A_{0 + n}$ is not $A_n$, and it requires more infrastructure for working with horizontal compositions in sequential diagrams to be formalized in terms of addition.

To contrast, defining the operations by induction does satisfy $\A[0] \judeq \A$, it computes when proving properties by induction, which is the expected primary use-case, and no further infrastructure is necessary.
#+end_remark

#+begin_constr
Given a morphism of sequential diagrams $F \judeq (f, H) : \A \to \B$, construct its *shift* by one as the morphism
#+begin_center
\begin{tikzcd}
  A_1 \arrow[r, "a_1"]
  \arrow[d, "f_1"']
  & A_2 \arrow[r, "a_2"]
  \arrow[d, "f_2"]
  & \cdots
  \arrow[d, phantom, "\cdots"] \\
  B_1 \arrow[r, "b_1"']
  \arrow[ur, phantom, "H_1"]
  & B_2 \arrow[r, "b_2"']
  & \cdots,
\end{tikzcd}
#+end_center
and call it $F[1] : \A[1] \to \B[1]$.

Construct further shifts by induction
\begin{alignat*}{2}
  &F[0] \defeq F &&: \A[0] \to \B[0] \\
  &F[k + 1] \defeq (F[k])[1] &&: \A[k + 1] \to \B[k + 1].
\end{alignat*}
#+end_constr

#+begin_constr
Given a cocone $c : \coconeN(\A, X)$, construct its *shift* by one as the cocone
#+begin_center
\begin{tikzcd}[column sep=large]
  A_1 \arrow[r, "a_1"]
  \arrow[dr, "i_1"', ""{name=I1, anchor=center}]
  & A_2
  \arrow[r, "a_2"]
  \arrow[d, "i_2"]
  \arrow[from=I1, phantom, "H_1"]
  & A_3 \arrow[r, "a_3"]
  \arrow[dl, "i_3", ""{name=I3, anchor=center}]
  & \cdots \\
  & X,
  \arrow[urr, phantom, "\cdots"]
  \arrow[from=1-2, to=I3, phantom, "H_2"]
\end{tikzcd}
#+end_center
call it $c[1] : \coconeN(\A[1], X)$.

Construct arbitrary shifts by induction
\begin{alignat*}{2}
  &c[0] \defeq c &&: \coconeN(\A[0], X) \\
  &c[k + 1] \defeq (c[k])[1] &&: \coconeN(\A[k + 1], X).
\end{alignat*}
#+end_constr

Cocones can be "unshifted" as well. If shifting corresponds to forgetting data, then unshifting corresponds to recovering forgotten data. The data can be recovered, because the missing data has the type $\Sigma (i : A_0 \to X).\, (i \htpy i_0 \comp a_0)$, which is contractible at $(i_0 \comp a_0, \reflhtpy)$.

#+begin_constr
Given a cocone $c : \coconeN(\A[1], X)$, \ie a diagram with the shape
#+begin_center
\begin{tikzcd}[column sep=large]
  A_1 \arrow[r, "a_1"]
  \arrow[dr, "i_0"', ""{name=I0, anchor=center}]
  & A_2
  \arrow[r, "a_2"]
  \arrow[d, "i_1"]
  \arrow[from=I0, phantom, "H_0"]
  & A_3 \arrow[r, "a_3"]
  \arrow[dl, "i_2", ""{name=I2, anchor=center}]
  & \cdots \\
  & X,
  \arrow[urr, phantom, "\cdots"]
  \arrow[from=1-2, to=I2, phantom, "H_1"]
\end{tikzcd}
#+end_center
construct its *unshift* by one as the cocone
#+begin_center
\begin{tikzcd}[column sep=large]
  A_0 \arrow[r, "a_0"]
  \arrow[dr, "i_0 \comp a_0"', ""{name=I0, anchor=center}]
  & A_1
  \arrow[r, "a_1"]
  \arrow[d, "i_0"']
  & A_2 \arrow[r, "a_2"]
  \arrow[dl, "i_1", ""{name=I1, anchor=center}]
  & \cdots \\
  & X,
  \arrow[urr, phantom, "\cdots"]
  \arrow[from=1-2, to=I1, phantom, "H_0"]
\end{tikzcd}
#+end_center
where the left triangle is $\reflhtpy : (i_0 \comp a_0) \htpy (i_0 \comp a_0)$, and denote it \linebreak $c[-1] : \coconeN(\A, X)$.

Then inductively define arbitrary unshifts
\begin{alignat*}{3}
  &c[-0] \defeq c &&: \coconeN(\A, X) &\quad& \text{for $c : \coconeN(\A[0], X)$} \\
  &c[-(k + 1)] \defeq c[-1][-k] &&: \coconeN(\A, X) && \text{for $c : \coconeN(\A[k + 1], X)$.}
\end{alignat*}
#+end_constr

#+begin_remark
One might expect that, following the pattern of shifts, the inductive case should be $c[-k][-1]$. Note, however, that the construction only provides a way to unshift a cocone under $\A[n]$ by $n$; since the cocone $c$ in the inductive case is under $\A[k][1]$, we first need to unshift by $1$ to get $c[-1]$ under $\A[k]$, and only then we can unshift by $k$ to get $c[-1][-k]$ under $\A$.
#+end_remark

Shifting and unshifting homotopies will also be required to show that shifting and unshifting cocones are inverses to each other.

#+begin_constr
Given cocones $c \judeq (i, H)$ and $c' \judeq (i', H')$ under $\A$ on $X$, and a homotopy $\Kappa \judeq (K, \alpha) : c \htpy c'$, construct the *shift* by one of $\Kappa$ to be the homotopy between $c[1]$ and $c'[1]$ consisting of $(K', \alpha')$, where
\begin{alignat*}{2}
  &K' \defeq (\lambda n \to K_{n + 1}) &&: i_{n + 1} \htpy i'_{n + 1} \\
  &\alpha' \defeq (\lambda n \to \alpha_{n + 1}) &&: (H_{n + 1} \hconcat (K_{n + 2} \rwhisk a_{n + 1})) \htpy (K_{n + 1} \hconcat H'_{n + 1}).
\end{alignat*}
Denote it by $\Kappa[1]$.

Then define other shifts by induction
\begin{alignat*}{2}
  &\Kappa[0] \defeq \Kappa &&: c[0] \htpy c'[0] \\
  &\Kappa[k + 1] \defeq (\Kappa[k])[1] &&: c[k + 1] \htpy c'[k + 1].
\end{alignat*}
#+end_constr

Similarly to unshifting cocones, we can recover the first homotopy and coherence to unshift a homotopy of cocones.

#+begin_constr
Given cocones $c \judeq (i, H)$ and $c' \judeq (i', H')$ under $\A[1]$ on $X$, and a homotopy $\Kappa \judeq (K, \alpha) : c \htpy c'$, we construct the *unshift* by one of $\Kappa$, which is a homotopy $\Kappa[-1] : c[-1] \htpy c'[-1]$. The input data has the form
#+begin_center
\begin{tikzcd}[column sep=tiny]
  A_{n + 1} \arrow[rr, "a_{n + 1}"]
  \arrow[dr, "i_n"', ""{name=IN, anchor=center}]
  && A_{n + 2} \arrow[dl, "i_{n + 1}"] \\
  & X
  \arrow[from=IN, to=ur, phantom, "H_n"]
\end{tikzcd}
$\htpy$
\begin{tikzcd}[column sep=tiny]
  A_{n + 1} \arrow[rr, "a_{n + 1}"]
  \arrow[dr, "i'_n"', ""{name=IN, anchor=center}]
  && A_{n + 2} \arrow[dl, "i'_{n + 1}"] \\
  & X,
  \arrow[from=IN, to=ur, phantom, "H'_n"]
\end{tikzcd}
#+end_center
which we need to turn into a homotopy
#+begin_center
\begin{tikzcd}[column sep=large]
  A_0 \arrow[r, "a_0"]
  \arrow[dr, "i_0 \comp a_0"']
  & A_1
  \arrow[r, "a_1"]
  \arrow[d, "i_0"']
  & A_2
  \arrow[dl, "i_1", ""{name=I1, anchor=center}]
  \arrow[d, phantom, "\cdots"] \\
  & X, & {}
  \arrow[from=1-2, to=I1, phantom, "H_0"]
\end{tikzcd}
$\htpy$
\begin{tikzcd}[column sep=large]
  A_0 \arrow[r, "a_0"]
  \arrow[dr, "i'_0 \comp a_0"']
  & A_1
  \arrow[r, "a_1"]
  \arrow[d, "i'_0"']
  & A_2
  \arrow[dl, "i_1", ""{name=I1, anchor=center}]
  \arrow[d, phantom, "\cdots"] \\
  & X. & {}
  \arrow[from=1-2, to=I1, phantom, "H'_0"]
\end{tikzcd}
#+end_center

Define $\Kappa[-1] \judeq (K', \alpha')$ by case splitting on the index
\begin{alignat*}{2}
  &K'_0 \defeq K_0 \rwhisk a_0 &&: (i_0 \comp a_0) \htpy (i'_0 \comp a_0) \\
  &K'_{n + 1} \defeq K_n &&: i_n \htpy i'_n \\
  &\alpha'_0 \defeq \runithtpy^{-1} &&: (\reflhtpy \hconcat (K_0 \rwhisk a_0)) \htpy ((K_0 \rwhisk a_0) \hconcat \reflhtpy) \\
  &\alpha'_{n + 1} \defeq \alpha_n &&: (H_n \hconcat (K_{n + 1} \rwhisk a_n)) \htpy (K_n \hconcat H'_n).
\end{alignat*}

Then define arbitrary unshifts by induction on $k$
\begin{alignat*}{2}
  &\Kappa[0] \defeq \Kappa &&: c[-0] \htpy c'[-0] \\
  &\Kappa[-(k + 1)] \defeq (\Kappa[-1])[-k] &&: c[-(k + 1)] \htpy c'[-(k + 1)].
\end{alignat*}
#+end_constr

#+name: lemma:is-equiv-shift
#+begin_lemma
For every sequential diagram $\A$ and a natural number $k$, the map
\begin{displaymath}
  (\blank)[k] : \coconeN(\A, X) \to \coconeN(\A[k], X)
\end{displaymath}
is an equivalence, with the inverse
\begin{displaymath}
  (\blank)[-k] : \coconeN(\A[k], X) \to \coconeN(\A, X)
\end{displaymath}
#+end_lemma

#+begin_proof
The goal is to show that for any $k$, we have $c[-k][k] = c$ and $c[k][-k] = c$, for appropriately typed cocones $c$.

First note that for any cocone $c : \cocone(\A[1], X)$, $c[-1][1]$ computes to the cocone $c$ --- $c[-1]$ is the cocone $c$ with synthesized data at the front, and $c[-1][1]$ forgets the new data. Inductively, we define the homotopy $c[-k][k] \htpy c$ for all $k$. We have $c[-0][0] \htpy c$ by the reflexive homotopy, and
\begin{alignat*}{3}
  c[-(k + 1)][k + 1] \,
  &\judeq &\,& c[-1][-k][k][1] &\quad& \\
  &\htpy && c[-1][1] &&\text{by shifting the induction hypothesis} \\
  &&&&& \term{IH}: (c[-1])[-k][k] \htpy c[-1] \\
  &\judeq && c.
\end{alignat*}
Since homotopies of cocones characterize their identity types, we obtain the desired identifications $c[-k][k] = c$.

For the other direction, we begin by giving a homotopy $c \htpy c[1][-1]$ for every cocone $c : \coconeN(\A, X)$. We choose this orientation of the homotopy, because the first component of the homotopy now needs a proof of $i_0 \htpy i_1 \comp a_0$, which we can supply directly by $H_0$. Define the homotopy of cocones by case splitting as
\begin{alignat*}{2}
  &K_0 \defeq H_0 &&: i_0 \htpy i_1 \comp a_n \\
  &K_{n + 1} \defeq \reflhtpy &&: i_{n + 1} \htpy i_{n + 1} \\
  &\alpha_0 \defeq \reflhtpy &&: (H_0 \hconcat \reflhtpy) \htpy (H_0 \hconcat \reflhtpy) \\
  &\alpha_{n + 1} \defeq \runithtpy &&: (H_{n + 1} \hconcat \reflhtpy) \htpy (\reflhtpy \hconcat H_{n + 1}).
\end{alignat*}
Then extend the homotopy by induction to all $k$. We again have $c \htpy c[0][-0]$ by the reflexivity homotopy, and in the inductive case we compose the homotopies
\begin{alignat*}{3}
  c \,
  &\htpy &\,& c[k][-k] &&\text{by the inductive hypothesis} \\
  &\htpy && c[k][1][-1][-k] &&\text{by unshifting the homotopy $c[k] \htpy c[k][1][-1]$ by $k$} \\
  &\judeq && c[k + 1][-(k + 1)]. &\quad&
\end{alignat*}
This family of homotopies can be made into a family of identifications, and inverted to get the required $c[k][-k] = c$.
#+end_proof

#+name: thm:up-shift
#+begin_thm
Given a sequential diagram $\A$ and its colimit cocone $c : \coconeN(\A, X)$, the cocone $c[k] : \coconeN(\A[k], X)$ is a sequential colimit of the diagram $\A[k]$, for any natural number $k$.
#+end_thm

#+begin_proof
We construct a commuting triangle
#+begin_center
\begin{tikzcd}
  (X \to Y)
  \arrow[rr, "\coconeNMap_c", "\simeq"']
  \arrow[dr, "\coconeNMap_{c[k]}"', near start]
  && \coconeN(\A, Y)
  \arrow[dl, "{(\blank)[k]}", "\simeq"'] \\
  & \coconeN(\A[k], Y),
\end{tikzcd}
#+end_center
where the right map is an equivalence by [[lemma:is-equiv-shift]], and the top map is an equivalence by assumption. The it follows that the left map is an equivalence.

The triangle is constructed by induction. Note that it commutes by $\reflhtpy$ for the case $k = 0$, since then the right map is an identity and the cocone maps are the same map, and also for the case $k = 1$, since then both paths map a function $h : X \to Y$ to the cocone $(\lambda n \to h \comp i_n, \lambda n \to h \lwhisk H_n)$. To show that the triangle commutes for $k + 1$, compose it out of the smaller triangles
#+begin_center
\begin{tikzcd}[row sep=large, column sep=large]
  (X \to Y)
  \arrow[rr, "\coconeNMap_c"]
  \arrow[dr, "\coconeNMap_{c[k]}"', near end]
  \arrow[ddr, bend right, "\coconeNMap_{c[k + 1]}"']
  && \coconeN(\A, Y)
  \arrow[dl, "{(\blank)[k]}"]
  \arrow[ddl, bend left, "{(\blank)[k + 1]}"] \\
  & \coconeN(\A[k], Y)
  \arrow[d, "{(\blank)[1]}"] \\
  & \coconeN(\A[k + 1], Y),
\end{tikzcd}
#+end_center
where the top one is the induction hypothesis, the left one is the case for $k = 1$, and the right one is the definition of $(\blank)[k + 1]$.
#+end_proof

To conclude this section, we show that there are inclusion morphisms of sequential diagrams $\A \to \A[k]$, which induce the identity map on the colimit.

#+begin_constr
Given a sequential diagram $\A \judeq (A, a)$, construct the morphism of sequential diagrams
\begin{displaymath}
  \inclHomN[k] : \A \to \A[1]
\end{displaymath}
as the morphism
\begin{alignat*}{2}
  &f_n \defeq a_n &&: A_n \to A_{n + 1} \\
  &H_n \defeq \reflhtpy &&: (a_{n + 1} \comp a_n) \htpy (a_{n + 1} \comp a_n).
\end{alignat*}
Diagrammatically, the morphism can be drawn as
#+begin_center
\begin{tikzcd}
  A_0 \arrow[r, "a_0"]
  \arrow[d, "a_0"']
  & A_1 \arrow[r, "a_1"]
  \arrow[d, "a_1"]
  & \cdots
  \arrow[d, phantom, "\cdots"] \\
  A_1 \arrow[r, "a_1"']
  & A_2 \arrow[r, "a_2"']
  & \cdots.
\end{tikzcd}
#+end_center

Extend the morphism by induction, where $\inclHomN[0] : \A \to \A[0]$ is the identity morphism, and $\inclHomN[k + 1] : \A \to \A[k + 1]$ is the composition of $\inclHomN[k] : \A \to \A[k]$ and then $\inclHomN[1] : \A[k] \to \A[k][1]$.
#+end_constr

These morphisms offer another way of unshifting cocones --- a cocone $c : \coconeN(\A[k], X)$ may be precomposed with the morphism $\inclHomN[k] : \A \to \A[k]$ to get a cocone $c' : \coconeN(\A, X)$. We show that these two constructions result in homotopic cocones. We limit ourselves to the case $k = 1$, as we do not need the general case in further development.

#+begin_lemma
Given a cocone $c \judeq (i, H) : \coconeN(\A[1], X)$, there is a homotopy of cocones
\begin{displaymath}
  c[-1] \htpy \precompHomN_c^{\A}(\inclHomN[1]).
\end{displaymath}
#+end_lemma

#+begin_proof
We need to show a homotopy between the cocones
#+begin_center
\begin{tikzcd}
  A_0 \arrow[r, "a_0"]
  \arrow[dr, "i_0 \comp a_0"']
  & A_1
  \arrow[r, "a_1"]
  \arrow[d, "i_0"]
  & A_2
  \arrow[dl, "i_1"]
  \arrow[d, phantom, "\cdots"] \\
  & X & {}
\end{tikzcd}
and \hspace{1em}
\begin{tikzcd}[column sep=tiny]
A_n \arrow[rr, "a_n"] \arrow[d, "a_n"']
&& A_{n + 1} \arrow[d, "a_{n + 1}"] \\
A_{n + 1} \arrow[rr, "a_{n + 1}"] \arrow[dr, "i_n"']
&& A_{n + 2} \arrow[dl, "i_{n + 1}"] \\
& X.
\end{tikzcd}
#+end_center

This homotopy can be constructed by induction on $n$ as
\begin{alignat*}{2}
  &K_0 \defeq \reflhtpy &&: (i_0 \comp a_0) \htpy (i_0 \comp a_0) \\
  &K_{n + 1} \defeq H_n &&: i_n \htpy (i_{n + 1} \comp a_{n + 1}) \\
  &\alpha_0 \defeq \runithtpy^{-1} &&: (\reflhtpy \hconcat H_0) \htpy (\reflhtpy \hconcat H_n \hconcat \reflhtpy) \\
  &\alpha_{n + 1} \defeq H_n \lwhisk \runithtpy^{-1} &&: (H_n \hconcat (H_{n + 1} \rwhisk a_{n + 1})) \\
  &&&\htpy (H_n \hconcat (H_{n + 1} \rwhisk a_{n + 1}) \hconcat \reflhtpy).
\end{alignat*}
#+end_proof

#+name: corol:htpy-cocone-precomp
#+begin_corol
For any cocone $c : \coconeN(\A, X)$, there is a homotopy
\begin{displaymath}
  c \htpy \precompHomN_{c[1]}(\inclHomN[1]).
\end{displaymath}
#+end_corol

#+begin_proof
Compose the homotopies $c \htpy c[1][-1]$ from [[lemma:is-equiv-shift]] and $c[1][-1] \htpy \precompHomN_{c[1]}(\inclHomN[1])$ from the above lemma applied to $c[1]$.
#+end_proof

#+name: lemma:colim-incl-id
#+begin_lemma
Assume a sequential diagram $\A$ with its colimit $c : \coconeN(\A, X)$. Then for any natural number $k$, the morphism $\inclHomN[k] : \A \to \A[k]$ induces a map out of $X$. If we consider $c[k] : \coconeN(\A[k], X)$ as the colimit of $\A[k]$ by [[thm:up-shift]], this map's codomain is $X$. The induced map $\inclHomN[k]_{\infty} : X \to X$ is homotopic to the identity map $\id : X \to X$.
#+end_lemma

#+begin_proof
Proceed by induction on $k$. For $k = 0$, note that the morphism \linebreak $\inclHomN[0] : \A \to \A[0]$ is the identity morphism, hence it is mapped to the identity by [[lemma:colim-preserves-id]].

For $k = k' + 1$, the inclusion morphism computes to the composition $\A \to \A[k] \to \A[k][1]$. By [[lemma:colim-preserves-comp]], passing to the colimit preserves composition, so there is a homotopy
\begin{displaymath}
  \inclHomN[k + 1]_{\infty} \htpy \inclHomN[1]_{\infty} \comp \inclHomN[k]_{\infty}.
\end{displaymath}
The map $\inclHomN[k]_{\infty}$ is homotopic to the identity map by the inductive hypothesis, so it remains to show that $\inclHomN[1] : \A[k] \to \A[k + 1]$ induces the identity map. The map $\inclHomN[1]_{\infty} : X \to X$ is constructed using the universal property of $c[k]$ being the colimit of $\A[k]$, by the cocone \linebreak $\precompHomN_{c[k + 1]}(\inclHomN[1])$. By [[corol:htpy-cocone-precomp]] this cocone is homotopic to the cocone $c[k]$. Hence it suffices to show that the map induced by the cocone $c[k]$ using the universal property of $c[k]$ is the identity map, which is lemma \TODO[ref].
#+end_proof

*** Descent property and flattening lemma

\TODO[We prove the flattening lemma phrased with descent data, which can be seen as an elementary case of the main theorem from SvDR20. The full theorem could reasonably be called "generalized flattening lemma", as it shows commutativity of taking the total space and sequential colimit of not just a type family induced by descent data, but a more general case where the descent data is generated using shifts from an arbitrary dependent sequential diagram].

#+begin_defn
Given a sequential diagram $\A \judeq (A, a)$, define the type of *descent data* over $\A$ to be the type of pairs $(B, b)$, where $B$ is a family of type families
\begin{displaymath}
  B : (n : \N) \to A_n \to \UU
\end{displaymath}
and $b$ is a family of fiberwise equivalences
\begin{displaymath}
  b : (n : \N) (x : A_n) \to B_n(x) \simeq B_{n + 1}(a_n x).
\end{displaymath}

We write $\DDN(\A)$ for the type of descent data over $\A$.
#+end_defn

#+begin_remark
There is a principled way of looking at descent data over sequential diagrams --- as /equifibered/ sequential diagrams. A fibered (or dependent) sequential diagram consists of type families $B_n$ over $A_n$'s and connecting maps $b_n$ over $a_n$'s. An equifibered sequential diagram is one in which all connecting maps are equivalences.

In fact, all descent data arise as dependent diagrams with maps replaced by equivalences. Sometimes the structure may be simplified by replacing a span of fiberwise equivalences with a single fiberwise equivalence. To take the example of pushout, an equifibered span diagram consists of the data[fn:1]
\begin{align*}
  P_S &: S \to \UU \\
  P_A &: A \to \UU \\
  P_B &: B \to \UU \\
  P_f &: (s : S) \to P_S(s) \simeq P_A(f s) \\
  P_g &: (s : S) \to P_S(s) \simeq P_B(g s).
\end{align*}

The type of equifibered span diagrams is equivalent to the type of descent data over span diagrams, since we can contract away the pair $(P_S, P_f)$. The simplification reduces the amount of data we have to track and make coherent, at the expense of introducing an arbitrary direction --- there is no reason to prefer the direction $P_A(f s) \simeq P_B(g s)$ over $P_B(g s) \simeq P_A(f s)$.

Sequential diagrams do not contain any spans, so there is no simplification to be made.
#+end_remark

#+begin_constr
Given a sequential diagram $\A \judeq (A, a)$ and a cocone $c \judeq (i, H) : \coconeN(\A, X)$, construct the map
\begin{displaymath}
  \ddNFam_c : (X \to \UU) \to \DDN(\A)
\end{displaymath}
which sends a type family $B$ to the descent data
\begin{alignat*}{2}
  &(\lambda n, x \to B(i_n x)) &&: (n : \N) \to A_n \to \UU \\
  &(\lambda n, x \to \tr_B(H_n x)) &&: (n : \N) (x : A_n) \to B(i_n x) \simeq B(i_{n + 1}(a_n x)).
\end{alignat*}
#+end_constr

#+begin_defn
Given a sequential diagram $\A$ and a cocone \linebreak $c \judeq (i, H) : \coconeN(\A, X)$, a *type family with descent data* is a triple \linebreak $(B_{\infty}, B', e')$, where $B_{\infty} : X \to \UU$ is a type family, $B' \judeq (B, b) : \DD(\A)$ is descent data over $\A$, and $e' \judeq (e, K)$ is an equivalence of descent data consisting of a family of equivalences
\begin{displaymath}
  e : (n : \N)(x : A_n) \to B_{\infty}(i_n x) \simeq B_n(x)
\end{displaymath}
and a family of commuting squares indexed by $n$ and $x : A_n$
#+begin_center
\begin{tikzcd}
  B_{\infty}(i_n x)
  \arrow[r, "e_n(x)"]
  \arrow[d, "\tr_{B_{\infty}}(H_n x)"']
  & B_n(x)
  \arrow[d, "b_n(x)"] \\
  B_{\infty}(i_{n + 1}(a_n x))
  \arrow[r, "e_{n + 1}(a_n x)"']
  & B_{n + 1}(a_n x).
\end{tikzcd}
#+end_center

We write $e' : B_{\infty} \correspDD B'$ for the triple $(B_{\infty}, B', e')$.
#+end_defn

#+attr_latex: :options [Descent property of sequential colimits]
#+begin_thm
Consider a sequential diagram $\A \judeq (A, a)$ and its sequential colimit $c : \coconeN(\A, X)$. Then the map $\ddNFam_c$ is an equivalence.
#+end_thm

#+begin_proof
We construct a commuting triangle of maps
#+begin_center
\begin{tikzcd}
  (X \to Y)
  \arrow[rr, "\coconeNMap_c", "\simeq"']
  \arrow[dr, "\ddNFam_c"']
  && \coconeN(\A, \UU)
  \arrow[dl, "\simeq"] \\
  & \DDN(\A).
\end{tikzcd}
#+end_center
The right equivalence sends $(B, H)$ to $(B, \lambda n, x \to \equivEq(H_n(x)))$, and the triangle commutes by function extensionality and [[lemma:compute-equiv-eq-ap]].
#+end_proof

#+begin_corol
Given a sequential diagram $\A \judeq (A, a)$, its colimit $c \judeq (i, H) : \coconeN(\A, X)$ and descent data $(B, b) : \DDN(\A)$, there is a unique type family $B_{\infty} : X \to \UU$ and an equivalence of descent data $e : B_{\infty} \correspDD (B, b)$.
#+end_corol

#+begin_constr
Given a sequential diagram $\A \judeq (A, a)$ and descent data $(B, b) : \DDN(\A)$, take the *total sequential diagram* to be the diagram
\begin{alignat*}{2}
  &(\lambda n \to \Sigma A_n B_n) &&: \N \to \UU \\
  &(\lambda n \to \tot_{a_n}(b_n)) &&: (n : \N) \to (\Sigma A_n B_n) \to (\Sigma A_{n + 1} B_{n + 1}).
\end{alignat*}
#+end_constr

#+begin_constr
Given a sequential diagram $\A \judeq (A, a)$, a cocone $c \judeq (i, H) : \coconeN(\A, X)$, and a family with descent data $(e, K) : (B, b) \correspDD B_{\infty}$, construct the *total cocone* under the total sequential diagram
#+begin_center
\begin{tikzcd}
  \Sigma A_n B_n
  \arrow[rr, "\tot_{a_n}(b_n)"]
  \arrow[dr, "\tot_{i_n}(e_n)"']
  && \Sigma A_{n + 1} B_{n + 1}
  \arrow[dl, "\tot_{i_{n + 1}}(e_{n + 1})"] \\
  & \Sigma X B_{\infty}
\end{tikzcd}
#+end_center
which commutes by the homotopy $H'$ given at $x : A_n$, $y : B_n(a)$ by
\begin{alignat*}{2}
  &H'_1 \defeq H_n(x) &&: i_n(x) = i_{n + 1}(a_n x) \\
  &H'_2 \defeq K_n(x, y) &&: \tr_{B_{\infty}}(H_n x)(e_n(y)) = e_{n + 1}(b_n(x, y)).
\end{alignat*}
#+end_constr

We proceed similarly to the proof of the flattening lemma with descent data for pushouts --- we split the proof into two steps, one showing it holds for a type family $P : X \to \UU$ and its induced descent data, and one generalizing it to arbitrary families with descent data.

The proofs lean on technical results regarding preservation of universal properties by equivalences of cocones and coforks (not to be confused with homotopies of cocones and coforks), which were introduced in the formalization but we don't cover them in the thesis text. The precise statements and proofs of those lemmas can be read off the attached Agda code.

#+begin_remark
The idea of those lemmas is that in the context of cocones under span diagrams, a commuting cube whose vertical maps are equivalences may be regarded as an equivalence of span diagrams and cocones under them. With this perspective, [[lemma:is-pushout-bottom-ff-is-pushout-top]] says being a pushout is preserved by equivalences of cocones. Adapting it to coforks yields the concept of an equivalence of double arrows and coforks under them, and the property of being a coequalizer is preserved by such an equivalence, because equivalences of coforks induce equivalences of the associated cocones. Going one step further, we get a notion of equivalences of sequential diagrams and cocones under those, and being a sequential colimit is preserved by equivalences of cocones, because they induce equivalences of the associated coforks.
#+end_remark

#+name: lemma:flattening-seq-family
#+begin_lemma
Given a sequential colimit $c : \cocone(\A, X)$ and a type family $B_{\infty} : X \to \UU$, the total cocone of the family with descent data $\id : \ddNFam_c(B_{\infty}) \correspDD B_{\infty}$ is a sequential colimit.
#+end_lemma

#+begin_proof
Similarly to the proof of the flattening lemma for coequalizers, we leverage the fact that sequential colimits correspond to certain coequalizers.

We construct an equivalence of coforks
#+begin_center
\begin{tikzcd}[row sep=large]
  \Sigma (n : \N) (x : A_n).\, B_{\infty}(i_n x)
  \arrow[rr, shift left=1.25, "\tot_{+1}(\tot_{a_{(\blank)}}(\tr_{B_{\infty}}(H_{(\blank)})))"]
  \arrow[rr, shift right=1.25, "\id"']
  \arrow[d, "\term{assoc-\mupSigma}"', "\simeq"]
  && \Sigma (n : \N) (x : A_n).\, B_{\infty}(i_n x)
  \arrow[r, "\uncurry(\tot_{i_{(\blank)}}(\id))", outer sep=4pt]
  \arrow[d, "\term{assoc-\mupSigma}", "\simeq"']
  & \Sigma X B_{\infty}
  \arrow[d, "\id", "\simeq"'] \\
  \Sigma ((n, x) : \Sigma \N A).\, B_{\infty}(i_n x)
  \arrow[rr, shift left=1.25, "\tot_{\tot_{+1}(a_{(\blank)})}(\tr_{B_{\infty}}(H_{(\blank)}))"]
  \arrow[rr, shift right=1.25, "\tot_{\id}(\id)"']
  && \Sigma ((n, x) : \Sigma \N A).\, B_{\infty}(i_n x)
  \arrow[r, "\tot_{\uncurry(i)}(\id)"', outer sep=6pt]
  & \Sigma X B_{\infty}
\end{tikzcd}
#+end_center
where the top cofork is the cofork associated to the total cocone, and on the bottom is the total cofork of the cofork associated to $c$ and $B_{\infty}$. All the squares commute by $\reflhtpy$, so the coherence is a combination of unit laws for concatenation with $\reflhtpy$ and whiskering by $\id$.

Since the bottom cofork is a coequalizer by the flattening lemma for coequalizers, the top cofork is also a coequalizer, from which it follows that the total cocone is a sequential colimit.
#+end_proof

#+attr_latex: :options [Flattening lemma for sequential colimits]
#+begin_thm
Given a sequential colimit $c : \coconeN(\A, X)$ and a family with descent data $(B, b) \correspDD B_{\infty}$, the total cocone is a sequential colimit.
#+end_thm

#+begin_proof
Put $\A \judeq (A, a)$ and $c \judeq (i, H)$. It suffices to show that there is an "equivalence of cocones"
#+begin_center
\begin{tikzcd}[row sep=small]
  \Sigma A_n B_n
  \arrow[dd, "\tot(e_n)"']
  \arrow[rr, "\tot_{a_n}(b_n)"]
  \arrow[dr, "\tot_{i_n}(e_n)"', near end]
  && \Sigma A_{n + 1} B_{n + 1}
  \arrow[dd, "\tot(e_{n + 1})"]
  \arrow[dl, "\tot_{i_{n + 1}}(e_{n + 1})", near end] \\
  & \Sigma X B_{\infty} \\
  \Sigma A_n (B_{\infty} \comp i_n)
  \arrow[rr, "\tr_{B_{\infty}}(H_n)", near start]
  \arrow[dr, "\tot_{i_n}(\id)"']
  && \Sigma A_{n + 1} (B_{\infty} \comp i_{n + 1})
  \arrow[dl, "\tot_{i_{n + 1}}(\id)"] \\
  & \Sigma X B_{\infty},
  \arrow[from=uu, "\id", near start, crossing over]
\end{tikzcd}
#+end_center
where the bottom cocone is the total cocone of $B_{\infty}$ and its induced descent data, and the top cocone is the total cocone of $(B, b) \correspDD B_{\infty}$. The vertical maps are equivalences, and the prisms commute by a homotopy algebra argument similar to [[lemma:flattening-cube]]. The bottom cocone is a sequential colimit by [[lemma:flattening-seq-family]], so it follows that the top cocone is a sequential colimit.
#+end_proof

* Partial proof of correctness of the zigzag construction
:PROPERTIES:
:CUSTOM_ID: chap:zigzag-construction
:END:

[cite/t:@War23] \TODO[describes an explicit construction of identity types of pushouts. He does so by fixing an element $a_0 : A$, and then defining type families $a_0 \rightsquigarrow_{\infty} a$ and $a_0 \rightsquigarrow_{\infty} b$, such that for any $a : A$ and $b : B$, there are equivalences]
\begin{align*}
  (\inl(a_0) = \inl(a)) &\simeq (a_0 \rightsquigarrow_{\infty} a) \\
  (\inl(a_0) = \inr(b)) &\simeq (a_0 \rightsquigarrow_{\infty} b).
\end{align*}

\TODO[The type families are defined by gradual approximations of the identity types, $a_0 \rightsquigarrow_t a$ and $a_0 \rightsquigarrow_{t + 1} b$. If one thinks of the pushout $\PO{S}{A}{B}$ as a coproduct $A + B$ with added "bridges" from $f(s)$ to $g(s)$, then $a_0 \rightsquigarrow_t a$ describes the type of identifications between $\inl(a_0)$ and $\inl(a)$, provided that we can pass from the $A$ component to the $B$ component and back $t$ times, and similarly for $a_0 \rightsquigarrow_{t + 1} b$. The full identity types are then constructed by removing the upper bound on the number of steps, by taking the sequential colimit.]

The two type families are related --- if one can get from $\inl(a_0)$ to $\inl(f s)$ in $t$ crossings, then one can get from $\inl(a_0)$ to $\inr(g s)$ in $t + 1$ crossings, and similarly in reverse. We can formally encode this relationship in a structure called a "zigzag" between sequential diagrams. We begin by defining general zigzags of sequential diagrams and their behavior in the colimit. Then we define the type families of approximations of identity types, and a zigzag between them. At last, we present a partial proof that the construction satisfies the induction principle of identity systems of pushouts from [[#sec:identity-systems]]. One coherence proof remains unsolved. The construction and proof of correctness are presented with emphasis on their encoding in the Agda proof assistant [cite//b:@Agda], which due to its mutually inductive nature presented challenges to termination checking and computation.

** Zigzags between sequential diagrams
:PROPERTIES:
:CUSTOM_ID: sec:zigzags
:END:

#+begin_defn
Given sequential diagrams $\A \judeq (A, a)$ and $\B \judeq (B, b)$, a *zigzag* between them is a quadruple $(f, g, U, L)$, where $f$ and $g$ are families of maps
\begin{align*}
  f &: (n : \N) \to A_n \to B_n \\
  g &: (n : \N) \to B_n \to A_{n + 1},
\end{align*}
and $U$ and $L$ are families of coherences between them
\begin{align*}
  U &: (n : \N) \to a_n \htpy (g_n \comp f_n) \\
  L &: (n : \N) \to b_n \htpy (f_{n + 1} \comp g_n).
\end{align*}
#+end_defn

A zigzag $(f, g, U, L)$ can be visualized as a sequence of juxtaposed triangles
#+begin_center
\begin{tikzcd}
  A_0 \arrow[rr, "a_0"]
  \arrow[dr, "f_0"', ""{name=F0, anchor=center}]
  & \arrow[d, phantom, "U_0"]
  & A_1 \arrow[rr, "a_1"]
  \arrow[dr, "f_1"]
  & \arrow[d, phantom, "U_1"]
  & A_2 \arrow[rr, "a_2"]
  \arrow[dr, "f_2"]
  & \arrow[d, phantom, "\cdots"]
  & \cdots \\
  & B_0 \arrow[rr, "b_0"']
  \arrow[ur, "g_0"']
  & \arrow[u, phantom, "L_0"]
  & B_1 \arrow[rr, "b_1"']
  \arrow[ur, "g_1"']
  & \arrow[u, phantom, "L_1"]
  & B_2 \arrow[rr, "b_2"']
  && \cdots.
\end{tikzcd}
#+end_center

By forgetting the first triangle and turning the figure upside down, we get a new zigzag, this time between $\B$ and the shift $\A[1]$. This new zigzag is called a half-shift.

#+begin_constr
Given sequential diagrams $\A \judeq (A, a)$ and $\B \judeq (B, b)$, and a zigzag $z \judeq (f, g, U, L)$ between them, construct the *half-shift* of $z$ as the zigzag $(g, f', L, U')$ between $\B$ and $\A[1]$, where
\begin{alignat*}{2}
  &g &&: (n : \N) \to B_n \to A_{n + 1} \\
  &f' \defeq (\lambda n \to f_{n + 1}) &&: (n : \N) \to A_{n + 1} \to B_{n + 1} \\
  &L &&: (n : \N) \to b_n \htpy (f'_n \comp g_n) \\
  &U' \defeq (\lambda n \to U_{n + 1}) &&: (n : \N) \to a_{n + 1} \htpy (g_{n + 1} \comp f'_n).
\end{alignat*}
#+end_constr

#+begin_remark
Half-shifts of zigzags provide a symmetry of the downward-going $f$ maps and upward-going $g$ maps. We exploit this symmetry in constructions and lemmas to follow, by formulating them for the downwards direction, and then applying them to the half-shift of a zigzag to get the constructions for the upward direction.
#+end_remark

Repeating a half-shift twice gives a full shift, which shifts all the components by one.

#+begin_constr
Given a zigzag $z \judeq (f, g, U, L)$ between the sequential diagrams $\A$ and $\B$, define the *full shift* of $z$, denoted $z[1]$, as the zigzag between $\A[1]$ and $\B[1]$ obtained by taking the half-shift of the half-shift of $z$. Explicitly, it consists of the components $(f', g', U', L')$, where
\begin{alignat*}{2}
  &f' \defeq (\lambda n \to f_{n + 1}) &&: (n : \N) \to A_{n + 1} \to B_{n + 1} \\
  &g' \defeq (\lambda n \to g_{n + 1}) &&: (n : \N) \to B_{n + 1} \to A_{n + 2} \\
  &U' \defeq (\lambda n \to U_{n + 1}) &&: (n : \N) \to a_{n + 1} \htpy (g_{n + 1} \comp f_{n + 1}) \\
  &L' \defeq (\lambda n \to L_{n + 1}) &&: (n : \N) \to b_{n + 1} \htpy (f_{n + 2} \comp g_{n + 1}).
\end{alignat*}
#+end_constr

We can "shear" a zigzag to look at it from yet another perspective, as a morphism $F : \A \to \B$, where the necessary squares are constructed by pasting triangles. Diagrammatically, we have
#+begin_center
\begin{tikzcd}
  A_0 \arrow[r, "a_0"]
  \arrow[d, "f_0"']
  & A_1 \arrow[r, "a_1"]
  \arrow[d, "f_1"]
  & \cdots
  \arrow[d, phantom, "\cdots"] \\
  B_0 \arrow[r, "b_0"']
  \arrow[ur, "g_0"]
  & B_1 \arrow[r, "b_1"']
  & \cdots.
\end{tikzcd}
#+end_center

This is the morphism of sequential diagrams associated to the zigzag.

#+begin_constr
Given a zigzag $z \judeq (f, g, U, L)$ between $\A$ and $\B$, construct the *associated morphism* of sequential diagrams from $\A$ to $\B$ to be the morphism $(f, H)$, where
\begin{alignat*}{2}
  &f &&: (n : \N) \to A_n \to B_n \\
  &H \defeq (L_n \rwhisk f_n) \hconcat (f_{n + 1} \lwhisk U_n^{-1}) &&: (n : \N) \to (b_n \comp f_n) \htpy (f_{n _ 1} \comp a_n).
\end{alignat*}

For sequential colimits $c : \coconeN(\A, X)$ and $c' : \coconeN(\B, Y)$, write $f_{\infty} : X \to Y$ for the induced map of colimits.
#+end_constr

By taking the associated morphism of a half-shift of a zigzag, we get the associated inverse morphism.

#+begin_constr
Given a zigzag $z$ between $\A$ and $\B$, define the *associated inverse morphism* to be the morphism $\B \to \A[1]$ associated to the half-shift of $z$.

For sequential colimits $c : \coconeN(\B, Y)$ and $c' : \coconeN(\A[1], X)$, write $g_{\infty} : Y \to X$ for the induced map of colimits.
#+end_constr

It deserves the moniker "inverse", because we will show that the induced map $g_{\infty}$ is an inverse of $f_{\infty}$. The last prerequisite to showing that the induced maps are inverses is a lemma relating zigzags and the shift inclusion morphisms $\inclHomN[1]$.

#+name: lemma:zigzag-htpy-incl-hom
#+begin_lemma
Given a zigzag between sequential diagrams $\A$ and $\B$, the inclusion morphism $\inclHomN[1] : \A \to \A[1]$ is homotopic to the composition of the associated morphism $\A \to \B$ and the inverse morphism $\B \to \A[1]$.
#+end_lemma

#+begin_proof
Write $(f, g, U, L)$ for the zigzag, and $\A \judeq (A, a)$ and $\B \judeq (B, b)$.

We need to show that the morphism
#+begin_center
\begin{tikzcd}
  A_0 \arrow[r, "a_0"]
  \arrow[d, "a_0"']
  & A_1 \arrow[r, "a_1"]
  \arrow[d, "a_1"]
  & \cdots
  \arrow[d, phantom, "\cdots"] \\
  A_1 \arrow[r, "a_1"']
  & A_2 \arrow[r, "a_2"']
  & \cdots.
\end{tikzcd}
#+end_center
and
#+begin_center
\begin{tikzcd}
  A_0 \arrow[r, "a_0"]
  \arrow[d, "f_0"']
  & A_1 \arrow[r, "a_1"]
  \arrow[d, "f_1"]
  & \cdots
  \arrow[d, phantom, "\cdots"] \\
  B_0 \arrow[r, "b_0"']
  \arrow[ur, "g_0"']
  \arrow[d, "g_0"']
  & B_1 \arrow[r, "b_1"']
  \arrow[d, "g_1"]
  & \cdots
  \arrow[d, phantom, "\cdots"] \\
  A_1 \arrow[r, "a_1"']
  \arrow[ur, "f_1"']
  & A_1 \arrow[r, "a_2"']
  & \cdots
\end{tikzcd}
#+end_center
are homotopic.

The first component of the homotopy is a family of homotopies of maps $K_n : a_n \htpy g_n \comp f_n$. We take the triangles $U_n$ for the homotopies of maps. Then we need to show that the homotopies
#+begin_center
\begin{tikzcd}[column sep=small]
  A_n
  \arrow[rr, "a_n"]
  \arrow[dd, "a_n"']
  && A_{n + 1}
  \arrow[dr, "f_{n + 1}"]
  \arrow[dd, "a_{n + 1}"' near end, ""{name=A, anchor=center}] \\
  &&& B_{n + 1}
  \arrow[dl, "g_{n + 1}"]
  \arrow[from=A, phantom, "U_{n + 1}"]\\
  A_{n + 1}
  \arrow[rr, "a_{n + 1}"']
  \arrow[uurr, phantom, "\reflhtpy"]
  && A_{n + 2}
\end{tikzcd}
and
\begin{tikzcd}
  A_n \arrow[r, "a_n"]
  \arrow[d, "f_n"', ""{name=FN}]
  \arrow[dd, bend right=60, "a_n"', ""{name=AN}]
  & A_{n + 1}
  \arrow[d, "f_{n + 1}", ""{name=FN1}]
  \arrow[from=FN, phantom, "U_n^{-1}"] \\
  B_n \arrow[r]
  \arrow[ur]
  \arrow[d, "g_n"', ""{name=GN}]
  \arrow[from=AN, phantom, "U_n"]
  \arrow[to=FN1, phantom, "L_n"]
  & B_{n + 1}
  \arrow[d, "g_{n + 1}", ""{name=GN1}]
  \arrow[from=GN, phantom, "L_n^{-1}"] \\
  A_{n + 1} \arrow[r, "a_{n + 1}"']
  \arrow[ur]
  \arrow[to=GN1, shift right, phantom, "U_{n + 1}"]
  & A_{n + 2}
\end{tikzcd}
#+end_center
are themselves homotopic. With some effort the pairs $U_n$ and $U_n^{-1}$, and $L_n$ and $L_n^{-1}$ cancel out, and we end up with $U_{n + 1}$ on both sides.
#+end_proof

#+name: thm:equiv-zigzag
#+begin_thm
Consider sequential diagrams $\A$ and $\B$, their respective colimits $c : \coconeN(\A, X)$ and $c' : \coconeN(\B, Y)$, and a zigzag $z \judeq (f, g, U, L)$ between them. Then the associated morphism to $z$ induces a map $f_{\infty} : X \to Y$, and when we take $c[1] : \coconeN(\A[1], X)$ to be the colimit of $\A[1]$, the associated inverse morphism induces a map $g_{\infty} : Y \to X$. Then the two maps are mutually inverse equivalences.
#+end_thm

#+begin_proof
We first show that with the above assumptions, $f_{\infty}$ is a section of $g_{\infty}$, \ie $g_{\infty} \comp f_{\infty} \htpy \id$. We can prove it by concatenating the following homotopies:
\begin{alignat*}{2}
  g_{\infty} \comp f_{\infty}
  & \htpy (g \comp f)_{\infty} &\quad&\text{by \autoref{lemma:colim-preserves-comp}} \\
  & \htpy (\inclHomN[1])_{\infty} &&\text{by \autoref{lemma:zigzag-htpy-incl-hom} and \autoref{lemma:colim-preserves-htpy}} \\
  & \htpy \id &&\text{by \autoref{lemma:colim-incl-id}}
\end{alignat*}

Then consider the half-shift of $z$. The premises of the theorem are fulfilled by the sequential diagrams $\B$ and $\A[1]$, the colimits $c'$ and $c[1]$, and the half-shift. By the first half of the proof, we get that $g_{\infty}$ is a section of $f[1]_{\infty}$, in other words there is a triangle $f[1]_{\infty} \comp g_{\infty} \htpy \id$. Thus we found a section and a retraction of $g_{\infty}$, so by definition it is an equivalence. Then since $f_{\infty}$ is a section of an equivalence, it is itself an equivalence, and it is an inverse of $g_{\infty}$.
#+end_proof

** The zigzag construction of identity types
:PROPERTIES:
:CUSTOM_ID: sec:zigzag-constr
:END:

The following construction is a variation of the original zigzag construction of [cite/t:@War23]. It differs from Wärn's version in representation of span diagrams --- Wärn represents span diagrams as a pair of types $A$, $B$ with a type-valued relation $R : A \to B \to \UU$. We use the same representation as in the rest of the thesis, \ie a triple of types $S$, $A$, $B$, and a pair of maps $f : S \to A$, $g : S \to B$. These two representations are equivalent: a relation $R$ can be seen as the spanning type $\Sigma (a : A) (b : B).\, R(a, b)$ with the first and second projections, and conversely a spanning type $S$ with maps $f$, $g$ can be seen as the relation $\lambda a, b \to \Sigma (s : S).\, (f s = a) \times (g s = b)$. Adapting Wärn's construction involves reconstructing a relation from a span diagram and removing contractible pairs.

This version of the construction is the original type-theoretic one. Wärn later published a categorical version [cite//b:@War24]. The categorical version was published \TODO[when I was already working on the infrastructure for the type-theoretic version, and it requires differnet tooling to be built]. It is also not as straightforward to recover the concrete equivalences between identity types and the resulting type families.

\TODO[We assume existence of all pushouts and sequential colimits, because I don't know how to ask the user for the pushouts of inductively defined spans. The maps into pushouts are called $\inl$ and $\inr$ and the square is called $\glue$. The pushout cocone of a span diagram $\S$ is written $\psh(\S)$. The unique map corresponding to a dependent cocone $d$ is called $\depCogap(d)$. The inclusion maps into the sequential colimit are called $\iota_n$, and the triangles are called $\kappa_n$. Name the computation rules].

We begin by describing the construction informally, and then discuss necessary modifications to encode it in a proof assistant.

For the remainder of this section, assume a span diagram $\S \judeq (f, g)$ and a basepoint $a_0 : A$. The data we need to construct is a pair of type families
\begin{align*}
  P_A^n &: A \to \UU \\
  P_B^n &: B \to \UU
\end{align*}
and a pair of connecting maps
\begin{align*}
  \blank \concat_n s &: P_A^n(f s) \to P_B^{n + 1}(g s) \\
  \blank \concat_n \overline{s} &: P_B^n(g s) \to P_A^n(f s),
\end{align*}
all of which are indexed by $n : \N$. The construction proceeds by induction on $n$, with various interdependencies between definitions of the above data.

Take $P_A^0(a)$ to be the identity type $(a_0 = a)$, $P_B^0(b)$ to be the empty type $\0$, and $\blank \concat_0 \overline{s}$ to be the unique map out of the empty type[fn:2]. Note that we cannot yet define $\blank \concat_0 s$, because its intended codomain $P_B^1(g s)$ is not defined. Then construct the types $P_A^{n + 1}(a)$, $P_B^{n + 1}(b)$ and the connecting maps $\blank \concat_{n + 1} \overline{s}$ and $\blank \concat_n s$ together as the pushouts and their inclusion maps
#+begin_center
\begin{tikzcd}[column sep=6em]
  \Sigma (s : S) (r : a = (f s)). \; P_A^n(a)
  \arrow[r, "\tot(\tot(\blank \concat_n' s))"]
  \arrow[d, "\pr_3"']
  \arrow[rd, phantom, "\ulcorner", at end]
  & \Sigma (s : S) (r : a = (f s)). \; P_B^{n + 1}(g s)
  \arrow[d, "\blank \concat_{n + 1} \overline{s} \defeq \inr"] \\
  P_A^n(a)
  \arrow[r]
  & P_A^{n + 1}(a)
\end{tikzcd}
#+end_center
for $a : A$, and
#+begin_center
\begin{tikzcd}[column sep=6em]
  \Sigma (s : S) (r : b = (g s)). \; P_B^n(b)
  \arrow[r, "\tot(\tot(\blank \concat_n \overline{s}))"]
  \arrow[d, "\pr_3"']
  \arrow[rd, phantom, "\ulcorner", very near end]
  & \Sigma (s : S) (r : b = (g s)). \; P_A^n(f s)
  \arrow[d, "\blank \concat_n s \defeq \inr"] \\ P_B^n(b)
  \arrow[r]
  & P_B^{n + 1}(b)
\end{tikzcd}
#+end_center
for $b : B$. The top maps $\tot(\tot(\blank \concat_n s))$ and $\tot(\tot(\blank \concat_n \overline{s}))$ additionally transport in the type families $P_A^n$ and $P_B^n$ using the identifications $r : (a = f s)$ and $r : (b = g s)$ respectively, to make the types line up.

The data dependencies resulting from these definitions are summarized in [[fig:zigzag-deps]].

#+name: fig:zigzag-deps
#+caption: Dependencies between definitions in the zigzag construction.
#+begin_figure
\begin{align*}
  \cdot &\vdash P_B^0 & P_B^n, P_A^n, \blank \concat_n \overline{s} &\vdash P_B^{n + 1} \\
  \cdot &\vdash P_A^0 & P_A^n, P_B^{n + 1}, \blank \concat_n s &\vdash P_A^{n + 1} \\
  \cdot &\vdash \blank \concat_0 \overline{s} & P_A^{n + 1} &\vdash \blank \concat_{n + 1} \overline{s} \\
  P_B^1(b) &\vdash \blank \concat_0 s & P_B^{n + 1} &\vdash \blank \concat_n s \\
\end{align*}
#+end_figure

Formally, we induct on the stage $n : \N$, so we need a type family over $\N$ to induct into. Writing down the type of $\blank \concat_n s$ poses a challenge already, because to define it at stage $n$, it needs to know what the type family $P_B$ is at the next stage $n + 1$. One possibility is to not refer to its codomain as $P_B^{n + 1}(g s)$, but instead inline its definition as the appropriate pushout, because all the necessary data to construct $P_B^{n + 1}(g s)$ is available at stage $n$. Then after performing the construction, its codomain will be judgmentally equal to $P_B^{n + 1}(g s)$. This approach has two disadvantages. The first one is duplication of code --- one would need to construct the exact span diagram and its pushout to both state the type, and provide an inhabitant of one of its components. Additionally, the code for the definition of the cases $\blank \concat_0 s$ and $\blank \concat_{n + 1} s$ would be identical. The other issue is computational: in contrast to $\blank \concat_n \overline{s}$, the map $\blank \concat_n s$ is defined as the right inclusion map of a pushout at every stage $n$. But this is invisible to computation, because it is defined together with the other data by induction on $n$, so the definition only computes when it is applied to either of the constructors $0$ or $n' + 1$.

An alternative definition of the type family removes the $\blank \concat_n s$ component altogether. In the construction itself it is only used to define $P_A^{n + 1}$, where it can be replaced by a direct reference to the right inclusion map of the pushout $P_B^{n + 1}(g s)$, which is already defined by the time we need to define $P_A^{n + 1}$. Then $\blank \concat_n s$ can be defined after the construction as the right inclusion map at every stage, without induction, removing code duplication and giving it the right computational behavior. We also want to refer to the span diagrams defining $P_B^{n + 1}$ and $P_A^{n + 1}$ later in the code, hence we also remember those in the construction.

#+begin_defn
Given a natural number $n$, define the type of *zigzag construction data* at stage $n$ to be the type of quadruples $(P_B^n, P_A^n, \blank \concat_n \overline{s}, D)$, where
\begin{align*}
  P_B^n &: B \to \UU \\
  P_A^n &: A \to \UU
\end{align*}
are type families,
\begin{displaymath}
  \blank \concat_n \overline{s} : P_B^n(g s) \to P_A^n(f s)
\end{displaymath}
is a family of map indexed by $s : S$, and $D$ is an element of the unit type if $n = 0$, or of the type of pairs $(\T_B^n, \T_A^n)$ where $\T_B^n$ is a family of span diagrams indexed by $B$, and $\T_A^n$ is a family of span diagrams indexed by $A$ if $n$ is a successor.
#+end_defn

This type can be inhabited for all $n : \N$, using the construction described above.

#+begin_constr
Construct an inhabitant of the type of zigzag construction data for every stage $n$ by induction.

For the zero case, use
\begin{alignat*}{3}
  &P_B^0 \defeq (\lambda b \to \0) &&: B \to \UU \\
  &P_A^0 \defeq (\lambda a \to (a_0 = a)) &&: A \to \UU \\
  &\blank \concat_n \overline{s} \defeq \exf &&: P_B^0(g s) \to P_A^0(f s) \\
  &D^0 \defeq \star &&: \1.
\end{alignat*}

For the successor case $n + 1$, first construct the families of span diagrams $\T_B^{n + 1}$. For an element $b : B$, define $\T_B^{n + 1}(b)$ to be the span diagram
#+begin_center
\begin{tikzcd}
  P_B^n(b)
  & \Sigma (s : S) (r : b = g s).\, P_B^n(b)
  \arrow[l, "\pr_3"']
  \arrow[r, "\varphi"]
  & \Sigma (s : S) (r : b = g s). \, P_A^n(f s),
\end{tikzcd}
#+end_center
where $\varphi$ sends $(s, r, p)$ to $(s, r, (\tr_{P_B^n}(r, p)) \concat_n \overline{s})$. Take $P_B^{n + 1}(b)$ to be the standard pushout of this diagram. Analogously, for an element $a : A$, define $\T_A^{n + 1}(a)$ to be the span diagram
#+begin_center
\begin{tikzcd}
  P_A^n(a)
  & \Sigma (s : S) (r : a = f s).\, P_A^n(a)
  \arrow[l, "\pr_3"']
  \arrow[r, "\psi"]
  & \Sigma (s : S) (r : a = f s). \, P_B^{n + 1}(g s)
\end{tikzcd}
#+end_center
where the map $\psi$ takes $(s, r, p)$ to $(s, r, \inr(s, \refl, \tr_{P_A^n}(r, p)))$, using the right inclusion $\inr$ into the pushout $P_B^{n + 1}(g s)$. Then define $P_A^{n + 1}(a)$ to be the standard pushout of $\T_A^{n + 1}(a)$. Finally, define $p \concat_{n + 1} \overline{s}$ to be $\inr(s, \refl, p)$ using the right inclusion map into $P_A^{n + 1}(f s)$.
#+end_constr

We keep using the names $P_B^n$, $P_A^n$, $\blank \concat_n s$, $\T_B^n$ and $\T_A^n$ for the corresponding elements of this canonical construction. Note that the span diagrams $\T_B^n(b)$ and $\T_A^n(a)$ are not defined when $n$ is zero; they are the defining span diagrams of $P_B^n(b)$ and $P_A^n(a)$, respectively, which are only pushouts in the successor case.

#+begin_constr
For every stage $n : \N$ and element $s : S$, define the map
\begin{displaymath}
  \blank \concat_n s : P_A^n(f s) \to P_B^{n + 1}(g s)
\end{displaymath}
to send $p$ to $\inr(s, \refl, p)$, where $\inr$ is the right inclusion of the defining pushout of $P_B^{n + 1}(g s)$.
#+end_constr

We may also construct the sequential diagrams of approximations of the type families $(\inl(a_0) = \inr(b))$ and $(\inl(a_0) = \inl(a))$.

#+begin_constr
Given an element $b : B$, define the sequential diagram $P_B^{\bullet}(b)$ to be the diagram
#+begin_center
\begin{tikzcd}
  \0
  \arrow[r, "\incl_B^0"]
  & P_B^1(b)
  \arrow[r, "\incl_B^1"]
  & P_B^2(b)
  \arrow[r, "\incl_B^2"]
  & \cdots,
\end{tikzcd}
#+end_center
where the maps $\incl_B^n$ are the left inclusions $\inl$ of the pushouts defining $P_B^{n + 1}(b)$.
#+end_constr

#+begin_constr
Given an element $a : A$, define the sequential diagram $P_A^{\bullet}(a)$ to be the diagram
#+begin_center
\begin{tikzcd}
  (a_0 = a)
  \arrow[r, "\incl_A^0"]
  & P_A^1(a)
  \arrow[r, "\incl_A^1"]
  & P_A^2(a)
  \arrow[r, "\incl_A^2"]
  & \cdots,
\end{tikzcd}
#+end_center
where the maps $\incl_A^n$ are the left inclusions $\inl$ of the pushouts defining $P_A^{n + 1}(a)$.
#+end_constr

\TODO[While we define the full sequential diagram starting with $P_B^0(b)$, we only do so for uniformity of the zigzag construction. This way exactly the type families with a non-zero index are pushouts. When working with the construction we drop the first vertex, and compute only with $P_B^{n + 1}(b)$, which are all pushouts].

When constrained to the sequential diagrams $P_B^{\bullet}(g s)$ and $P_A^{\bullet}(f s)$, those sequential diagrams admit a zigzag between them.

#+name: constr:zigzag-zigzag
#+begin_constr
Given an element $s : S$, construct the zigzag $Z$ between $P_A^{\bullet}(f s)$ and the shift $P_B^{\bullet}(g s)[1]$ as
#+begin_center
\begin{tikzcd}[column sep=tiny]
  (a_0 = f s) \arrow[rr, "\incl_A^0"]
  \arrow[dr, "\blank \concat_0 s"']
  && P_A^1(f s) \arrow[rr, "\incl_A^1"]
  \arrow[dr, "\blank \concat_1 s"]
  && P_A^2(f s) \arrow[rr, "\incl_A^2"]
  \arrow[dr, "\blank \concat_2 s"]
  && \cdots \\
  & P_B^1(g s) \arrow[rr, "\incl_B^1"']
  \arrow[ur, "\blank \concat_1 \overline{s}"']
  && P_B^2(g s) \arrow[rr, "\incl_B^2"']
  \arrow[ur, "\blank \concat_2 \overline{s}"']
  && P_B^3(g s) \arrow[rr, "\incl_B^3"']
  && \cdots,
\end{tikzcd}
#+end_center
where the triangles are the gluing homotopies
\begin{align*}
  \glue_A^n(s, \refl) &: \incl_A^n \htpy (\blank \concat_n s) \concat_{n + 1} \overline{s} \\
  \glue_B^n(s, \refl) &: \incl_B^n \htpy (\blank \concat_n \overline{s}) \concat_{n} s.
\end{align*}
of the defining pushouts of $P_A^{n + 1}(f s)$ and $P_B^{n + 1}$, respectively.
#+end_constr

#+begin_constr
Define the *zigzag descent data* $(P_A^{\infty}, P_B^{\infty}, \blank \concat_{\infty} s)$, where the type families are constructed by taking sequential colimits of $P_A^{\bullet}(a)$ and $P_B^{\bullet}(b)[1]$, respectively, and the family of equivalences
\begin{displaymath}
  \blank \concat_{\infty} s : P_A^{\infty}(f s) \simeq P_B^{\infty}(g s)
\end{displaymath}
is induced by the zigzag between $P_A^{\infty}(f s)$ and $P_B^{\infty}(g s)$ for an element $s : S$, using [[thm:equiv-zigzag]].

Additionally, this descent data is pointed with $\iota_0(\refl_{a_0}) : P_A^\infty(a_0)$, which we call $\refl_{\infty}$.
#+end_constr

#+name: lemma:coherence-prism-zigzag
#+begin_lemma
For every element $s : S$, there is a family of commuting square of maps indexed by $n : \N$
#+begin_center
\begin{tikzcd}
  P_A^n(f s)
  \arrow[r, "\blank \concat_n s"]
  \arrow[d, "\iota_A^n"']
  & P_B^{n + 1}(g s)
  \arrow[d, "\iota_B^{n + 1}"] \\
  P_A^{\infty}(f s)
  \arrow[r, "\blank \concat_{\infty} s"']
  & P_B^{\infty}(g s),
\end{tikzcd}
#+end_center
call them $C^n(s)$, which fit in a commuting prism
#+begin_center
\begin{tikzcd}[row sep=small]
  P_A^n(f s)
  \arrow[dd, "\blank \concat_n s"']
  \arrow[rr, "\incl_A^n"]
  \arrow[dr, "\iota_A^n"', near end]
  && P_A^{n + 1}(f s)
  \arrow[dd, "\blank \concat_{n + 1} s"]
  \arrow[dl, "\iota_A^{n + 1}", near end] \\
  & P_A^{\infty}(f s) \\
  P_B^{n + 1}(g s)
  \arrow[rr, "\incl_B^{n + 1}", near start]
  \arrow[dr, "\iota_B^{n + 1}"']
  && P_B^{n + 2}(g s)
  \arrow[dl, "\iota_B^{n + 2}"] \\
  & P_B^{\infty}(g s)
  \arrow[from=uu, "\blank \concat_{\infty} s", near start, crossing over]
\end{tikzcd}
#+end_center
as the front squares, with the triangles being $\kappa_A^n$ and $\kappa_B^{n + 1}$, and the back square a composition of $(\glue_A^n)^{-1}$ and $\glue_B^{n + 1}$.
#+end_lemma

#+begin_proof
The data is obtained from the morphism associated to the zigzag $Z$ using [[lemma:prism-hom-seq-diag]].
#+end_proof

** Partial proof of correctness
:PROPERTIES:
:CUSTOM_ID: sec:zigzag-correct
:END:

We write down a partial proof that the zigzag descent data $(P_A^{\infty}, P_B^{\infty}, \blank \concat_{\infty} s)$ is an identity system at $\reflinf$. Incompleteness of the proof is due to [[conj:zigzag-coherence]], which remains an unproven coherence condition at the time of writing.

To show that the zigzag descent data is an identity system, we assume pointed descent data $Q$ over its total span diagram, and the rest of the thesis is dedicated to providing a section of $Q$.

Explicitly, in the remainder of this section assume type families
\begin{align*}
  Q_{\Sigma A} &: (a : A) \to P_A^{\infty}(a) \to \UU \\
  Q_{\Sigma B} &: (b : B) \to P_B^{\infty}(b) \to \UU,
\end{align*}
a family of equivalences
\begin{displaymath}
  Q_{\Sigma S} : (s : S) (p : P_A^{\infty}(a)) \to Q_{\Sigma A}(f s, p) \simeq Q_{\Sigma B}(g s, p \concat_{\infty} s),
\end{displaymath}
and a point $q_0 : Q_{\Sigma A}(a_0, \reflinf)$. The goal is to conjure a section, \ie define a pair of dependent functions
\begin{align*}
  t_A &: (a : A) (p : P_A^{\infty}(a)) \to Q_{\Sigma A}(a, p) \\
  t_B &: (b : B) (p : P_B^{\infty}(b)) \to Q_{\Sigma B}(b, p)
\end{align*}
and a family of identifications
\begin{displaymath}
  t_S : (s : S) (p : P_A^{\infty}(f s)) \to Q_{\Sigma S}(s, p, t_A(f s, p)) = t_B(g s, p \concat_{\infty} s).
\end{displaymath}
We may occasionally omit some arguments when writing down expressions, and we pass freely between the curried and uncurried forms, to aid readability and clarity of intent.

In each case the construction proceeds by induction on the argument $p$. By the dependent universal property of sequential colimits, it suffices to define the data
\begin{align*}
  t_A^n &: (a : A) (p : P_A^n(a)) \to Q_{\Sigma A}(a, \iota_A^n(p)) \\
  K_A^n &: (a : A) (p : P_A^n(a)) \to \tr_{Q_{\Sigma A}(a)}(\kappa_A^n(p), t_A^n(a, p)) = t_A^{n + 1}(a, \incl_A^n p) \\
  t_B^n &: (b : B) (p : P_B^n(b)) \to Q_{\Sigma B}(b, \iota_B^n(p)) \\
  K_B^n &: (b : B) (p : P_B^n(b)) \to \tr_{Q_{\Sigma B}(b)}(\kappa_B^n(p), t_B^n(b, p)) = t_B^{n + 1}(b, \incl_B^n p)
\end{align*}
for the maps, and
\begin{alignat*}{2}
  t_S^n &: &\:&(s : S) (p : P_A^n(f s)) \to Q_{\Sigma S}(s, \iota_A^n(p), t_A(f s, \iota_A^n(p))) = t_B(g s, (\iota_A^n(p)) \concat_{\infty} s) \\
  K_S^n &: &&(s : S) (p : P_A^n(f s)) \to \\
  &&&\tr_{\lambda q \to (Q_{\Sigma S}(s, q, t_A(f s, q)) = t_B(g s, q \concat_{\infty} s))}(\kappa_A^n(p), t_S^n(s, p)) = t_S^{n + 1}(s, \incl_A^n p)
\end{alignat*}
for the coherence.

We begin with the maps $t_B^n$ and $t_A^n$, which are defined together. We first present their construction informally, and then explain the modifications necessary for Agda to accept them in code.

The maps $t_B^n$ and $t_A^n$ are defined by induction on $n$. In the zero case, the domain of $t_B^0(b)$ is the empty type, so it is defined by $\exf$. The domain of $t_A^0(a)$ is the identity type $(a_0 = a)$, and inducting on it gives us the goal of inhabiting $Q_{\Sigma A}(a_0, \iota_A^0(\refl))$, which we can do by the basepoint $q_0$. In the successor case $n + 1$, we eliminate from the pushouts $P_B^{n + 1}(b)$ and $P_A^{n + 1}(a)$, so we use the dependent universal property of pushouts. This means that we need to give definitions of the maps on point constructors and a coherence over the path constructor, which defines a dependent cocone. Let us begin with the point constructor cases.

To define $t_B^{n + 1}$, the behavior on point constructors consists of maps
\begin{alignat*}{2}
  &\overline{t_B^{n + 1}}(b, \incl_B^n(\blank)) &&: (p : P_B^n(b)) \to Q_{\Sigma B}(b, \iota_B^{n + 1}(\incl_B^n p)) \\
  &\overline{t_B^{n + 1}}(g s, \blank \concat_n s) &&: (p : P_A^n(f s)) \to Q_{\Sigma B}(g s, \iota_B^{n + 1}(p \concat_n s)).
\end{alignat*}
We need to distinguish between $t_B^{n + 1}$ and $\overline{t_B^{n + 1}}$, because they have different computational properties. Since we work in a type theory without judgmental computation rules for pushouts, once we combine the data into the map $t_B^{n + 1}$, its behavior on path constructors will only hold up to an identification. In contrast, $\overline{t_B^{n + 1}}$ is a pair of functions which compute judgmentally, but their applications are only well-formed when they are syntactically applied to a point constructor. The statement of the second function is in a form after inducting on the term $r : b = g s$ in the context. The maps are defined by
\begin{align*}
  &\overline{t_B^{n + 1}}(b, \incl_B^n(p)) \defeq \tr_{Q_{\Sigma B}(b)}(\kappa_B^n(p), t_B^n(b, p)) \\
  &\overline{t_B^{n + 1}}(g s, p \concat_n s) \defeq \tr_{Q_{\Sigma B}(g s)}(C^n(s, p), Q_{\Sigma S}(s, \iota_A^n(p), f s, t_A^n(f s, p))).
\end{align*}

Similarly for the definition of $t_A^{n + 1}$ on point constructors, we need to give
\begin{alignat*}{2}
  &\overline{t_A^{n + 1}}(a, \incl_A^n(\blank)) &&: (p : P_A^n(a)) \to Q_{\Sigma A}(a, \iota_A^{n + 1}(\incl_A^n p)) \\
  &\overline{t_A^{n + 1}}(f s, \blank \concat_{n + 1} \overline{s}) &&: (p : P_B^{n + 1}(g s)) \to Q_{\Sigma A}(f s, \iota_A^{n + 1}(p \concat_{n + 1} \overline{s})).
\end{alignat*}
The behavior on $\incl_A^n$ is analogous to the one of $t_B^{n + 1}$, specifically
\begin{displaymath}
  \overline{t_A^{n + 1}}(a, \incl_A^n(p)) \defeq \tr_{Q_{\Sigma A}(a)}(\kappa_A^n(p), t_A^n(a, p)).
\end{displaymath}
For the second map, we would expect to use the inverse $Q_{\Sigma S}(s, \blank)^{-1}$. It isn't that straightforward, because $t_B^{n + 1}(g s, p)$ gives an element of $Q_{\Sigma B}(g s, \iota_B^{n + 1}(p))$, and $Q_{\Sigma S}(s, \blank)^{-1}$ can only undo an application of $\blank \concat_{\infty} s$ under $Q_{\Sigma B}(g s)$, not add an application of $\blank \concat_{\infty} \overline{s}$ under $Q_{\Sigma A}(f s)$. One might try to fix this by recalling that $\blank \concat_{\infty} s$ and $\blank \concat_{\infty} \overline{s}$ are inverse equivalences, and using the homotopy
\begin{displaymath}
  \id \htpy (\blank \concat_{\infty} \overline{s}) \concat_{\infty} s.
\end{displaymath}
This approach leads to complications in proving further coherences, so instead we define a helper function which we can later compute with.

#+begin_constr
For any element $s : S$ and natural number $n$, define the map
\begin{displaymath}
  \Phi^n(s) : (p : P_B^{n + 1}(g s)) \to Q_{\Sigma B}(g s, \iota_B^{n + 1} p) \to Q_{\Sigma B}(g s, (\iota_A^{n + 1}(p \concat_{n + 1} \overline{s})) \concat_{\infty} s)
\end{displaymath}
as the composition of transports
#+begin_center
\begin{tikzcd}
  Q_{\Sigma B}(g s, \iota_B^{n + 1} p)
  \arrow[d, "\tr_{Q_{\Sigma B}(g s)}(\kappa_B^{n + 1} p)"] \\
  Q_{\Sigma B}(g s, \iota_B^{n + 2}(\incl_B^{n + 1} p))
  \arrow[d, "{\tr_{Q_{\Sigma B}(g s, \iota_B^{n + 2}(\blank))}(\glue_B^{n + 1}(s, \refl, p))}"] \\
  Q_{\Sigma B}(g s, \iota_B^{n + 2}((p \concat_{n + 1} \overline{s}) \concat_{n + 1} s))
  \arrow[d, "{\tr_{Q_{\Sigma B}(g s)}(C^{n + 1}(s, p \concat_{n + 1} \overline{s}))^{-1}}"] \\
  Q_{\Sigma B}(g s, (\iota_A^{n + 1}(p \concat_{n + 1} \overline{s})) \concat_{\infty} s).
\end{tikzcd}
#+end_center
#+end_constr

With this function in hand, we can define
\begin{displaymath}
  \overline{t_A^{n + 1}}(f s, p \concat_{n + 1} \overline{s}) \defeq (Q_{\Sigma S}(s, \iota_A^{n + 1}(p \concat_{n + 1} \overline{s})))^{-1}(\Phi^n(s, p, t_B^{n + 1}(g s, p))).
\end{displaymath}

The path constructor cases will be less similar between $t_B^{n + 1}$ and $t_A^{n + 1}$. The coherence of $t_B^{n + 1}$ asks us to inhabit the type
\begin{displaymath}
  (p : P_B^n(g s)) \to \tr_{Q_{\Sigma B}(g s, \iota_B^{n + 1}(\blank))}(\glue_B^n(p), \overline{t_B^{n + 1}}(\incl_B^n(p))) = \overline{t_B^{n + 1}}((p \concat_n \overline{s}) \concat_n s).
\end{displaymath}
Here we once again need to case split on $n$. In the zero case we eliminate from $P_B^0(g s) \judeq \0$, so we inhabit the coherence by $\exf$. In the successor case, the right-hand side computes to
\begin{displaymath}
  \tr_{Q_{\Sigma B}(g s)}(C^{n + 1}(s, p \concat_{n + 1} \overline{s}), Q_{\Sigma S}(s, \iota_A^{n + 1}(p \concat_{n + 1} \overline {s}), t_A^{n + 1}(p \concat_{n + 1} \overline{s}))),
\end{displaymath}
where we can use a computation rule of $t_A^{n + 1}$ and further expand $\Phi^n$ in the resulting expression. Then the two sides are identified, because the equivalence $Q_{\Sigma S}(s, \iota_A^{n + 1}(p \concat_{n + 1} \overline{s}))$ cancels out with its inverse, and so does \linebreak $\tr_{Q_{\Sigma B}(g s)}(C^{n + 1}(s, p \concat_{n + 1} \overline{s}))$.

The coherence for $t_A^{n + 1}$ has the type
\begin{displaymath}
  (p : P_A^n(f s)) \to \tr_{Q_{\Sigma A}(f s, \iota_A^{n + 1}(\blank))}(\glue_A^n(p), \overline{t_A^{n + 1}}(\incl_A^n(p))) = \overline{t_A^{n + 1}}((p \concat_n s) \concat_{n + 1} \overline{s}).
\end{displaymath}
We can expand the $\overline{t_A^{n + 1}}$, the $\Phi^n$, and also use the computation rule of $t_B^{n + 1}$ to compute $t_B^{n + 1}(p \concat_n s)$. By transposing $Q_{\Sigma S}(s, \iota_A^{n + 1}((p \concat_n s) \concat_{n + 1} \overline{s}))^{-1}$ to the other side of the identification, we see that the goal is to make the diagram
#+begin_center
\begin{tikzcd}[column sep=8em]
  Q_{\Sigma A}(f s, \iota_A^n(p))
  \arrow[r, "{Q_{\Sigma S}(s, \iota_A^n(p))}"]
  \arrow[dd, "\tr_{Q_{\Sigma A}(f s)}(\kappa_A^n(p))"]
  & Q_{\Sigma B}(g s, (\iota_A^n(p)) \concat_{\infty} s)
  \arrow[d, "{\tr_{Q_{\Sigma B}(g s)}(C^n(s, p))}"']
  \arrow[ddddl, Rightarrow, shorten=11.5em] \\
  & Q_{\Sigma B}(g s, \iota_B^{n + 1}(p \concat_n s))
  \arrow[d, "{\tr_{Q_{\Sigma B}(g s)}(\kappa_B^{n + 1}(p \concat_n s))}"'] \\
  Q_{\Sigma A}(f s, \iota_A^{n + 1}(\incl_A^n(p)))
  \arrow[dd, "{\tr_{Q_{\Sigma A}(f s, \iota_A^{n + 1}(\blank))}(\glue_A^n(p))}"]
  & Q_{\Sigma B}(g s, \iota_B^{n + 2}(\incl_B^{n + 1}(p \concat_n s)))
  \arrow[d, "{\tr_{Q_{\Sigma A}(g s), \iota_B^{n + 2}(\blank)}(\glue_B^{n + 1}(p \concat_n s))}"'] \\
  & Q_{\Sigma B}(g s, \iota_B^{n + 2}(((p \concat_n s) \concat_{n + 1} \overline{s}) \concat_{n + 1} s))
  \arrow[d, "{\tr_{Q_{\Sigma B}(g s)}(C^{n + 1}(s, (p \concat_n s) \concat_{n + 1} \overline{s}))^{-1}}"'] \\
  Q_{\Sigma A}(f s, \iota_A^{n + 1}((p \concat_n s) \concat_{n + 1} \overline{s}))
  \arrow[r, "{Q_{\Sigma S}(s, \iota_A^{n + 1}((p \concat_n s) \concat_{n + 1} \overline{s}))}"']
  & Q_{\Sigma B}(g s, (\iota_B^{n + 1}((p \concat_n s) \concat_{n + 1} \overline{s})) \concat_{\infty} s)
\end{tikzcd}
#+end_center
commute from right to left --- it is rotated only to fit on the page. Commutativity can be established using the following lemma.

#+begin_lemma
Given types $A$, $B$ and a function $f : A \to B$, type families $P : A \to \UU$ and $Q : B \to \UV$, a fiberwise function $h : (a : A) \to P(a) \to Q(f a)$, identifications $p : x = y$ of elements in $A$ and $q : f x = f y$, and a coherence $\alpha : \ap_f(p) = q$, there is a commuting square
#+begin_center
\begin{tikzcd}
  P(x)
  \arrow[r, "\tr_P(p)"]
  \arrow[d, "h(x)"']
  & P(y)
  \arrow[d, "h(y)"] \\
  Q(f x)
  \arrow[r, "\tr_Q(q)"']
  & Q(f y).
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_proof
By induction on $\alpha$ and $p$, it suffices to provide a homotopy $h(x) \htpy h(x)$, which we can fulfill with $\reflhtpy$.
#+end_proof

Computing transports of the form $\tr_{(P \comp f)}(p)$ to $\tr_P(\ap_f p)$ \TODO[ref?] and distributivity of concatenation and transport \TODO[ref?] allows us to collect both sides of the diagram into one transport each, at which point we may apply the lemma. The coherence $\alpha$ is obtained from the prism [[lemma:coherence-prism-zigzag]] by straightforward homotopy algebra. This completes the paper construction of the maps $t_B^n$ and $t_A^n$.

In the formalization, we are again met with computation issues. Since $t_B^n$ and $t_A^n$ are defined together by induction on $n$, and the definition of $t_B^{n + 1}$ does one more case split on $n$, we end up with three cases for the induction, namely $0$, $1$ and $n + 2$. As a consequence, $\overline{t_A^{n + 1}}(p \concat_{n + 1} \overline{s})$ does not have a uniform definition, because it is also defined by cases $0$, $1$ and $n + 2$. But we rely on its definition when computing the coherence of $t_B^{n + 1}$. If we naïvely try to case split on $n$ again to analyze the cases $t_A^1$ and $t_A^{n + 2}$ separately, we would end up defining everything in terms of the cases $0$, $1$, $2$ and $n + 3$. Instead, during the definition of $t_B^{n + 1}$ and $t_A^{n + 1}$ we carry a proof that $\overline{t_A^{n + 1}}(p \concat_{n + 1} \overline{s})$ is identical to the desired composition of $Q_{\Sigma S}^{-1}$ and $\Phi$. This component will be satisfied by $\refl$ at all stages.

Furthermore, during induction we need to compute with $t_B^{n + 1}$ and $t_A^{n + 1}$ as maps defined by the dependent universal property, meaning that we need to carry around their defining dependent cocones. Rather than defining together the maps, the dependent cocones, and proofs that the maps are defined by the respective dependent cocones, we prefer to construct only the dependent cocones during induction, materializing their induced maps $t_B^{n + 1}$ and $t_A^{n + 1}$ only when necessary.

#+begin_defn
Given a natural number $n$, the type of *section cocones* at stage $n$ is the type of triples $(d_B^n, d_A^n, R^n)$, where
\begin{align*}
  d_B^n &: (b : B) \to \depCocone(\psh(\T_B^{n + 1}(b)), Q_{\Sigma B}(b, \iota_B^{n + 1}(\blank))) \\
  d_A^n &: (a : A) \to \depCocone(\psh(\T_A^{n + 1}(a)), Q_{\Sigma A}(a, \iota_A^{n + 1}(\blank)))
\end{align*}
are families of dependent cocones over the standard pushout cocones of the span diagrams defining $P_B^{n + 1}(b)$ and $P_A^{n + 1}(a)$, respectively, and $R^n$ is an identification between the vertical map of $d_A^n(f s)$ applied to $p : P_B^{n + 1}(g s)$ and the element
\begin{displaymath}
  (Q_{\Sigma S}(s, \iota_A^{n + 1}(p \concat_{n + 1} \overline{s})))^{-1}(\Phi^n(s, p, \depCogap(d_B^{n}(g s), p))).
\end{displaymath}
#+end_defn

#+begin_constr
For any natural number $n$, construct a section cocone at stage $n$. Begin by case splitting on $n$. Define the left map and coherence of $d_B^0$ by $\exf$, and the right map by pattern matching on $p : P_A^0(f s)$, and filling the goal with $\tr_{Q_{\Sigma B}(g s)}(C^0(s, \refl), Q_{\Sigma S}(s, \refl_{\infty})(q_0))$. For the successor case, define the left and right maps of $d_B^{n + 1}$ like in the informal description, replacing $t_B^{n + 1}(b)$ by $\depCogap(d_B^n(b))$ and $t_A^{n + 1}(a)$ by $\depCogap(d_A^n(a))$. Similarly, define the left and right maps and coherences of $d_A^0$ and $d_A^{n + 1}$ following the informal description, replacing calls to $t_B^{n + 1}$ and $t_A^n$ with the cogap maps of the appropriate dependent cocones. Use the reflexive homotopy for the witnesses $R^0$ and $R^{n + 1}$.

Finally, construct the coherence of $d_B^{n + 1}$ using the informal description, following the computation rule of $\depCogap(d_A^{n + 1})$ by the identification $R^n$ to get to the desired shape of the right-hand side of the coherence.
#+end_constr

The dependent cocones induce maps $t_B^{n + 1}$ and $t_A^{n + 1}$, for which we can add the base cases to get the maps $t_B^n$ and $t_A^n$.

#+begin_constr
Construct the maps
\begin{align*}
  t_B^n &: (b : B) (p : P_B^n(b)) \to Q_{\Sigma B}(b, \iota_B^n(p)) \\
  t_A^n &: (a : A) (p : P_A^n(a)) \to Q_{\Sigma A}(a, \iota_A^n(p))
\end{align*}
by induction on $n$.

In the zero case, define
\begin{align*}
  &t_B^0(b) \defeq \exf \\
  &t_A^0(a_0, \refl) \defeq q_0,
\end{align*}
and in the successor case, define
\begin{align*}
  &t_B^{n + 1}(b) \defeq \depCogap(d_B^n(b)) \\
  &t_A^{n + 1}(a) \defeq \depCogap(d_A^n(a)).
\end{align*}
#+end_constr

The coherences $K_B^n$ and $K_A^n$ can be recovered from the computation rules of $t_B^{n + 1}$ and $t_A^{n + 1}$, respectively.

#+begin_constr
Define the family of coherences
\begin{displaymath}
  K_B : (n : \N) (b : B) (p : P_B^n(b)) \to \tr_{Q_{\Sigma B}(b)}(\kappa_B^n(p), t_B^n(b, p)) = t_B^{n + 1}(b, \incl_B^n p)
\end{displaymath}
by case analysis on $n$. In the zero case, define
\begin{displaymath}
  K_B^0(b) \defeq \exf,
\end{displaymath}
and in the successor case, unfold the definition of $t_B^{n + 2}(b)$ as the dependent cogap of the cocone $d_B^{n + 1}(b)$, which comes equipped with the computation rule
\begin{displaymath}
  t_B^{n + 2}(\incl_B^{n + 1}(p)) = \tr_{Q_{\Sigma B}(b)}(\kappa_B^{n + 1}(p), t_B^{n + 1}(b, p)),
\end{displaymath}
which may be inverted to get the desired identification.
#+end_constr

#+begin_constr
Define the family of coherences
\begin{displaymath}
  K_A : (n : \N) (a : A) (p : P_A^n(a)) \to \tr_{Q_{\Sigma A}(a)}(\kappa_A^n(p), t_A^n(a, p)) = t_A^{n + 1}(a, \incl_A^n p)
\end{displaymath}
by case analysis on $n$. In both cases, the identification $K_A^{\bullet}(a, p)$ is the inverse of the computation rule of $t_A^{n + 1}$ as the dependent cogap of $d_A^n(a)$.
#+end_constr

The maps and coherences fit together to define dependent cocones under the sequential diagrams $P_B^{\bullet}(a)$ and $P_A^{\bullet}(b)$, which induce dependent maps out of their respective colimits.

#+begin_constr
Define the maps
\begin{align*}
  &t_A : (a : A) (p : P_A^{\infty}(a)) \to Q_{\Sigma A}(a, p) \\
  &t_B : (b : B) (p : P_B^{\infty}(b)) \to Q_{\Sigma B}(b, p)
\end{align*}
using the dependent universal property of sequential colimits of $P_A^{\infty}(a)$ and $P_B^{\infty}$, from the families of dependent cocones
\begin{align*}
  (\lambda a \to (\lambda n \to t_A^n, \lambda n \to K_A^n)) : (a : A) \to \depCoconeN(P_A^{\bullet}(a), Q_{\Sigma A}(a)) \\
  (\lambda b \to (\lambda n \to t_B^n, \lambda n \to K_B^n)) : (b : B) \to \depCoconeN(P_B^{\bullet}(b), Q_{\Sigma B}(b)).
\end{align*}
#+end_constr

It remains to define the families of identifications $t_S^n$ and coherences $K_S^n$.

#+name: lemma:comp-tB
#+begin_lemma
For all natural numbers $n$, elements $s : S$ and $p : P_A^n(f s)$, there is an identification
\begin{displaymath}
  t_B^{n + 1}(g s)(p \concat_n s) = \tr_{Q_{\Sigma B}(g s)}(C^n(s, p), Q_{\Sigma S}(s, \iota_A^n(p), f s, t_A^n(p))).
\end{displaymath}
#+end_lemma

#+begin_proof
Doing case analysis on $n$ allows the underlying dependent cocones to compute, and the identification holds by the computation rule of $\depCogap$.
#+end_proof

#+begin_constr
Given a natural number $n$, construct the family of identifications
\begin{displaymath}
  t_S^n : (s : S) (p : P_A^n(f s)) \to Q_{\Sigma S}(s, \iota_A^n(p), t_A(f s, \iota_A^n(p))) = t_B(g s, (\iota_A^n(p)) \concat_{\infty} s)
\end{displaymath}
by concatenating
#+begin_center
\begin{tikzcd}
  Q_{\Sigma S}(s, \iota_A^n(p), t_A(f s, \iota_A^n(p)))
  \arrow[d, equals] \\
  Q_{\Sigma S}(s, \iota_A^n(p), t_A^n(f s, p))
  \arrow[d, equals] \\
  t_B(g s, (\iota_A^n(p)) \concat_{\infty} s),
\end{tikzcd}
#+end_center
where the top identification is obtained from the computation rule for maps out of sequential colimits defined by dependent cocones, and the bottom identification follows from the observation that there is an identification
#+begin_center
\begin{tikzcd}
  \tr_{Q_{\Sigma B}(g s)}(C^n(s, p), Q_{\Sigma S}(s, \iota_A^n(p), t_A^n(f s, p)))
  \arrow[d, equals] \\
  t_B^{n + 1}(g s, p \concat_n s)
  \arrow[d, equals] \\
  t_B(g s, \iota_B^{n + 1}(p \concat_n s))
  \arrow[d, equals] \\
  \tr_{Q_{\Sigma B}(g s)}(C^n(s, p), t_B(g s, (\iota_A^n(p)) \concat_{\infty} s)),
\end{tikzcd}
#+end_center
where the top identification is [[lemma:comp-tB]], the middle identification is the computation rule of $t_B$, and the bottom identification is the inverse of \linebreak $\apd_{t_B(g s)}(C^n(s, p))$. We may "unapply" the transport from the composite, because transporting is an equivalence.
#+end_constr

At the time of writing, the coherences $K_S^n$ have not been formally constructed, so we leave their existence as a conjecture, and claim only a partial proof of correctness.

#+name: conj:zigzag-coherence
#+begin_conj
The coherences $K_S^n$ exist.
#+end_conj

#+begin_constr
Construct the family of coherences
\begin{displaymath}
  t_S : (s : S) (p : P_A^{\infty}(f s)) \to Q_{\Sigma S}(s, p, t_A(f s, p)) = t_B(g s, p \concat_{\infty} s)
\end{displaymath}
using the dependent universal property of $P_A^{\infty}(f s)$, from the families of dependent cocones
\begin{align*}
  &(\lambda s \to (\lambda n \to t_S^n, \lambda n \to K_S^n)) : \\
  &\quad (s : S) \to \depCoconeN(P_A^{\bullet}(f s), \lambda p \to (Q_{\Sigma S}(s, p, t_A(f s, p)) = t_B(g s, p \concat_{\infty} s)))
\end{align*}
#+end_constr

#+name: thm:is-identity-system-zigzag
#+begin_thm
Assuming [[conj:zigzag-coherence]] holds, the descent data ${(P_A^{\infty}, P_B^{\infty}, \blank \concat_{\infty} s)}$ is an identity system at $\refl_\infty(a_0)$.
#+end_thm

#+begin_proof
The data $(t_A, t_B, t_S)$ form an element of $\sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$, which makes $(P_A^{\infty}, P_B^{\infty}, \blank \concat_{\infty} s)$ an identity system by [[lemma:identity-system-ind-singleton]].
#+end_proof

#+begin_corol
Assuming [[conj:zigzag-coherence]] holds, there are families of equivalences
\begin{align*}
  e_A : (a : A) \to (\inl(a_0) = \inl(a)) &\simeq P_A^{\infty}(a) \\
  e_B : (b : B) \to (\inl(a_0) = \inr(b)) &\simeq P_B^{\infty}(b)
\end{align*}
satisfying $e_A(a_0, \refl) = \refl_{\infty}$, and for every $s : S$ a commuting square
#+begin_center
\begin{tikzcd}[column sep=large]
  (\inl(a_0) = \inl(f s))
  \arrow[r, "e_A(f s)"]
  \arrow[d, "\blank \concat (H s)"']
  & P_A^{\infty}(f s)
  \arrow[d, "\blank \concat_{\infty} s"] \\
  (\inl(a_0) = \inr(g s))
  \arrow[r, "e_B(g s)"']
  & P_B^{\infty}(g s).
\end{tikzcd}
#+end_center
#+end_corol

#+begin_proof
By [[thm:unique-uniqueness-id-system]] and [[thm:is-identity-system-zigzag]], there is a unique equivalence of descent data $e : (I_A, I_B, I_S) \simeq (P_A^{\infty}, P_B^{\infty}, \blank \concat_{\infty} \blank)$ sending $\refl$ to $\refl_{\infty}$.
#+end_proof

* Conclusion

The goal of the thesis was to improve existing infrastructure for working with homotopy pushouts in the {{{AU}}} library, and formalize existing results from the literature. Specifically the descent property, the flattening lemma, and the induction principle of identity types of pushouts were successfully formalized, properly documented, and integrated into the library. In an attempt to formalize the zigzag construction of identity types of pushouts, infrastructure for coequalizers and sequential colimits was developed. The zigzag construction was formalized, but it has not been shown to satisfy the induction principle of identity types of pushouts. Progress was made, but one coherence condition remains unproven.

**** Future work

There is an obvious step to continue the presented work, which is to complete the proof of correctness of the zigzag construction. Additional insight into strategies of its proof might be necessary, for example using the calculus of dependent identifications to abstract the transports, or formulating general lemmas about type families over sequential diagrams connected by a zigzag. This abstraction has not been explored in the thesis for its perceived low applicability.

The inductive definition of $d_B^n$ and $d_A^n$ could be improved by removing contractible data, \ie the right map of $d_A^n$ and the witness $R^n$.

The thesis also does not attempt to formalize applications of the zigzag construction. Wärn presents truncatedness and connectivity results as applications of the construction. For reasoning about the zigzag construction, more results about sequential colimits might be necessary, particularly the full "generalized flattening lemma" [cite//b:@SvDR20]. While the paper presents a proof in homotopy type theory, it does so in a context with judgmental computation rules for sequential colimits, which are not present in our setting.

#+PRINT_BIBLIOGRAPHY: :heading bibintoc

\appendix
* List of attachments

Attachments consist of Git patch files, most of which were submitted as pull requests to the {{{AU}}} GitHub {{{AURepo}}}. They may be found in the =attachments= directory in the thesis source [[https://github.com/VojtechStep/homotopy-pushouts][repository]], and should also be included with any distribution of the thesis.

- {{{PR(535,refactor-descent-circle)}}}
  updates formalization of the descent property of the circle to be consistent with its description in [cite//b:@Rij22].
- {{{PR(709,descent-circle)}}}
  documents the above and extends the formalization with characterization of other kinds of type families over the circle.
- {{{PR(724,foundation-precomp-concat-squares)}}}
  shows commutativity of pasting and exponentiation of commuting squares.
- {{{PR(725,foundation-horizontal-paste-pushouts)}}}
  formalizes horizontal pasting of pushouts squares.
- {{{PR(755,foundation-vertical-paste-pushouts)}}}
  formalizes vertical pasting of pushouts squares.
- {{{PR(758,foundation-unpaste-pushouts)}}}
  formalizes the inverse direction of pasting properties of pushout squares.
- {{{PR(764,flattening-pushouts-family)}}}
  formalizes the flattening lemma for pushouts, without descent data.
- {{{PR(792,coequalizers)}}}
  introduces coequalizers to the extent described in the thesis.
- {{{PR(816,flattening-pushouts-descent-data)}}}
  formalizes the flattening lemma for pushouts, using descent data.
- {{{PR(831,flattening-coequalizers)}}}
  refactors the flattening lemma for coequalizers to be derived from the flattening lemma for pushouts.
- {{{PR(841,sequential-colimits)}}}
  defines and documents basic infrastructure of sequential diagrams and their colimits in terms of universal properties.
- {{{PR(919,functoriality-sequential-colimits)}}}
  introduces commuting prisms and formalizes functoriality of taking the standard sequential colimit, to the extent described in the thesis.
- {{{PR(972,flattening-sequential-colimits-family)}}}
  formalizes the flattening lemma for sequential colimits, without descent data.
- {{{PR(978,refactor-functoriality-sequential-colimits)}}}
  generalizes functoriality of sequential colimits from only the standard ones to arbitrary cocones satisfying the universal property.
- {{{PR(988,refactor-lifts-families)}}}
  refactors and documents formalization of lifts of families of elements, which underpin the equivalence of the dependent and non-dependent pullback properties of pushouts.
- {{{PR(1070,shifts-sequential-colimits)}}}
  formalizes shifts of sequential diagrams and related concepts, and its preservation of sequential colimits.
- {{{PR(1098,refactor-coequalizers)}}}
  introduces infrastructure for double arrows, and adopts coequalizers to use it.
- {{{PR(1109,flattening-sequential-colimits-descent-data)}}}
  formalizes descent data over sequential diagrams and the flattening lemma for sequential colimits, using descent data.
- {{{PR(1117,equivalences-sequential-comp)}}}
  formalizes the fact that equivalences are closed under sequential composition.
- {{{PR(1129,zigzags-sequential-diagrams)}}}
  formalizes zigzags of sequential diagrams, to the extent described in the thesis.
- {{{PR(1145,descent-pushouts)}}}
  refactors, extends and documents the descent property of pushouts.
- {{{PR(1148,characterization-families-pushouts)}}}
  characterizes families of functions and families of equivalences over pushouts, and the family of based identity types.
- {{{PR(1150,identity-systems-descent-pushouts)}}}
  formalizes the induction principle of identity types of pushouts, using descent data.
- =zigzag-construction-identity-types.patch=
  formalizes the zigzag construction and its partial proof of correctness, to the extent of the thesis.


* COMMENT Battle plan
- [X] $\Sigma$ -types over pushouts
  - [X] Flattening lemma
  - [X] Applications
- [X] Path spaces of pushouts
  - [X] Formalize Kraus, von Raumer
    - [X] Understand the proof
    - [X] Convert from relations to spans?
  - [X] Figure out how to encode the sequence construction
    - [X] Induction on naturals with Σ → Σ, pushing forward $(a_0 \rightsquigarrow_t a , a_0 \rightsquigarrow_{t+1} b) \mapsto (a_0 \rightsquigarrow_{t + 2} a , a_0 \rightsquigarrow_{t + 3} b)$
    - [X] Try encoding the construction with spans instead of relations
- [X] Descent stuff
- [X] Zig-zags of sequences induce equivalences on sequential colimits
  - [X] More general functoriality of sequential colimits - not just standard ones, but formulated with UP

- [ ] Link constructions in prose to their definitions
- [ ] Link formal statements to the formalization (fix a commit)
- [ ] =column sep={between origins}= in wide diagrams
- [ ] Check that there are no TODO's
- [ ] Properly cite agda-unimath, not just with a repo link
- [X] Describe attachments
- [X] +Open a PR for the zigzag construction+ included as an independent patch
- [ ] Check capitalization of autoref
- [X] Cite Brunerie's thesis for the flattening lemma
- [X] Cite Egbert's thesis for descent
- [ ] Try to move important ideas from remarks to section introductions
- [ ] Make the first part of Pushouts a subsection, add section intro

* Footnotes
[fn:2] Since the types $A$, $B$ and $S$ can all live in different universes, we also formally have to raise the identity type and the empty type to the smallest universe containing all of them. This is done in the formalization, but it is omitted from the thesis text. 

[fn:1] There is a slight inaccuracy caused by universe levels --- the type families $P_A$, $P_B$ and $P_S$ should be allowed to range over different universes $\UU$, $\UV$, $\UW$. This can be formally rectified by appropriately raising to the common universe $\UU \sqcup \UV \sqcup \UW$.

# Local Variables:
# org-latex-default-packages-alist: (("" "graphicx" t) ("" "wrapfig" nil) ("" "rotating" nil) ("normalem" "ulem" t) ("" "amsmath" t) ("" "amssymb" t) ("" "amsthm" t) ("" "capt-of" nil) ("rgb" "xcolor" nil) ("pdfa" "hyperref" nil) ("" "hyperxmp" nil) ("" "geometry" nil) ("nottoc" "tocbibind" nil) ("" "newpxtext" nil) ("" "unicode-math" nil) ("" "aliascnt") ("" "tikz-cd" t))
# org-latex-classes: (("report" "\\documentclass{report}" ("\\chapter{%s}" . "\\chapter*{%1$s}\\addcontentsline{toc}{chapter}{%1$s}") ("\\section{%s}" . "\\section*{%s}") ("\\subsection{%s}" . "\\subsection*{%s}") ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
# org-latex-reference-command: "\\autoref{%s}"
# org-latex-prefer-user-labels: t
# eval: (general-define-key :states 'normal :keymaps 'local "C-c C-f" #'hl-todo-next "C-c C-b" #'hl-todo-previous)
# eval: (general-define-key :states 'insert :keymaps 'local "C-c C-." #'latex-insert-block)
# End:
