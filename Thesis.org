#+TITLE: Formalization of Homotopy Pushouts in Homotopy Type Theory
#+AUTHOR: Vojtěch Štěpančík
#+KEYWORDS: synthetic homotopy theory, homotopy type theory, univalent foundations of mathematics, formalization, homotopy pushouts
#+DESCRIPTION: Homotopy pushouts can be constructed as higher inductive types in Homotopy Type Theory, and their properties
#+DESCRIPTION: may be explored using the logical framework and formalized in a proof assitant. This thesis focuses on
#+DESCRIPTION: the descent property, characterizing type families over pushouts, and the flattening lemma, characterizing
#+DESCRIPTION: the total spaces of such families. We then use the built machinery to provide the first fully formalized
#+DESCRIPTION: proof of Wärn's zigzag construction of identity types of pushouts as sequential colimits.

# Document settings
#+LATEX_COMPILER: lualatex
#+BIBLIOGRAPHY: ./bibliography.bib
#+CITE_EXPORT: biblatex iso-numeric,sorting=nyt,maxcitenames=3,backref=true,useprefix=true
#+LATEX_CLASS: report
#+LATEX_CLASS_OPTIONS: [12pt,a4paper,twoside,openright]
#+OPTIONS: title:nil toc:nil ':t

# Package options, derived partially from the thesis template
#+LATEX_HEADER: \geometry{margin=25mm,bindingoffset=14.2mm}
#+LATEX_HEADER: \let\openright=\cleardoublepage
#+LATEX_HEADER: \hypersetup{unicode,breaklinks=true,pdfapart=2,pdfaconformance=U}
#+LATEX_HEADER: \usetikzlibrary{decorations.pathmorphing}
#+LATEX_HEADER: \input{tex/pdfa.tex}

# Highlight overfull
#+LATEX_HEADER: \overfullrule=1mm

#+LATEX_HEADER: \newcommand{\TODO}[1][]{{\leavevmode\color{red}{\ifthenelse{\equal{#1}{}}{TODO}{#1}}}}

#+LATEX_HEADER: \newcommand{\ie}{i.e.~}
#+LATEX_HEADER: \newcommand{\eg}{e.g.~}

#+MACRO: AU [[https://unimath.github.io/agda-unimath/][agda-unimath]]
#+MACRO: AURepo [[https://github.com/UniMath/agda-unimath][repository]]

#+MACRO: PR (eval (let* ((full-name (concat $1 "-" $2 ".patch")) (path (concat "attachments/" full-name))) (if (file-exists-p path) (concat "=" full-name "= ([[https://github.com/UniMath/agda-unimath/pull/" $1 "][PR]])") (error (concat "File does not exist: " path)))))

# Syntax macros
#+LATEX_HEADER: \newcommand{\blank}{{-}}
#+LATEX_HEADER: \newcommand{\typeformer}[1]{\operatorname{#1}}
#+LATEX_HEADER: \newcommand{\constructor}[1]{\operatorname{#1}}
#+LATEX_HEADER: \newcommand{\defterm}[1]{\operatorname{#1}}
#+LATEX_HEADER: \newcommand{\term}[1]{\operatorname{#1}}
#+LATEX_HEADER: \DeclareMathOperator{\id}{id}
#+LATEX_HEADER: \newcommand{\defeq}{\mathrel{:=}}
#+LATEX_HEADER: \newcommand{\judeq}{\doteq}
#+LATEX_HEADER: \DeclareMathOperator{\comp}{\circ}

#+LATEX_HEADER: \DeclareMathOperator{\equivEq}{equiv-eq}

#+LATEX_HEADER: \DeclareMathOperator{\Id}{Id}
#+LATEX_HEADER: \DeclareMathOperator{\refl}{refl}
#+LATEX_HEADER: \DeclareMathOperator{\concat}{\bullet}
#+LATEX_HEADER: \DeclareMathOperator{\lunit}{lunit}
#+LATEX_HEADER: \DeclareMathOperator{\runit}{runit}
#+LATEX_HEADER: \DeclareMathOperator{\tr}{tr}
#+LATEX_HEADER: \DeclareMathOperator{\ap}{ap}
#+LATEX_HEADER: \DeclareMathOperator{\apd}{apd}

#+LATEX_HEADER: \DeclareMathOperator{\htpy}{\sim}
#+LATEX_HEADER: \DeclareMathOperator{\reflhtpy}{refl-htpy}
#+LATEX_HEADER: \DeclareMathOperator{\lwhisk}{\cdot_{l}}
#+LATEX_HEADER: \DeclareMathOperator{\rwhisk}{\cdot_{r}}

#+LATEX_HEADER: \newcommand{\N}{\mathbb{N}}

# Products
#+LATEX_HEADER: \DeclareMathOperator{\pr}{pr}

# Pushouts/coproducts
#+LATEX_HEADER: \DeclareMathOperator{\inl}{inl}
#+LATEX_HEADER: \DeclareMathOperator{\inr}{inr}
# #+LATEX_HEADER: \DeclareMathOperator{\spanDiag}{span-diagram}
#+LATEX_HEADER: \DeclareMathOperator{\cocone}{cocone}
#+LATEX_HEADER: \DeclareMathOperator{\coconeMap}{cocone-map}
#+LATEX_HEADER: \DeclareMathOperator{\depCocone}{dep-cocone}
#+LATEX_HEADER: \DeclareMathOperator{\depCoconeMap}{dep-cocone-map}
#+LATEX_HEADER: \DeclareMathOperator{\incl}{incl}

# Apparently unicode-math doesn't fix \Sigma in operator font,
# so use the "fixed" mupSigma command
# https://tex.stackexchange.com/questions/477662/fontspec-breaks-capital-greek-letters-in-declaremathoperator
#+LATEX_HEADER: \DeclareMathOperator{\uncurry}{ind-\mupSigma}
#+LATEX_HEADER: \DeclareMathOperator{\tot}{tot}

# Object macros
#+LATEX_HEADER: \newcommand{\POData}[2]{\typeformer{Pushout}\;#1\;#2}
#+LATEX_HEADER: \newcommand{\PO}[3]{#2 \sqcup_{#1} #3}
#+LATEX_HEADER: \renewcommand{\S}{\mathcal{S}}

# Universes
#+LATEX_HEADER: \newcommand{\UU}{\mathcal{U}}
#+LATEX_HEADER: \newcommand{\UV}{\mathcal{V}}
#+LATEX_HEADER: \newcommand{\UW}{\mathcal{W}}

# Descent data
#+LATEX_HEADER: \newcommand{\DD}{\term{DD}}
#+LATEX_HEADER: \newcommand{\ddFam}{\term{dd-fam}}
#+LATEX_HEADER: \newcommand{\correspDD}{\approx}

#+LATEX_HEADER: \newcommand{\sectDD}{\term{sect}}
#+LATEX_HEADER: \newcommand{\evreflidsystemDD}{\term{ev-refl-id-system-DD}}
#+LATEX_HEADER: \newcommand{\indidsystemDD}{\term{ind-Q}}

# Title page
#+begin_export latex
\def\Department{Department of Algebra}
\def\ThesisSupervisor{doctor Egbert Rijke}
\def\StudyProgramme{Mathematical Structures}
\def\StudyBranch{MSPN}
\def\YearSubmitted{2024}
\def\Dedication{
DEDICATION
}
\include{tex/title.tex}
\tableofcontents
#+end_export

# Theorem environments
#+begin_export latex
\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newaliascnt{lemma}{thm}
\newtheorem{lemma}[lemma]{Lemma}
\aliascntresetthe{lemma}
\newaliascnt{corol}{thm}
\newtheorem{corol}[corol]{Corollary}
\aliascntresetthe{corol}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newaliascnt{constr}{defn}
\newtheorem{constr}[constr]{Construction}
\aliascntresetthe{constr}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\def\thmautorefname{Theorem}
\def\lemmaautorefname{Lemma}
\def\corolautorefname{Corollary}
\def\defnautorefname{Definition}
\def\constructorautorefname{Construction}
#+end_export

* Introduction
:PROPERTIES:
:UNNUMBERED: t
:END:

 Homotopy Type Theory [cite//b:@UF13] is a logical framework built on Martin-Löf's type theory and the univalence axiom, which characterizes identity types of universes. It is inspired by the homotopy interpretation of dependent type theory, in which types are interpreted as spaces, elements of types as points in the spaces, and identifications of elements as paths between the points. Using proof assistants such as Agda [cite//b:@Agda], one can translate proofs in Homotopy Type Theory into programs in a programming language, engaging in an activity called "formalization". The validity of the constructions is verified by type-checking the programs.

 In this setting, one can define higher inductive types (HITs), by specifying both /point/ constructors, and higher /path/ constructors of the type. Homotopy pushouts are examples of HITs — given types $S, A, B$ and maps $f : S → A$, $g : S → B$, we define $\POData{f}{g}$ to be the higher inductive type with point constructors
 
 \begin{align*}
   \constructor{inl} &: A \to \POData{f}{g} \\
   \constructor{inr} &: B \to \POData{f}{g}
 \end{align*}
 
 and a path constructor
 
 \begin{align*}
   \constructor{glue} : (s : S) \to \constructor{inl}(f s) =_{\POData{f}{g}} \constructor{inr}(g s)
 \end{align*}

 This work focuses on homotopy pushouts \mdash specifically we provide an exposition and formalization of the descent property and flattening lemma, and use the built infrastructure to formally prove correctness of Wärn's zigzag construction of identity types of pushouts.
 
 \TODO[We build more infrastructure than strictly necessary for sequential colimits, since we anticipate it will be useful when formalizing applications of the zigzag construction. The formalized material comes from SvDR20, and as a byproduct we started an effort to collect pages for formalization of results from the literature. Even though it is not of mathematical nature, it is relevant to the formalization aspect, as it builds more documentation, makes the development accessible, and sets an example for beginning formalizers].
 
 \TODO[Mention that David writes "At the time of writing, no such formalisation has been carried out, but we believe it would be feasible and worthwhile". But it's in the categorical paper?]

* Homotopy Type Theory

#+NAME: lemma:is-equiv-concat
#+begin_lemma
\TODO[is-equiv concat].
#+end_lemma

#+NAME: lemma:tr-id-right
#+begin_lemma
\TODO[tr-id-right].
#+end_lemma

#+NAME: lemma:is-equiv-tr
#+begin_lemma
For every type $A$, type family $B : A \to \UU$, two elements $x, y : A$ and an identification $p : x = y$, the transport map $\tr_P p : B x \to B y$ is an equivalence.
#+end_lemma

#+begin_proof
\TODO
#+end_proof

#+NAME: lemma:compute-equiv-eq-ap
#+begin_lemma
\TODO[transport is equiv-eq(ap)].
#+end_lemma

#+NAME: lemma:fundamental-theorem-id
#+ATTR_LATEX: :options [Fundamental theorem of identity types]
#+begin_lemma
\TODO[Fundamental theorem of identity types]
#+end_lemma

#+NAME: lemma:3for2-equiv
#+ATTR_LATEX: :options [3-for-2 property of equivalences]
#+begin_lemma
Consider a commuting triangle of maps
#+begin_center
\begin{tikzcd}
  A \arrow[rr, "f"] \arrow[rd, "h"'] & & B \arrow[ld, "g"] \\
  & C.
\end{tikzcd}

If any two of the maps are equivalences, then so is the third.
#+end_center
#+end_lemma

#+begin_proof
\TODO
#+end_proof

#+NAME: lemma:distributive-pi-sigma
#+begin_lemma
\TODO[Distributivity of Pi over Sigma].
#+end_lemma

** Higher inductive types

\TODO[Does this even deserve a chapter? Or should it be assimilated into "Pushouts"?]

* Pushouts

\TODO[Decide how to treat and write "span" vs "span diagram"].

\TODO[We differentiate between the concept of a "span", which is an element on a structure with a fixed domain and codomain, and a "span diagram", which is a pair of types with a span between them. The distinction is important when looking at morphisms of these structures --- a morphism of spans is a map between the spanning types, equipped with two homotopies for the appropriate triangles, while a morphism of span diagrams is a natural transformation. The presented material does not formally require the notion of spans, so we introduce span diagrams as the primitive notion. A similar distinction may be done between "cocone structure" with a specific vertex, and a "cocone". It is not realized in the current work, but there are plans to make the change in the library].

#+begin_defn
A *span diagram* is a quintuple $(A, B, S, f, g)$, where $A : \UU$, $B : \UV$ and $S : \UW$ are types, and $f : S \to A$ and $g : S \to B$ are ordinary maps.

We call $A$, $B$ and $S$ the *domain*, *codomain*, and the *spanning type* of the span diagram, respectively.
#+end_defn

#+begin_remark
\TODO[This might be a bad idea:] In the prose, we will often write $\S$ or $\S \judeq (f, g)$ for a span diagram, implicitly introducing the relevant types as the domains and codomains of the maps $f$ and $g$, which will by convention be called $A$, $B$ and $S$ as in the definition. We hope to not cause confusion by this choice.
#+end_remark

#+begin_defn
Given a span diagram $\S \judeq (f, g)$ and a type $X : \UU$, a *cocone* under $\S$ on $X$ is a triple $(i, j, H)$, where $i : A \to X$ and $j : B \to X$ are ordinary maps, and $H$ is a homotopy witnessing that the square
#+begin_center
\begin{tikzcd}
  S \arrow[r, "g"] \arrow[d, "f"']
  & B \arrow[d, "j"] \\
  A \arrow[r, "i"']
  & X
\end{tikzcd}
#+end_center
commutes, \ie $H : i \comp f \htpy j \comp g$.

We write $\cocone(\S, X)$ for the type of cocones under $\S$ on $X$.
#+end_defn

\TODO[To define what a "colimiting cocone" is in type theory, we derive inspiration from the categorical description as a classifier of cocones (phrasing?): a cocone $c$ on $X$ is a pushout if maps $X \to Y$ are in bijection with cocones on $Y$. There is a natural construction for extending a cocone $c$ on $X$ by a map $X \to Y$ to a cocone on $Y$, and we say that $c$ is a pushout of $\S$ exactly when this extension map is an equivalence $(X \to Y) \simeq \cocone(\S, Y)$].

#+begin_constr
Given a cocone $c \judeq (i, j, H) : \cocone(\S, X)$ and a type $Y : \UV$ we construct a map
\begin{equation*}
  \coconeMap_c^Y : (X \to Y) \to \cocone(\S, Y)
\end{equation*}
which sends $h$ to $(h \comp i, h \comp j, h \lwhisk H)$.

We may omit the upper index $Y$ or the lower index $c$, or both, if the appropriate value is clear from context.
#+end_constr

#+begin_defn
A cocone $c$ under $\S$ on $X$ satisfies the *universal property of pushouts* if for all $Y : \UV$, the map $\coconeMap_c^Y$ is an equivalence.

A cocone satisfying the universal property of pushouts is called a *pushout*. We will sometimes abuse notation and call just the type $X$ the pushout.
#+end_defn

\TODO[The universal property characterizes simple maps out of the colimit. In dependent type theory, we can also ask about characterizations of /dependent/ maps out of the colimit. To that end we introduce dependent cocones and the dependent universal property].

#+begin_defn
Consider a cocone $c \judeq (i, j, H) : \cocone(\S, X)$ and a type family $P : X \to \UV$. A *dependent cocone* over $c$ on $P$ is a triple $(i', j', H')$, where $i' : (a : A) \to P(i a)$ and $j' : (b : B) \to P(j b)$ are dependent maps over $i$ and $j$, respectively, and $H$ is a \TODO[dependent homotopy] between $i' \comp f$ and $j' \comp g$, \ie a family of identifications
\begin{alignat*}{2}
  H &:&& (s : S) \to i'(f s) =_{H s} j'(g s) \\
    &\judeq\;&& (s : S) \to \tr_P(H s) (i'(f s)) = j'(g s).
\end{alignat*}

We write $\depCocone(c, P)$ for the type of dependent cocones over $c$ on $P$.
#+end_defn

#+begin_constr
Given a cocone $c \judeq (i, j, H) : \cocone(\S, X)$ and a type family $P : X \to \UV$, define a map
\begin{equation*}
  \depCoconeMap_c^P : ((x : X) \to P(x)) \to \depCocone(c, P)
\end{equation*}
which sends $h$ to $(h \comp i, h \comp j, \lambda s \to \apd_h(H s))$.

We may omit the indices $c$ or $P$ if they are clear from context.
#+end_constr

#+begin_defn
A cocone $c : \cocone(\S, X)$ satisfies the *dependent universal property of pushouts* if for all $P : X \to \UV$, the map $\depCoconeMap_c^P$ is an equivalence.
#+end_defn

Note that the dependent universal property isn't a property of dependent cocones, but rather a property of cocones and their extensions by dependent functions.

\TODO[We don't introduce a new name for cocones satisfying the dependent universal property, because curiously enough, the two properties are equivalent, as claimed by the following lemma.]

#+name: lemma:dup-iff-up-pushout
#+begin_lemma
A cocone $c : \cocone(\S, X)$ satisfies the universal property of pushouts if and only if it satisfies the dependent universal property of pushouts.
#+end_lemma

#+begin_proof
\TODO[Figure out how to skip this proof].
#+end_proof

#+begin_remark
This equivalence of a non-dependent and dependent universal property is a more general phenomenon. In homotopy type theory, there are often multiple ways of describing universal properties. These expressions usually involve a base sort of objects and dependent objects, which can be equipped with some structure functorial in an appropriate notion of maps and dependent maps.

The functorial action
\begin{equation*}
  \term{fmap} : (X \to Y) \to \term{structure}(X) \to \term{structure}(Y)
\end{equation*}
can have its arguments rearranged so that for every structured object $(X, s)$ and a plain object $Y$, we get an "evaluation" map
\begin{equation*}
  \term{ev-map}_{(X, s)}^Y : (X \to Y) \to \term{structure}(Y).
\end{equation*}
In the dependent case, we get a map
\begin{equation*}
  \term{dep-ev-map}_{(X, s)}^P : ((x : X) \to P(x)) \to \term{dep-structure}((X, s), P).
\end{equation*}

When talking about pushouts, we take the base objects to be types, dependent objects to be type families, and maps and dependent maps to be ordinary functions and dependent functions. The functorial structure on a type $X$ is the structure of a cocone on $X$ under a fixed span $\S$, and the dependent structure on a type family $P : X \to \UV$ over a cocone $c$ on $X$ is the structure of a dependent cocone on $P$ over $c$. The evaluation maps are $\coconeMap$ and $\depCoconeMap$, respectively.

With these general definitions in place, consider a structured object $(X, s)$; we may ask for the following properties to be satisfied:
- Universal property: For every object $Y$, $\term{ev-map}_{(X, s)}^Y$ is an equivalence
- Dependent universal property: For every dependent object $P$, $\term{dep-ev-map}_{(X, s)}^P$ is an equivalence
- Recursion principle and uniqueness: For every object $Y$, $\term{ev-map}_{(X, s)}^Y$ has a unique section
- Induction principle: For every dependent object $P$, $\term{dep-ev-map}_{(X, s)}^P$ has a section

The universal properties correspond to a notion of initiality: the evaluation map is an equivalence if and only if it has contractible fibers, \ie for all structured objects $(X, s)$ and $(Y, t)$, there is a unique map $h : X \to Y$ such that $\term{ev-map}_{(X, s)}^Y h = t$. The condition asks for $h$ to preserve the structure. In other words, the universal property says that $(X, s)$ is the initial object in a hypothetical "category" of structured objects and homomorphisms.

It was first shown by [cite/t:@AGS12] that the four properties are equivalent for a class of examples, where we have objects, type families, ordinary functions, dependent functions, and the (dependent) structures are (fibered) algebras for a polynomial functor. The result was later extended by
[cite/t:@Soj14] to include (fibered) algebras for W-suspensions, a higher inductive analogue of W-types. The structure of a (dependent) cocone can be expressed as a (fibered) algebra of a specific W-suspension, so this result is applicable to [[lemma:dup-iff-up-pushout]], but it hasn't been formalized in the library.

We will rely on informal understanding of this principle when discussing options for formalization of a universal property of the identity types of pushouts in [[#sec:identity-systems]].
#+end_remark

** Descent property

The study of type theoretic descent describes how type families over a colimit and related concepts, such as fiberwise maps or sections, arise as local data with gluing conditions \TODO[source?]. It has been studied to some extent by Rijke in [cite//b:@Rij19] and [cite//b:@Rij22Pre].

The universal property of pushouts characterizes maps out of a pushout to any type in any universe, so in particular maps where the codomain itself is a universe: a type family $P : X \to \UU$ corresponds to a cocone $(P_A, P_B, H)$ where $P_A : A \to \UU$, $P_B : B \to \UU$ are type families, and $H$ is a homotopy in the universe $H : (s : S) \to P_A(f s) = P_B(g s)$. Since identifications in universes are characterized by equivalences via the univalence axiom, we arrive at the definition of descent data:

#+begin_defn
Given a span diagram $\S \defeq (f, g)$, we call *descent data* over $\S$ a triple $(P_A, P_B, P_S)$ consisting of type families
\begin{align*}
  P_A &: A \to \UU \\
  P_B &: B \to \UU \\
\intertext{and a fiberwise equivalence}
  P_S &: (s : S) \to P_A(f s) \simeq P_B(g s).
\end{align*}

We use the notation $\DD(\S)$ for the type of descent data over a span diagram $\S$.
#+end_defn

It may not be immediately clear why "descent data" is an appropriate name for this concept, because there is no apparent downward motion. Traditionally, descent is studied in the context of a collection of objects $X_i$ covering a single object $X$, and local structure on the individual $X_i$'s descending onto $X$, collecting into a global structure, given that the pieces are appropriately compatible on any "overlaps". A pushout $X$ of $\S$ is covered by $A$ and $B$, and the overlaps are encoded in $f$ and $g$. Structure on $A$ and $B$, expressed as type families $P_A$ and $P_B$, "descends" to a structure on $X$ (a type family over $X$). Two elements "overlap" in $X$ if there is an identification between them coming from $S$, and the gluing/compatibility condition exactly requires the local structure of $P_A$ and $P_B$ to agree on such elements, i.e. asks for an equivalence $P_A(f s) \simeq P_B(g s)$.

The first task is to establish an equivalence between type families over a pushout and descent data over its defining span. A map from type families to descent data is easy enough to construct: 

#+begin_constr
Given a cocone $c \judeq (i, j, H)$ on $X$, construct a map
\begin{displaymath}
  \ddFam_c : (X \to \UU) \to \DD(\S)
\end{displaymath}
which sends a type family $P : X \to \UU$ to the descent data $(P_A, P_B, P_S)$ obtained by precomposing
\begin{alignat*}{3}
  P_A &:= (\lambda a \to P(i a)) &&: A \to \UU \\
  P_B &:= (\lambda b \to P(j b)) &&: B \to \UU \\
\intertext{and transporting in $P$}
  P_S &:= (\lambda s \to \tr_P (H s)) &\quad&: (s : S) \to P (i (f s)) \simeq P (j (g s)).
\end{alignat*}

Note that $\tr_P (H s)$ is an equivalence by [[lemma:is-equiv-tr]].
#+end_constr

To show that $\ddFam_c$ is an equivalence, we employ a common technique for proving equivalences: construct a commuting diagram involving $\ddFam_c$ in which all other maps are equivalences. By repeated applications of [[lemma:3for2-equiv]], it follows that $\ddFam_c$ is an equivalence.

#+NAME: thm:descent-property
#+ATTR_LATEX: :options [Descent property]
#+begin_thm
Consider a span diagram $\S \defeq (f, g)$ and its pushout cocone $c$ on $X$. Then the map $\ddFam_c$ is an equivalence $(X \to \UU) \simeq \DD(\S)$.
#+end_thm

#+begin_proof
There is a triangle of maps
#+begin_center
\begin{tikzcd}
  (X \to \UU) \arrow[rr, "\coconeMap_c", "\simeq"'] \arrow[dr, "\ddFam_c"']
  && \cocone(\S, \UU) \arrow[dl, "\tot(\tot(\lambda s \to \equivEq))", "\simeq"'] \\
  & \DD(\S).
\end{tikzcd}
#+end_center

The top map is an equivalence by assumption, since $c$ is a pushout. The right map is an equivalence, because the map $\tot(h)$ is an equivalence if and only if $h$ is a fiberwise equivalence, and $\equivEq$ is an equivalence by the univalence axiom \TODO[ref]. By [[lemma:3for2-equiv]], it suffices to show that the triangle commutes to prove that $\ddFam_c$ is an equivalence.

By chasing a type family $P$ along the diagram, we see that we need to provide an identification
\[
  (P \comp i, P \comp j, \lambda s \to \tr_P(H s)) = (P \comp i, P \comp j, \lambda s \to \equivEq(\ap_P(H s))).
\]

The first two components are identical. To identify the third component, we invoke function extensionality \TODO[ref]; then it suffices to prove that for all $s : S$, there is an identification of equivalences
\[
  \tr_P(H s) = \equivEq(\ap_P(H s)),
\]
which is always the case by [[lemma:compute-equiv-eq-ap]] applied to the identification\linebreak ${H s : i(f s) = j(g s)}$.
#+end_proof

A corollary of $\ddFam_c$ being an equivalence is that it has contractible fibers, \ie for any descent data $(P_A, P_B, P_S)$ there is a unique type family $P$ such that $\ddFam_c(P) = (P_A, P_B, P_S)$. We proceed to work on characterization of identifications of descent data to get a more pleasant statement of this theorem. \TODO[phrasing]

#+begin_defn
Consider a span diagram $\S \judeq (f, g)$, and two descent data $(P_A, P_B, P_S)$ and $(Q_A, Q_B, Q_S)$ over it. A *morphism* of descent data between them is a pair of fiberwise maps
\begin{align*}
  h_A &: (a : A) → P_A a → Q_A a\\
  h_B &: (b : B) → P_B b → Q_B b
\end{align*}
equipped with a family of homotopies $h_S$ indexed by $s : S$ making
#+begin_center
\begin{tikzcd}
  P_A(f s) \arrow[r, "h_A(f s)"] \arrow[d, "P_S s"'] & Q_A(f s) \arrow[d, "Q_S s"] \\
  P_B(g s) \arrow[r, "h_B(g s)"'] & Q_B(g s)
\end{tikzcd}
#+end_center
commute.

We write $(h_A, h_B, h_S) : (P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)$.
#+end_defn

Analogously, we define equivalences of descent data.

#+begin_defn
Consider a span diagram $\S \judeq (f, g)$, and two descent data $(P_A, P_B, P_S)$ and $(Q_A, Q_B, Q_S)$ over it. An *equivalence* of descent data between them is a pair of fiberwise equivalences
\begin{align*}
  e_A &: (a : A) → P_A a \simeq Q_A a\\
  e_B &: (b : B) → P_B b \simeq Q_B b
\end{align*}
equipped with a family of homotopies $e_S$ indexed by $s : S$ making
#+begin_center
\begin{tikzcd}
  P_A(f s) \arrow[r, "e_A(f s)"] \arrow[d, "P_S s"'] & Q_A(f s) \arrow[d, "Q_S s"] \\
  P_B(g s) \arrow[r, "e_B(g s)"'] & Q_B(g s)
\end{tikzcd}
#+end_center
commute.

We write $(e_A, e_B, e_S) : (P_A, P_B, P_S) \simeq (Q_A, Q_B, Q_S)$.
#+end_defn

#+begin_remark
\TODO[equivalences with coherence vs hom with is-equiv].
#+end_remark

#+begin_lemma
\TODO[Equivalences characterize identifications]
#+end_lemma

#+attr_latex: [Uniqueness of descent data]
#+begin_thm
Consider a span diagram $\S \judeq (f, g)$ and a pushout cocone $c \judeq (i, j, H)$ on $X$. Then for any descent data $(P_A, P_B, P_S)$ over $\S$, the type of type families $P : X \to \UU$ equipped with equivalences
\begin{align*}
  e_A : (a : A) \to P(i a) \simeq P_A(a) \\
  e_B : (b : B) \to P(j b) \simeq P_B(b)
\end{align*}
and a family of coherences $e_s$
#+begin_center
\begin{tikzcd}
  P(i (f s)) \arrow[r, "e_A(f s)"] \arrow[d, "\tr_P(H s)"'] & P_A(f s) \arrow[d, "P_S s"] \\
  P(j (g s)) \arrow[r, "e_B(g s)"'] & P_B(g s)
\end{tikzcd}
#+end_center
indexed by $s : S$, is contractible.
#+end_thm

#+begin_proof
The type of quadruples $(P, e_A, e_B, e_S)$ is exactly the type of type families $P : X \to \UU$ equipped with an equivalence $(e_A, e_B, e_S) : \ddFam_c(P) \simeq (P_A, P_B, P_S)$. Equivalences of descent data characterize identifications of descent data, so the second part corresponds to an identification $\ddFam_c(P) = (P_A, P_B, P_S)$. Since contractibility is preserved by equivalences, it suffices to show that the type $\Sigma (P : X \to \UU). (\ddFam_c(P) = (P_A, P_B, P_S))$ is contractible. But that is exactly the type of fibers of $\ddFam_c$ over $(P_A, P_B, P_S)$, which are contractible on account of $\ddFam_c$ being an equivalence.
#+end_proof

When relating concepts from the world of type families with concepts from the world of descent data, it can be beneficial to be parametric over the data of a type family $P$ and its "corresponding descent data", meaning some descent data $(P_A, P_B, P_S)$ which is equivalent to the descent data induced by $P$. Of course, by the descent theorem this data is completely determined by either $P$ or $(P_A, P_B, P_S)$ up to identification, but this level of generality allows users to provide their own equivalences for potentially better computational properties. We introduce a shorthand notation.

#+begin_defn
Given a span $\S$ and a cocone $c$ on $X$, we define the type of *families with descent data* to be the type of triples $(P, P', e)$ consisting of a type family $P : X \to \UU$, descent data $P' : \DD(\S)$, and an equivalence of descent data $e : \ddFam_c(P) \simeq P'$.

We write $e : P \correspDD P'$ for a family $P$ with descent data $P'$ related by an equivalence $e$.
#+end_defn

#+begin_remark
\TODO[Note that we don't require $c$ to be a pushout. In subsequent development, and in the formalization, we often parameterize constructions by a family with descent data, which incentivizes general constructions applicable to non-pushout cocones.]
#+end_remark

#+begin_remark
\TODO[Move this to flattening?] The concept of a family with descent data has a direction: the equivalence relates $\ddFam_c(P)$ on the left with $P'$ on the right. It lends itself well to characterizations of concrete type families, where $P$ has a specific shape, and we want to recover the shape of corresponding descent data by computing $P(i a)$'s and $P(j b)$'s. However there are applications where the converse direction is more suitable. In those cases we write $e : P' \correspDD P$ for descent data $P'$, a type family $P$, and an equivalence of descent data $e : P' \simeq \ddFam(P)$.
#+end_remark

#+begin_constr
\TODO[$(I_A, I_B, I_S)$].
Given a cocone
#+begin_center
\begin{tikzcd}
  S \arrow[d, "f"'] \arrow[r, "g"] & B \arrow[d, "j"] \\
  A \arrow[r, "i"'] \arrow[ur, phantom, "H"] & X
\end{tikzcd}
#+end_center
and a point $x_0 : X$, construct the descent data $(I_A, I_B, I_S)$ as \TODO[typesetting]
\begin{align*}
  I_A &:= (\lambda a \to x = (i a)) &&: A \to \UU \\
  I_B &:= (\lambda b \to x = (j b)) &&: B \to \UU \\
  I_S &:= (\lambda s, p \to p \concat (H s)) &&: (s : S) \to I_A(f s) \simeq I_B(g s).
\end{align*}

The concatenation operation is an equivalence by [[lemma:is-equiv-concat]].
#+end_constr

#+begin_remark
Note that the basepoint $x_0$ is not mentioned in the notation $(I_A, I_B, I_S)$. \TODO[Whenever we use it, it should be clear from the context].
#+end_remark

#+name: lemma:fam-with-dd-id
#+begin_lemma
Given a cocone and a basepoint $x_0 : X$ as above, the type family $\Id(x_0) : X \to \UU$ is characterized by the descent data $(I_A, I_B, I_S)$. Explicitly, there are equivalences
\begin{align*}
  e_A &: (a : A) \to (x_0 = (i a)) \simeq I_A(a) \\
  e_B &: (b : B) \to (x_0 = (j b)) \simeq I_B(b)
\end{align*}
and a coherence $e_S$
#+begin_center
\begin{tikzcd}
  (x_0 = (i (f s)))
  \arrow[r, "e_A(f s)"]
  \arrow[d, "\tr_{\Id(x_0)} (H s)"']
  & I_A(f s)
  \arrow[d, "I_S s"] \\
  (x_0 = (j (g s)))
  \arrow[r, "e_B(g s)"']
  & I_B(g s)
\end{tikzcd}
#+end_center
#+end_lemma

#+begin_proof
By definition, $I_A(a) \judeq (x_0 = (i a))$ and $I_B(b) \judeq (x_0 = (j b))$, so we may choose the identity equivalence for $e_A$ and $e_B$. Then the coherence datum amounts to showing that $\tr_{\Id(x_0)}(H s, p) = p \concat (H s)$, which is [[lemma:tr-id-right]].
#+end_proof

#+begin_lemma
\TODO[Given $P \approx (P_A, P_B, P_S)$ and $Q \approx (Q_A, Q_B, Q_S)$, fiberwise maps correspond to homs of descent data].
#+end_lemma

#+begin_defn
For any two morphisms $(h_A, h_B, h_S)$ and $(k_A, k_B, k_S)$ between $(P_A, P_B, P_S)$ and $(Q_A, Q_B, Q_S)$, we define the type of *homotopies* to be the type of triples $(H_A, H_B, H_S)$ consisting of fiberwise homotopies
\begin{align*}
  H_A &: (a : A) \to h_A(a) \htpy k_A(a) \\
  H_B &: (b : B) \to h_B(b) \htpy h_B(b)
\end{align*}
and a coherence datum $H_S$ indexed by $s : S$, asserting that the squares of homotopies
#+begin_center
\begin{tikzcd}[column sep=6em]
  h_B(g s) \comp P_S(s)
  \arrow[r, squiggly, "H_B(g s) \rwhisk P_S(s)"]
  \arrow[d, squiggly, "h_S(s)"']
  & k_B(g s) \comp P_S(s)
  \arrow[d, squiggly, "k_S(s)"] \\
  Q_S(s) \comp h_A(f s)
  \arrow[r, squiggly, "Q_S(s) \lwhisk H_A(f s)"'] & Q_S(s) \comp k_A(f s)
\end{tikzcd}
#+end_center
commute.

We write $(H_A, H_B, H_S) : (h_A, h_B, h_S) \htpy (k_A, k_B, k_S)$.
#+end_defn

#+begin_remark
The coherence can be seen as a filler of the shape one gets by gluing the squares $h_S$ and $k_S$ along the common vertical maps, as in
#+begin_center
\begin{tikzcd}[row sep=5em]
  P_A(f s)
  \arrow[r, bend left, "k_A(f s)"]
  \arrow[r, bend right, "h_A(f s)"']
  \arrow[d, "P_S(s)"']
  & Q_A(f s) \arrow[d, "Q_S(s)"] \\
  P_B(g s)
  \arrow[r, bend left, "k_B(g s)"]
  \arrow[r, bend right, "h_B(g s)"']
  & Q_B(g s).
\end{tikzcd}
#+end_center

The front square is $h_S$, the back square is $k_S$, the top face is $H_A$ and the bottom face is $H_B$. The coherence $H_S$ expresses that going along the front square and then the top face is homotopic to first going along the bottom face and then the back square.
#+end_remark

#+begin_lemma
The type of homotopies of morphisms of descent data characterizes the identity type of morphisms of descent data. In other words, given two morphisms of descent data $h, k : (P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)$, there is an equivalence
\begin{equation*}
  \defterm{extensionality-hom-DD} : (h = k) \simeq (h \htpy k).
\end{equation*}
#+end_lemma

#+begin_proof
We define the underlying map by path induction. Assume $h \doteq k$ are identified by $\refl$. The identity homotopy $h \htpy k$ is defined as \TODO[typesetting]
\begin{align*}
  H_A &:= (\lambda a \to \reflhtpy) &&: (a : A) \to h_A \htpy h_A \\
  H_B &:= (\lambda b \to \reflhtpy) &&: (b : B) \to h_B \htpy h_B \\
  H_S &:= (\lambda s \to \runit)    &&: (s : S) \to h_S(s) \concat refl = h_S(s).
\end{align*}

To show that it is an equivalence, we may appeal to [[lemma:fundamental-theorem-id]]. It then suffices to show that the type $\Sigma (k : P \to Q). (h \htpy k)$ is contractible.
#+end_proof

#+begin_corol
\TODO[Uniqueness of a fiberwise map with nice computational properties].
#+end_corol

#+begin_lemma
\TODO[Fiberwise equivalences correspond to equivs of descent data].
#+end_lemma

#+begin_defn
\TODO[Sections of descent data].
#+end_defn

#+begin_lemma
\TODO[Sections of descent data correspond to sections of type families].
#+end_lemma

\TODO[Summary, lead onto flattening].

|                    | Families                       | Descent data                             |
|--------------------+--------------------------------+------------------------------------------|
| Objects            | $P : X \to \UU$                | $(P_A, P_B, P_S)$                        |
| Morphisms          | $(x : X) \to P(x) \to Q(x)$    | $(P_A, P_B, P_S) \to (Q_A, Q_B, Q_S)$    |
| Equivalences       | $(x : X) \to P(x) \simeq Q(x)$ | $(P_A, P_B, P_S) \simeq (Q_A, Q_B, Q_S)$ |
| Sections           | $(x : X) \to P(x)$             | $\sectDD(P_A, P_B, P_S)$                 |
| Identity types     | $\lambda x \to (x_0 = x)$      | $(I_A, I_B, I_S)$                        |
| Identity induction | Identity systems               | ???                                      |


** Flattening lemma

\TODO[The flattening lemma for pushouts states that pushouts commute with dependent pair types --- a total space over a pushout is a pushout of total spaces].

\TODO[Outline proof - first for just $P$, then with descent data using a cube].

#+name: lemma:is-pushout-bottom-ff-is-pushout-top
#+begin_lemma
\TODO[In a cube where vertical maps are equivalences, the bottom square is a pushout iff the top square is a pushout].
#+end_lemma

#+begin_proof
\TODO[Probably omitted].
#+end_proof

#+begin_constr
Given a cocone
#+begin_center
\begin{tikzcd}
  S \arrow[d, "f"'] \arrow[r, "g"] & B \arrow[d, "j"] \\
  A \arrow[r, "i"'] \arrow[ur, phantom, "H"] & X
\end{tikzcd}
#+end_center
and a family with descent data $(P_A, P_B, P_S) \correspDD P$, construct the *total cocone*
#+begin_center
\begin{tikzcd}[column sep=huge]
  \Sigma S (P_A \comp f)
  \arrow[d, "\tot_f(\id)"']
  \arrow[r, "\tot_g(P_S)"]
  & \Sigma B P_B
  \arrow[d, "\tot_j(e_B)"] \\
  \Sigma A P_A
  \arrow[r, "\tot_i(e_A)"']
  \arrow[ur, phantom, "H'"]
  & \Sigma X P,
\end{tikzcd}
#+end_center
where the coherence $H'$ at $s : S$, $p : P_A(f s)$ is given by
\begin{align*}
  H'_1 &:= H(s) &&: (i (f s)) = (j (g s)) \\
  H'_2 &:= e_S(s, p)^{-1} &&: \tr_P(H(s), e_A(s, p)) = e_B(P_S(s, p)).
\end{align*}
\TODO[An identification in $\Sigma$ is a $\Sigma$ of identifications].
#+end_constr

#+name: lemma:flattening-base
#+begin_lemma
Given a pushout square
#+begin_center
\begin{tikzcd}
  S \arrow[d, "f"'] \arrow[r, "g"] \arrow[dr, phantom, "\ulcorner", at end] & B \arrow[d, "j"] \\
  A \arrow[r, "i"'] \arrow[ur, phantom, "H"] & X
\end{tikzcd}
#+end_center
and a type family $P : X \to \UU$, the total cocone of $(P \comp i, P \comp j, \tr_P(H)) \correspDD P$ is a pushout.
#+end_lemma

#+begin_proof
\TODO
#+end_proof

#+name: lemma:flattening-cube
#+begin_lemma
Given a type family $P : X \to \UU$ with corresponding descent data $(P_A, P_B, P_S)$, there is a commuting cube
#+begin_center
\begin{tikzcd}[column sep=huge, row sep=huge]
  & \Sigma S (P_A \comp f)
  \arrow[dl, "\tot_f(\id)"']
  \arrow[d, "\tot(e_A \comp f)"]
  \arrow[dr, "\tot_g(P_S)"]
  & \\
  \Sigma A P_A
  \arrow[d, "\tot(e_A)"']
  & \Sigma S (P \comp i \comp f)
  \arrow[dl, "\tot_f(\id)"', very near start]
  \arrow[dr, "\tot_g(\tr_P(H))", very near start]
  & \Sigma B P_B
  \arrow[dl, crossing over, "\tot_j(e_B)", very near end]
  \arrow[d, "\tot(e_B)"] \\
  \Sigma A (P \comp i)
  \arrow[dr, "\tot_i(\id)"']
  & \Sigma X P
  \arrow[from=ul, crossing over, "\tot_i(e_A)"', very near end]
  \arrow[d, "\id"]
  & \Sigma B (P \comp j)
  \arrow[dl, "\tot_j(\id)"] \\
  & \Sigma X P
\end{tikzcd}
#+end_center
where the top square is the coherence of the total cocone of $(P_A, P_B, P_S) \correspDD P$, and the bottom square is the coherence of the total cocone of $(P \comp i, P \comp j, \tr_P(H)) \correspDD P$.
#+end_lemma

#+begin_proof
\TODO
#+end_proof

#+name: lemma:flattening-lemma
#+begin_lemma
Given a pushout
#+begin_center
\begin{tikzcd}
  S \arrow[d, "f"'] \arrow[r, "g"] & B \arrow[d, "j"] \\
  A \arrow[r, "i"'] \arrow[ur, phantom, "H"] & X
\end{tikzcd}
#+end_center
and a family with descent data $(P_A, P_B, P_S) \correspDD P$, the total cocone is a pushout.
#+end_lemma

#+begin_proof
\TODO[By [[lemma:flattening-base]], the bottom square in [[lemma:flattening-cube]] is a pushout, and all of $e_A(a)$, $e_A(f s)$, $e_B(b)$ and $\id$ are equivalences, so it follows by [[lemma:is-pushout-bottom-ff-is-pushout-top]] that the top square is a pushout].
#+end_proof

** Identity systems
:PROPERTIES:
:CUSTOM_ID: sec:identity-systems
:END:

We define a universal property of descent data for the identity types of pushouts, which allows their alternative characterizations. The property is analogous to a pointed type family being an identity system \TODO[Define pointed-type-family identity systems somewhere]; in fact, we show that a type family over a pushout is an identity system if and only if the corresponding descent data satisfies this universal property.

Given descent data $(P_A, P_B, P_S)$ for a span diagram $\S := (f, g)$ and a point $p_0 : P_A a_0$ over a basepoint $a_0 : A$, we would like to mirror the definition of identity systems. A naïve translation would lead us to define dependent descent data and its sections. We choose to sidestep building that technical infrastructure.

By the descent property, there is a unique type family $P : X → \UU$ corresponding to $(P_A, P_B, P_S)$. Observe that the type of dependent type families $(x : X) → P x → \UU$ is equivalent to the uncurried form $(\Sigma X P) → \UU$. By the flattening lemma, the total space $\Sigma X P$ is the pushout of the span diagram of total spaces
#+begin_center
\begin{tikzcd}[column sep=large]
  \Sigma A P_A
  & \Sigma S (P_A \circ f)
  \arrow[l, "\tot_f \id"']
  \arrow[r, "\tot_g P_S"]
  & \Sigma B P_B
\end{tikzcd}
#+end_center

so, again by the descent property, descent data over it correspond to type families over `\Sigma X P`. Hence we can talk about descent data $(R_{\Sigma A}, R_{\Sigma B}, R_{\Sigma S})$ over the total span diagram instead of dependent descent data.

#+begin_constr
Assume a span diagram $\S := (f, g)$, descent data $(P_A, P_B, P_S)$ over it, a basepoint $a_0 : A$ and a point $p_0 : P_A(a_0)$. For any descent data $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ over the total span \TODO[Call it $\Sigma \S P$?], define the map
\begin{align*}
  \evreflidsystemDD : \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S}) &\to Q_{\Sigma A}(a_0, p_0) \\
  (t_A, t_B, t_S) &\mapsto t_A (a_0, p_0).
\end{align*}
#+end_constr

#+begin_defn
Descent data $(P_A, P_B, P_S)$ equipped with a point $p_0 : P_A(a_0)$ satisfies the *induction principle of identity systems* if for all $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$, the map $\evreflidsystemDD$ has a section, in the sense that there is a converse map
\begin{equation*}
  \indidsystemDD : Q_{\Sigma A}(a_0, p_0) \to \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})
\end{equation*}
and a path
#+name: eq:is-section-ind-id-system-DD
\begin{equation}
  (\indidsystemDD q_0)_A (a_0, p_0) = q_0
\end{equation}
for all $q_0 : Q_{\Sigma A}(a_0, p_0)$.

Such descent data is called an *identity system* at $p_0$.
#+end_defn

\TODO[Mind the unfortunate
terminology clash between "sections of descent data" and "sections of a map"].

#+begin_remark
Note that this development is biased towards the left \mdash we pick a basepoint in the domain $a_0 : A$, a point in the left type family $p_0 : P_A a_0$, and the evaluation map evaluates the left map of the section. By symmetry of pushouts we could just as well work with the points $b_0 : B$, $p_0 : P_B b_0$, and the evaluation map evaluating the right map of the section.
#+end_remark

#+begin_remark
By showing that the canonical descent data for identity types is an identity system, we recover the "induction principle for pushout equality" stated and proved by [cite/t/f:@KvR19] \TODO[figure out proper citation incantation].

First observe that the type of sections of $\evreflidsystemDD$ is
\begin{align*}
  \Sigma \;
  &(\indidsystemDD : (Q_{\Sigma A} (a_0, p_0)) \to \sectDD (Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})) \\
  &((q_0 : Q_{\Sigma A} (a_0, p_0)) \to (\indidsystemDD q_0)_A (a_0, p_0) = q_0),
\end{align*}
which is equivalent to the type
\begin{align}
  &(q_0 : Q_{\Sigma A} (a_0, p_0)) \to \nonumber\\
  &\Sigma \;
  (\indidsystemDD : \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})) \label{kvr:section} \\
  &\quad(\indidsystemDD_A (a_0, p_0) = q_0) \label{kvr:issection}
\end{align}
by [[lemma:distributive-pi-sigma]].

Then the induction terms from [cite//b:@KvR19] (with names changed to fit our naming scheme)
\begin{align*}
  \term{ind_A} &: (a : A) (r : i(a_0) = i(a)) → Q_{\Sigma A} (a, r) \\
  \term{ind_B} &: (b : B) (r : i(a_0) = j(b)) → Q_{\Sigma B} (b, r)
\end{align*}
are the first and second components of the section \ref{kvr:section} induced by $q_0$, and their computation rules
\begin{align*}
  &\term{ind_A} (a_0, \refl) = q_0 \\
  &Q_{\Sigma S} (s, r, \term{ind_A} (f s, r)) = \term{ind_B} (g s, r \concat H s)
\end{align*}
arise as the second component \ref{kvr:issection}, and the coherence condition of \ref{kvr:section}, respectively.
#+end_remark

We first show a result relating identity systems stated as pointed type families and identity systems stated as pointed descent data.

#+name: lemma:square-id-system-id-system-DD
#+begin_lemma
\TODO[Expand on the role of implicit cocones in this definition, elaborate some types].
Consider a type family with corresponding descent data $P \correspDD (P_A, P_B, P_S)$ and a point $p_0 : P_A(a_0)$. Then for any type family with corresponding descent data $Q_{\Sigma} \correspDD (Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ there is a commuting diagram
#+begin_equation
\begin{tikzcd}[row sep=large, column sep=small]
  ((x : X) (p : P x) \to Q_{\Sigma} (x , p))
  \arrow[r, "\simeq"]
  \arrow[d, "\term{ev-refl-id-system}"']
  & ((u : \Sigma X P) \to Q_{\Sigma} u)
  \arrow[r, "\simeq"]
  & \term{sect}(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})
  \arrow[d, "\evreflidsystemDD"] \\
  Q_{\Sigma}(i a_0, p_0')
  \arrow[rr, "e^Q_A(a_0{,} p_0)"', "\simeq"]
  &
  & Q_{\Sigma A}(a_0, p_0).
\end{tikzcd}
#+end_equation
#+end_lemma

#+begin_proof
\TODO
#+end_proof

#+name: lemma:is-id-system-DD-is-id-system
#+begin_corol
Assume $P \correspDD (P_A, P_B, P_S)$ where $P$ is an identity system at \linebreak $(e^P_A(a_0))^{-1}(p_0) : P(i a_0)$. Then $(P_A, P_B, P_S)$ is an identity system at $p_0$.
#+end_corol

#+begin_proof
For every $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ there is a corresponding type family $Q_{\Sigma}$. Then we may apply [[lemma:square-id-system-id-system-DD]]. The top and bottom maps are equivalences, and the left maps has a section by assumption, hence the right map has a section.
#+end_proof

#+begin_corol
Analogously, if $(P_A, P_B, P_S)$ is an identity system at $p_0 : P_A(a_0)$, then $P$ is an identity system at $(e^P_A(a_0))^{-1}(p_0)$.
#+end_corol

#+begin_lemma
\TODO[$(I_A, I_B, I_S)$ is an identity system].
#+end_lemma

#+begin_proof
By [[lemma:fam-with-dd-id]] and [[lemma:is-id-system-DD-is-id-system]], the descent data $(I_A, I_B, I_S)$ is an identity system at $\refl : (i a_0) = (i a_0)$ if and only if the corresponding type family $\Id (i a_0) : X → 𝒰$ is an identity system at $\refl$, which is established in \TODO[Lemma XXX].
#+end_proof

The induction principle of identity systems is stated in terms of an evaluation map having a section, which makes it consistent with statements of other induction principles in Homotopy Type Theory. However, the following lemma shows that the condition on the converse map of being a section is redundant.

#+begin_lemma
To show that $(P_A, P_B, P_S)$ is an identity system at $p₀ : P_A(a_0)$, it suffices
to provide an element of
\begin{displaymath}
  Q_{\Sigma A}(a_0, p_0) \to \sectDD(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})
\end{displaymath}
for every descent data $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$ over the total span diagram.
#+end_lemma

#+begin_proof
\TODO[
Consider the unique family $P : X → \UU$ for $(P_A, P_B, P_S)$. It suffices to show that $P$ is an identity system. As above, we can do that by showing that it is torsorial. By definition, that means that the total space $\Sigma X P$ is contractible. We can prove that using the property that a type is contractible if we provide a point, here $(i a_0, (e^P_A a)^{-1} p_0)$, and a map
\begin{equation*}
  H' : (R_{\Sigma} : \Sigma X P → \UU) → (r_0 : R_{\Sigma} (i a_0, (e^P_A a)^{-1} p_0)) → (u : \Sigma X P) → R_{\Sigma} u.
\end{equation*}
Assume such $R_{\Sigma}$ and $r_0$. A section $(u : \Sigma X P) → R_{\Sigma} u$ is given by a section
of $(R_{\Sigma A}, R_{\Sigma B}, R_{\Sigma S})$, and we can get one by applying $H$ to
$e^R_A (a_0, p_0) r_0 : R_{\Sigma A} (a_0, p_0)$.
]
#+end_proof

#+begin_lemma
\TODO[For any identity system $(P_A, P_B, P_S)$ at $p_0$, there is a unique equivalence of descent data $(I_A, I_B, I_S) \simeq (P_A, P_B, P_S)$ sending $refl$ to $p_0$].
#+end_lemma

#+begin_proof
\TODO[Consider the unique type family $P : X → \UU$ corresponding to
$(P_A, P_B, P_S)$. The type of point preserving equivalences between $(I_A, I_B, I_S)$
and $(P_A, P_B, P_S)$ is equivalent to the type of
fiberwise equivalences
$(x : X) → ((i a_0) = x) \simeq P(x)$ that send $\refl$ to $(e^P_A a_0)^{-1} p_0$. To show that this type is contractible, it suffices to show that $P$ is
torsorial. A type family is
torsorial if it is an identity system, and we have shown that $(P_A, P_B, P_S)$
being an identity system implies that $P$ is an identity system].
#+end_proof

* Other colimits

\TODO[The zigzag construction requires a formalization of sequential colimits. Existence and properties of sequential colimits can be derived from pushouts, and it factors through coequalizers. As a side-product of formalizing sequential colimits, some basic theory of coequalizers was formalized].

** Coequalizers

#+begin_defn
\TODO[Double arrows].
#+end_defn

#+begin_defn
\TODO[Coforks].
#+end_defn

#+begin_defn
\TODO[Universal property of coequalizers]
#+end_defn

The standard coequalizer may be obtained as a pushout of the span diagram
#+begin_center
\begin{tikzcd}
  A
  & A + A
  \arrow[l, "\nabla"']
  \arrow[r, "{[f, g]}"]
  & B
\end{tikzcd}
#+end_center
where the left map is the codiagonal map, sending $\inl(a)$ and $\inr(a)$ to $a$, and the right map is defined by the universal property of coproducts to send $\inl(a)$ to $f(a)$ and $\inr(a)$ to $g(a)$.

\TODO[The pushout thus constructed will consist of a copy of $B$, a copy of $A$, and
for every point $a : A$ there will be a path from $f(a)$ to $a$ and to
$g(a)$, which corresponds to having a copy of $B$ with paths connecting every
$f(a)$ to $g(a)$.]

\TODO[Maybe present all of this infrastructure informally?]

#+begin_lemma
\TODO[Cofork is a coequalizer iff the corresponding cocone is a pushout].
#+end_lemma

#+begin_defn
\TODO[Dependent coforks].
#+end_defn

#+begin_defn
\TODO[Dependent universal property of coequalizers].
#+end_defn

#+begin_lemma
\TODO[DUP $\leftrightarrow$ UP].
#+end_lemma

** Sequential colimits

[cite/t/cf:@SvDR20]

\TODO[Note that AFAIK descent and flattening aren't necessary for the main result of this thesis, but flattening and esp. generalized flattening are used in SvDR20 to prove connectivity results, which are then used in applications].

#+begin_defn
\TODO[Sequential diagrams].
#+end_defn

#+begin_remark
\TODO[AKA cotowers --- we decided to use (inverse) sequential diagrams in agda-unimath].
#+end_remark

#+begin_defn
\TODO[Cocones under sequential diagrams].
#+end_defn

The standard sequential colimit may be obtained as a coequalizer of
#+begin_center
\begin{tikzcd}[column sep=large]
  \Sigma \N A
  \arrow[r, shift right=1.25, "\id"']
  \arrow[r, shift left=1.25, "\tot_{\term{suc}}(a)"]
  & \Sigma \N A
\end{tikzcd}
#+end_center

#+begin_defn
\TODO[Dependent cocones under sequential diagrams].
#+end_defn

#+begin_defn
\TODO[Universal property].
#+end_defn

#+begin_defn
\TODO[Dependent universal property].
#+end_defn

#+begin_lemma
\TODO[DUP $\leftrightarrow$ UP].
#+end_lemma

#+begin_lemma
\TODO[Functoriality].
#+end_lemma

\TODO[The initial motivation for shifts is to show that dropping a finite number of vertices from a sequential diagram preserves the colimit. It is also useful for showing that zigzags induce equivalences in the colimit].

#+begin_constr
\TODO[Shifts of sequential diagrams].
#+end_constr

#+begin_constr
\TODO[Inclusion morphisms into shifts].
#+end_constr

#+begin_constr
\TODO[Shifts of morphisms of sequential diagrams].
#+end_constr

#+begin_constr
\TODO[Shifts of cocones].
#+end_constr

#+begin_constr
\TODO[Shifts of homotopies of cocones].
#+end_constr

#+begin_constr
\TODO[Unshifts of cocones].
#+end_constr

#+begin_constr
\TODO[Unshifts of homotopies of cocones].
#+end_constr

* Proof of correctness of the zigzag construction

\TODO[Mention that there are multiple versions].
\TODO[Mention that ours is a slight variation by switching relations for spans].

** Zigzags of sequential diagrams

#+begin_defn
\TODO[Zigzags].
#+end_defn

** The zigzag construction

#+begin_center
\begin{tikzcd}[column sep=6em]
  \Sigma (s : S) (r : b = (g s)). \; P_B^n(b)
  \arrow[r, "\tot(\tot(\blank \concat_n \overline{s}))"]
  \arrow[d, "\pr_3"']
  \arrow[rd, phantom, "\ulcorner", at end]
  & \Sigma (s : S) (r : b = (g s)). \; P_A^n(f s)
  \arrow[d, "\blank \concat_n' s \defeq \inr"] \\ P_B^n(b)
  \arrow[r, "\incl_B^n \defeq \inl"']
  & P_B^{n + 1}(b)
\end{tikzcd}
#+end_center

#+begin_center
\begin{tikzcd}[column sep=6em]
  \Sigma (s : S) (r : a = (f s)). \; P_A^n(a)
  \arrow[r, "\tot(\tot(\blank \concat_n' s))"]
  \arrow[d, "\pr_3"']
  \arrow[rd, phantom, "\ulcorner", at end]
  & \Sigma (s : S) (r : a = (f s)). \; P_B^{n + 1}(g s)
  \arrow[d, "\blank \concat_n \overline{s} \defeq \inr"] \\
  P_A^n(a)
  \arrow[r, "\incl_A^n \defeq \inl"']
  & P_A^{n + 1}(a)
\end{tikzcd}
#+end_center

** Proof of correctness

\TODO[The objective is to show that the zigzag descent data is an identity system. To do that, assume "dependent" descent data $(Q_{\Sigma A}, Q_{\Sigma B}, Q_{\Sigma S})$, and a point $q_0 : Q_{\Sigma A}(a_0, \iota_A^0(\refl))$ and conjure a section of $Q$. Explicitly (write out the type of a section), which in every case proceeds by induction on $P_\bullet^{\infty}$.]

* Conclusion

Future work:
- more abstract proof of the last coherence: using the calculus of dependent identifications, and/or a more general lemma about coherent sections over zigzags; although that might have limited applications
- formalize applications
- formalize categorical statement

#+PRINT_BIBLIOGRAPHY: :heading bibintoc

\appendix
* List of attachments

Attachments consist of Git patch files, submitted as pull requests to the {{{AU}}} GitHub {{{AURepo}}}. They may be found in the =attachments= directory in the thesis source [[https://github.com/VojtechStep/homotopy-pushouts][repository]], and should also be included with any distribution of the thesis.

- {{{PR(535,refactor-descent-circle)}}}
- {{{PR(709,descent-circle)}}}
- {{{PR(724,foundation-precomp-concat-squares)}}}
- {{{PR(725,foundation-horizontal-paste-pushouts)}}}
- {{{PR(755,foundation-vertical-paste-pushouts)}}}
- {{{PR(758,foundation-unpaste-pushouts)}}}
- {{{PR(764,flattening-pushouts-family)}}}
- {{{PR(792,coequalizers)}}}
- {{{PR(816,flattening-pushouts-descent-data)}}}
- {{{PR(831,flattening-coequalizers)}}}
- {{{PR(841,sequential-colimits)}}}
- {{{PR(919,functoriality-sequential-colimits)}}}
- {{{PR(972,flattening-sequential-colimits-family)}}}
- {{{PR(978,refactor-functoriality-sequential-colimits)}}}
- {{{PR(988,refactor-lifts-families)}}}
- {{{PR(1070,shifts-sequential-colimits)}}}
- {{{PR(1098,refactor-coequalizers)}}}
- {{{PR(1109,flattening-sequential-colimits-descent-data)}}}
- {{{PR(1117,equivalences-sequential-comp)}}}
- {{{PR(1129,zigzags-sequential-diagrams)}}}
- {{{PR(1140,descent-coequalizers)}}}
- {{{PR(1145,descent-pushouts)}}}
- {{{PR(1148,characterization-families-pushouts)}}}
- {{{PR(1150,identity-systems-descent-pushouts)}}}

  
* COMMENT Battle plan
- [cite:@BW22] 2.5 for straightening/unstraightening

- [X] $\Sigma$ -types over pushouts
  - [X] Flattening lemma
  - [X] Applications
- [X] Path spaces of pushouts
  - [X] Formalize Kraus, von Raumer
    - [X] Understand the proof
    - [X] Convert from relations to spans?
  - [X] Figure out how to encode the sequence construction
    - [X] Induction on naturals with Σ → Σ, pushing forward $(a_0 \rightsquigarrow_t a , a_0 \rightsquigarrow_{t+1} b) \mapsto (a_0 \rightsquigarrow_{t + 2} a , a_0 \rightsquigarrow_{t + 3} b)$
    - [X] Try encoding the construction with spans instead of relations
- [X] Descent stuff
- [X] Zig-zags of sequences induce equivalences on sequential colimits
  - [X] More general functoriality of sequential colimits - not just standard ones, but formulated with UP

- [ ] Link constructions in prose to their definitions
- [ ] Link formal statements to the formalization

# The local variable is necessary to setup hyperref correctly

# Local Variables:
# org-latex-default-packages-alist: (("" "graphicx" t) ("" "wrapfig" nil) ("" "rotating" nil) ("normalem" "ulem" t) ("" "amsmath" t) ("" "amssymb" t) ("" "amsthm" t) ("" "capt-of" nil) ("rgb" "xcolor" nil) ("pdfa" "hyperref" nil) ("" "hyperxmp" nil) ("" "geometry" nil) ("nottoc" "tocbibind" nil) ("" "newpxtext" nil) ("" "unicode-math" nil) ("" "aliascnt") ("" "tikz-cd" t))
# org-latex-classes: (("report" "\\documentclass{report}" ("\\chapter{%s}" . "\\chapter*{%1$s}\\addcontentsline{toc}{chapter}{%1$s}") ("\\section{%s}" . "\\section*{%s}") ("\\subsection{%s}" . "\\subsection*{%s}") ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
# org-latex-reference-command: "\\autoref{%s}"
# eval: (general-define-key :states 'normal :keymaps 'local "C-c C-f" #'hl-todo-next "C-c C-b" #'hl-todo-previous)
# End:
